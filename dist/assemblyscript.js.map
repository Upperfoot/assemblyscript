{"version":3,"sources":["webpack://assemblyscript/webpack/universalModuleDefinition","webpack://assemblyscript/./node_modules/long/src/long.js","webpack://assemblyscript/./src/ast.ts","webpack://assemblyscript/./src/builtins.ts","webpack://assemblyscript/./src/common.ts","webpack://assemblyscript/./src/compiler.ts","webpack://assemblyscript/./src/definitions.ts","webpack://assemblyscript/./src/diagnosticMessages.generated.ts","webpack://assemblyscript/./src/diagnostics.ts","webpack://assemblyscript/./src/extra/ast.ts","webpack://assemblyscript/./src/flow.ts","webpack://assemblyscript/./src/glue/js/index.ts","webpack://assemblyscript/./src/index.ts","webpack://assemblyscript/./src/module.ts","webpack://assemblyscript/./src/parser.ts","webpack://assemblyscript/./src/passes/findusedlocals.ts","webpack://assemblyscript/./src/passes/pass.ts","webpack://assemblyscript/./src/passes/rtrace.ts","webpack://assemblyscript/./src/passes/shadowstack.ts","webpack://assemblyscript/./src/program.ts","webpack://assemblyscript/./src/resolver.ts","webpack://assemblyscript/./src/tokenizer.ts","webpack://assemblyscript/./src/types.ts","webpack://assemblyscript/./src/util/binary.ts","webpack://assemblyscript/./src/util/collections.ts","webpack://assemblyscript/./src/util/index.ts","webpack://assemblyscript/./src/util/math.ts","webpack://assemblyscript/./src/util/path.ts","webpack://assemblyscript/./src/util/terminal.ts","webpack://assemblyscript/./src/util/text.ts","webpack://assemblyscript/./src/util/vector.ts","webpack://assemblyscript/./std/assembly/shared/feature.ts","webpack://assemblyscript/./std/assembly/shared/target.ts","webpack://assemblyscript/./std/assembly/shared/typeinfo.ts","webpack://assemblyscript/./src/glue/binaryen.js","webpack://assemblyscript/./src/glue/js/collections.js","webpack://assemblyscript/./src/glue/js/float.js","webpack://assemblyscript/./src/glue/js/i64.js","webpack://assemblyscript/./std/portable/index.js","webpack://assemblyscript/external \"binaryen\"","webpack://assemblyscript/webpack/bootstrap","webpack://assemblyscript/webpack/runtime/global","webpack://assemblyscript/webpack/startup"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__911__","Long","wasm","WebAssembly","Instance","Module","Uint8Array","e","low","high","unsigned","isLong","obj","prototype","__isLong__","Object","defineProperty","value","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","Math","pow","fromString","str","radix","length","Error","RangeError","p","indexOf","substring","radixToPower","result","i","size","min","parseInt","power","mul","add","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","toNumber","toString","isZero","isNegative","eq","radixLong","div","rem1","sub","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","equals","other","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","get_high","b00","divide","divisor","approx","res","div_u","div_s","toUnsigned","shru","shr","shl","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","rem_u","rem_s","mod","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","toSigned","toBytes","toBytesLE","toBytesBE","hi","lo","fromBytes","bytes","fromBytesLE","fromBytesBE","NodeKind","DecoratorKind","LiteralKind","SourceKind","Node","kind","range","name","TypeName","createIdentifierExpression","typeArguments","isNullable","NamedTypeNode","parameters","returnType","explicitThisType","FunctionTypeNode","createSimpleTypeName","extendsType","defaultType","TypeParameterNode","parameterKind","type","initializer","ParameterNode","args","DecoratorNode","fromNode","commentKind","text","CommentNode","isQuoted","IdentifierExpression","elementExpressions","ArrayLiteralExpression","assertionKind","expression","toType","AssertionExpression","operator","left","right","BinaryExpression","CallExpression","declaration","ClassExpression","expressions","CommaExpression","ConstructorExpression","elementExpression","ElementAccessExpression","FalseExpression","FloatLiteralExpression","FunctionExpression","isType","InstanceOfExpression","IntegerLiteralExpression","typeName","NewExpression","NullExpression","names","values","ObjectLiteralExpression","OmittedExpression","ParenthesizedExpression","property","PropertyAccessExpression","pattern","patternFlags","RegexpLiteralExpression","condition","ifThen","ifElse","TernaryExpression","StringLiteralExpression","SuperExpression","tag","parts","rawParts","TemplateLiteralExpression","ThisExpression","TrueExpression","operand","UnaryPostfixExpression","UnaryPrefixExpression","expr","CompiledExpression","statements","BlockStatement","label","BreakStatement","decorators","flags","typeParameters","implementsTypes","members","ClassDeclaration","ContinueStatement","statement","DoStatement","EmptyStatement","EnumDeclaration","EnumValueDeclaration","path","isDeclare","ExportStatement","ExportDefaultStatement","externalName","ExportImportStatement","localName","exportedName","ExportMember","ExpressionStatement","ifTrue","ifFalse","IfStatement","declarations","ImportStatement","namespaceName","foreignName","ImportDeclaration","InterfaceDeclaration","FieldDeclaration","incrementor","ForStatement","variable","iterable","ForOfStatement","signature","body","arrowKind","FunctionDeclaration","keyType","valueType","IndexSignatureNode","MethodDeclaration","NamespaceDeclaration","ReturnStatement","cases","SwitchStatement","SwitchCase","ThrowStatement","catchVariable","catchStatements","finallyStatements","TryStatement","TypeDeclaration","VariableStatement","VariableDeclaration","VoidStatement","WhileStatement","literalKind","LITERAL","changetype","FLOAT","INTEGER","STRING","NULL","TRUE","FALSE","node","CALL","PROPERTYACCESS","isAccessOn","THIS","SUPER","TypeNode","super","typeParameterNodes","NAMEDTYPE","namedTypeNode","next","typeArgumentNodes","k","hasGenericComponent","identifier","FUNCTIONTYPE","functionTypeNode","parameterNodes","assert","TYPENAME","TYPEPARAMETER","ParameterKind","PARAMETER","implicitFieldDeclaration","CommonFlags","NONE","flag","nameNode","IDENTIFIER","nameStr","charCodeAt","BUILTIN","EXTERNAL","FINAL","GLOBAL","INLINE","LAZY","OPERATOR","UNMANAGED","UNSAFE","propertyAccessNode","propStr","OPERATOR_BINARY","OPERATOR_PREFIX","OPERATOR_POSTFIX","CUSTOM","decoratorKind","DECORATOR","CommentKind","COMMENT","Expression","LiteralExpression","ARRAY","AssertionKind","ASSERTION","BINARY","numTypeArguments","Range","join","numArguments","CLASS","COMMA","CONSTRUCTOR","ELEMENTACCESS","FUNCTION","INSTANCEOF","NEW","OBJECT","OMITTED","PARENTHESIZED","REGEXP","TERNARY","TEMPLATE","UnaryExpression","UNARYPOSTFIX","UNARYPREFIX","COMPILED","Statement","sourceKind","normalizedPath","SOURCE","Array","debugInfoIndex","exportPaths","lineCache","lineColumn","internalPath","mangleInternalPath","pos","lastIndexOf","PATH_DELIMITER","simplePath","source","LIBRARY_SUBST","LIBRARY","LIBRARY_ENTRY","off","end","push","l","r","m","s","unchecked","DeclarationStatement","INDEXSIGNATURE","VariableLikeDeclarationStatement","BLOCK","BREAK","CLASSDECLARATION","indexSignature","CONTINUE","DO","EMPTY","ENUMDECLARATION","ENUMVALUEDECLARATION","EXPORTIMPORT","EXPORTMEMBER","EXPORT","normalizePath","startsWith","resolvePath","LIBRARY_PREFIX","EXPORTDEFAULT","EXPRESSION","parameterIndex","FIELDDECLARATION","FOR","FOROF","ArrowKind","FUNCTIONDECLARATION","IF","IMPORTDECLARATION","IMPORT","INTERFACEDECLARATION","METHODDECLARATION","NAMESPACEDECLARATION","RETURN","SWITCHCASE","SWITCH","THROW","TRY","TYPEDECLARATION","VARIABLEDECLARATION","VARIABLE","VOID","WHILE","len","cur","isTrivialAlphanum","decorator","BuiltinNames","start","started","argumentsLength","setArgumentsLength","abort","trace","seed","isInteger","isFloat","isBoolean","isSigned","isReference","isString","isArray","isArrayLike","isFunction","isDefined","isConstant","isManaged","isVoid","clz","ctz","popcnt","rotl","rotr","abs","copysign","nearest","reinterpret","sqrt","trunc","load","store","atomic_load","atomic_store","atomic_add","atomic_sub","atomic_and","atomic_or","atomic_xor","atomic_xchg","atomic_cmpxchg","atomic_wait","atomic_notify","atomic_fence","sizeof","alignof","offsetof","nameof","lengthof","select","unreachable","call_indirect","instantiate","idof","i8","i16","i32","i64","isize","u8","u16","u32","u64","usize","bool","f32","f64","v128","i32_clz","i64_clz","i32_ctz","i64_ctz","i32_popcnt","i64_popcnt","i32_rotl","i64_rotl","i32_rotr","i64_rotr","f32_abs","f64_abs","f32_max","f64_max","f32_min","f64_min","f32_ceil","f64_ceil","f32_floor","f64_floor","f32_copysign","f64_copysign","f32_nearest","f64_nearest","i32_reinterpret_f32","i64_reinterpret_f64","f32_reinterpret_i32","f64_reinterpret_i64","f32_sqrt","f64_sqrt","f32_trunc","f64_trunc","i32_add","i64_add","f32_add","f64_add","i32_sub","i64_sub","f32_sub","f64_sub","i32_mul","i64_mul","f32_mul","f64_mul","i32_div_s","i32_div_u","i64_div_s","i64_div_u","f32_div","f64_div","i32_load8_s","i32_load8_u","i32_load16_s","i32_load16_u","i32_load","i64_load8_s","i64_load8_u","i64_load16_s","i64_load16_u","i64_load32_s","i64_load32_u","i64_load","f32_load","f64_load","i32_store8","i32_store16","i32_store","i64_store8","i64_store16","i64_store32","i64_store","f32_store","f64_store","i32_atomic_load8_u","i32_atomic_load16_u","i32_atomic_load","i64_atomic_load8_u","i64_atomic_load16_u","i64_atomic_load32_u","i64_atomic_load","i32_atomic_store8","i32_atomic_store16","i32_atomic_store","i64_atomic_store8","i64_atomic_store16","i64_atomic_store32","i64_atomic_store","i32_atomic_rmw8_add_u","i32_atomic_rmw16_add_u","i32_atomic_rmw_add","i64_atomic_rmw8_add_u","i64_atomic_rmw16_add_u","i64_atomic_rmw32_add_u","i64_atomic_rmw_add","i32_atomic_rmw8_sub_u","i32_atomic_rmw16_sub_u","i32_atomic_rmw_sub","i64_atomic_rmw8_sub_u","i64_atomic_rmw16_sub_u","i64_atomic_rmw32_sub_u","i64_atomic_rmw_sub","i32_atomic_rmw8_and_u","i32_atomic_rmw16_and_u","i32_atomic_rmw_and","i64_atomic_rmw8_and_u","i64_atomic_rmw16_and_u","i64_atomic_rmw32_and_u","i64_atomic_rmw_and","i32_atomic_rmw8_or_u","i32_atomic_rmw16_or_u","i32_atomic_rmw_or","i64_atomic_rmw8_or_u","i64_atomic_rmw16_or_u","i64_atomic_rmw32_or_u","i64_atomic_rmw_or","i32_atomic_rmw8_xor_u","i32_atomic_rmw16_xor_u","i32_atomic_rmw_xor","i64_atomic_rmw8_xor_u","i64_atomic_rmw16_xor_u","i64_atomic_rmw32_xor_u","i64_atomic_rmw_xor","i32_atomic_rmw8_xchg_u","i32_atomic_rmw16_xchg_u","i32_atomic_rmw_xchg","i64_atomic_rmw8_xchg_u","i64_atomic_rmw16_xchg_u","i64_atomic_rmw32_xchg_u","i64_atomic_rmw_xchg","i32_atomic_rmw8_cmpxchg_u","i32_atomic_rmw16_cmpxchg_u","i32_atomic_rmw_cmpxchg","i64_atomic_rmw8_cmpxchg_u","i64_atomic_rmw16_cmpxchg_u","i64_atomic_rmw32_cmpxchg_u","i64_atomic_rmw_cmpxchg","i32_wait","i64_wait","v128_splat","v128_extract_lane","v128_replace_lane","v128_shuffle","v128_swizzle","v128_load_splat","v128_load_ext","v128_load_zero","v128_load_lane","v128_store_lane","v128_load","v128_load8x8_s","v128_load8x8_u","v128_load16x4_s","v128_load16x4_u","v128_load32x2_s","v128_load32x2_u","v128_load8_splat","v128_load16_splat","v128_load32_splat","v128_load64_splat","v128_load32_zero","v128_load64_zero","v128_load8_lane","v128_load16_lane","v128_load32_lane","v128_load64_lane","v128_store8_lane","v128_store16_lane","v128_store32_lane","v128_store64_lane","v128_store","v128_add","v128_sub","v128_mul","v128_div","v128_neg","v128_add_sat","v128_sub_sat","v128_shl","v128_shr","v128_and","v128_or","v128_xor","v128_andnot","v128_not","v128_bitselect","v128_any_true","v128_all_true","v128_bitmask","v128_popcnt","v128_min","v128_max","v128_pmin","v128_pmax","v128_dot","v128_avgr","v128_abs","v128_sqrt","v128_ceil","v128_floor","v128_trunc","v128_nearest","v128_eq","v128_ne","v128_lt","v128_le","v128_gt","v128_ge","v128_convert","v128_convert_low","v128_trunc_sat","v128_trunc_sat_zero","v128_narrow","v128_extend_low","v128_extend_high","v128_extadd_pairwise","v128_demote_zero","v128_promote_low","v128_q15mulr_sat","v128_extmul_low","v128_extmul_high","i8x16","i16x8","i32x4","i64x2","f32x4","f64x2","i8x16_splat","i8x16_extract_lane_s","i8x16_extract_lane_u","i8x16_replace_lane","i8x16_add","i8x16_sub","i8x16_mul","i8x16_min_s","i8x16_min_u","i8x16_max_s","i8x16_max_u","i8x16_avgr_u","i8x16_abs","i8x16_neg","i8x16_add_sat_s","i8x16_add_sat_u","i8x16_sub_sat_s","i8x16_sub_sat_u","i8x16_shl","i8x16_shr_s","i8x16_shr_u","i8x16_all_true","i8x16_bitmask","i8x16_popcnt","i8x16_eq","i8x16_ne","i8x16_lt_s","i8x16_lt_u","i8x16_le_s","i8x16_le_u","i8x16_gt_s","i8x16_gt_u","i8x16_ge_s","i8x16_ge_u","i8x16_narrow_i16x8_s","i8x16_narrow_i16x8_u","i8x16_shuffle","i8x16_swizzle","i16x8_splat","i16x8_extract_lane_s","i16x8_extract_lane_u","i16x8_replace_lane","i16x8_add","i16x8_sub","i16x8_mul","i16x8_min_s","i16x8_min_u","i16x8_max_s","i16x8_max_u","i16x8_avgr_u","i16x8_abs","i16x8_neg","i16x8_add_sat_s","i16x8_add_sat_u","i16x8_sub_sat_s","i16x8_sub_sat_u","i16x8_shl","i16x8_shr_s","i16x8_shr_u","i16x8_all_true","i16x8_bitmask","i16x8_eq","i16x8_ne","i16x8_lt_s","i16x8_lt_u","i16x8_le_s","i16x8_le_u","i16x8_gt_s","i16x8_gt_u","i16x8_ge_s","i16x8_ge_u","i16x8_narrow_i32x4_s","i16x8_narrow_i32x4_u","i16x8_extend_low_i8x16_s","i16x8_extend_low_i8x16_u","i16x8_extend_high_i8x16_s","i16x8_extend_high_i8x16_u","i16x8_extadd_pairwise_i8x16_s","i16x8_extadd_pairwise_i8x16_u","i16x8_q15mulr_sat_s","i16x8_extmul_low_i8x16_s","i16x8_extmul_low_i8x16_u","i16x8_extmul_high_i8x16_s","i16x8_extmul_high_i8x16_u","i32x4_splat","i32x4_extract_lane","i32x4_replace_lane","i32x4_add","i32x4_sub","i32x4_mul","i32x4_min_s","i32x4_min_u","i32x4_max_s","i32x4_max_u","i32x4_dot_i16x8_s","i32x4_abs","i32x4_neg","i32x4_shl","i32x4_shr_s","i32x4_shr_u","i32x4_all_true","i32x4_bitmask","i32x4_eq","i32x4_ne","i32x4_lt_s","i32x4_lt_u","i32x4_le_s","i32x4_le_u","i32x4_gt_s","i32x4_gt_u","i32x4_ge_s","i32x4_ge_u","i32x4_trunc_sat_f32x4_s","i32x4_trunc_sat_f32x4_u","i32x4_trunc_sat_f64x2_s_zero","i32x4_trunc_sat_f64x2_u_zero","i32x4_extend_low_i16x8_s","i32x4_extend_low_i16x8_u","i32x4_extend_high_i16x8_s","i32x4_extend_high_i16x8_u","i32x4_extadd_pairwise_i16x8_s","i32x4_extadd_pairwise_i16x8_u","i32x4_extmul_low_i16x8_s","i32x4_extmul_low_i16x8_u","i32x4_extmul_high_i16x8_s","i32x4_extmul_high_i16x8_u","i64x2_splat","i64x2_extract_lane","i64x2_replace_lane","i64x2_add","i64x2_sub","i64x2_mul","i64x2_abs","i64x2_neg","i64x2_shl","i64x2_shr_s","i64x2_shr_u","i64x2_all_true","i64x2_bitmask","i64x2_eq","i64x2_ne","i64x2_lt_s","i64x2_lt_u","i64x2_le_s","i64x2_le_u","i64x2_gt_s","i64x2_gt_u","i64x2_ge_s","i64x2_ge_u","i64x2_extend_low_i32x4_s","i64x2_extend_low_i32x4_u","i64x2_extend_high_i32x4_s","i64x2_extend_high_i32x4_u","i64x2_extmul_low_i32x4_s","i64x2_extmul_low_i32x4_u","i64x2_extmul_high_i32x4_s","i64x2_extmul_high_i32x4_u","f32x4_splat","f32x4_extract_lane","f32x4_replace_lane","f32x4_add","f32x4_sub","f32x4_mul","f32x4_div","f32x4_neg","f32x4_min","f32x4_max","f32x4_pmin","f32x4_pmax","f32x4_abs","f32x4_sqrt","f32x4_ceil","f32x4_floor","f32x4_trunc","f32x4_nearest","f32x4_eq","f32x4_ne","f32x4_lt","f32x4_le","f32x4_gt","f32x4_ge","f32x4_convert_i32x4_s","f32x4_convert_i32x4_u","f32x4_demote_f64x2_zero","f64x2_splat","f64x2_extract_lane","f64x2_replace_lane","f64x2_add","f64x2_sub","f64x2_mul","f64x2_div","f64x2_neg","f64x2_min","f64x2_max","f64x2_pmin","f64x2_pmax","f64x2_abs","f64x2_sqrt","f64x2_ceil","f64x2_floor","f64x2_trunc","f64x2_nearest","f64x2_eq","f64x2_ne","f64x2_lt","f64x2_le","f64x2_gt","f64x2_ge","f64x2_convert_low_i32x4_s","f64x2_convert_low_i32x4_u","f64x2_promote_low_f32x4","i31_new","i31_get","data_end","stack_pointer","heap_base","rtti_base","visit_globals","visit_members","tostack","isFinite","ERROR","WARNING","INFO","Function","memory_size","memory_grow","memory_copy","memory_fill","memory_data","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Int64Array","Uint64Array","Float32Array","Float64Array","String_raw","wasiAbort","wasiTrace","wasiSeed","builtin_clz","ctx","compiler","checkTypeOptional","checkArgsRequired","arg0","compileExpression","operands","Type","currentType","isValue","unary","UnaryOp","ClzI32","options","isWasm64","ClzI64","error","DiagnosticCode","Operation_0_cannot_be_applied_to_type_1","reportNode","typeArgumentsRange","builtin_ctz","CtzI32","CtzI64","builtin_popcnt","PopcntI32","PopcntI64","builtin_rotl","arg1","flow","currentFlow","temp1","getTempLocal","findUsedLocals","setLocalFlag","index","LocalFlags","WRAPPED","temp2","ret","binary","BinaryOp","OrI32","ShlI32","local_tee","AndI32","ShrU32","local_get","TypeRef","I32","SubI32","freeTempLocal","RotlI32","RotlI64","builtin_rotr","RotrI32","RotrI64","builtin_abs","auto","XorI32","AddI32","ShrI32","usizeType","XorI64","AddI64","ShrI64","sizeTypeRef","I64","AbsF32","AbsF64","builtin_max","isNumericLiteral","op","GtI32","GtU32","GtI64","GtU64","MaxF32","MaxF64","typeRef","toRef","builtin_min","LtI32","LtU32","LtI64","LtU64","MinF32","MinF64","builtin_ceil","CeilF32","CeilF64","builtin_floor","FloorF32","FloorF64","builtin_copysign","CopysignF32","CopysignF64","builtin_nearest","NearestF32","NearestF64","builtin_reinterpret","checkTypeRequired","ReinterpretF32ToI32","ReinterpretF64ToI64","ReinterpretI32ToF32","ReinterpretI64ToF64","builtin_sqrt","SqrtF32","SqrtF64","builtin_trunc","TruncF32","TruncF64","builtin_load","checkArgsOptional","contextualType","outType","isIntegerValue","numOperands","immOffset","immAlign","byteSize","evaluateImmediateOffset","evaluateImmediateAlign","isSignedIntegerValue","builtin_store","void","contextIsExact","inType","convertExpression","builtin_add","isNumericValue","makeAdd","builtin_sub","makeSub","builtin_mul","makeMul","builtin_div","makeDiv","builtin_atomic_load","checkFeatureEnabled","builtin_atomic_store","builtin_atomic_binary","opName","atomic_rmw","builtin_atomic_add","AtomicRMWOp","Add","builtin_atomic_sub","Sub","builtin_atomic_and","And","builtin_atomic_or","Or","builtin_atomic_xor","Xor","builtin_atomic_xchg","Xchg","builtin_atomic_cmpxchg","arg2","builtin_atomic_wait","builtin_diagnostic","category","checkTypeAbsent","emitDiagnostic","User_defined_0","DiagnosticCategory","nop","builtin_conversion","builtin_i8x16","precomp","runExpression","ExpressionRunnerFlags","PreserveSideeffects","writeI8","getConstValueI32","Expression_must_be_a_compile_time_constant","builtin_v128_splat","SplatI8x16","SplatI16x8","SplatI32x4","SplatI64x2","SplatF32x4","SplatF64x2","builtin_v128_extract_lane","idx","maxIdx","_0_must_be_a_value_between_1_and_2_inclusive","simd_extract","SIMDExtractOp","ExtractLaneI8x16","ExtractLaneU8x16","ExtractLaneI16x8","ExtractLaneU16x8","ExtractLaneI32x4","ExtractLaneI64x2","ExtractLaneF32x4","ExtractLaneF64x2","builtin_v128_replace_lane","simd_replace","SIMDReplaceOp","ReplaceLaneI8x16","ReplaceLaneI16x8","ReplaceLaneI32x4","ReplaceLaneI64x2","ReplaceLaneF32x4","ReplaceLaneF64x2","builtin_v128_shuffle","laneWidth","laneCount","isPowerOf2","mask","argN","off8","idx8","simd_shuffle","builtin_v128_swizzle","SwizzleI8x16","builtin_v128_load_splat","simd_load","SIMDLoadOp","Load8Splat","Load16Splat","Load32Splat","Load64Splat","builtin_v128_load_ext","Load8x8S","Load8x8U","Load16x4S","Load16x4U","Load32x2S","Load32x2U","builtin_v128_load_zero","Load32Zero","Load64Zero","builtin_v128_load_lane","simd_loadstorelane","SIMDLoadStoreLaneOp","Load8Lane","Load16Lane","Load32Lane","Load64Lane","builtin_v128_store_lane","Store8Lane","Store16Lane","Store32Lane","Store64Lane","builtin_v128_add","AddI8x16","AddI16x8","AddI32x4","AddI64x2","AddF32x4","AddF64x2","builtin_v128_sub","SubI8x16","SubI16x8","SubI32x4","SubI64x2","SubF32x4","SubF64x2","builtin_v128_mul","MulI16x8","MulI32x4","MulI64x2","MulF32x4","MulF64x2","builtin_v128_div","DivF32x4","DivF64x2","builtin_v128_add_sat","AddSatI8x16","AddSatU8x16","AddSatI16x8","AddSatU16x8","builtin_v128_sub_sat","SubSatI8x16","SubSatU8x16","SubSatI16x8","SubSatU16x8","builtin_v128_min","MinI8x16","MinU8x16","MinI16x8","MinU16x8","MinI32x4","MinU32x4","MinF32x4","MinF64x2","builtin_v128_max","MaxI8x16","MaxU8x16","MaxI16x8","MaxU16x8","MaxI32x4","MaxU32x4","MaxF32x4","MaxF64x2","builtin_v128_pmin","PminF32x4","PminF64x2","builtin_v128_pmax","PmaxF32x4","PmaxF64x2","builtin_v128_dot","DotI16x8","builtin_v128_avgr","AvgrU8x16","AvgrU16x8","builtin_v128_eq","EqI8x16","EqI16x8","EqI32x4","EqI64x2","EqF32x4","EqF64x2","builtin_v128_ne","NeI8x16","NeI16x8","NeI32x4","NeI64x2","NeF32x4","NeF64x2","builtin_v128_lt","LtI8x16","LtU8x16","LtI16x8","LtU16x8","LtI32x4","LtU32x4","LtI64x2","LtF32x4","LtF64x2","builtin_v128_le","LeI8x16","LeU8x16","LeI16x8","LeU16x8","LeI32x4","LeU32x4","LeI64x2","LeF32x4","LeF64x2","builtin_v128_gt","GtI8x16","GtU8x16","GtI16x8","GtU16x8","GtI32x4","GtU32x4","GtI64x2","GtF32x4","GtF64x2","builtin_v128_ge","GeI8x16","GeU8x16","GeI16x8","GeU16x8","GeI32x4","GeU32x4","GeI64x2","GeF32x4","GeF64x2","builtin_v128_narrow","NarrowI16x8ToI8x16","NarrowU16x8ToU8x16","NarrowI32x4ToI16x8","NarrowU32x4ToU16x8","builtin_v128_neg","NegI8x16","NegI16x8","NegI32x4","NegI64x2","NegF32x4","NegF64x2","builtin_v128_abs","AbsI8x16","AbsI16x8","AbsI32x4","AbsI64x2","AbsF32x4","AbsF64x2","builtin_v128_sqrt","SqrtF32x4","SqrtF64x2","builtin_v128_ceil","CeilF32x4","CeilF64x2","builtin_v128_floor","FloorF32x4","FloorF64x2","builtin_v128_trunc","TruncF32x4","TruncF64x2","builtin_v128_nearest","NearestF32x4","NearestF64x2","builtin_v128_convert","ConvertI32x4ToF32x4","ConvertU32x4ToF32x4","builtin_v128_convert_low","ConvertLowI32x4ToF64x2","ConvertLowU32x4ToF64x2","builtin_v128_trunc_sat","TruncSatF32x4ToI32x4","TruncSatF32x4ToU32x4","builtin_v128_trunc_sat_zero","TruncSatF64x2ToI32x4Zero","TruncSatF64x2ToU32x4Zero","builtin_v128_extend_low","ExtendLowI8x16ToI16x8","ExtendLowU8x16ToU16x8","ExtendLowI16x8ToI32x4","ExtendLowU16x8ToU32x4","ExtendLowI32x4ToI64x2","ExtendLowU32x4ToU64x2","builtin_v128_extend_high","ExtendHighI8x16ToI16x8","ExtendHighU8x16ToU16x8","ExtendHighI16x8ToI32x4","ExtendHighU16x8ToU32x4","ExtendHighI32x4ToI64x2","ExtendHighU32x4ToU64x2","builtin_v128_shl","simd_shift","SIMDShiftOp","ShlI8x16","ShlI16x8","ShlI32x4","ShlI64x2","builtin_v128_shr","ShrI8x16","ShrU8x16","ShrI16x8","ShrU16x8","ShrI32x4","ShrU32x4","ShrI64x2","ShrU64x2","builtin_v128_bitwise_binary","builtin_v128_all_true","AllTrueI8x16","AllTrueI16x8","AllTrueI32x4","AllTrueI64x2","builtin_v128_bitmask","BitmaskI8x16","BitmaskI16x8","BitmaskI32x4","BitmaskI64x2","builtin_v128_popcnt","PopcntI8x16","builtin_v128_extadd_pairwise","ExtaddPairwiseI8x16ToI16x8","ExtaddPairwiseU8x16ToU16x8","ExtaddPairwiseI16x8ToI32x4","ExtaddPairwiseU16x8ToU32x4","builtin_v128_demote_zero","DemoteZeroF64x2ToF32x4","builtin_v128_promote_low","PromoteLowF32x4ToF64x2","builtin_v128_q15mulr_sat","Q15mulrSatI16x8","builtin_v128_extmul_low","ExtmulLowI16x8","ExtmulLowU16x8","ExtmulLowI32x4","ExtmulLowU32x4","ExtmulLowI64x2","ExtmulLowU64x2","builtin_v128_extmul_high","ExtmulHighI16x8","ExtmulHighU16x8","ExtmulHighI32x4","ExtmulHighU32x4","ExtmulHighI64x2","ExtmulHighU64x2","ensureVisitMembersOf","instance","visitRef","program","sizeTypeSize","visitInstance","base","call","internalName","None","hasVisitImpl","isDeclaredInLibrary","visitPrototype","lookupInSelf","ElementKind","FUNCTION_PROTOTYPE","resolver","resolveFunction","compileFunction","visitSignature","visitThisType","thisType","parameterTypes","isStrictlyAssignableTo","needsTempValue","_values","Map_values","j","member","FIELD","parent","fieldOffset","memoryOffset","if","addFunction","createType","flatten","typeToRuntimeFlags","alignLog2","is","evaluateConstantType","Expected_0_type_arguments_but_got_1","Expected_0_arguments_but_got_1","argumentsRange","usize64","getConstValueI64High","getConstValueI64Low","usize32","naturalAlign","align","_0_must_be_a_power_of_two","feature","hasFeature","Feature_0_is_not_enabled","featureToString","setCurrentTypeOnError","Type_0_is_not_generic","expected","expectedMinimum","expectedMaximum","Expected_at_least_0_arguments_but_got_1","contextualUsize","i64_is_i32","i64_low","i64_is_u32","i64_high","thisOperand","builtins","Map","function_builtins","set","isFloatValue","isBooleanValue","classReference","getClass","isAssignableTo","stringInstance","extends","arrayPrototype","isNullableReference","element","lookupExpression","ReportMode","SWALLOW","getExpressionId","ExpressionId","Const","signatureReference","Type_0_has_no_call_signatures","i64_new","getClassOrWrapper","firstOperand","isLiteralKind","String_literal_expected","fieldName","classMembers","has","get","Type_0_has_no_property_1","nextMemoryOffset","resultType","isInternalReference","getSignature","ensureStaticString","id","hasDecorator","DecoratorFlags","maybeDropCondition","LocalGet","NeF32","getLocalGetIndex","F32","temp","NeF64","F64","EqF32","SubF32","EqF64","SubF64","isAny","makeIsTrueish","compileCallDirect","offset","elementType","valuesOperand","Array_literal_expected","numElements","exprs","isStatic","makeZero","buf","writeStaticBuffer","byteLength","addAlignedMemorySegment","i31ref","fromType","isChangeableTo","Type_0_cannot_be_changed_to_type_1","nonNullableType","noAssert","evaled","Default","getExpressionType","getConstValueF32","getConstValueF64","makeAbort","EqzI32","EqzI64","ref_is","RefIsOp","RefIsNull","alreadyUnchecked","unset","indexArg","operandExprs","paramTypeRefs","classInstance","This_expression_is_not_constructable","ctor","ensureConstructor","checkFieldInitialization","compileInstantiate","functionPrototype","ftype","requiredParameters","functionArg","shift","thisArg","_this_cannot_be_referenced_in_current_location","compileCallIndirect","Not_implemented_0","isizeType","writeI16","writeI32","writeF32","writeF64","AndV128","OrV128","XorV128","AndnotV128","builtin_v128_bitwise_unary","NotV128","simd_ternary","builtin_v128_bitwise_ternary","SIMDTernaryOp","Bitselect","AnyTrueV128","runtimeFeatures","elementsByName","global","INLINED","constantIntegerValue","global_get","block","managedClasses","nextId","_keys","Map_keys","instanceId","isPointerfree","return","current","switch","SubI64","count","data","abvInstance","arrayBufferViewInstance","abvPrototype","setPrototype","mapPrototype","staticArrayPrototype","lastId","getArrayValueType","getTypeArgumentsTo","rttiFlags","segment","addGlobal","instanceofInstance","stmts","instances","PARENT_SUBST","GETTER_PREFIX","SETTER_PREFIX","INSTANCE_DELIMITER","STATIC_DELIMITER","INNER_DELIMITER","INDEX_SUFFIX","STUB_DELIMITER","CommonNames","funcref","externref","anyref","eqref","dataref","u8x16","u16x8","u32x4","u64x2","void_","number","boolean","string","native","indexof","valueof","returnof","nonnull","null_","true_","false_","this_","super_","constructor","ASC_TARGET","ASC_NO_TREESHAKING","ASC_NO_ASSERT","ASC_MEMORY_BASE","ASC_TABLE_BASE","ASC_OPTIMIZE_LEVEL","ASC_SHRINK_LEVEL","ASC_LOW_MEMORY_LIMIT","ASC_EXPORT_RUNTIME","ASC_WASI","ASC_FEATURE_SIGN_EXTENSION","ASC_FEATURE_MUTABLE_GLOBALS","ASC_FEATURE_NONTRAPPING_F2I","ASC_FEATURE_BULK_MEMORY","ASC_FEATURE_SIMD","ASC_FEATURE_THREADS","ASC_FEATURE_EXCEPTION_HANDLING","ASC_FEATURE_TAIL_CALLS","ASC_FEATURE_REFERENCE_TYPES","ASC_FEATURE_MULTI_VALUE","ASC_FEATURE_GC","ASC_FEATURE_MEMORY64","ASC_VERSION_MAJOR","ASC_VERSION_MINOR","ASC_VERSION_PATCH","I8","I16","Isize","U8","U16","U32","U64","Usize","Bool","V128","Funcref","Externref","Anyref","Eqref","I31ref","Dataref","String","StaticArray","Set","ArrayBufferView","ArrayBuffer","Mathf","NativeMath","NativeMathf","TemplateStringsArray","ipow32","ipow64","alloc","realloc","free","new_","renew","link","collect","typeinfo","instanceof_","visit","newBuffer","newArray","Feature","Target","Typeinfo","TypeinfoFlags","ExportNames","target","WASM32","exportMemory","importMemory","initialMemory","maximumMemory","sharedMemory","importTable","exportTable","sourceMap","explicitStart","memoryBase","tableBase","globalAliases","features","noUnsafe","pedantic","lowMemoryLimit","exportRuntime","stackSize","bundleMajorVersion","bundleMinorVersion","bundlePatchVersion","optimizeLevelHint","shrinkLevelHint","WASM64","isize64","isize32","Constraints","RuntimeFeatures","memory","table","runtimeFunctions","runtimeGlobals","Compiler","DiagnosticEmitter","diagnostics","currentParent","memorySegments","stringSegments","functionTable","builtinArgumentsLength","inlineStack","lazyFunctions","pendingClassInstanceOf","virtualCalls","pendingElements","doneModuleExports","f32ModInstance","f64ModInstance","f32PowInstance","f64PowInstance","i32PowInstance","i64PowInstance","_reusableCallExpression","create","setLowMemoryUnused","featureFlags","FeatureFlags","SignExt","MutableGloabls","NontrappingFPToInt","BulkMemory","SIMD128","Atomics","ExceptionHandling","TailCall","ReferenceTypes","MultiValue","GC","Memory64","setFeatures","startFunctionInstance","makeNativeFunction","Signature","currentBody","shadowStack","ShadowStackPass","compile","hasShadowStack","initialize","actualFunction","startFunctionBody","files","filesByName","file","USER_ENTRY","compileFile","compileExports","ensureModuleExports","requireFunction","hasExport","addFunctionExport","requireGlobal","compileGlobal","addGlobalExport","functionsToCompile","Set_values","clear","compileClassInstanceOf","VIRTUAL","INSTANCE","ensureVirtualStub","finalizeVirtualStub","ensureVarargsStub","delete","removeGlobal","compileRTTI","compileVisitGlobals","compileVisitMembers","i64_align","lowMemoryLimit32","i64_gt","Low_memory_limit_exceeded_by_static_data_0_1","i64_to_string","initialPages","i64_shr_u","Module_requires_at_least_0_pages_of_initial_memory","maximumPages","UNLIMITED_MEMORY","Module_requires_at_least_0_pages_of_maximum_memory","isSharedMemory","Shared_memory_requires_maximum_memory_to_be_defined","Shared_memory_requires_feature_threads_to_be_enabled","setMemory","addMemoryImport","addTableImport","willOptimize","Importing_the_table_disables_some_indirect_call_optimizations","addTableExport","Exporting_the_table_disables_some_indirect_call_optimizations","functionTableNames","addFunctionTable","UNLIMITED_TABLE","global_set","ensureArgumentsLength","startIsEmpty","isWasi","unshift","funcRef","paramRefs","resultRefs","typesToRefs","additionalLocals","finalize","setStart","walkModule","lookup","RtraceMemory","elementName","ensureModuleExport","exportsStar","prefix","functionInstances","instanceName","GENERIC","fullName","Exported_generic_function_or_class_has_no_concrete_instances","identifierNode","CLASS_PROTOTYPE","classPrototype","classInstances","PROPERTY_PROTOTYPE","propertyInstance","CONST","STATIC","READONLY","exportName","Cannot_export_a_mutable_global","ENUMVALUE","enumValue","isImmutable","functionInstance","hasManagedOperands","noteExport","getManagedOperandIndices","PROPERTY","getterInstance","setterInstance","fieldInstance","getterExportName","compileFieldGetter","internalGetterName","internalGetterSignature","setterExportName","compileFieldSetter","internalSetterName","internalSetterSignature","isUnmanaged","ENUM","INTERFACE_PROTOTYPE","NAMESPACE","TYPEDEFINITION","subPrefix","implicitExport","SCOPED","memberName","PRIVATE","compileMembers","compileEnum","resolveClass","compileClass","resolveProperty","compileProperty","compileElement","exportStar","normalizedPathWithoutExtension","pathWithIndex","File_0_not_found","startFunction","startSignature","previousBody","previousFlow","compileTopLevelStatement","locals","localsByIndex","numLocals","varTypes","ERRORED","initExpr","typeNode","initializerNode","RESOLVED","resolvedType","resolveType","Type_expected","setType","checkTypeSupported","atEnd","Type_0_is_not_assignable_to_type_1","AMBIENT","isDeclaredConstant","isDeclaredInline","MODULE_IMPORT","mangleImportName","addGlobalImport","mangleImportName_moduleName","mangleImportName_elementName","initializeInStart","GlobalGet","fromName","getGlobalGetName","isGlobalMutable","getGlobal","warning","Mutable_value_cannot_be_inlined","constantValueKind","constantFloatValue","compileInlineConstant","Decorator_0_is_not_valid_here","findDecorator","decoratorNodes","previousParent","previousValue","previousValueIsMut","isInline","initInStart","valueNode","In_const_enum_declarations_member_initializer_must_be_constant_expression","Enum_member_must_have_initializer","makeGlobalAssignment","setConstantIntegerValue","MODULE_EXPORT","forceStdAlternative","numParameters","visited","paramIdentifier","paramName","Duplicate_identifier_0","previousType","bodyNode","declarationNode","checkSignatureSupported","An_implementation_cannot_be_declared_in_ambient_contexts","compileFunctionBody","addFunctionImport","getFunction","ABSTRACT","INTERFACE","Function_implementation_is_missing_or_not_immediately_following_the_declaration","thisLocal","lookupLocal","bodyStartIndex","compileStatements","GET","SET","canOverflow","isNonnull","allocStmts","makeConditionalAllocation","makeFieldInitializationInConstructor","Explicitly_returning_constructor_drops_this_allocation","A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final","Constructors_for_derived_classes_must_contain_a_super_call","A_function_whose_declared_type_is_not_void_must_return_a_value","staticMembers","instanceMembers","compileField","getterRef","valueTypeRef","thisTypeRef","setterRef","bodyExpr","linkInstance","compilePropertyGetter","compilePropertySetter","buffer","alignment","MemorySegment","computeBlockStart64","stringValue","ptr","ensureStaticStringPtr","stringSegment","totalOverhead","segments","createBuffer","addRuntimeMemorySegment","elementTypeRef","writeI64","arrayBufferInstance","OBJECTInstance","writeField","bufferSegment","arrayInstance","bufferLength","readI32","arrayLength","bufferAddress","STUB","memorySegment","rtInstance","memberStatements","getElementByDeclaration","exportStatement","compileFileByPath","importStatement","stmt","compileStatement","Nop","isLastInBody","compileBlockStatement","compileBreakStatement","compileContinueStatement","compileDoStatement","compileEmptyStatement","compileExpressionStatement","compileForStatement","compileForOfStatement","compileIfStatement","compileReturnStatement","compileSwitchStatement","compileThrowStatement","compileTryStatement","compileVariableStatement","compileVoidStatement","compileWhileStatement","addDebugLocation","isBody","numStatements","Block","getBlockName","getBlockChildCount","getBlockChildAt","needsExplicitUnreachable","outerFlow","innerFlow","fork","freeScopedLocals","inherit","labelNode","breakLabel","A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement","br","continueLabel","A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement","doCompileDoStatement","flowAfter","pushBreakLabel","unifyLocalFlags","flowBefore","bodyFlow","bodyStmts","condFlow","condExpr","condKind","evaluateCondition","drop","tcond","local_set","Flow","hasIncompatibleLocalStates","popBreakLabel","hasScopedLocals","loop","doCompileForStatement","loopLabel","loopStmts","inheritNonnullIfTrue","inheritBranch","ifStmts","incrFlow","thenStmts","thenFlow","elseStmts","elseFlow","inheritNonnullIfFalse","inheritMutual","valueExpression","constraints","inlineReturnLabel","numCases","context","tempLocal","tempLocalIndex","breaks","breakIndex","defaultIndex","EqI32","currentBlock","commonCategorical","commonConditional","isLast","nextLabel","terminates","message","newArgs","numDeclarations","initializers","uniqueMap","contextualTypeArguments","dummy","addScopedDummyLocal","freeScopedDummyLocal","isConst","local","Local","parentFunction","setConstantFloatValue","scopedLocals","existing","errorRelated","_const_declarations_must_be_initialized","LET","existingLocal","getScopedLocal","isNative","addScopedLocal","CONSTANT","addLocal","makeLocalAssignment","isShortIntegerValue","doCompileWhileStatement","computeSmallIntegerShift","computeSmallIntegerMask","compileAssertionExpression","compileBinaryExpression","compileCallExpression","compileCommaExpression","compileElementAccessExpression","compileFunctionExpression","compileIdentifierExpression","compileInstanceOfExpression","compileLiteralExpression","compileNewExpression","compilePropertyAccessExpression","compileTernaryExpression","compileUnaryPostfixExpression","compileUnaryPrefixExpression","compiled","wrap","ensureSmallIntegerWrap","explicit","makeRuntimeNonNullCheck","isExternalReference","makeRuntimeUpcastCheck","Conversion_from_type_0_to_1_requires_an_explicit_cast","PromoteF32ToF64","DemoteF64ToF32","saturating","isLongIntegerValue","TruncSatF32ToI64","TruncF32ToI64","TruncSatF32ToI32","TruncF32ToI32","TruncSatF32ToU64","TruncF32ToU64","TruncSatF32ToU32","TruncF32ToU32","TruncSatF64ToI64","TruncF64ToI64","TruncSatF64ToI32","TruncF64ToI32","TruncSatF64ToU64","TruncF64ToU64","TruncSatF64ToU32","TruncF64ToU32","ConvertI64ToF32","ConvertU64ToF32","ConvertI32ToF32","ConvertU32ToF32","ConvertI64ToF64","ConvertU64ToF64","ConvertI32ToF64","ConvertU32ToF64","NeI64","WrapI64ToI32","ExtendI32ToI64","ExtendU32ToU64","isVaryingIntegerValue","Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit","inheritedConstraints","PREFIX","AS","NONNULL","exceptVoid","info","Expression_is_never_null","leftExpr","leftType","rightExpr","rightType","commonType","compound","Token","LESSTHAN","overload","lookupOverload","OperatorKind","LT","compileBinaryOverload","commonDenominator","Operator_0_cannot_be_applied_to_types_1_and_2","makeLt","GREATERTHAN","GT","makeGt","LESSTHAN_EQUALS","LE","makeLe","GREATERTHAN_EQUALS","GE","makeGe","EQUALS_EQUALS_EQUALS","EQUALS_EQUALS","EQ","operatorTokenToString","makeEq","EXCLAMATION_EQUALS_EQUALS","EXCLAMATION_EQUALS","NE","makeNe","EQUALS","compileAssignment","PLUS_EQUALS","PLUS","ADD","The_0_operator_cannot_be_applied_to_type_1","MINUS_EQUALS","MINUS","SUB","ASTERISK_EQUALS","ASTERISK","MUL","ASTERISK_ASTERISK_EQUALS","ASTERISK_ASTERISK","POW","makePow","SLASH_EQUALS","SLASH","DIV","PERCENT_EQUALS","PERCENT","REM","makeRem","LESSTHAN_LESSTHAN_EQUALS","LESSTHAN_LESSTHAN","intType","BITWISE_SHL","makeShl","GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN","BITWISE_SHR","makeShr","GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN_GREATERTHAN","BITWISE_SHR_U","makeShru","AMPERSAND_EQUALS","AMPERSAND","BITWISE_AND","makeAnd","BAR_EQUALS","BAR","BITWISE_OR","makeOr","CARET_EQUALS","CARET","BITWISE_XOR","makeXor","AMPERSAND_AMPERSAND","rightFlow","cloneExpression","BAR_BAR","targetType","getTypeOfElement","makeAssignment","currentThisExpression","currentElementExpression","LtF32","LtF64","GtF32","GtF64","LeI32","LeI64","LeU32","LeU64","LeF32","LeF64","GeI32","GeI64","GeU32","GeU64","GeF32","GeF64","EqI64","ref_eq","NeI32","AddF32","AddF64","MulI32","MulI64","MulF32","MulF64","Cannot_find_name_0","makeCallDirect","namespace","namespaceMembers","DivI32","DivI64","DivU32","DivU64","DivF32","DivF64","RemI32","RemI64","RemU32","RemU64","ShlI64","ShrU64","AndI64","OrI64","operatorInstance","valueExpr","thisExpression","LOCAL","Variable_0_used_before_its_declaration","checkUnsafe","propertyPrototype","Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property","isUnchecked","indexedSet","INDEXED_SET","INDEXED_GET","Index_signature_in_type_0_only_permits_reading","Index_signature_is_missing_in_type_0","Indexed_access_may_involve_bounds_checking","indexExpression","tee","isLocalFlag","isConstructor","setThisFieldFlag","FieldFlags","INITIALIZED","fieldParent","makeFieldAssignment","thisExpr","returnTypeRef","tempThis","elementExpr","tempTarget","tempElement","localIndex","unsetLocalFlag","field","fieldType","fieldTypeRef","Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors","baseClassInstance","_super_can_only_be_referenced_in_a_derived_class","baseCtorInstance","superCall","_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class","compileCallExpressionBuiltin","maybeInferCall","inlinedValue","Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures","Expression_cannot_be_represented_by_a_type","createCallExpression","resolveTypeArguments","callee","BuiltinContext","fn","methodName","hasThis","The_this_types_of_each_signature_are_incompatible","hasRest","minimum","maximum","relatedReportNode","isLibrary","Operation_is_unsafe","argumentExpressions","checkCallSignature","isAccessOnThis","isAccessOnSuper","includes","makeCallInline","pop","Function_0_cannot_be_inlined_into_itself","numArgumentsInclThis","paramType","paramExpr","immediatelyDropped","createInline","usedLocals","argumentLocal","getParameterName","addScopedAlias","initType","checkFieldInitializationInFlow","original","stub","varargsStub","originalSignature","originalParameterTypes","originalParameterDeclarations","isInstance","minArguments","minOperands","maxArguments","maxOperands","numOptional","forwardedOperands","operandIndex","newStub","numNames","ofN","Optional_parameter_must_have_an_initializer","virtualStub","ref","overloadPrototypes","overloads","parentClassInstance","tempIndex","builder","SwitchBuilder","unboundOverloadPrototype","isBound","unboundOverloadParent","isProperty","propertyParent","overloadInstance","boundProperty","boundPropertyInstance","boundPrototype","overloadType","originalType","overloadSignature","overloadParameterTypes","overloadNumParameters","paramExprs","n","needsVarargsStub","calledName","addCase","extendees","getAllExtendees","a","b","extendee","removeFunction","render","isConstZero","Function_0_is_virtual_and_will_not_be_inlined","theOperands","slice","allOptionalsAreConstant","compilesToConst","resolved","lastOperand","getSideEffects","SideEffects","WritesGlobal","lastOperandType","operandsTostack","makeCallIndirect","numExpressions","targetExpression","resolveExpression","indexedGet","clone","isNamed","isSemanticallyAnonymous","FunctionPrototype","nextAnonymousId","contextualSignature","signatureNode","numPresentParameters","parameterNode","isTypeOmitted","thisTypeNode","outer","worked","ensureRuntimeFunction","fname","asNullable","Expression_resolves_to_unusual_type_0","_this_cannot_be_referenced_in_constructor_arguments","_super_cannot_be_referenced_in_constructor_arguments","_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class","scopedThis","superType","maybeCompileEnclosingSource","lookupIdentifierExpression","localType","globalType","A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums","ref_func","Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime","namedType","hasTypeArguments","resolveTypeName","makeInstanceofClass","expectedType","makeInstanceofType","actualType","Expression_compiles_to_a_dynamic_check_at_runtime","implicitlyNegate","compileArrayLiteral","floatValue","intValue","determineIntegerLiteralType","i64_to_f32","i64_to_f64","compileStringLiteral","compileTemplateLiteral","compileObjectLiteral","numParts","stringType","addStaticBuffer","joinInstance","getMethod","indexedSetInstance","makeToString","tsaArrayInstance","templateStringsArrayInstance","first","arraySegment","partExprs","rawExprs","addStaticArrayHeader","rawHeaderSegment","createCompiledExpression","nativeRange","compileCallExpressionLike","contextualClass","compileStaticArrayLiteral","arrayType","tempDataStart","arrayAddress","newArrayInstance","arrayTypeRef","dataStartMember","bufferSize","newBufferInstance","classType","Cannot_create_an_instance_of_an_abstract_class","ctorPrototype","constructorPrototype","Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal","hasErrors","classTypeRef","omittedFields","memberKey","Property_0_does_not_exist_on_type_1","Property_0_is_private_and_only_accessible_within_class_1","PROTECTED","Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses","Property_0_is_missing_in_type_1_but_required_in_type_2","resolveClassInclTypeArguments","constructorInstance","baseClass","baseCtor","makeNativeFunctionDeclaration","setResolvedInstance","relatedNode","didCheckFieldInitialization","isThisFieldFlag","DEFINITELY_ASSIGNED","Property_0_is_always_assigned_before_being_used","Unnecessary_definite_assignment","Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned","ctorInstance","ctxType","parentEnum","Property_0_is_used_before_being_assigned","Object_is_possibly_null","ifThenFlow","ifThenExpr","ifThenType","ifElseFlow","ifElseExpr","ifElseType","getValue","Unreachable","PLUS_PLUS","POSTFIX_INC","getLocalSetValue","compileUnaryOverload","makeOne","MINUS_MINUS","POSTFIX_DEC","setValue","NegF32","NegF64","PREFIX_INC","PREFIX_DEC","EXCLAMATION","NOT","TILDE","BITWISE_NOT","makeNegOne","TYPEOF","compileTypeof","DOT_DOT_DOT","typeString","REPORT","Extend8I32","Extend16I32","addDebugInfoFile","debugInfoRef","debugLocations","supported","parameterReportNode","v128_zero","ref_null","toStringInstance","toStringSignature","identifierAndSignatureRange","toStringReturnType","allocInstance","newInstance","thisIndex","makeAllocation","thisLocalIndex","nonParameterFields","fieldPrototype","codeLocation","abortInstance","messageArg","makeStaticAbort","messageExpr","filenameExpr","lineAt","columnAt","mangleInternalName","arg","ExportsWalker","includePrivate","seen","visitFile","visitElement","visitGlobal","visitEnum","visitFunctionInstances","visitClassInstances","visitField","visitFunction","hasCompiledMember","visitNamespace","visitAlias","visitClass","IDLBuilder","sb","indentLevel","build","indent","typeToString","originalName","walk","TSDBuilder","remainingMembers","isInterface","extendsNode","code","diagnosticCategoryToString","PEDANTIC","diagnosticCategoryToColor","COLOR_MAGENTA","COLOR_CYAN","COLOR_YELLOW","COLOR_RED","diagnosticCodeToString","DiagnosticMessage","relatedRange","replace","thisRange","otherRange","thisRelatedRange","otherRelatedRange","formatDiagnosticContext","isLineBreak","isColorsEnabled","COLOR_RESET","useColors","showContext","wasColorsEnabled","setColorsEnabled","relatedSource","withRange","seenInSource","seenMessagesAtPos","ASTBuilder","visitNode","finish","visitSource","visitNamedTypeNode","visitFunctionTypeNode","visitTypeParameter","visitIdentifierExpression","visitAssertionExpression","visitBinaryExpression","visitCallExpression","visitClassExpression","visitCommaExpression","visitElementAccessExpression","visitFunctionExpression","visitInstanceOfExpression","visitLiteralExpression","visitNewExpression","visitParenthesizedExpression","visitPropertyAccessExpression","visitTernaryExpression","visitUnaryPostfixExpression","visitUnaryPrefixExpression","visitBlockStatement","visitBreakStatement","visitContinueStatement","visitDoStatement","visitEmptyStatement","visitExportStatement","visitExportDefaultStatement","visitExportImportStatement","visitExpressionStatement","visitForStatement","visitForOfStatement","visitIfStatement","visitImportStatement","visitReturnStatement","visitSwitchStatement","visitThrowStatement","visitTryStatement","visitVariableStatement","visitWhileStatement","visitClassDeclaration","visitEnumDeclaration","visitEnumValueDeclaration","visitFieldDeclaration","visitFunctionDeclaration","visitImportDeclaration","visitInterfaceDeclaration","visitMethodDeclaration","visitNamespaceDeclaration","visitTypeDeclaration","visitVariableDeclaration","serializeDecorator","visitExportMember","serializeParameter","visitSwitchCase","visitIndexSignature","visitNodeAndTerminate","visitTypeName","visitTypeNode","visitStringLiteral","elements","visitArguments","numArgs","visitFunctionCommon","visitFloatLiteralExpression","visitIntegerLiteralExpression","visitStringLiteralExpression","visitTemplateLiteralExpression","visitRegexpLiteralExpression","visitArrayLiteralExpression","visitObjectLiteralExpression","visitRawString","quote","last","lastCharPos","isDefault","serializeExternalModifiers","numImplementsTypes","numMembers","numValues","serializeAccessModifiers","numTypeParameters","firstDeclaration","REST","OPTIONAL","DECLARE","PUBLIC","FlowFlags","ConditionKind","localFlags","thisFieldFlags","inlineFunction","initThisFieldFlags","nextInlineId","resetBreakContext","branch","except","temps","tempI32s","tempI64s","tempF32s","tempF64s","tempV128s","tempFuncrefs","tempExternrefs","tempAnyrefs","tempEqrefs","tempI31refs","tempDatarefs","resetTemporaryName","scopedLocal","setTemporaryName","scopedDummy","scopedAlias","scope","localsByName","defaultIfInlined","actualParent","actualClass","fieldFlags","nextBreakId","stack","breakStack","otherFlags","conditionKind","thisFlags","newFlags","thisLocalFlags","numThisLocalFlags","otherLocalFlags","numOtherLocalFlags","maxLocalFlags","leftFlags","rightFlags","rightLocalFlags","leftLocalFlags","numLeftLocalFlags","numRightLocalFlags","leftFieldFlags","newFieldFlags","rightFieldFlags","key","before","after","LocalSet","isLocalTee","getLocalSetIndex","iff","If","getIfFalse","getIfCondition","getIfTrue","Unary","getUnaryOp","getUnaryValue","Binary","getBinaryOp","getBinaryLeft","getBinaryRight","exprType","canConversionOverflow","isUnsignedIntegerValue","Extend8I64","Extend16I64","Extend32I64","Load","signed","isLoadSigned","getLoadBytes","Select","getSelectThen","getSelectElse","Call","instancesByName","getCallTarget","levels","formatDiagnosticMessage","Options","alias","DEFAULT_STACK_SIZE","FEATURE_SIGN_EXTENSION","FEATURE_MUTABLE_GLOBALS","FEATURE_NONTRAPPING_F2I","FEATURE_BULK_MEMORY","FEATURE_SIMD","FEATURE_THREADS","FEATURE_EXCEPTION_HANDLING","FEATURE_TAIL_CALLS","FEATURE_REFERENCE_TYPES","FEATURE_MULTI_VALUE","FEATURE_GC","FEATURE_MEMORY64","optimizeLevel","shrinkLevel","Program","diagnosticsOffset","getSource","isEntry","parser","parseFile","nextFile","getDependee","util","Auto","ExternalKind","RefAsOp","BrOnOp","useShadowStack","sizeType","hasTemporaryFunction","cachedStringsToPointers","cachedPointersToStrings","lit","binaryen","_malloc","_BinaryenSizeofLiteral","_BinaryenModuleCreate","cArr","allocU8Array","_BinaryenModuleRead","_free","out","_BinaryenLiteralInt32","_BinaryenConst","valueLow","valueHigh","_BinaryenLiteralInt64","i64_is","_BinaryenLiteralFloat32","_BinaryenLiteralFloat64","__i32_store8","_BinaryenLiteralVec128","_BinaryenRefNull","_BinaryenRefEq","_last","isWam64","ClzSize","CtzSize","PopcntSize","EqzSize","_BinaryenUnary","AddSize","SubSize","MulSize","DivISize","DivUSize","RemISize","RemUSize","AndSize","OrSize","XorSize","ShlSize","ShrISize","ShrUSize","RotlSize","RotrSize","EqSize","NeSize","LtISize","LtUSize","LeISize","LeUSize","GtISize","GtUSize","GeISize","GeUSize","_BinaryenBinary","_BinaryenMemorySize","_BinaryenMemoryGrow","_BinaryenLocalGet","_BinaryenExpressionGetType","_BinaryenLocalTee","cStr","allocStringCached","_BinaryenGlobalGet","_BinaryenLoad","_BinaryenStore","_BinaryenAtomicLoad","_BinaryenAtomicStore","_BinaryenAtomicRMW","replacement","_BinaryenAtomicCmpxchg","timeout","_BinaryenAtomicWait","notifyCount","_BinaryenAtomicNotify","_BinaryenAtomicFence","_BinaryenLocalSet","_BinaryenGlobalSet","children","allocPtrArray","_BinaryenBlock","single","Return","Throw","singleType","_BinaryenBreak","_BinaryenDrop","ReadsLocal","ReadsGlobal","_BinaryenLoop","_BinaryenIf","_BinaryenNop","_BinaryenReturn","_BinaryenSelect","defaultName","strs","_BinaryenSwitch","isReturn","_BinaryenReturnCall","_BinaryenCall","params","results","_BinaryenReturnCallIndirect","_BinaryenCallIndirect","tableName","_BinaryenUnreachable","dest","_BinaryenMemoryCopy","_BinaryenMemoryFill","tagName","_BinaryenThrow","_BinaryenRethrow","_BinaryenPop","_BinaryenTupleMake","tuple","_BinaryenTupleExtract","vec","_BinaryenSIMDExtract","_BinaryenSIMDReplace","vec1","vec2","_BinaryenSIMDShuffle","c","_BinaryenSIMDTernary","_BinaryenSIMDShift","_BinaryenSIMDLoad","_BinaryenSIMDLoadStoreLane","_BinaryenRefIs","_BinaryenRefAs","_BinaryenRefFunc","_BinaryenI31New","_BinaryenI31Get","mutable","_BinaryenAddGlobal","_BinaryenGetGlobal","_BinaryenRemoveGlobal","_BinaryenAddTag","_BinaryenGetTag","_BinaryenRemoveTag","_BinaryenAddFunction","_BinaryenGetFunction","_BinaryenRemoveFunction","paramTypes","tempName","func","_BinaryenSetStart","cStr1","cStr2","_BinaryenAddFunctionExport","_BinaryenAddTableExport","_BinaryenAddMemoryExport","_BinaryenAddGlobalExport","_BinaryenAddTagExport","_BinaryenRemoveExport","_BinaryenGetExport","externalModuleName","externalBaseName","cStr3","_BinaryenAddFunctionImport","_BinaryenAddTableImport","shared","_BinaryenAddMemoryImport","_BinaryenAddGlobalImport","_BinaryenAddTagImport","initial","segs","psvs","offs","sizs","cArr1","cArr2","cArr3","cArr4","u32s","__i32_store","allocU32Array","_BinaryenSetMemory","funcs","tableRef","_BinaryenGetTable","_BinaryenTableSetInitial","_BinaryenTableSetMax","_BinaryenAddTable","_BinaryenAddActiveElementSegment","contents","_BinaryenAddCustomSection","_BinaryenGetOptimizeLevel","level","_BinaryenSetOptimizeLevel","_BinaryenGetShrinkLevel","_BinaryenSetShrinkLevel","_BinaryenGetDebugInfo","on","_BinaryenSetDebugInfo","_BinaryenGetLowMemoryUnused","_BinaryenSetLowMemoryUnused","_BinaryenGetFastMath","_BinaryenSetFastMath","_BinaryenGetPassArgument","readString","_BinaryenSetPassArgument","_BinaryenClearPassArguments","_BinaryenGetAlwaysInlineMaxSize","_BinaryenSetAlwaysInlineMaxSize","_BinaryenGetFlexibleInlineMaxSize","_BinaryenSetFlexibleInlineMaxSize","_BinaryenGetOneCallerInlineMaxSize","_BinaryenSetOneCallerInlineMaxSize","_BinaryenGetAllowInliningFunctionsWithLoops","enabled","_BinaryenSetAllowInliningFunctionsWithLoops","_BinaryenModuleGetFeatures","_BinaryenModuleSetFeatures","pass","allocString","_BinaryenFunctionRunPasses","_BinaryenModuleRunPasses","passes","cStrs","debugInfo","setOptimizeLevel","setShrinkLevel","setDebugInfo","setFastMath","clearPassArguments","setAlwaysInlineMaxSize","setFlexibleInlineMaxSize","setOneCallerInlineMaxSize","setAllowInliningFunctionsWithLoops","getLowMemoryUnused","getFeatures","runPasses","_BinaryenModuleValidate","_BinaryenModuleInterpret","sourceMapUrl","binaryPtr","sourceMapPtr","_BinaryenModuleAllocateAndWrite","__i32_load","binaryLen","BinaryModule","__i32_load8_u","readBuffer","watFormat","cached","_BinaryenModuleDispose","Relooper","noSideEffects","maxDepth","nested1","nested2","_BinaryenExpressionGetId","_BinaryenConstGetValueI32","_BinaryenConstGetValueI64Low","_BinaryenConstGetValueI64High","_BinaryenConstGetValueF32","_BinaryenConstGetValueF64","_BinaryenLocalGetGetIndex","globalName","_BinaryenGlobalGetGetName","_BinaryenLoadGetPtr","_BinaryenLoadIsAtomic","_BinaryenLoadGetBytes","_BinaryenLoadGetOffset","_BinaryenLoadIsSigned","_BinaryenLoadGetAlign","_BinaryenUnaryGetValue","_BinaryenUnaryGetOp","_BinaryenBinaryGetLeft","_BinaryenBinaryGetRight","_BinaryenBinaryGetOp","_BinaryenExpressionCopy","maxLoopIterations","runner","_ExpressionRunnerCreate","_ExpressionRunnerRunAndDispose","_BinaryenModuleAddDebugInfoFileName","_BinaryenModuleGetDebugInfoFileName","fileIndex","lineNumber","columnNumber","_BinaryenFunctionSetDebugLocation","types","_BinaryenTypeCreate","arity","_BinaryenTypeArity","_BinaryenTypeExpand","_BinaryenLocalSetGetIndex","_BinaryenLocalSetGetValue","_BinaryenLocalSetIsTee","_BinaryenStoreGetBytes","_BinaryenStoreGetOffset","_BinaryenStoreGetPtr","_BinaryenStoreGetValue","_BinaryenBlockGetName","_BinaryenBlockGetNumChildren","_BinaryenBlockGetChildAt","_BinaryenIfGetCondition","_BinaryenIfGetIfTrue","_BinaryenIfGetIfFalse","_BinaryenLoopGetName","_BinaryenLoopGetBody","_BinaryenBreakGetName","_BinaryenBreakGetCondition","_BinaryenSelectGetIfTrue","_BinaryenSelectGetIfFalse","_BinaryenSelectGetCondition","_BinaryenDropGetValue","_BinaryenReturnGetValue","_BinaryenCallGetTarget","_BinaryenCallGetNumOperands","_BinaryenCallGetOperandAt","_BinaryenMemoryGrowGetDelta","_BinaryenFunctionGetBody","_BinaryenFunctionGetName","_BinaryenFunctionGetParams","_BinaryenFunctionGetResults","_BinaryenFunctionGetNumVars","_BinaryenFunctionGetVar","_BinaryenGlobalGetName","_BinaryenGlobalGetType","_BinaryenGlobalIsMutable","_BinaryenGlobalGetInitExpr","_BinaryenTagGetName","_BinaryenTagGetParams","_BinaryenTagGetResults","_RelooperCreate","_RelooperAddBlock","from","to","_RelooperAddBranch","_RelooperAddBlockWithSwitch","indexes","i32s","allocI32Array","_RelooperAddBranchForSwitch","entry","labelHelper","_RelooperRenderAndDispose","All","_BinaryenExpressionGetSideEffects","u8s","ptrs","u","stringLengthUTF8","cp","u1","u2","u3","arr","ch","fromCharCodes","labelPostfix","labels","defaultLabel","lastCase","output","Break","numChildren","Dependee","Parser","sources","backlog","seenlog","donelog","onComment","currentSource","dependees","tryParseSignatureIsSignature","parseParametersThis","dependee","Source","USER","tn","Tokenizer","skip","ENDOFFILE","parseTopLevelStatement","skipStatement","startPos","AT","tokenPos","parseDecorator","exportStart","exportEnd","defaultStart","defaultEnd","DEFAULT","declareStart","declareEnd","contextIsAmbient","A_declare_modifier_cannot_be_used_in_an_already_ambient_context","peek","nextTokenPos","parseEnum","parseVariable","VAR","parseFunction","state","mark","abstractStart","abstractEnd","nextTokenOnNewLine","reset","parseStatement","_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration","discard","parseClassOrInterface","IdentifierHandling","PREFER","parseNamespace","parseExportImport","parseImport","TYPE","parseTypeDeclaration","skipIdentifier","An_export_assignment_cannot_have_modifiers","parseExportDefaultAlias","parseExport","_0_modifier_cannot_be_used_here","Decorators_are_not_valid_here","createExportDefaultStatement","dependent","readIdentifier","DOT","Identifier_expected","acceptParenthesized","suppressErrors","token","OPENPAREN","isNullableSignature","tryParseFunctionType","CLOSEPAREN","_0_expected","Unexpected_token","innerType","parseType","createNamedType","STRINGLITERAL","parseTypeName","parameter","notNullStart","notNull","OPENBRACKET","bracketStart","CLOSEBRACKET","bracketRange","nullable","isSignature","firstParamNameNoType","firstParamKind","paramStart","COLON","QUESTION","A_rest_parameter_cannot_be_optional","param","createParameter","createOmittedType","EQUALS_GREATERTHAN","createFunctionType","createPropertyAccessExpression","createDecorator","parseArguments","isFor","parseVariableDeclaration","createVariableStatement","SEMICOLON","parentFlags","parentDecorators","isIllegalVariableIdentifier","Initializers_are_not_allowed_in_ambient_contexts","parseExpression","A_definite_assignment_assertion_is_not_permitted_in_this_context","createVariableDeclaration","OPENBRACE","CLOSEBRACE","parseEnumValue","createEnumDeclaration","createEnumValueDeclaration","nextToken","createReturnStatement","seenOptional","typeParameter","parseTypeParameter","Required_type_parameters_may_not_follow_optional_type_parameters","Type_parameter_list_cannot_be_empty","EXTENDS","createTypeParameter","seenRest","reportedRest","parseParameter","A_rest_parameter_must_be_last_in_a_parameter_list","A_required_parameter_cannot_follow_an_optional_parameter","isRest","isOptional","startRange","accessFlags","A_parameter_property_cannot_be_declared_using_a_rest_parameter","A_rest_parameter_cannot_have_an_initializer","Parameter_cannot_have_question_mark_and_initializer","signatureStart","parseTypeParameters","parseParameters","isSetter","A_set_accessor_must_have_exactly_one_parameter","A_set_accessor_parameter_cannot_have_an_initializer","A_get_accessor_cannot_have_parameters","parseBlockStatement","createFunctionDeclaration","createEmptyIdentifierExpression","parseFunctionExpressionCommon","explicitThis","bodyExpression","createExpressionStatement","createFunctionExpression","IMPLEMENTS","Interface_declaration_cannot_have_implements_clause","createInterfaceDeclaration","createClassDeclaration","parseClassMember","createClassExpression","accessStart","accessEnd","staticStart","staticEnd","GENERIC_CONTEXT","readonlyStart","readonlyEnd","isGetter","getStart","getEnd","setEnd","isGetterOrSetter","createConstructorExpression","retIndex","parseIndexSignature","ALWAYS","typeParametersStart","Type_parameters_cannot_appear_on_a_constructor_declaration","An_accessor_cannot_have_type_parameters","createFieldDeclaration","_0_keyword_cannot_be_used_here","Type_annotation_cannot_appear_on_a_constructor_declaration","A_set_accessor_cannot_have_a_return_type_annotation","Method_0_cannot_have_an_implementation_because_it_is_marked_abstract","retMethod","createMethodDeclaration","Constructor_implementation_is_missing","Optional_properties_are_not_supported","retField","createIndexSignature","createNamespaceDeclaration","parseExportMember","FROM","createStringLiteralExpression","createExportStatement","asIdentifier","createExportMember","skipFrom","parseImportDeclaration","createImportDeclaration","createWildcardImportStatement","createImportStatement","createExportImportStatement","topLevel","parseBreak","parseContinue","parseDoStatement","parseForStatement","parseIfStatement","A_return_statement_can_only_be_used_within_a_function_body","parseReturn","createEmptyStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVoidStatement","parseWhileStatement","parseExpressionStatement","createBlockStatement","createBreakStatement","createContinueStatement","createDoStatement","OF","parseForOfStatement","The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer","createForStatement","createForOfStatement","elseStatement","ELSE","createIfStatement","switchCases","switchCase","parseSwitchCase","createSwitchStatement","CASE","createSwitchCase","_case_or_default_expected","createThrowStatement","CATCH","FINALLY","createTryStatement","createTypeDeclaration","createVoidStatement","createWhileStatement","YIELD","DELETE","createUnaryPrefixExpression","The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access","arguments_","tryParseTypeArgumentsBeforeArguments","createNewExpression","createNullExpression","createTrueExpression","createFalseExpression","createThisExpression","again","parseFunctionExpression","inner","createParenthesizedExpression","maybeParseCallExpression","createOmittedExpression","createArrayLiteralExpression","createObjectLiteralExpression","createAssertionExpression","identifierText","TEMPLATELITERAL","parseTemplateLiteral","_super_must_be_followed_by_an_argument_list_or_member_access","createSuperExpression","INTEGERLITERAL","readInteger","checkForIdentifierStartAfterNumericLiteral","createIntegerLiteralExpression","FLOATLITERAL","readFloat","createFloatLiteralExpression","regexpPattern","readRegexpPattern","createRegexpLiteralExpression","readRegexpFlags","parseClassExpression","Unexpected_end_of_text","Expression_expected","Type_argument_list_cannot_be_empty","precedence","parseExpressionStart","nextPrecedence","determinePrecedence","createInstanceOfExpression","createElementAccessExpression","createUnaryPostfixExpression","createTernaryExpression","commaExprs","createCommaExpression","joinPropertyCall","createBinaryExpression","readStringStart","readStringEnd","readingTemplateString","createTemplateLiteralExpression","potentiallyGeneric","skipBlock","depth","IN","Precedence","FindUsedLocalsVisitor","Visitor","used","localGet","localSet","singleton","visitor","_currentExpression","currentExpression","previousExpression","visitLabel","visitBlock","visitIf","Loop","visitLoop","_BinaryenBreakGetValue","visitBreak","Switch","_BinaryenSwitchGetDefaultName","_BinaryenSwitchGetNumNames","_BinaryenSwitchGetNameAt","_BinaryenSwitchGetCondition","_BinaryenSwitchGetValue","visitSwitch","visitCallPre","visitName","visitCall","CallIndirect","visitCallIndirectPre","_BinaryenCallIndirectGetTarget","_BinaryenCallIndirectGetNumOperands","_BinaryenCallIndirectGetOperandAt","visitCallIndirect","visitIndex","visitLocalGet","visitLocalSet","visitGlobalGet","GlobalSet","_BinaryenGlobalSetGetName","_BinaryenGlobalSetGetValue","visitGlobalSet","visitLoad","Store","visitStore","visitConst","visitUnary","visitBinary","visitSelect","Drop","visitDrop","visitReturn","MemorySize","visitMemorySize","MemoryGrow","visitMemoryGrow","visitNop","visitUnreachable","AtomicRMW","_BinaryenAtomicRMWGetPtr","_BinaryenAtomicRMWGetValue","visitAtomicRMW","AtomicCmpxchg","_BinaryenAtomicCmpxchgGetPtr","_BinaryenAtomicCmpxchgGetExpected","_BinaryenAtomicCmpxchgGetReplacement","visitAtomicCmpxchg","AtomicWait","_BinaryenAtomicWaitGetPtr","_BinaryenAtomicWaitGetExpected","_BinaryenAtomicWaitGetTimeout","visitAtomicWait","AtomicNotify","_BinaryenAtomicNotifyGetPtr","_BinaryenAtomicNotifyGetNotifyCount","visitAtomicNotify","AtomicFence","visitAtomicFence","SIMDExtract","_BinaryenSIMDExtractGetVec","visitSIMDExtract","SIMDReplace","_BinaryenSIMDReplaceGetVec","_BinaryenSIMDReplaceGetValue","visitSIMDReplace","SIMDShuffle","_BinaryenSIMDShuffleGetLeft","_BinaryenSIMDShuffleGetRight","visitSIMDShuffle","SIMDTernary","_BinaryenSIMDTernaryGetA","_BinaryenSIMDTernaryGetB","_BinaryenSIMDTernaryGetC","visitSIMDTernary","SIMDShift","_BinaryenSIMDShiftGetVec","_BinaryenSIMDShiftGetShift","visitSIMDShift","SIMDLoad","_BinaryenSIMDLoadGetPtr","visitSIMDLoad","SIMDLoadStoreLane","_BinaryenSIMDLoadStoreLaneGetPtr","_BinaryenSIMDLoadStoreLaneGetVec","visitSIMDLoadStoreLane","MemoryInit","_BinaryenMemoryInitGetDest","_BinaryenMemoryInitGetOffset","_BinaryenMemoryInitGetSize","visitMemoryInit","DataDrop","visitDataDrop","MemoryCopy","_BinaryenMemoryCopyGetDest","_BinaryenMemoryCopyGetSource","_BinaryenMemoryCopyGetSize","visitMemoryCopy","MemoryFill","_BinaryenMemoryFillGetDest","_BinaryenMemoryFillGetValue","_BinaryenMemoryFillGetSize","visitMemoryFill","Pop","visitPop","RefNull","visitRefNull","RefIs","_BinaryenRefIsGetValue","visitRefIs","RefFunc","_BinaryenRefFuncGetFunc","visitRefFunc","RefEq","_BinaryenRefEqGetLeft","_BinaryenRefEqGetRight","visitRefEq","Try","_BinaryenTryGetBody","numCatchBodies","_BinaryenTryGetNumCatchBodies","_BinaryenTryGetCatchBodyAt","visitTry","visitTag","_BinaryenThrowGetTag","_BinaryenThrowGetNumOperands","_BinaryenThrowGetOperandAt","visitThrow","Rethrow","visitRethrow","TupleMake","_BinaryenTupleMakeGetNumOperands","_BinaryenTupleMakeGetOperandAt","visitTupleMake","TupleExtract","_BinaryenTupleExtractGetTuple","visitTupleExtract","I31New","_BinaryenI31NewGetValue","visitI31New","I31Get","_BinaryenI31GetGetI31","visitI31Get","CallRef","visitCallRef","RefTest","visitRefTest","RefCast","visitRefCast","BrOn","visitBrOn","RttCanon","visitRttCanon","RttSub","visitRttSub","StructNew","visitStructNew","StructGet","visitStructGet","StructSet","visitStructSet","ArrayNew","visitArrayNew","ArrayGet","visitArrayGet","ArraySet","visitArraySet","ArrayLen","visitArrayLen","RefAs","visitRefAs","replaceChild","search","child","_BinaryenBlockSetChildAt","_BinaryenIfSetCondition","_BinaryenIfSetIfTrue","_BinaryenIfSetIfFalse","_BinaryenLoopSetBody","_BinaryenBreakSetCondition","_BinaryenBreakSetValue","_BinaryenSwitchSetCondition","_BinaryenSwitchSetValue","_BinaryenCallSetOperandAt","_BinaryenCallIndirectSetTarget","_BinaryenCallIndirectSetOperandAt","_BinaryenLocalSetSetValue","_BinaryenGlobalSetSetValue","_BinaryenLoadSetPtr","_BinaryenStoreSetPtr","_BinaryenStoreSetValue","_BinaryenUnarySetValue","_BinaryenBinarySetLeft","_BinaryenBinarySetRight","_BinaryenSelectSetIfTrue","_BinaryenSelectSetIfFalse","_BinaryenSelectSetCondition","_BinaryenDropSetValue","_BinaryenReturnSetValue","_BinaryenMemoryGrowSetDelta","_BinaryenAtomicRMWSetPtr","_BinaryenAtomicRMWSetValue","_BinaryenAtomicCmpxchgSetPtr","_BinaryenAtomicCmpxchgSetExpected","repl","_BinaryenAtomicCmpxchgSetReplacement","_BinaryenAtomicWaitSetPtr","_BinaryenAtomicWaitSetExpected","_BinaryenAtomicWaitSetTimeout","_BinaryenAtomicNotifySetPtr","_BinaryenAtomicNotifySetNotifyCount","_BinaryenSIMDExtractSetVec","_BinaryenSIMDReplaceSetVec","_BinaryenSIMDReplaceSetValue","_BinaryenSIMDShuffleSetLeft","_BinaryenSIMDShuffleSetRight","_BinaryenSIMDTernarySetA","_BinaryenSIMDTernarySetB","_BinaryenSIMDTernarySetC","_BinaryenSIMDShiftSetVec","_BinaryenSIMDShiftSetShift","_BinaryenSIMDLoadSetPtr","_BinaryenSIMDLoadStoreLaneSetPtr","_BinaryenSIMDLoadStoreLaneSetVec","_BinaryenMemoryInitSetDest","_BinaryenMemoryInitSetOffset","_BinaryenMemoryInitSetSize","_BinaryenMemoryCopySetDest","_BinaryenMemoryCopySetSource","_BinaryenMemoryCopySetSize","_BinaryenMemoryFillSetDest","_BinaryenMemoryFillSetValue","_BinaryenMemoryFillSetSize","_BinaryenRefIsSetValue","_BinaryenRefEqSetLeft","_BinaryenRefEqSetRight","_BinaryenTrySetBody","catchBody","_BinaryenTrySetCatchBodyAt","_BinaryenThrowSetOperandAt","_BinaryenTupleMakeSetOperandAt","_BinaryenTupleExtractSetTuple","_BinaryenI31NewSetValue","i31Expr","_BinaryenI31GetSetI31","_currentFunction","_currentGlobal","currentFunction","currentGlobal","walkFunctions","walkGlobals","moduleRef","_BinaryenGetNumFunctions","walkFunction","_BinaryenGetFunctionByIndex","_BinaryenGetNumGlobals","walkGlobal","_BinaryenGetGlobalByIndex","init","_BinaryenFunctionSetBody","parentExpressionOrNull","_BinaryenExpressionFinalize","Pass","seenStores","ptrType","readStringCached","checkRT","matchPattern","needsSlot","slotMaps","tempMaps","exportMap","hasStackCheckFunction","callSlotOffset","callSlotStack","slotMap","slotIndex","managedOperandIndices","tempMap","_BinaryenFunctionGetNumLocals","ptrBinaryAdd","ptrBinarySub","ptrConst","makeStackCheck","frameSize","remain","nativeSource","numSlots","match","noteSlot","getSharedTemp","ptrSize","updateCallOperands","callIndirect","replaceCurrent","numVars","vars","exportRef","_BinaryenExportGetKind","internalNameRef","_BinaryenExportGetValue","externalNameRef","_BinaryenExportGetName","expandType","numParams","wrapperName","wrapperNameRef","makeStackOffset","instrumentReturns","InstrumentReturns","makeStackFill","bodyType","updateFunction","updateExport","parentPass","AL_MASK","AL_SIZE","QueuedImport","localFile","localIdentifier","foreignIdentifier","foreignPath","foreignPathAlt","QueuedExport","QueuedExportStar","pathLiteral","fromDecorator","UNCHECKED_INDEXED_GET","UNCHECKED_INDEXED_SET","INVALID","fromBinaryToken","fromUnaryPrefixToken","fromUnaryPostfixToken","nextClassId","nextSignatureId","initialized","elementsByDeclaration","wrapperClasses","uniqueSignatures","_arrayBufferViewInstance","_arrayBufferInstance","_arrayPrototype","_staticArrayPrototype","_setPrototype","_mapPrototype","_functionPrototype","_int8ArrayPrototype","_int16ArrayPrototype","_int32ArrayPrototype","_int64ArrayPrototype","_uint8ArrayPrototype","_uint8ClampedArrayPrototype","_uint16ArrayPrototype","_uint32ArrayPrototype","_uint64ArrayPrototype","_float32ArrayPrototype","_float64ArrayPrototype","_stringInstance","_objectInstance","_templateStringsArrayInstance","_allocInstance","_reallocInstance","_freeInstance","_newInstance","_renewInstance","_linkInstance","_collectInstance","_visitInstance","_typeinfoInstance","_instanceofInstance","_newBufferInstance","_newArrayInstance","_BLOCKInstance","_OBJECTInstance","nativeDummySignature","Resolver","nativeFile","File","requireClass","BLOCKInstance","blockOverhead","objectOverhead","currentOffset","payloadSize","blockSize","computeBlockStart","blockMinsize","decoratorFlags","registerNativeType","TypeDefinition","makeNativeTypeDeclaration","registerConstantInteger","queuedImports","queuedExports","queuedExportsStar","queuedExtends","queuedImplements","initializeExports","initializeExportDefault","initializeImports","initializeVariables","initializeClass","initializeEnum","initializeFunction","initializeInterface","initializeNamespace","initializeTypeDefinition","starExports","foreignFile","lookupForeignFile","ensureExportStar","madeProgress","queuedImport","lookupForeign","splice","asAliasNamespace","Module_0_has_no_exported_member_1","exportNames","queuedExport","ensureExport","globalElement","isDeclaredElement","registerWrapperClass","thisPrototype","baseElement","basePrototype","Class_0_is_final_and_cannot_be_extended","Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa","A_class_may_only_extend_another_class","An_interface_can_only_extend_an_interface","implementsNodes","implementsNode","interfaceElement","interfacePrototype","interfacePrototypes","A_class_can_only_implement_an_interface","markVirtuals","firstChar","markModuleExports","thisInstanceMembers","baseInstanceMembers","thisMember","baseMember","thisMethod","baseMethod","visibilityEquals","Overload_signatures_must_all_be_public_private_or_protected","baseMethodInstances","thisProperty","baseProperty","baseGetter","getterPrototype","thisGetter","baseGetterInstances","baseSetter","setterPrototype","thisSetter","baseSetterInstances","nextPrototype","markModuleExport","className","classElement","wrappedType","isIntegerInclReference","Global","makeNativeVariableDeclaration","merged","tryMerge","lookupExport","fileQueuedExports","queuedExportForeignPath","otherFile","acceptedFlags","fromKind","Duplicate_decorator","ClassPrototype","checkDecorators","Unmanaged_classes_cannot_implement_interfaces","memberDeclarations","memberDeclaration","initializeField","methodDeclaration","initializeProperty","method","initializeMethod","FieldPrototype","addInstance","checkOperatorOverloads","firstArg","_0_is_not_a_valid_operator","Duplicate_function_implementation","operatorKind","parentMembers","PropertyPrototype","Duplicate_property_0","ensureProperty","Enum","initializeEnumValue","EnumValue","initializeExport","queued","endsWith","Export_declaration_conflicts_with_exported_declaration_of_0","initializeImport","validDecorators","InterfacePrototype","initializeFieldAsProperty","Namespace","copyMembers","Element","shadowType","FILE","localIdentifierIfImport","originalDeclaration","reportedIdentifier","isPublic","vis","declaredElements","DeclaredElement","selfProperty","selfGetter","selfSetter","typedElements","TypedElement","aliasNamespaces","ensureGlobal","makeNativeNamespaceDeclaration","ns","copyExportsToNamespace","inSelf","ConstantValueKind","VariableLikeElement","i64_zero","boundPrototypes","bound","instanceKey","nameInclTypeParameters","parameterType","parameterName","createParent","registerConcreteElement","getDefaultParameterName","postfix","setDebugLocation","FIELD_PROTOTYPE","_internalGetterName","_internalSetterName","_internalGetterSignature","_internalSetterSignature","toBound","_isInterface","basePtototype","Class","interfaces","_id","implementers","isBuiltinArray","lengthField","inheritedTypeArguments","baseName","baseType","iface","uncheckedOverload","overhead","computeBlockSize","baseOffset","typeKind","writeI32AsI64","writeI64AsI32","extendedPrototype","float32ArrayPrototype","float64ArrayPrototype","int8ArrayPrototype","int16ArrayPrototype","int32ArrayPrototype","int64ArrayPrototype","uint8ArrayPrototype","uint8ClampedArrayPrototype","uint16ArrayPrototype","uint32ArrayPrototype","uint64ArrayPrototype","exceptIfMember","older","newer","Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local","src","srcMembers","destMembers","asGlobal","cachedDefaultParameterNames","resolveClassPending","ctxElement","ctxTypes","reportMode","resolveNamedType","resolveFunctionType","isSimpleType","simpleName","Type_0_cannot_be_nullable","typeDefinition","resolveBuiltinNativeType","resolveBuiltinIndexofType","resolveBuiltinValueofType","resolveBuiltinReturnTypeType","resolveBuiltinNotNullableType","parameterTypeNode","returnTypeNode","typeArgumentNode","ensureOneTypeArgument","typeArgument","prev","alternativeReportNode","minParameterCount","maxParameterCount","argumentCount","oldCtxTypes","ctxFlow","resolveFunctionInclTypeArguments","typeParameterNames","argumentNodes","argumentExpression","propagateInferredGenericTypes","resolvedTypeArguments","typeParameterNode","inferredType","resolvedDefaultType","Type_argument_expected","ensureResolvedLazyGlobal","isTypedElement","lookupAssertionExpression","lookupBinaryExpression","lookupCallExpression","lookupCommaExpression","lookupElementAccessExpression","lookupFunctionExpression","lookupThisExpression","lookupSuperExpression","lookupInstanceOfExpression","lookupLiteralExpression","lookupNewExpression","lookupPropertyAccessExpression","lookupTernaryExpression","lookupUnaryPostfixExpression","lookupUnaryPrefixExpression","resolveAssertionExpression","resolveBinaryExpression","resolveCallExpression","resolveCommaExpression","resolveElementAccessExpression","resolveFunctionExpression","resolveIdentifierExpression","resolveThisExpression","resolveSuperExpression","resolveInstanceOfExpression","resolveLiteralExpression","resolveNewExpression","resolvePropertyAccessExpression","resolveTernaryExpression","resolveUnaryPostfixExpression","resolveUnaryPrefixExpression","getElementOfType","targetNode","propertyName","variableLikeElement","wrapper","baseInstance","i64_is_i8","i64_is_u8","i64_is_i16","i64_is_u16","i64_is_bool","Type_0_is_illegal_in_this_context","superLocal","fltType","numNullLiterals","The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly","isClass","varType","varElement","thenType","elseType","typesToString","resolvedInstance","getResolvedInstance","classTypeArguments","classTypeParameters","numClassTypeArguments","classTypeParameterName","numFunctionTypeArguments","signatureParameters","numSignatureParameters","parameterDeclaration","nameInclTypeParamters","Interface","pendingClasses","anyPending","_0_is_referenced_directly_or_indirectly_in_its_own_base_expression","setBase","addInterface","finishResolveClass","unimplemented","ifaceMembers","isCompatibleOverride","This_overload_signature_is_not_compatible_with_its_implementation_signature","baseMembers","instanceMemberPrototypes","properties","fieldTypeNode","baseField","Field","propertyGetter","propertySetter","Getter_and_setter_accessors_do_not_agree_in_visibility","Property_0_only_has_a_setter_and_is_missing_a_getter","Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2","overloadKind","overloadPrototype","IndexSignature","pending","dependsOnInstance","_values2","Property","tokenFromKeyword","ASYNC","AWAIT","DEBUGGER","IS","KEYOF","MODULE","PACKAGE","WITH","tokenIsAlsoIdentifier","identifierHandling","unsafeNext","maxTokenLength","chr","isDecimalDigit","commentStartPos","LINE","TRIPLE","closed","testInteger","isIdentifierStart","posBefore","isIdentifierPart","maybeKeywordToken","isWhiteSpace","Invalid_character","checkOnNewLine","maxCompoundLength","tokenBefore","tokenPosBefore","reusableState","State","isTaggedTemplate","Unterminated_string_literal","readEscapeSequence","readExtendedUnicodeEscape","readUnicodeEscape","readHexadecimalEscape","fromCharCode","escaped","Unterminated_regular_expression_literal","Invalid_regular_expression_flags","readHexInteger","readBinaryInteger","readOctalInteger","isOctalDigit","Octal_literals_are_not_allowed_in_strict_mode","readDecimalInteger","sepEnd","i64_4","i64_shl","Numeric_separators_are_not_allowed_here","Multiple_consecutive_numeric_separators_are_not_permitted","Hexadecimal_digit_expected","i64_10","Digit_expected","i64_3","Octal_digit_expected","i64_1","Binary_digit_expected","readDecimalFloat","sepCount","readDecimalFloatPartial","replaceAll","parseFloat","allowLeadingZeroSep","startIfTaggedTemplate","An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal","value32","invalid","An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive","Unterminated_Unicode_escape_sequence","TypeKind","TypeFlags","_nonNullableType","_nullableType","nullableType","signednessIsRelevant","currentClass","targetClass","targetFunction","isVectorValue","signednessIsImportant","validWat","nullablePostfix","numTypes","signatureTypes","numParameterTypes","typeRefs","thisThisType","otherThisType","thisParameterTypes","otherParameterTypes","requireSameSize","targetThisType","targetParameterTypes","thisParameterType","targetParameterType","thisReturnType","targetReturnType","indices","optionalStart","restIndex","cloneParameterTypes","readI64","i32_as_f32","f32_as_i32","i64_as_f64","valueI64","f64_as_i64","overrides","cloned","v","x","separator","ipos","dirname","origin","COLOR_GRAY","COLOR_GREEN","COLOR_BLUE","COLOR_WHITE","colorsEnabled","isEnabled","color","CharCode","c0","lookupInUnicodeMap","unicodeIdentifierStart","unicodeIdentifierPart","map","mid","midVal","unmanaged","g","toText","wrapModule","emitStackIR","emitText","toAsmjs","emitAsmjs","keys","i64_one","i64_neg_one","i64_pow","rightLo","rightHi","i64_div","i64_rem","i64_rem_u","i64_and","i64_or","i64_xor","i64_shr","i64_not","i64_eq","i64_ne","minSafeF32","MIN_SAFE_INTEGER","maxSafeF32","MAX_SAFE_INTEGER","i64_is_f32","minSafeF64","maxSafeF64","i64_is_f64","fround","globalScope","window","ASC_FEATURE_MUTABLE_GLOBAL","UnreachableError","captureStackTrace","AssertionError","defaultComparator","nanA","nanB","defineProperties","writable","Infinity","NaN","clz32","round","y","sign","isTrueish","CHUNKSIZE","apply","fromCodePoint","at","charAt","configurable","replacment","split","arraySort","sort","comparator","forEach","Ctr","findLastIndex","Number","sincos_sin","sincos_cos","signbit","Boolean","sincos","sin","cos","exp2","arguments","console","byteOffset","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","globalThis"],"mappings":"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iGACA,qHACA,qGACA,+DACA,iEACA,iGACA,uFACA,yDACA,uGACA,qHACA,yEACA,yLACA,2GACA,+KACA,uIACA,uIACA,+GACA,iGACA,yHACA,2EACA,qIACA,oEACA,oDACA,oCACA,8FACA,kEACA,8CACA,gHACA,oHACA,8HACA,0GACA,8GACA,4EACA,oFACA,oGACA,0GACA,oHACA,wFACA,gFACA,kIACA,kIACA,4FACA,oHACA,oFACA,kFACA,wKACA,sLACA,kIACA,oDACA,wCACA,oJACA,gDACA,kGACA,wGACA,0CACA,kEACA,0DACA,gDACA,gEACA,sIACA,4IACA,0DACA,4DACA,wEACA,sDACA,4FACA,4FACA,oHACA,wDACA,sDACA,8HACA,gKACA,oKACA,sFACA,wEACA,sKACA,sJACA,8IACA,wFACA,0IACA,sJACA,0DACA,kDACA,gFACA,gGACA,gGACA,wDACA,kFACA,sFACA,0GACA,oHACA,8GACA,sHACA,wMACA,oFACA,8HACA,0NACA,sFACA,0IACA,gMACA,0LACA,wGACA,oIACA,kIACA,0HACA,wGACA,oIACA,wFACA,4KACA,sHACA,gFACA,oKACA,gLACA,4FACA,0MACA,wKACA,0FACA,kQACA,8DACA,kGACA,gKACA,oIACA,kJACA,0GACA,kKACA,4DACA,oJACA,oJACA,0GACA,0EACA,4FACA,oFACA,sNACA,8FACA,0QACA,kLACA,sLACA,gHACA,sFACA,8IACA,sDACA,0HACA,wEACA,8CACA,4FACA,gIACA,iLACA,+MAjLF,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAqL1B,kCAAuCivD,GACrC,OAAQA,GACN,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,oBACjB,KAAK,IAAK,MAAO,gCACjB,KAAK,IAAK,MAAO,sDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,uDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,iEACjB,KAAK,IAAK,MAAO,sGACjB,KAAK,IA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,0BACA,kBACA,oBACA,4BACA,kBACA,gBACA,gCACA,wBACA,gBACA,gCACA,8BACA,gBACA,sBACA,kBACA,wBACA,8BACA,kBACA,oBACA,gBACA,0BACA,0BACA,8BACA,wBACA,4BACA,wBACA,kBACA,wBACA,sBACA,wBACA,oBACA,sBACA,oBACA,kBACA,oBACA,wBACA,kBACA,oBACA,sBACA,oBACA,sBAIA,8BACA,gCACA,8BACA,gCACA,kCACA,oCACA,kBACA,kCACA,8BACA,sBACA,4BACA,kCACA,0CACA,gDACA,sCACA,gDACA,oDACA,8DACA,gDACA,oBACA,sBACA,8CACA,4BACA,sBACA,0BACA,8BACA,kCACA,8CACA,0DACA,kFACA,8BACA,kBACA,sBACA,kCACA,sBACA,kDACA,0BACA,4BACA,sBACA,yBACA,mCACA,qCACA,2CACA,6DACA,qCACA,yCACA,6DACA,yEACA,iGACA,6CACA,iCACA,qCACA,iBAIA,iCACA,uCACA,yCACA,qCACA,2CAIA,2BACA,+BAtIF,CAAYA,EAAA,EAAAA,QAAA,EAAAA,MAAK,KAyIjB,SAAYgmC,GACV,yBACA,uBACA,uBAHF,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAM9B,qBAgIA,0BAwBA,uCAA4CztG,GAE1C,OADA4K,OAAO5K,EAAKrI,QACJqI,EAAKwL,WAAW,IACtB,KAAK,IAAY,MAAe,UAARxL,EACxB,KAAK,IAAY,MAAe,OAARA,EACxB,KAAK,IAAY,MAAe,cAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EAE1B,OAAO,GAGT,iCAAsC6uG,GACpC,OAAQA,GACN,KAAKpnC,EAAMsyC,OAAQ,MAAO,SAC1B,KAAKtyC,EAAMg2C,GAAI,MAAO,KACtB,KAAKh2C,EAAM95D,WAAY,MAAO,aAC9B,KAAK85D,EAAM75D,IAAK,MAAO,MACvB,KAAK65D,EAAMyZ,OAAQ,MAAO,SAC1B,KAAKzZ,EAAM90D,KAAM,MAAO,OACxB,KAAK80D,EAAMqyC,MAAO,MAAO,QACzB,KAAKryC,EAAM2Z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AAMynI,EAClC,OAAOxkI,EAGX,OAASS,EAAM,GACb,GAAIT,EAAejD,WAAW0D,IAAQ+jI,EACpC,OAAOxkI,EAAezW,UAAU,EAAGkX,GAGvC,MAAO,IA3GT,kBAoFA,uBAA4BT,EAAwB2kI,GAClD,OAAI3kI,EAAeyC,WAAW,QACrBzC,EAEFwC,EACLkiI,EAAQC,GAAU,EAAAhkI,eAAiBX,IAKvC,a,4PC3Ga,EAAA4kI,WAAa,QAEb,EAAA9tD,UAAY,QAEZ,EAAA+tD,YAAc,QAEd,EAAAhuD,aAAe,QAEf,EAAAiuD,WAAa,QAEb,EAAAnuD,cAAgB,QAEhB,EAAAC,WAAa,QAEb,EAAAmuD,YAAc,QAEd,EAAArtD,YAAc,OAG3B,IAAIstD,GAAgB,EAGpB,6BACE,OAAOA,GAIT,4BAAiCC,GAG/B,OADAD,EAAgBC,EADCA,GAMnB,oBAAyBpyI,EAAcqyI,GACrC,OAAOF,EAAgBE,EAAQryI,EAAO,EAAA6kF,YAAc7kF,I,yBCyItD,SAAgBurI,EAAelxC,GAC7B,OAAOA,GAAK,IAAeA,GAAK,G,iNA7KlC,SAAkBi4C,GAEhB,mBACA,4BACA,wCACA,wCACA,kDACA,6BAEA,sBACA,6CACA,0BACA,0BACA,4BACA,4BACA,4CACA,0CACA,wCACA,oCACA,8CACA,gCACA,gCACA,0CACA,kDACA,+CACA,gDACA,wBAEA,cAEA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBACA,gBAEA,cACA,cACA,cACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eAEA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cAEA,8BACA,4BACA,gBACA,8BACA,4BACA,mBACA,sBACA,iCACA,oCACA,gCACA,sBACA,sBACA,wBACA,kBACA,kCACA,wBACA,kCACA,kCACA,oBACA,4BACA,sBACA,+BACA,kCACA,8BACA,0BACA,oBACA,4BACA,8BACA,kCACA,sBACA,uBAEA,6BACA,4BACA,yCACA,iBACA,kCAnIF,CAAkB,EAAAA,WAAA,EAAAA,SAAQ,KAuI1B,uBAA4Bj4C,GAC1B,OAAQA,GACN,KAAK,GACL,KAAK,GACL,KAAK,KACL,KAAK,KACH,OAAO,EAET,QACE,OAAO,IAMb,wBAA6BA,GAC3B,OAAQA,GACN,KAAK,GACL,KAAK,EACL,KAAK,GACL,KAAK,GACL,KAAK,IACL,KAAK,IACL,KAAK,KACL,KAAK,KACL,KAAK,KACL,KAAK,MACL,KAAK,MACH,OAAO,EAET,QACE,OAAOA,GAAK,MAAmBA,GAAK,OAM1C,mBAKA,wBAA6BA,GAC3B,OAAOA,GAAK,IAAeA,GAAK,IAIlC,sBAA2BA,GACzB,OAAOkxC,EAAelxC,KAAY,GAAJA,IAAW,KAAmB,GAAJA,IAAW,KAIrE,6BAAkC3W,GAChC,OAAOA,GAAQ,IAAcA,GAAQ,KAC9BA,GAAQ,IAAcA,GAAQ,IAC9BA,GAAQ,IAAeA,GAAQ,IAIxC,6BAAkC2W,GAChC,IAAIk4C,EAAS,GAAJl4C,EACT,OAAOk4C,GAAM,IAAcA,GAAM,KACrB,IAALl4C,GACK,IAALA,GACAA,EAAI,SA8KqB3W,EA9KY2W,GA+K9B,KAAO3W,EAAO,QACrB8uD,EAAmB9uD,EAAa+uD,IAFzC,IAAkC/uD,GA1KlC,4BAAiC2W,GAC/B,MAAMk4C,EAAS,GAAJl4C,EACX,OAAOk4C,GAAM,IAAcA,GAAM,KAC1Bl4C,GAAK,IAAeA,GAAK,IACpB,IAALA,GACK,IAALA,GACAA,EAAI,SAyKoB3W,EAzKY2W,GA0K7B,KAAO3W,EAAO,QACrB8uD,EAAmB9uD,EAAagvD,IAFzC,IAAiChvD,GArKjC,MAAM+uD,EAAgC,CACpC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAEtCC,EAA+B,CACnC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KACxB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,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","file":"assemblyscript.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__911__) {\nreturn ","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n","/**\r\n * @fileoverview Abstract syntax tree representing a source file once parsed.\r\n *\r\n * Each node in the AST is represented by an instance of a subclass of `Node`,\r\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\r\n * dependent code typically switches over. The intended way to create a node\r\n * is to use the respective `Node.createX` method instead of its constructor.\r\n *\r\n * Note that the AST does not contain any type information except type names.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\r\n// it doesn't reference the non-serializable `Source` object.\r\n\r\nimport {\r\n  CommonFlags,\r\n  PATH_DELIMITER,\r\n  LIBRARY_PREFIX,\r\n  LIBRARY_SUBST\r\n} from \"./common\";\r\n\r\nimport {\r\n  Token,\r\n  Range\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  normalizePath,\r\n  resolvePath,\r\n  CharCode,\r\n  isTrivialAlphanum\r\n} from \"./util\";\r\n\r\nimport {\r\n  ExpressionRef\r\n} from \"./module\";\r\n\r\nimport {\r\n  Type\r\n} from \"./types\";\r\n\r\n/** Indicates the kind of a node. */\r\nexport enum NodeKind {\r\n\r\n  SOURCE,\r\n\r\n  // types\r\n  NAMEDTYPE,\r\n  FUNCTIONTYPE,\r\n  TYPENAME,\r\n  TYPEPARAMETER,\r\n  PARAMETER,\r\n\r\n  // expressions\r\n  IDENTIFIER,\r\n  ASSERTION,\r\n  BINARY,\r\n  CALL,\r\n  CLASS,\r\n  COMMA,\r\n  ELEMENTACCESS,\r\n  FALSE,\r\n  FUNCTION,\r\n  INSTANCEOF,\r\n  LITERAL,\r\n  NEW,\r\n  NULL,\r\n  OMITTED,\r\n  PARENTHESIZED,\r\n  PROPERTYACCESS,\r\n  TERNARY,\r\n  SUPER,\r\n  THIS,\r\n  TRUE,\r\n  CONSTRUCTOR,\r\n  UNARYPOSTFIX,\r\n  UNARYPREFIX,\r\n  COMPILED,\r\n\r\n  // statements\r\n  BLOCK,\r\n  BREAK,\r\n  CONTINUE,\r\n  DO,\r\n  EMPTY,\r\n  EXPORT,\r\n  EXPORTDEFAULT,\r\n  EXPORTIMPORT,\r\n  EXPRESSION,\r\n  FOR,\r\n  FOROF,\r\n  IF,\r\n  IMPORT,\r\n  RETURN,\r\n  SWITCH,\r\n  THROW,\r\n  TRY,\r\n  VARIABLE,\r\n  VOID,\r\n  WHILE,\r\n\r\n  // declaration statements\r\n  CLASSDECLARATION,\r\n  ENUMDECLARATION,\r\n  ENUMVALUEDECLARATION,\r\n  FIELDDECLARATION,\r\n  FUNCTIONDECLARATION,\r\n  IMPORTDECLARATION,\r\n  INTERFACEDECLARATION,\r\n  METHODDECLARATION,\r\n  NAMESPACEDECLARATION,\r\n  TYPEDECLARATION,\r\n  VARIABLEDECLARATION,\r\n\r\n  // special\r\n  DECORATOR,\r\n  EXPORTMEMBER,\r\n  SWITCHCASE,\r\n  INDEXSIGNATURE,\r\n  COMMENT\r\n}\r\n\r\n/** Base class of all nodes. */\r\nexport abstract class Node {\r\n  constructor(\r\n    /** Kind of this node. */\r\n    public kind: NodeKind,\r\n    /** Source range. */\r\n    public range: Range\r\n  ) {}\r\n\r\n  // types\r\n\r\n  static createSimpleTypeName(\r\n    name: string,\r\n    range: Range\r\n  ): TypeName {\r\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\r\n  }\r\n\r\n  static createNamedType(\r\n    name: TypeName,\r\n    typeArguments: TypeNode[] | null,\r\n    isNullable: bool,\r\n    range: Range\r\n  ): NamedTypeNode {\r\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\r\n  }\r\n\r\n  static createFunctionType(\r\n    parameters: ParameterNode[],\r\n    returnType: TypeNode,\r\n    explicitThisType: NamedTypeNode | null,\r\n    isNullable: bool,\r\n    range: Range\r\n  ): FunctionTypeNode {\r\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\r\n  }\r\n\r\n  static createOmittedType(\r\n    range: Range\r\n  ): NamedTypeNode {\r\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\r\n  }\r\n\r\n  static createTypeParameter(\r\n    name: IdentifierExpression,\r\n    extendsType: NamedTypeNode | null,\r\n    defaultType: NamedTypeNode | null,\r\n    range: Range\r\n  ): TypeParameterNode {\r\n    return new TypeParameterNode(name, extendsType, defaultType, range);\r\n  }\r\n\r\n  static createParameter(\r\n    parameterKind: ParameterKind,\r\n    name: IdentifierExpression,\r\n    type: TypeNode,\r\n    initializer: Expression | null,\r\n    range: Range\r\n  ): ParameterNode {\r\n    return new ParameterNode(parameterKind, name, type, initializer, range);\r\n  }\r\n\r\n  // special\r\n\r\n  static createDecorator(\r\n    name: Expression,\r\n    args: Expression[] | null,\r\n    range: Range\r\n  ): DecoratorNode {\r\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\r\n  }\r\n\r\n  static createComment(\r\n    commentKind: CommentKind,\r\n    text: string,\r\n    range: Range\r\n  ): CommentNode {\r\n    return new CommentNode(commentKind, text, range);\r\n  }\r\n\r\n  // expressions\r\n\r\n  static createIdentifierExpression(\r\n    text: string,\r\n    range: Range,\r\n    isQuoted: bool = false\r\n  ): IdentifierExpression {\r\n    return new IdentifierExpression(text, isQuoted, range);\r\n  }\r\n\r\n  static createEmptyIdentifierExpression(\r\n    range: Range\r\n  ): IdentifierExpression {\r\n    return new IdentifierExpression(\"\", false, range);\r\n  }\r\n\r\n  static createArrayLiteralExpression(\r\n    elementExpressions: Expression[],\r\n    range: Range\r\n  ): ArrayLiteralExpression {\r\n    return new ArrayLiteralExpression(elementExpressions, range);\r\n  }\r\n\r\n  static createAssertionExpression(\r\n    assertionKind: AssertionKind,\r\n    expression: Expression,\r\n    toType: TypeNode | null,\r\n    range: Range\r\n  ): AssertionExpression {\r\n    return new AssertionExpression(assertionKind, expression, toType, range);\r\n  }\r\n\r\n  static createBinaryExpression(\r\n    operator: Token,\r\n    left: Expression,\r\n    right: Expression,\r\n    range: Range\r\n  ): BinaryExpression {\r\n    return new BinaryExpression(operator, left, right, range);\r\n  }\r\n\r\n  static createCallExpression(\r\n    expression: Expression,\r\n    typeArguments: TypeNode[] | null,\r\n    args: Expression[],\r\n    range: Range\r\n  ): CallExpression {\r\n    return new CallExpression(expression, typeArguments, args, range);\r\n  }\r\n\r\n  static createClassExpression(\r\n    declaration: ClassDeclaration\r\n  ): ClassExpression {\r\n    return new ClassExpression(declaration);\r\n  }\r\n\r\n  static createCommaExpression(\r\n    expressions: Expression[],\r\n    range: Range\r\n  ): CommaExpression {\r\n    return new CommaExpression(expressions, range);\r\n  }\r\n\r\n  static createConstructorExpression(\r\n    range: Range\r\n  ): ConstructorExpression {\r\n    return new ConstructorExpression(range);\r\n  }\r\n\r\n  static createElementAccessExpression(\r\n    expression: Expression,\r\n    elementExpression: Expression,\r\n    range: Range\r\n  ): ElementAccessExpression {\r\n    return new ElementAccessExpression(expression, elementExpression, range);\r\n  }\r\n\r\n  static createFalseExpression(\r\n    range: Range\r\n  ): FalseExpression {\r\n    return new FalseExpression(range);\r\n  }\r\n\r\n  static createFloatLiteralExpression(\r\n    value: f64,\r\n    range: Range\r\n  ): FloatLiteralExpression {\r\n    return new FloatLiteralExpression(value, range);\r\n  }\r\n\r\n  static createFunctionExpression(\r\n    declaration: FunctionDeclaration\r\n  ): FunctionExpression {\r\n    return new FunctionExpression(declaration);\r\n  }\r\n\r\n  static createInstanceOfExpression(\r\n    expression: Expression,\r\n    isType: TypeNode,\r\n    range: Range\r\n  ): InstanceOfExpression {\r\n    return new InstanceOfExpression(expression, isType, range);\r\n  }\r\n\r\n  static createIntegerLiteralExpression(\r\n    value: i64,\r\n    range: Range\r\n  ): IntegerLiteralExpression {\r\n    return new IntegerLiteralExpression(value, range);\r\n  }\r\n\r\n  static createNewExpression(\r\n    typeName: TypeName,\r\n    typeArguments: TypeNode[] | null,\r\n    args: Expression[],\r\n    range: Range\r\n  ): NewExpression {\r\n    return new NewExpression(typeName, typeArguments, args, range);\r\n  }\r\n\r\n  static createNullExpression(\r\n    range: Range\r\n  ): NullExpression {\r\n    return new NullExpression(range);\r\n  }\r\n\r\n  static createObjectLiteralExpression(\r\n    names: IdentifierExpression[],\r\n    values: Expression[],\r\n    range: Range\r\n  ): ObjectLiteralExpression {\r\n    return new ObjectLiteralExpression(names, values, range);\r\n  }\r\n\r\n  static createOmittedExpression(\r\n    range: Range\r\n  ): OmittedExpression {\r\n    return new OmittedExpression(range);\r\n  }\r\n\r\n  static createParenthesizedExpression(\r\n    expression: Expression,\r\n    range: Range\r\n  ): ParenthesizedExpression {\r\n    return new ParenthesizedExpression(expression, range);\r\n  }\r\n\r\n  static createPropertyAccessExpression(\r\n    expression: Expression,\r\n    property: IdentifierExpression,\r\n    range: Range\r\n  ): PropertyAccessExpression {\r\n    return new PropertyAccessExpression(expression, property, range);\r\n  }\r\n\r\n  static createRegexpLiteralExpression(\r\n    pattern: string,\r\n    patternFlags: string,\r\n    range: Range\r\n  ): RegexpLiteralExpression {\r\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\r\n  }\r\n\r\n  static createTernaryExpression(\r\n    condition: Expression,\r\n    ifThen: Expression,\r\n    ifElse: Expression,\r\n    range: Range\r\n  ): TernaryExpression {\r\n    return new TernaryExpression(condition, ifThen, ifElse, range);\r\n  }\r\n\r\n  static createStringLiteralExpression(\r\n    value: string,\r\n    range: Range\r\n  ): StringLiteralExpression {\r\n    return new StringLiteralExpression(value, range);\r\n  }\r\n\r\n  static createSuperExpression(\r\n    range: Range\r\n  ): SuperExpression {\r\n    return new SuperExpression(range);\r\n  }\r\n\r\n  static createTemplateLiteralExpression(\r\n    tag: Expression | null,\r\n    parts: string[],\r\n    rawParts: string[],\r\n    expressions: Expression[],\r\n    range: Range\r\n  ): TemplateLiteralExpression {\r\n    return new TemplateLiteralExpression(tag, parts, rawParts, expressions, range);\r\n  }\r\n\r\n  static createThisExpression(\r\n    range: Range\r\n  ): ThisExpression {\r\n    return new ThisExpression(range);\r\n  }\r\n\r\n  static createTrueExpression(\r\n    range: Range\r\n  ): TrueExpression {\r\n    return new TrueExpression(range);\r\n  }\r\n\r\n  static createUnaryPostfixExpression(\r\n    operator: Token,\r\n    operand: Expression,\r\n    range: Range\r\n  ): UnaryPostfixExpression {\r\n    return new UnaryPostfixExpression(operator, operand, range);\r\n  }\r\n\r\n  static createUnaryPrefixExpression(\r\n    operator: Token,\r\n    operand: Expression,\r\n    range: Range\r\n  ): UnaryPrefixExpression {\r\n    return new UnaryPrefixExpression(operator, operand, range);\r\n  }\r\n\r\n  static createCompiledExpression(\r\n    expr: ExpressionRef,\r\n    type: Type,\r\n    range: Range\r\n  ): Expression {\r\n    return new CompiledExpression(expr, type, range);\r\n  }\r\n\r\n  // statements\r\n\r\n  static createBlockStatement(\r\n    statements: Statement[],\r\n    range: Range\r\n  ): BlockStatement {\r\n    return new BlockStatement(statements, range);\r\n  }\r\n\r\n  static createBreakStatement(\r\n    label: IdentifierExpression | null,\r\n    range: Range\r\n  ): BreakStatement {\r\n    return new BreakStatement(label, range);\r\n  }\r\n\r\n  static createClassDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    typeParameters: TypeParameterNode[] | null,\r\n    extendsType: NamedTypeNode | null,\r\n    implementsTypes: NamedTypeNode[] | null,\r\n    members: DeclarationStatement[],\r\n    range: Range\r\n  ): ClassDeclaration {\r\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\r\n  }\r\n\r\n  static createContinueStatement(\r\n    label: IdentifierExpression | null,\r\n    range: Range\r\n  ): ContinueStatement {\r\n    return new ContinueStatement(label, range);\r\n  }\r\n\r\n  static createDoStatement(\r\n    statement: Statement,\r\n    condition: Expression,\r\n    range: Range\r\n  ): DoStatement {\r\n    return new DoStatement(statement, condition, range);\r\n  }\r\n\r\n  static createEmptyStatement(\r\n    range: Range\r\n  ): EmptyStatement {\r\n    return new EmptyStatement(range);\r\n  }\r\n\r\n  static createEnumDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    values: EnumValueDeclaration[],\r\n    range: Range\r\n  ): EnumDeclaration {\r\n    return new EnumDeclaration(name, decorators, flags, values, range);\r\n  }\r\n\r\n  static createEnumValueDeclaration(\r\n    name: IdentifierExpression,\r\n    flags: CommonFlags,\r\n    initializer: Expression | null,\r\n    range: Range\r\n  ): EnumValueDeclaration {\r\n    return new EnumValueDeclaration(name, flags, initializer, range);\r\n  }\r\n\r\n  static createExportStatement(\r\n    members: ExportMember[] | null,\r\n    path: StringLiteralExpression | null,\r\n    isDeclare: bool,\r\n    range: Range\r\n  ): ExportStatement {\r\n    return new ExportStatement(members, path, isDeclare, range);\r\n  }\r\n\r\n  static createExportDefaultStatement(\r\n    declaration: DeclarationStatement,\r\n    range: Range\r\n  ): ExportDefaultStatement {\r\n    return new ExportDefaultStatement(declaration, range);\r\n  }\r\n\r\n  static createExportImportStatement(\r\n    name: IdentifierExpression,\r\n    externalName: IdentifierExpression,\r\n    range: Range\r\n  ): ExportImportStatement {\r\n    return new ExportImportStatement(name, externalName, range);\r\n  }\r\n\r\n  static createExportMember(\r\n    localName: IdentifierExpression,\r\n    exportedName: IdentifierExpression | null,\r\n    range: Range\r\n  ): ExportMember {\r\n    if (!exportedName) exportedName = localName;\r\n    return new ExportMember(localName, exportedName, range);\r\n  }\r\n\r\n  static createExpressionStatement(\r\n    expression: Expression\r\n  ): ExpressionStatement {\r\n    return new ExpressionStatement(expression);\r\n  }\r\n\r\n  static createIfStatement(\r\n    condition: Expression,\r\n    ifTrue: Statement,\r\n    ifFalse: Statement | null,\r\n    range: Range\r\n  ): IfStatement {\r\n    return new IfStatement(condition, ifTrue, ifFalse, range);\r\n  }\r\n\r\n  static createImportStatement(\r\n    declarations: ImportDeclaration[] | null,\r\n    path: StringLiteralExpression,\r\n    range: Range\r\n  ): ImportStatement {\r\n    return new ImportStatement(declarations, null, path, range);\r\n  }\r\n\r\n  static createWildcardImportStatement(\r\n    namespaceName: IdentifierExpression,\r\n    path: StringLiteralExpression,\r\n    range: Range\r\n  ): ImportStatement {\r\n    return new ImportStatement(null, namespaceName, path, range);\r\n  }\r\n\r\n  static createImportDeclaration(\r\n    foreignName: IdentifierExpression,\r\n    name: IdentifierExpression | null,\r\n    range: Range\r\n  ): ImportDeclaration {\r\n    if (!name) name = foreignName;\r\n    return new ImportDeclaration(name, foreignName, range);\r\n  }\r\n\r\n  static createInterfaceDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    typeParameters: TypeParameterNode[] | null,\r\n    extendsType: NamedTypeNode | null,\r\n    implementsTypes: NamedTypeNode[] | null,\r\n    members: DeclarationStatement[],\r\n    range: Range\r\n  ): InterfaceDeclaration {\r\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\r\n  }\r\n\r\n  static createFieldDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    type: TypeNode | null,\r\n    initializer: Expression | null,\r\n    range: Range\r\n  ): FieldDeclaration {\r\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\r\n  }\r\n\r\n  static createForStatement(\r\n    initializer: Statement | null,\r\n    condition: Expression | null,\r\n    incrementor: Expression | null,\r\n    statement: Statement,\r\n    range: Range\r\n  ): ForStatement {\r\n    return new ForStatement(initializer, condition, incrementor, statement, range);\r\n  }\r\n\r\n  static createForOfStatement(\r\n    variable: Statement,\r\n    iterable: Expression,\r\n    statement: Statement,\r\n    range: Range\r\n  ): ForOfStatement {\r\n    return new ForOfStatement(variable, iterable, statement, range);\r\n  }\r\n\r\n  static createFunctionDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    typeParameters: TypeParameterNode[] | null,\r\n    signature: FunctionTypeNode,\r\n    body: Statement | null,\r\n    arrowKind: ArrowKind,\r\n    range: Range\r\n  ): FunctionDeclaration {\r\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\r\n  }\r\n\r\n  static createIndexSignature(\r\n    keyType: NamedTypeNode,\r\n    valueType: TypeNode,\r\n    flags: CommonFlags,\r\n    range: Range\r\n  ): IndexSignatureNode {\r\n    return new IndexSignatureNode(keyType, valueType, flags, range);\r\n  }\r\n\r\n  static createMethodDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    typeParameters: TypeParameterNode[] | null,\r\n    signature: FunctionTypeNode,\r\n    body: Statement | null,\r\n    range: Range\r\n  ): MethodDeclaration {\r\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\r\n  }\r\n\r\n  static createNamespaceDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    members: Statement[],\r\n    range: Range\r\n  ): NamespaceDeclaration {\r\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\r\n  }\r\n\r\n  static createReturnStatement(\r\n    value: Expression | null,\r\n    range: Range\r\n  ): ReturnStatement {\r\n    return new ReturnStatement(value, range);\r\n  }\r\n\r\n  static createSwitchStatement(\r\n    condition: Expression,\r\n    cases: SwitchCase[],\r\n    range: Range\r\n  ): SwitchStatement {\r\n    return new SwitchStatement(condition, cases, range);\r\n  }\r\n\r\n  static createSwitchCase(\r\n    label: Expression | null,\r\n    statements: Statement[],\r\n    range: Range\r\n  ): SwitchCase {\r\n    return new SwitchCase(label, statements, range);\r\n  }\r\n\r\n  static createThrowStatement(\r\n    value: Expression,\r\n    range: Range\r\n  ): ThrowStatement {\r\n    return new ThrowStatement(value, range);\r\n  }\r\n\r\n  static createTryStatement(\r\n    statements: Statement[],\r\n    catchVariable: IdentifierExpression | null,\r\n    catchStatements: Statement[] | null,\r\n    finallyStatements: Statement[] | null,\r\n    range: Range\r\n  ): TryStatement {\r\n    return new TryStatement(statements, catchVariable, catchStatements, finallyStatements, range);\r\n  }\r\n\r\n  static createTypeDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    typeParameters: TypeParameterNode[] | null,\r\n    type: TypeNode,\r\n    range: Range\r\n  ): TypeDeclaration {\r\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\r\n  }\r\n\r\n  static createVariableStatement(\r\n    decorators: DecoratorNode[] | null,\r\n    declarations: VariableDeclaration[],\r\n    range: Range\r\n  ): VariableStatement {\r\n    return new VariableStatement(decorators, declarations, range);\r\n  }\r\n\r\n  static createVariableDeclaration(\r\n    name: IdentifierExpression,\r\n    decorators: DecoratorNode[] | null,\r\n    flags: CommonFlags,\r\n    type: TypeNode | null,\r\n    initializer: Expression | null,\r\n    range: Range\r\n  ): VariableDeclaration {\r\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\r\n  }\r\n\r\n  static createVoidStatement(\r\n    expression: Expression,\r\n    range: Range\r\n  ): VoidStatement {\r\n    return new VoidStatement(expression, range);\r\n  }\r\n\r\n  static createWhileStatement(\r\n    condition: Expression,\r\n    statement: Statement,\r\n    range: Range\r\n  ): WhileStatement {\r\n    return new WhileStatement(condition, statement, range);\r\n  }\r\n\r\n  /** Tests if this node is a literal of the specified kind. */\r\n  isLiteralKind(literalKind: LiteralKind): bool {\r\n    return this.kind == NodeKind.LITERAL\r\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\r\n  }\r\n\r\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\r\n  get isNumericLiteral(): bool {\r\n    if (this.kind == NodeKind.LITERAL) {\r\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\r\n        case LiteralKind.FLOAT:\r\n        case LiteralKind.INTEGER: return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Tests whether this node is guaranteed to compile to a constant value. */\r\n  get compilesToConst(): bool {\r\n    switch (this.kind) {\r\n      case NodeKind.LITERAL: {\r\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\r\n          case LiteralKind.FLOAT:\r\n          case LiteralKind.INTEGER:\r\n          case LiteralKind.STRING: return true;\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.NULL:\r\n      case NodeKind.TRUE:\r\n      case NodeKind.FALSE: return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private isAccessOn(kind: NodeKind): bool {\r\n    let node = changetype<Node>(this);\r\n    if (node.kind == NodeKind.CALL) {\r\n      node = (<CallExpression>node).expression;\r\n    }\r\n    if (node.kind == NodeKind.PROPERTYACCESS) {\r\n      let target = (<PropertyAccessExpression>node).expression;\r\n      if (target.kind == kind) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Checks if this node accesses a method or property on `this`. */\r\n  get isAccessOnThis(): bool {\r\n    return this.isAccessOn(NodeKind.THIS);\r\n  }\r\n\r\n  /** Checks if this node accesses a method or property on `super`. */\r\n  get isAccessOnSuper(): bool {\r\n    return this.isAccessOn(NodeKind.SUPER);\r\n  }\r\n}\r\n\r\n// types\r\n\r\nexport abstract class TypeNode extends Node {\r\n  constructor(\r\n    /** Kind of the type node. */\r\n    kind: NodeKind,\r\n    /** Whether nullable or not. */\r\n    public isNullable: bool,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(kind, range);\r\n  }\r\n\r\n  /** Tests if this type has a generic component matching one of the given type parameters. */\r\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\r\n    if (this.kind == NodeKind.NAMEDTYPE) {\r\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\r\n      if (!namedTypeNode.name.next) {\r\n        let typeArgumentNodes = namedTypeNode.typeArguments;\r\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\r\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\r\n          }\r\n        } else {\r\n          let name = namedTypeNode.name.identifier.text;\r\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\r\n            if (typeParameterNodes[i].name.text == name) return true;\r\n          }\r\n        }\r\n      }\r\n    } else if (this.kind == NodeKind.FUNCTIONTYPE) {\r\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\r\n      let parameterNodes = functionTypeNode.parameters;\r\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\r\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\r\n      }\r\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\r\n      let explicitThisType = functionTypeNode.explicitThisType;\r\n      if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\r\n    } else {\r\n      assert(false);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n/** Represents a type name. */\r\nexport class TypeName extends Node {\r\n  constructor(\r\n    /** Identifier of this part. */\r\n    public identifier: IdentifierExpression,\r\n    /** Next part of the type name or `null` if this is the last part. */\r\n    public next: TypeName | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.TYPENAME, range);\r\n  }\r\n}\r\n\r\n/** Represents a named type. */\r\nexport class NamedTypeNode extends TypeNode {\r\n  constructor(\r\n    /** Type name. */\r\n    public name: TypeName,\r\n    /** Type argument references. */\r\n    public typeArguments: TypeNode[] | null,\r\n    /** Whether nullable or not. */\r\n    isNullable: bool,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.NAMEDTYPE, isNullable, range);\r\n  }\r\n\r\n  /** Checks if this type node has type arguments. */\r\n  get hasTypeArguments(): bool {\r\n    var typeArguments = this.typeArguments;\r\n    return typeArguments !== null && typeArguments.length > 0;\r\n  }\r\n}\r\n\r\n/** Represents a function type. */\r\nexport class FunctionTypeNode extends TypeNode {\r\n  constructor(\r\n    /** Function parameters. */\r\n    public parameters: ParameterNode[],\r\n    /** Return type. */\r\n    public returnType: TypeNode,\r\n    /** Explicitly provided this type, if any. */\r\n    public explicitThisType: NamedTypeNode | null, // can't be a function\r\n    /** Whether nullable or not. */\r\n    isNullable: bool,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.FUNCTIONTYPE, isNullable, range);\r\n  }\r\n}\r\n\r\n/** Represents a type parameter. */\r\nexport class TypeParameterNode extends Node {\r\n  constructor(\r\n    /** Identifier reference. */\r\n    public name: IdentifierExpression,\r\n    /** Extended type reference, if any. */\r\n    public extendsType: NamedTypeNode | null, // can't be a function\r\n    /** Default type if omitted, if any. */\r\n    public defaultType: NamedTypeNode | null, // can't be a function\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.TYPEPARAMETER, range);\r\n  }\r\n}\r\n\r\n/** Represents the kind of a parameter. */\r\nexport enum ParameterKind {\r\n  /** No specific flags. */\r\n  DEFAULT,\r\n  /** Is an optional parameter. */\r\n  OPTIONAL,\r\n  /** Is a rest parameter. */\r\n  REST\r\n}\r\n\r\n/** Represents a function parameter. */\r\nexport class ParameterNode extends Node {\r\n  constructor(\r\n    /** Parameter kind. */\r\n    public parameterKind: ParameterKind,\r\n    /** Parameter name. */\r\n    public name: IdentifierExpression,\r\n    /** Parameter type. */\r\n    public type: TypeNode,\r\n    /** Initializer expression, if any. */\r\n    public initializer: Expression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.PARAMETER, range);\r\n  }\r\n\r\n  /** Implicit field declaration, if applicable. */\r\n  implicitFieldDeclaration: FieldDeclaration | null = null;\r\n  /** Common flags indicating specific traits. */\r\n  flags: CommonFlags = CommonFlags.NONE;\r\n\r\n  /** Tests if this node has the specified flag or flags. */\r\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\r\n  /** Tests if this node has one of the specified flags. */\r\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\r\n  /** Sets a specific flag or flags. */\r\n  set(flag: CommonFlags): void { this.flags |= flag; }\r\n}\r\n\r\n// special\r\n\r\n/** Built-in decorator kinds. */\r\nexport enum DecoratorKind {\r\n  CUSTOM,\r\n  GLOBAL,\r\n  OPERATOR,\r\n  OPERATOR_BINARY,\r\n  OPERATOR_PREFIX,\r\n  OPERATOR_POSTFIX,\r\n  UNMANAGED,\r\n  FINAL,\r\n  INLINE,\r\n  EXTERNAL,\r\n  BUILTIN,\r\n  LAZY,\r\n  UNSAFE\r\n}\r\n\r\nexport namespace DecoratorKind {\r\n\r\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\r\n  export function fromNode(nameNode: Expression): DecoratorKind {\r\n    if (nameNode.kind == NodeKind.IDENTIFIER) {\r\n      let nameStr = (<IdentifierExpression>nameNode).text;\r\n      assert(nameStr.length);\r\n      switch (nameStr.charCodeAt(0)) {\r\n        case CharCode.b: {\r\n          if (nameStr == \"builtin\") return DecoratorKind.BUILTIN;\r\n          break;\r\n        }\r\n        case CharCode.e: {\r\n          if (nameStr == \"external\") return DecoratorKind.EXTERNAL;\r\n          break;\r\n        }\r\n        case CharCode.f: {\r\n          if (nameStr == \"final\") return DecoratorKind.FINAL;\r\n          break;\r\n        }\r\n        case CharCode.g: {\r\n          if (nameStr == \"global\") return DecoratorKind.GLOBAL;\r\n          break;\r\n        }\r\n        case CharCode.i: {\r\n          if (nameStr == \"inline\") return DecoratorKind.INLINE;\r\n          break;\r\n        }\r\n        case CharCode.l: {\r\n          if (nameStr == \"lazy\") return DecoratorKind.LAZY;\r\n          break;\r\n        }\r\n        case CharCode.o: {\r\n          if (nameStr == \"operator\") return DecoratorKind.OPERATOR;\r\n          break;\r\n        }\r\n        case CharCode.u: {\r\n          if (nameStr == \"unmanaged\") return DecoratorKind.UNMANAGED;\r\n          if (nameStr == \"unsafe\") return DecoratorKind.UNSAFE;\r\n          break;\r\n        }\r\n      }\r\n    } else if (nameNode.kind == NodeKind.PROPERTYACCESS) {\r\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\r\n      let expression = propertyAccessNode.expression;\r\n      if (expression.kind == NodeKind.IDENTIFIER) {\r\n        let nameStr = (<IdentifierExpression>expression).text;\r\n        assert(nameStr.length);\r\n        let propStr = propertyAccessNode.property.text;\r\n        assert(propStr.length);\r\n        if (nameStr == \"operator\") {\r\n          switch (propStr.charCodeAt(0)) {\r\n            case CharCode.b: {\r\n              if (propStr == \"binary\") return DecoratorKind.OPERATOR_BINARY;\r\n              break;\r\n            }\r\n            case CharCode.p: {\r\n              if (propStr == \"prefix\") return DecoratorKind.OPERATOR_PREFIX;\r\n              if (propStr == \"postfix\") return DecoratorKind.OPERATOR_POSTFIX;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return DecoratorKind.CUSTOM;\r\n  }\r\n}\r\n\r\n/** Represents a decorator. */\r\nexport class DecoratorNode extends Node {\r\n  constructor(\r\n    /** Built-in decorator kind, or custom. */\r\n    public decoratorKind: DecoratorKind,\r\n    /** Name expression. */\r\n    public name: Expression,\r\n    /** Argument expressions. */\r\n    public args: Expression[] | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.DECORATOR, range);\r\n  }\r\n}\r\n\r\n/** Comment kinds. */\r\nexport enum CommentKind {\r\n  /** Line comment. */\r\n  LINE,\r\n  /** Triple-slash line comment. */\r\n  TRIPLE,\r\n  /** Block comment. */\r\n  BLOCK\r\n}\r\n\r\n/** Represents a comment. */\r\nexport class CommentNode extends Node {\r\n  constructor(\r\n    /** Comment kind. */\r\n    public commentKind: CommentKind,\r\n    /** Comment text. */\r\n    public text: string,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.COMMENT, range);\r\n  }\r\n}\r\n\r\n// expressions\r\n\r\n/** Base class of all expression nodes. */\r\nexport abstract class Expression extends Node { }\r\n\r\n/** Represents an identifier expression. */\r\nexport class IdentifierExpression extends Expression {\r\n  constructor(\r\n    /** Textual name. */\r\n    public text: string,\r\n    /** Whether quoted or not. */\r\n    public isQuoted: bool,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.IDENTIFIER, range);\r\n  }\r\n}\r\n\r\n/** Indicates the kind of a literal. */\r\nexport enum LiteralKind {\r\n  FLOAT,\r\n  INTEGER,\r\n  STRING,\r\n  TEMPLATE,\r\n  REGEXP,\r\n  ARRAY,\r\n  OBJECT\r\n}\r\n\r\n/** Base class of all literal expressions. */\r\nexport abstract class LiteralExpression extends Expression {\r\n  constructor(\r\n    /** Specific literal kind. */\r\n    public literalKind: LiteralKind,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.LITERAL, range);\r\n  }\r\n}\r\n\r\n/** Represents an `[]` literal expression. */\r\nexport class ArrayLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** Nested element expressions. */\r\n    public elementExpressions: Expression[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.ARRAY, range);\r\n  }\r\n}\r\n\r\n/** Indicates the kind of an assertion. */\r\nexport enum AssertionKind {\r\n  /** A prefix assertion, i.e. `<T>expr`. */\r\n  PREFIX,\r\n  /** An as assertion, i.e. `expr as T`. */\r\n  AS,\r\n  /** A non-null assertion, i.e. `!expr`. */\r\n  NONNULL,\r\n  /** A const assertion, i.e. `expr as const`. */\r\n  CONST\r\n}\r\n\r\n/** Represents an assertion expression. */\r\nexport class AssertionExpression extends Expression {\r\n  constructor(\r\n    /** Specific kind of this assertion. */\r\n    public assertionKind: AssertionKind,\r\n    /** Expression being asserted. */\r\n    public expression: Expression,\r\n    /** Target type, if applicable. */\r\n    public toType: TypeNode | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.ASSERTION, range);\r\n  }\r\n}\r\n\r\n/** Represents a binary expression. */\r\nexport class BinaryExpression extends Expression {\r\n  constructor(\r\n    /** Operator token. */\r\n    public operator: Token,\r\n    /** Left-hand side expression */\r\n    public left: Expression,\r\n    /** Right-hand side expression. */\r\n    public right: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.BINARY, range);\r\n  }\r\n}\r\n\r\n/** Represents a call expression. */\r\nexport class CallExpression extends Expression {\r\n  constructor(\r\n    /** Called expression. Usually an identifier or property access expression. */\r\n    public expression: Expression,\r\n    /** Provided type arguments. */\r\n    public typeArguments: TypeNode[] | null,\r\n    /** Provided arguments. */\r\n    public args: Expression[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.CALL, range);\r\n  }\r\n\r\n  /** Gets the type arguments range for reporting. */\r\n  get typeArgumentsRange(): Range {\r\n    var typeArguments = this.typeArguments;\r\n    var numTypeArguments: i32;\r\n    if (typeArguments) {\r\n      if (numTypeArguments = typeArguments.length) {\r\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\r\n      }\r\n    }\r\n    return this.expression.range;\r\n  }\r\n\r\n  /** Gets the arguments range for reporting. */\r\n  get argumentsRange(): Range {\r\n    var args = this.args;\r\n    var numArguments = args.length;\r\n    if (numArguments) {\r\n      return Range.join(args[0].range, args[numArguments - 1].range);\r\n    }\r\n    return this.expression.range;\r\n  }\r\n}\r\n\r\n/** Represents a class expression using the 'class' keyword. */\r\nexport class ClassExpression extends Expression {\r\n  constructor(\r\n    /** Inline class declaration. */\r\n    public declaration: ClassDeclaration\r\n  ) {\r\n    super(NodeKind.CLASS, declaration.range);\r\n  }\r\n}\r\n\r\n/** Represents a comma expression composed of multiple expressions. */\r\nexport class CommaExpression extends Expression {\r\n  constructor(\r\n    /** Sequential expressions. */\r\n    public expressions: Expression[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.COMMA, range);\r\n  }\r\n}\r\n\r\n/** Represents a `constructor` expression. */\r\nexport class ConstructorExpression extends IdentifierExpression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(\"constructor\", false, range);\r\n    this.kind = NodeKind.CONSTRUCTOR;\r\n  }\r\n}\r\n\r\n/** Represents an element access expression, e.g., array access. */\r\nexport class ElementAccessExpression extends Expression {\r\n  constructor(\r\n    /** Expression being accessed. */\r\n    public expression: Expression,\r\n    /** Element of the expression being accessed. */\r\n    public elementExpression: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.ELEMENTACCESS, range);\r\n  }\r\n}\r\n\r\n/** Represents a float literal expression. */\r\nexport class FloatLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** Float value. */\r\n    public value: f64,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.FLOAT, range);\r\n  }\r\n}\r\n\r\n/** Represents a function expression using the 'function' keyword. */\r\nexport class FunctionExpression extends Expression {\r\n  constructor(\r\n    /** Inline function declaration. */\r\n    public declaration: FunctionDeclaration\r\n  ) {\r\n    super(NodeKind.FUNCTION, declaration.range);\r\n  }\r\n}\r\n\r\n/** Represents an `instanceof` expression. */\r\nexport class InstanceOfExpression extends Expression {\r\n  constructor(\r\n    /** Expression being asserted. */\r\n    public expression: Expression,\r\n    /** Type to test for. */\r\n    public isType: TypeNode,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.INSTANCEOF, range);\r\n  }\r\n}\r\n\r\n/** Represents an integer literal expression. */\r\nexport class IntegerLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** Integer value. */\r\n    public value: i64,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.INTEGER, range);\r\n  }\r\n}\r\n\r\n/** Represents a `new` expression. Like a call but with its own kind. */\r\nexport class NewExpression extends Expression {\r\n  constructor(\r\n    /** Type being constructed. */\r\n    public typeName: TypeName,\r\n    /** Provided type arguments. */\r\n    public typeArguments: TypeNode[] | null,\r\n    /** Provided arguments. */\r\n    public args: Expression[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.NEW, range);\r\n  }\r\n\r\n  /** Gets the type arguments range for reporting. */\r\n  get typeArgumentsRange(): Range {\r\n    var typeArguments = this.typeArguments;\r\n    var numTypeArguments: i32;\r\n    if (typeArguments !== null && (numTypeArguments = typeArguments.length) > 0) {\r\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\r\n    }\r\n    return this.typeName.range;\r\n  }\r\n\r\n  /** Gets the arguments range for reporting. */\r\n  get argumentsRange(): Range {\r\n    var args = this.args;\r\n    var numArguments = args.length;\r\n    if (numArguments) {\r\n      return Range.join(args[0].range, args[numArguments - 1].range);\r\n    }\r\n    return this.typeName.range;\r\n  }\r\n}\r\n\r\n/** Represents a `null` expression. */\r\nexport class NullExpression extends IdentifierExpression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(\"null\", false, range);\r\n    this.kind = NodeKind.NULL;\r\n  }\r\n}\r\n\r\n/** Represents an object literal expression. */\r\nexport class ObjectLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** Field names. */\r\n    public names: IdentifierExpression[],\r\n    /** Field values. */\r\n    public values: Expression[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.OBJECT, range);\r\n  }\r\n}\r\n\r\n/** Represents an omitted expression, e.g. within an array literal. */\r\nexport class OmittedExpression extends Expression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.OMITTED, range);\r\n  }\r\n}\r\n\r\n/** Represents a parenthesized expression. */\r\nexport class ParenthesizedExpression extends Expression {\r\n  constructor(\r\n    /** Expression in parenthesis. */\r\n    public expression: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.PARENTHESIZED, range);\r\n  }\r\n}\r\n\r\n/** Represents a property access expression. */\r\nexport class PropertyAccessExpression extends Expression {\r\n  constructor(\r\n    /** Expression being accessed. */\r\n    public expression: Expression,\r\n    /** Property of the expression being accessed. */\r\n    public property: IdentifierExpression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.PROPERTYACCESS, range);\r\n  }\r\n}\r\n\r\n/** Represents a regular expression literal expression. */\r\nexport class RegexpLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** Regular expression pattern. */\r\n    public pattern: string,\r\n    /** Regular expression flags. */\r\n    public patternFlags: string,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.REGEXP, range);\r\n  }\r\n}\r\n\r\n/** Represents a ternary expression, i.e., short if notation. */\r\nexport class TernaryExpression extends Expression {\r\n  constructor(\r\n    /** Condition expression. */\r\n    public condition: Expression,\r\n    /** Expression executed when condition is `true`. */\r\n    public ifThen: Expression,\r\n    /** Expression executed when condition is `false`. */\r\n    public ifElse: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.TERNARY, range);\r\n  }\r\n}\r\n\r\n/** Represents a string literal expression. */\r\nexport class StringLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** String value without quotes. */\r\n    public value: string,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.STRING, range);\r\n  }\r\n}\r\n\r\n/** Represents a `super` expression. */\r\nexport class SuperExpression extends IdentifierExpression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(\"super\", false, range);\r\n    this.kind = NodeKind.SUPER;\r\n  }\r\n}\r\n\r\n/** Represents a template literal expression. */\r\nexport class TemplateLiteralExpression extends LiteralExpression {\r\n  constructor(\r\n    /** Tag expression, if any. */\r\n    public tag: Expression | null,\r\n    /** String parts. */\r\n    public parts: string[],\r\n    /** Raw string parts. */\r\n    public rawParts: string[],\r\n    /** Expression parts. */\r\n    public expressions: Expression[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(LiteralKind.TEMPLATE, range);\r\n  }\r\n}\r\n\r\n/** Represents a `this` expression. */\r\nexport class ThisExpression extends IdentifierExpression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(\"this\", false, range);\r\n    this.kind = NodeKind.THIS;\r\n  }\r\n}\r\n\r\n/** Represents a `true` expression. */\r\nexport class TrueExpression extends IdentifierExpression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(\"true\", false, range);\r\n    this.kind = NodeKind.TRUE;\r\n  }\r\n}\r\n\r\n/** Represents a `false` expression. */\r\nexport class FalseExpression extends IdentifierExpression {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(\"false\", false, range);\r\n    this.kind = NodeKind.FALSE;\r\n  }\r\n}\r\n\r\n/** Base class of all unary expressions. */\r\nexport abstract class UnaryExpression extends Expression {\r\n  constructor(\r\n    /** Unary expression kind. */\r\n    kind: NodeKind,\r\n    /** Operator token. */\r\n    public operator: Token,\r\n    /** Operand expression. */\r\n    public operand: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(kind, range);\r\n  }\r\n}\r\n\r\n/** Represents a unary postfix expression, e.g. a postfix increment. */\r\nexport class UnaryPostfixExpression extends UnaryExpression {\r\n  constructor(\r\n    /** Operator token. */\r\n    operator: Token,\r\n    /** Operand expression. */\r\n    operand: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.UNARYPOSTFIX, operator, operand, range);\r\n  }\r\n}\r\n\r\n/** Represents a unary prefix expression, e.g. a negation. */\r\nexport class UnaryPrefixExpression extends UnaryExpression {\r\n  constructor(\r\n    /** Operator token. */\r\n    operator: Token,\r\n    /** Operand expression. */\r\n    operand: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.UNARYPREFIX, operator, operand, range);\r\n  }\r\n}\r\n\r\n/** Represents a special pre-compiled expression. If the expression has side-effects, special care has to be taken. */\r\nexport class CompiledExpression extends Expression {\r\n  constructor(\r\n    /** Compiled expression. */\r\n    public expr: ExpressionRef,\r\n    /** Type of the compiled expression. */\r\n    public type: Type,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.COMPILED, range);\r\n  }\r\n}\r\n\r\n// statements\r\n\r\n/** Base class of all statement nodes. */\r\nexport abstract class Statement extends Node { }\r\n\r\n/** Indicates the specific kind of a source. */\r\nexport enum SourceKind {\r\n  /** User-provided file. */\r\n  USER = 0,\r\n  /** User-provided entry file. */\r\n  USER_ENTRY = 1,\r\n  /** Library-provided file. */\r\n  LIBRARY = 2,\r\n  /** Library-provided entry file. */\r\n  LIBRARY_ENTRY = 3\r\n}\r\n\r\n/** A top-level source node. */\r\nexport class Source extends Node {\r\n  constructor(\r\n    /** Source kind. */\r\n    public sourceKind: SourceKind,\r\n    /** Normalized path with file extension. */\r\n    public normalizedPath: string,\r\n    /** Full source text. */\r\n    public text: string\r\n  ) {\r\n    super(NodeKind.SOURCE, new Range(0, text.length));\r\n    var internalPath = mangleInternalPath(normalizedPath);\r\n    this.internalPath = internalPath;\r\n    var pos = internalPath.lastIndexOf(PATH_DELIMITER);\r\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\r\n    this.range.source = this;\r\n  }\r\n\r\n  /** Path used internally. */\r\n  internalPath: string;\r\n  /** Simple path (last part without extension). */\r\n  simplePath: string;\r\n  /** Contained statements. */\r\n  statements: Statement[] = new Array();\r\n  /** Source map index. */\r\n  debugInfoIndex: i32 = -1;\r\n  /** Re-exported sources. */\r\n  exportPaths: string[] | null = null;\r\n\r\n  /** Checks if this source represents native code. */\r\n  get isNative(): bool {\r\n    return this.internalPath == LIBRARY_SUBST;\r\n  }\r\n\r\n  /** Checks if this source is part of the (standard) library. */\r\n  get isLibrary(): bool {\r\n    var kind = this.sourceKind;\r\n    return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;\r\n  }\r\n\r\n  /** Cached line starts. */\r\n  private lineCache: i32[] | null = null;\r\n\r\n  /** Remembered column number. */\r\n  private lineColumn: i32 = 1;\r\n\r\n  /** Determines the line number at the specified position. Starts at `1`. */\r\n  lineAt(pos: i32): i32 {\r\n    assert(pos >= 0 && pos < 0x7fffffff);\r\n    var lineCache = this.lineCache;\r\n    if (!lineCache) {\r\n      this.lineCache = lineCache = [0];\r\n      let text = this.text;\r\n      let off = 0;\r\n      let end = text.length;\r\n      while (off < end) {\r\n        if (text.charCodeAt(off++) == CharCode.LINEFEED) lineCache.push(off);\r\n      }\r\n      lineCache.push(0x7fffffff);\r\n    }\r\n    var l = 0;\r\n    var r = lineCache.length - 1;\r\n    while (l < r) {\r\n      let m = l + ((r - l) >> 1);\r\n      let s = unchecked(lineCache[m]);\r\n      if (pos < s) r = m;\r\n      else if (pos < unchecked(lineCache[m + 1])) {\r\n        this.lineColumn = pos - s + 1;\r\n        return m + 1;\r\n      }\r\n      else l = m + 1;\r\n    }\r\n    return assert(0);\r\n  }\r\n\r\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\r\n  columnAt(): i32 {\r\n    return this.lineColumn;\r\n  }\r\n}\r\n\r\n/** Base class of all declaration statements. */\r\nexport abstract class DeclarationStatement extends Statement {\r\n  constructor(\r\n    /** Declaration node kind. */\r\n    kind: NodeKind,\r\n    /** Simple name being declared. */\r\n    public name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    public decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    public flags: CommonFlags,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(kind, range);\r\n  }\r\n\r\n  /** Tests if this node has the specified flag or flags. */\r\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\r\n  /** Tests if this node has one of the specified flags. */\r\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\r\n  /** Sets a specific flag or flags. */\r\n  set(flag: CommonFlags): void { this.flags |= flag; }\r\n}\r\n\r\n/** Represents an index signature. */\r\nexport class IndexSignatureNode extends Node {\r\n  constructor(\r\n    /** Key type. */\r\n    public keyType: NamedTypeNode,\r\n    /** Value type. */\r\n    public valueType: TypeNode,\r\n    /** Common flags indicating specific traits. */\r\n    public flags: CommonFlags,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.INDEXSIGNATURE, range);\r\n  }\r\n}\r\n\r\n/** Base class of all variable-like declaration statements. */\r\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\r\n  constructor(\r\n    /** Variable-like declaration node kind. */\r\n    kind: NodeKind,\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Annotated type node, if any. */\r\n    public type: TypeNode | null,\r\n    /** Initializer expression, if any. */\r\n    public initializer: Expression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(kind, name, decorators, flags, range);\r\n  }\r\n}\r\n\r\n/** Represents a block statement. */\r\nexport class BlockStatement extends Statement {\r\n  constructor(\r\n    /** Contained statements. */\r\n    public statements: Statement[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.BLOCK, range);\r\n  }\r\n}\r\n\r\n/** Represents a `break` statement. */\r\nexport class BreakStatement extends Statement {\r\n  constructor(\r\n    /** Target label, if any. */\r\n    public label: IdentifierExpression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.BREAK, range);\r\n  }\r\n}\r\n\r\n/** Represents a `class` declaration. */\r\nexport class ClassDeclaration extends DeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Accepted type parameters. */\r\n    public typeParameters: TypeParameterNode[] | null,\r\n    /** Base class type being extended, if any. */\r\n    public extendsType: NamedTypeNode | null, // can't be a function\r\n    /** Interface types being implemented, if any. */\r\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\r\n    /** Class member declarations. */\r\n    public members: DeclarationStatement[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.CLASSDECLARATION, name, decorators, flags, range);\r\n  }\r\n\r\n  /** Index signature, if present. */\r\n  indexSignature: IndexSignatureNode | null = null;\r\n\r\n  get isGeneric(): bool {\r\n    var typeParameters = this.typeParameters;\r\n    return typeParameters != null && typeParameters.length > 0;\r\n  }\r\n}\r\n\r\n/** Represents a `continue` statement. */\r\nexport class ContinueStatement extends Statement {\r\n  constructor(\r\n    /** Target label, if applicable. */\r\n    public label: IdentifierExpression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.CONTINUE, range);\r\n  }\r\n}\r\n\r\n/** Represents a `do` statement. */\r\nexport class DoStatement extends Statement {\r\n  constructor(\r\n    /** Statement being looped over. */\r\n    public statement: Statement,\r\n    /** Condition when to repeat. */\r\n    public condition: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.DO, range);\r\n  }\r\n}\r\n\r\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\r\nexport class EmptyStatement extends Statement {\r\n  constructor(\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.EMPTY, range);\r\n  }\r\n}\r\n\r\n/** Represents an `enum` declaration. */\r\nexport class EnumDeclaration extends DeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Enum value declarations. */\r\n    public values: EnumValueDeclaration[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.ENUMDECLARATION, name, decorators, flags, range);\r\n  }\r\n}\r\n\r\n/** Represents a value of an `enum` declaration. */\r\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Initializer expression, if any. */\r\n    initializer: Expression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.ENUMVALUEDECLARATION, name, null, flags, null, initializer, range);\r\n  }\r\n}\r\n\r\n/** Represents an `export import` statement of an interface. */\r\nexport class ExportImportStatement extends Statement {\r\n  constructor(\r\n    /** Identifier being imported. */\r\n    public name: IdentifierExpression,\r\n    /** Identifier being exported. */\r\n    public externalName: IdentifierExpression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.EXPORTIMPORT, range);\r\n  }\r\n}\r\n\r\n/** Represents a member of an `export` statement. */\r\nexport class ExportMember extends Node {\r\n  constructor(\r\n    /** Local identifier. */\r\n    public localName: IdentifierExpression,\r\n    /** Exported identifier. */\r\n    public exportedName: IdentifierExpression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.EXPORTMEMBER, range);\r\n  }\r\n}\r\n\r\n/** Represents an `export` statement. */\r\nexport class ExportStatement extends Statement {\r\n  constructor(\r\n    /** Array of members if a set of named exports, or `null` if a file export. */\r\n    public members: ExportMember[] | null,\r\n    /** Path being exported from, if applicable. */\r\n    public path: StringLiteralExpression | null,\r\n    /** Whether this is a declared export. */\r\n    public isDeclare: bool,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.EXPORT, range);\r\n    if (path) {\r\n      let normalizedPath = normalizePath(path.value);\r\n      if (path.value.startsWith(\".\")) { // relative\r\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\r\n      } else { // absolute\r\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\r\n      }\r\n      this.internalPath = normalizedPath;\r\n    } else {\r\n      this.internalPath = null;\r\n    }\r\n  }\r\n\r\n  /** Internal path being referenced, if `path` is set. */\r\n  internalPath: string | null;\r\n}\r\n\r\n/** Represents an `export default` statement. */\r\nexport class ExportDefaultStatement extends Statement {\r\n  constructor(\r\n    /** Declaration being exported as default. */\r\n    public declaration: DeclarationStatement,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.EXPORTDEFAULT, range);\r\n  }\r\n}\r\n\r\n/** Represents an expression that is used as a statement. */\r\nexport class ExpressionStatement extends Statement {\r\n  constructor(\r\n    /** Expression being used as a statement.*/\r\n    public expression: Expression\r\n  ) {\r\n    super(NodeKind.EXPRESSION, expression.range);\r\n  }\r\n}\r\n\r\n/** Represents a field declaration within a `class`. */\r\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Annotated type node, if any. */\r\n    type: TypeNode | null,\r\n    /** Initializer expression, if any. */\r\n    initializer: Expression | null,\r\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\r\n    public parameterIndex: i32,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.FIELDDECLARATION, name, decorators, flags, type, initializer, range);\r\n  }\r\n}\r\n\r\n/** Represents a `for` statement. */\r\nexport class ForStatement extends Statement {\r\n  constructor(\r\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\r\n    public initializer: Statement | null,\r\n    /** Condition expression, if present. */\r\n    public condition: Expression | null,\r\n    /** Incrementor expression, if present. */\r\n    public incrementor: Expression | null,\r\n    /** Statement being looped over. */\r\n    public statement: Statement,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.FOR, range);\r\n  }\r\n}\r\n\r\n/** Represents a `for..of` statement. */\r\nexport class ForOfStatement extends Statement {\r\n  constructor(\r\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\r\n    public variable: Statement,\r\n    /** Iterable expression being iterated. */\r\n    public iterable: Expression,\r\n    /** Statement being looped over. */\r\n    public statement: Statement,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.FOROF, range);\r\n  }\r\n}\r\n\r\n/** Indicates the kind of an array function. */\r\nexport const enum ArrowKind {\r\n  /** Not an arrow function. */\r\n  NONE,\r\n  /** Parenthesized parameter list. */\r\n  ARROW_PARENTHESIZED,\r\n  /** Single parameter without parenthesis. */\r\n  ARROW_SINGLE\r\n}\r\n\r\n/** Represents a `function` declaration. */\r\nexport class FunctionDeclaration extends DeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Type parameters, if any. */\r\n    public typeParameters: TypeParameterNode[] | null,\r\n    /** Function signature. */\r\n    public signature: FunctionTypeNode,\r\n    /** Body statement. Usually a block. */\r\n    public body: Statement | null,\r\n    /** Arrow function kind, if applicable. */\r\n    public arrowKind: ArrowKind,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.FUNCTIONDECLARATION, name, decorators, flags, range);\r\n  }\r\n\r\n  /** Gets if this function is generic. */\r\n  get isGeneric(): bool {\r\n    var typeParameters = this.typeParameters;\r\n    return typeParameters != null && typeParameters.length > 0;\r\n  }\r\n\r\n  /** Clones this function declaration. */\r\n  clone(): FunctionDeclaration {\r\n    return new FunctionDeclaration(\r\n      this.name,\r\n      this.decorators,\r\n      this.flags,\r\n      this.typeParameters,\r\n      this.signature,\r\n      this.body,\r\n      this.arrowKind,\r\n      this.range\r\n    );\r\n  }\r\n}\r\n\r\n/** Represents an `if` statement. */\r\nexport class IfStatement extends Statement {\r\n  constructor(\r\n    /** Condition. */\r\n    public condition: Expression,\r\n    /** Statement executed when condition is `true`. */\r\n    public ifTrue: Statement,\r\n    /** Statement executed when condition is `false`. */\r\n    public ifFalse: Statement | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.IF, range);\r\n  }\r\n}\r\n\r\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\r\nexport class ImportDeclaration extends DeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Identifier being imported. */\r\n    public foreignName: IdentifierExpression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.IMPORTDECLARATION, name, null, CommonFlags.NONE, range);\r\n  }\r\n}\r\n\r\n/** Represents an `import` statement. */\r\nexport class ImportStatement extends Statement {\r\n  constructor(\r\n    /** Array of member declarations or `null` if an asterisk import. */\r\n    public declarations: ImportDeclaration[] | null,\r\n    /** Name of the local namespace, if an asterisk import. */\r\n    public namespaceName: IdentifierExpression | null,\r\n    /** Path being imported from. */\r\n    public path: StringLiteralExpression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.IMPORT, range);\r\n    var normalizedPath = normalizePath(path.value);\r\n    if (path.value.startsWith(\".\")) { // relative in project\r\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\r\n    } else { // absolute in library\r\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\r\n    }\r\n    this.internalPath = normalizedPath;\r\n  }\r\n\r\n  /** Internal path being referenced. */\r\n  internalPath: string;\r\n}\r\n\r\n/** Represents an `interfarce` declaration. */\r\nexport class InterfaceDeclaration extends ClassDeclaration {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Accepted type parameters. */\r\n    typeParameters: TypeParameterNode[] | null,\r\n    /** Base class type being extended, if any. */\r\n    extendsType: NamedTypeNode | null, // can't be a function\r\n    /** Interface types being implemented, if any. */\r\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\r\n    /** Class member declarations. */\r\n    members: DeclarationStatement[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\r\n    this.kind = NodeKind.INTERFACEDECLARATION;\r\n  }\r\n}\r\n\r\n/** Represents a method declaration within a `class`. */\r\nexport class MethodDeclaration extends FunctionDeclaration {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Type parameters, if any. */\r\n    typeParameters: TypeParameterNode[] | null,\r\n    /** Function signature. */\r\n    signature: FunctionTypeNode,\r\n    /** Body statement. Usually a block. */\r\n    body: Statement | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.NONE, range);\r\n    this.kind = NodeKind.METHODDECLARATION;\r\n  }\r\n}\r\n\r\n/** Represents a `namespace` declaration. */\r\nexport class NamespaceDeclaration extends DeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Array of namespace members. */\r\n    public members: Statement[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.NAMESPACEDECLARATION, name, decorators, flags, range);\r\n  }\r\n}\r\n\r\n/** Represents a `return` statement. */\r\nexport class ReturnStatement extends Statement {\r\n  constructor(\r\n    /** Value expression being returned, if present. */\r\n    public value: Expression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.RETURN, range);\r\n  }\r\n}\r\n\r\n/** Represents a single `case` within a `switch` statement. */\r\nexport class SwitchCase extends Node {\r\n  constructor(\r\n    /** Label expression. `null` indicates the default case. */\r\n    public label: Expression | null,\r\n    /** Contained statements. */\r\n    public statements: Statement[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.SWITCHCASE, range);\r\n  }\r\n}\r\n\r\n/** Represents a `switch` statement. */\r\nexport class SwitchStatement extends Statement {\r\n  constructor(\r\n    /** Condition expression. */\r\n    public condition: Expression,\r\n    /** Contained cases. */\r\n    public cases: SwitchCase[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.SWITCH, range);\r\n  }\r\n}\r\n\r\n/** Represents a `throw` statement. */\r\nexport class ThrowStatement extends Statement {\r\n  constructor(\r\n    /** Value expression being thrown. */\r\n    public value: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.THROW, range);\r\n  }\r\n}\r\n\r\n/** Represents a `try` statement. */\r\nexport class TryStatement extends Statement {\r\n  constructor(\r\n    /** Contained statements. */\r\n    public statements: Statement[],\r\n    /** Exception variable name, if a `catch` clause is present. */\r\n    public catchVariable: IdentifierExpression | null,\r\n    /** Statements being executed on catch, if a `catch` clause is present. */\r\n    public catchStatements: Statement[] | null,\r\n    /** Statements being executed afterwards, if a `finally` clause is present. */\r\n    public finallyStatements: Statement[] | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.TRY, range);\r\n  }\r\n}\r\n\r\n/** Represents a `type` declaration. */\r\nexport class TypeDeclaration extends DeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Type parameters, if any. */\r\n    public typeParameters: TypeParameterNode[] | null,\r\n    /** Type being aliased. */\r\n    public type: TypeNode,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.TYPEDECLARATION, name, decorators, flags, range);\r\n  }\r\n}\r\n\r\n/** Represents a variable declaration part of a {@link VariableStatement}. */\r\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\r\n  constructor(\r\n    /** Simple name being declared. */\r\n    name: IdentifierExpression,\r\n    /** Array of decorators, if any. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Common flags indicating specific traits. */\r\n    flags: CommonFlags,\r\n    /** Annotated type node, if any. */\r\n    type: TypeNode | null,\r\n    /** Initializer expression, if any. */\r\n    initializer: Expression | null,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.VARIABLEDECLARATION, name, decorators, flags, type, initializer, range);\r\n  }\r\n}\r\n\r\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\r\nexport class VariableStatement extends Statement {\r\n  constructor(\r\n    /** Array of decorators. */\r\n    public decorators: DecoratorNode[] | null,\r\n    /** Array of member declarations. */\r\n    public declarations: VariableDeclaration[],\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.VARIABLE, range);\r\n  }\r\n}\r\n\r\n/** Represents a void statement dropping an expression's value. */\r\nexport class VoidStatement extends Statement {\r\n  constructor(\r\n    /** Expression being dropped. */\r\n    public expression: Expression,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.VOID, range);\r\n  }\r\n}\r\n\r\n/** Represents a `while` statement. */\r\nexport class WhileStatement extends Statement {\r\n  constructor(\r\n    /** Condition expression. */\r\n    public condition: Expression,\r\n    /** Statement being looped over. */\r\n    public statement: Statement,\r\n    /** Source range. */\r\n    range: Range\r\n  ) {\r\n    super(NodeKind.WHILE, range);\r\n  }\r\n}\r\n\r\n/** Finds the first decorator matching the specified kind. */\r\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\r\n  if (decorators) {\r\n    for (let i = 0, k = decorators.length; i < k; ++i) {\r\n      let decorator = decorators[i];\r\n      if (decorator.decoratorKind == kind) return decorator;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/** Mangles an external to an internal path. */\r\nexport function mangleInternalPath(path: string): string {\r\n  var pos = path.lastIndexOf(\".\");\r\n  var len = path.length;\r\n  if (pos >= 0 && len - pos >= 2) { // at least one char plus dot\r\n    let cur = pos;\r\n    while (++cur < len) {\r\n      if (!isTrivialAlphanum(path.charCodeAt(cur))) {\r\n        assert(false); // not a valid external path\r\n        return path;\r\n      }\r\n    }\r\n    return path.substring(0, pos);\r\n  }\r\n  assert(false); // not an external path\r\n  return path;\r\n}\r\n\r\n/** Tests if the specified type node represents an omitted type. */\r\nexport function isTypeOmitted(type: TypeNode): bool {\r\n  if (type.kind == NodeKind.NAMEDTYPE) {\r\n    let name = (<NamedTypeNode>type).name;\r\n    return !(name.next !== null || name.identifier.text.length > 0);\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @fileoverview Built-in elements providing core WebAssembly functionality.\r\n *\r\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\r\n * When its prototype is called, the compiler recognizes the `@builtin`\r\n * decorator, looks up the respective handler in the global builtins map\r\n * and executes it, with the handler directly emitting WebAssembly code\r\n * according to context.\r\n *\r\n * Builtins can be categorized into core builtins that typically are generic\r\n * and emit code directly and aliases calling core builtins with overridden\r\n * contexts. The latter is used by inline assembler aliases of WebAssembly\r\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\r\n *\r\n * The `contextIsExact` modifier is used to force a specific instruction\r\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\r\n * ambiguous in that the input can still be an i32 or an i64, leading to\r\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\r\n * This behavior is indicated by `from i32/i64` in the comments below.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\r\n\r\nimport {\r\n  Compiler,\r\n  Constraints,\r\n  RuntimeFeatures\r\n} from \"./compiler\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticCategory\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Expression,\r\n  LiteralKind,\r\n  StringLiteralExpression,\r\n  CallExpression,\r\n  NodeKind,\r\n  LiteralExpression,\r\n  ArrayLiteralExpression\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Type,\r\n  TypeKind,\r\n  TypeFlags\r\n} from \"./types\";\r\n\r\nimport {\r\n  BinaryOp,\r\n  UnaryOp,\r\n  AtomicRMWOp,\r\n  SIMDExtractOp,\r\n  SIMDReplaceOp,\r\n  SIMDShiftOp,\r\n  SIMDTernaryOp,\r\n  SIMDLoadOp,\r\n  SIMDLoadStoreLaneOp,\r\n  RefIsOp,\r\n  TypeRef,\r\n  ExpressionRef,\r\n  ExpressionId,\r\n  getExpressionId,\r\n  getExpressionType,\r\n  getConstValueI64High,\r\n  getConstValueI64Low,\r\n  getConstValueI32,\r\n  getConstValueF32,\r\n  getConstValueF64,\r\n  getLocalGetIndex,\r\n  createType,\r\n  ExpressionRunnerFlags\r\n} from \"./module\";\r\n\r\nimport {\r\n  ElementKind,\r\n  FunctionPrototype,\r\n  Field,\r\n  Global,\r\n  DecoratorFlags,\r\n  ClassPrototype,\r\n  Class\r\n} from \"./program\";\r\n\r\nimport {\r\n  findUsedLocals,\r\n  FlowFlags,\r\n  LocalFlags\r\n} from \"./flow\";\r\n\r\nimport {\r\n  ReportMode\r\n} from \"./resolver\";\r\n\r\nimport {\r\n  CommonFlags,\r\n  Feature,\r\n  featureToString,\r\n  TypeinfoFlags\r\n} from \"./common\";\r\n\r\nimport {\r\n  writeI8,\r\n  writeI16,\r\n  writeI32,\r\n  writeF32,\r\n  writeF64,\r\n  isPowerOf2\r\n} from \"./util\";\r\n\r\n/** Internal names of various compiler built-ins. */\r\nexport namespace BuiltinNames {\r\n\r\n  // compiler-generated\r\n  export const start = \"~start\";\r\n  export const started = \"~started\";\r\n  export const argumentsLength = \"~argumentsLength\";\r\n  export const setArgumentsLength = \"~setArgumentsLength\";\r\n\r\n  // std/builtins.ts\r\n  export const abort = \"~lib/builtins/abort\";\r\n  export const trace = \"~lib/builtins/trace\";\r\n  export const seed = \"~lib/builtins/seed\";\r\n\r\n  export const isInteger = \"~lib/builtins/isInteger\";\r\n  export const isFloat = \"~lib/builtins/isFloat\";\r\n  export const isBoolean = \"~lib/builtins/isBoolean\";\r\n  export const isSigned = \"~lib/builtins/isSigned\";\r\n  export const isReference = \"~lib/builtins/isReference\";\r\n  export const isString = \"~lib/builtins/isString\";\r\n  export const isArray = \"~lib/builtins/isArray\";\r\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\r\n  export const isFunction = \"~lib/builtins/isFunction\";\r\n  export const isNullable = \"~lib/builtins/isNullable\";\r\n  export const isDefined = \"~lib/builtins/isDefined\";\r\n  export const isConstant = \"~lib/builtins/isConstant\";\r\n  export const isManaged = \"~lib/builtins/isManaged\";\r\n  export const isVoid = \"~lib/builtins/isVoid\";\r\n\r\n  export const add = \"~lib/builtins/add\";\r\n  export const sub = \"~lib/builtins/sub\";\r\n  export const mul = \"~lib/builtins/mul\";\r\n  export const div = \"~lib/builtins/div\";\r\n  export const clz = \"~lib/builtins/clz\";\r\n  export const ctz = \"~lib/builtins/ctz\";\r\n  export const popcnt = \"~lib/builtins/popcnt\";\r\n  export const rotl = \"~lib/builtins/rotl\";\r\n  export const rotr = \"~lib/builtins/rotr\";\r\n  export const abs = \"~lib/builtins/abs\";\r\n  export const max = \"~lib/builtins/max\";\r\n  export const min = \"~lib/builtins/min\";\r\n  export const ceil = \"~lib/builtins/ceil\";\r\n  export const floor = \"~lib/builtins/floor\";\r\n  export const copysign = \"~lib/builtins/copysign\";\r\n  export const nearest = \"~lib/builtins/nearest\";\r\n  export const reinterpret = \"~lib/builtins/reinterpret\";\r\n  export const sqrt = \"~lib/builtins/sqrt\";\r\n  export const trunc = \"~lib/builtins/trunc\";\r\n  export const load = \"~lib/builtins/load\";\r\n  export const store = \"~lib/builtins/store\";\r\n  export const atomic_load = \"~lib/builtins/atomic.load\";\r\n  export const atomic_store = \"~lib/builtins/atomic.store\";\r\n  export const atomic_add = \"~lib/builtins/atomic.add\";\r\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\r\n  export const atomic_and = \"~lib/builtins/atomic.and\";\r\n  export const atomic_or = \"~lib/builtins/atomic.or\";\r\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\r\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\r\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\r\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\r\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\r\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\r\n\r\n  export const sizeof = \"~lib/builtins/sizeof\";\r\n  export const alignof = \"~lib/builtins/alignof\";\r\n  export const offsetof = \"~lib/builtins/offsetof\";\r\n  export const nameof = \"~lib/builtins/nameof\";\r\n  export const lengthof = \"~lib/builtins/lengthof\";\r\n  export const select = \"~lib/builtins/select\";\r\n  export const unreachable = \"~lib/builtins/unreachable\";\r\n  export const changetype = \"~lib/builtins/changetype\";\r\n  export const assert = \"~lib/builtins/assert\";\r\n  export const call_indirect = \"~lib/builtins/call_indirect\";\r\n  export const unchecked = \"~lib/builtins/unchecked\";\r\n  export const instantiate = \"~lib/builtins/instantiate\";\r\n  export const idof = \"~lib/builtins/idof\";\r\n\r\n  export const i8 = \"~lib/builtins/i8\";\r\n  export const i16 = \"~lib/builtins/i16\";\r\n  export const i32 = \"~lib/builtins/i32\";\r\n  export const i64 = \"~lib/builtins/i64\";\r\n  export const isize = \"~lib/builtins/isize\";\r\n  export const u8 = \"~lib/builtins/u8\";\r\n  export const u16 = \"~lib/builtins/u16\";\r\n  export const u32 = \"~lib/builtins/u32\";\r\n  export const u64 = \"~lib/builtins/u64\";\r\n  export const usize = \"~lib/builtins/usize\";\r\n  export const bool = \"~lib/builtins/bool\";\r\n  export const f32 = \"~lib/builtins/f32\";\r\n  export const f64 = \"~lib/builtins/f64\";\r\n  export const v128 = \"~lib/builtins/v128\";\r\n\r\n  export const i32_clz = \"~lib/builtins/i32.clz\";\r\n  export const i64_clz = \"~lib/builtins/i64.clz\";\r\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\r\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\r\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\r\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\r\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\r\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\r\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\r\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\r\n\r\n  export const f32_abs = \"~lib/builtins/f32.abs\";\r\n  export const f64_abs = \"~lib/builtins/f64.abs\";\r\n  export const f32_max = \"~lib/builtins/f32.max\";\r\n  export const f64_max = \"~lib/builtins/f64.max\";\r\n  export const f32_min = \"~lib/builtins/f32.min\";\r\n  export const f64_min = \"~lib/builtins/f64.min\";\r\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\r\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\r\n  export const f32_floor = \"~lib/builtins/f32.floor\";\r\n  export const f64_floor = \"~lib/builtins/f64.floor\";\r\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\r\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\r\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\r\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\r\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\r\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\r\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\r\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\r\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\r\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\r\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\r\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\r\n\r\n  export const i32_add = \"~lib/builtins/i32.add\";\r\n  export const i64_add = \"~lib/builtins/i64.add\";\r\n  export const f32_add = \"~lib/builtins/f32.add\";\r\n  export const f64_add = \"~lib/builtins/f64.add\";\r\n  export const i32_sub = \"~lib/builtins/i32.sub\";\r\n  export const i64_sub = \"~lib/builtins/i64.sub\";\r\n  export const f32_sub = \"~lib/builtins/f32.sub\";\r\n  export const f64_sub = \"~lib/builtins/f64.sub\";\r\n  export const i32_mul = \"~lib/builtins/i32.mul\";\r\n  export const i64_mul = \"~lib/builtins/i64.mul\";\r\n  export const f32_mul = \"~lib/builtins/f32.mul\";\r\n  export const f64_mul = \"~lib/builtins/f64.mul\";\r\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\r\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\r\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\r\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\r\n  export const f32_div = \"~lib/builtins/f32.div\";\r\n  export const f64_div = \"~lib/builtins/f64.div\";\r\n\r\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\r\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\r\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\r\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\r\n  export const i32_load = \"~lib/builtins/i32.load\";\r\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\r\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\r\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\r\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\r\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\r\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\r\n  export const i64_load = \"~lib/builtins/i64.load\";\r\n  export const f32_load = \"~lib/builtins/f32.load\";\r\n  export const f64_load = \"~lib/builtins/f64.load\";\r\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\r\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\r\n  export const i32_store = \"~lib/builtins/i32.store\";\r\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\r\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\r\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\r\n  export const i64_store = \"~lib/builtins/i64.store\";\r\n  export const f32_store = \"~lib/builtins/f32.store\";\r\n  export const f64_store = \"~lib/builtins/f64.store\";\r\n\r\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\r\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\r\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\r\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\r\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\r\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\r\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\r\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\r\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\r\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\r\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\r\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\r\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\r\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\r\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\r\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\r\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\r\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\r\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\r\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\r\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\r\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\r\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\r\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\r\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\r\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\r\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\r\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\r\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\r\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\r\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\r\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\r\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\r\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\r\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\r\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\r\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\r\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\r\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\r\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\r\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\r\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\r\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\r\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\r\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\r\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\r\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\r\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\r\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\r\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\r\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\r\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\r\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\r\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\r\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\r\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\r\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\r\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\r\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\r\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\r\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\r\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\r\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\r\n  export const i32_wait = \"~lib/builtins/i32.wait\";\r\n  export const i64_wait = \"~lib/builtins/i64.wait\";\r\n\r\n  export const v128_splat = \"~lib/builtins/v128.splat\";\r\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\r\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\r\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\r\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\r\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\r\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\r\n  export const v128_load_zero = \"~lib/builtins/v128.load_zero\";\r\n  export const v128_load_lane = \"~lib/builtins/v128.load_lane\";\r\n  export const v128_store_lane = \"~lib/builtins/v128.store_lane\";\r\n  export const v128_load = \"~lib/builtins/v128.load\";\r\n  export const v128_load8x8_s = \"~lib/builtins/v128.load8x8_s\";\r\n  export const v128_load8x8_u = \"~lib/builtins/v128.load8x8_u\";\r\n  export const v128_load16x4_s = \"~lib/builtins/v128.load16x4_s\";\r\n  export const v128_load16x4_u = \"~lib/builtins/v128.load16x4_u\";\r\n  export const v128_load32x2_s = \"~lib/builtins/v128.load32x2_s\";\r\n  export const v128_load32x2_u = \"~lib/builtins/v128.load32x2_u\";\r\n  export const v128_load8_splat = \"~lib/builtins/v128.load8_splat\";\r\n  export const v128_load16_splat = \"~lib/builtins/v128.load16_splat\";\r\n  export const v128_load32_splat = \"~lib/builtins/v128.load32_splat\";\r\n  export const v128_load64_splat = \"~lib/builtins/v128.load64_splat\";\r\n  export const v128_load32_zero = \"~lib/builtins/v128.load32_zero\";\r\n  export const v128_load64_zero = \"~lib/builtins/v128.load64_zero\";\r\n  export const v128_load8_lane = \"~lib/builtins/v128.load8_lane\";\r\n  export const v128_load16_lane = \"~lib/builtins/v128.load16_lane\";\r\n  export const v128_load32_lane = \"~lib/builtins/v128.load32_lane\";\r\n  export const v128_load64_lane = \"~lib/builtins/v128.load64_lane\";\r\n  export const v128_store8_lane = \"~lib/builtins/v128.store8_lane\";\r\n  export const v128_store16_lane = \"~lib/builtins/v128.store16_lane\";\r\n  export const v128_store32_lane = \"~lib/builtins/v128.store32_lane\";\r\n  export const v128_store64_lane = \"~lib/builtins/v128.store64_lane\";\r\n  export const v128_store = \"~lib/builtins/v128.store\";\r\n  export const v128_add = \"~lib/builtins/v128.add\";\r\n  export const v128_sub = \"~lib/builtins/v128.sub\";\r\n  export const v128_mul = \"~lib/builtins/v128.mul\";\r\n  export const v128_div = \"~lib/builtins/v128.div\";\r\n  export const v128_neg = \"~lib/builtins/v128.neg\";\r\n  export const v128_add_sat = \"~lib/builtins/v128.add_sat\";\r\n  export const v128_sub_sat = \"~lib/builtins/v128.sub_sat\";\r\n  export const v128_shl = \"~lib/builtins/v128.shl\";\r\n  export const v128_shr = \"~lib/builtins/v128.shr\";\r\n  export const v128_and = \"~lib/builtins/v128.and\";\r\n  export const v128_or = \"~lib/builtins/v128.or\";\r\n  export const v128_xor = \"~lib/builtins/v128.xor\";\r\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\r\n  export const v128_not = \"~lib/builtins/v128.not\";\r\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\r\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\r\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\r\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\r\n  export const v128_popcnt = \"~lib/builtins/v128.popcnt\";\r\n  export const v128_min = \"~lib/builtins/v128.min\";\r\n  export const v128_max = \"~lib/builtins/v128.max\";\r\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\r\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\r\n  export const v128_dot = \"~lib/builtins/v128.dot\";\r\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\r\n  export const v128_abs = \"~lib/builtins/v128.abs\";\r\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\r\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\r\n  export const v128_floor = \"~lib/builtins/v128.floor\";\r\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\r\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\r\n  export const v128_eq = \"~lib/builtins/v128.eq\";\r\n  export const v128_ne = \"~lib/builtins/v128.ne\";\r\n  export const v128_lt = \"~lib/builtins/v128.lt\";\r\n  export const v128_le = \"~lib/builtins/v128.le\";\r\n  export const v128_gt = \"~lib/builtins/v128.gt\";\r\n  export const v128_ge = \"~lib/builtins/v128.ge\";\r\n  export const v128_convert = \"~lib/builtins/v128.convert\";\r\n  export const v128_convert_low = \"~lib/builtins/v128.convert_low\";\r\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\r\n  export const v128_trunc_sat_zero = \"~lib/builtins/v128.trunc_sat_zero\";\r\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\r\n  export const v128_extend_low = \"~lib/builtins/v128.extend_low\";\r\n  export const v128_extend_high = \"~lib/builtins/v128.extend_high\";\r\n  export const v128_extadd_pairwise = \"~lib/builtins/v128.extadd_pairwise\";\r\n  export const v128_demote_zero = \"~lib/builtins/v128.demote_zero\";\r\n  export const v128_promote_low = \"~lib/builtins/v128.promote_low\";\r\n  export const v128_q15mulr_sat = \"~lib/builtins/v128.q15mulr_sat\";\r\n  export const v128_extmul_low = \"~lib/builtins/v128.extmul_low\";\r\n  export const v128_extmul_high = \"~lib/builtins/v128.extmul_high\";\r\n\r\n  export const i8x16 = \"~lib/builtins/i8x16\";\r\n  export const i16x8 = \"~lib/builtins/i16x8\";\r\n  export const i32x4 = \"~lib/builtins/i32x4\";\r\n  export const i64x2 = \"~lib/builtins/i64x2\";\r\n  export const f32x4 = \"~lib/builtins/f32x4\";\r\n  export const f64x2 = \"~lib/builtins/f64x2\";\r\n\r\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\r\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\r\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\r\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\r\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\r\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\r\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\r\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\r\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\r\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\r\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\r\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\r\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\r\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\r\n  export const i8x16_add_sat_s = \"~lib/builtins/i8x16.add_sat_s\";\r\n  export const i8x16_add_sat_u = \"~lib/builtins/i8x16.add_sat_u\";\r\n  export const i8x16_sub_sat_s = \"~lib/builtins/i8x16.sub_sat_s\";\r\n  export const i8x16_sub_sat_u = \"~lib/builtins/i8x16.sub_sat_u\";\r\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\r\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\r\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\r\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\r\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\r\n  export const i8x16_popcnt = \"~lib/builtins/i8x16.popcnt\";\r\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\r\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\r\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\r\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\r\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\r\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\r\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\r\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\r\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\r\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\r\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\r\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\r\n  export const i8x16_shuffle = \"~lib/builtins/i8x16.shuffle\";\r\n  export const i8x16_swizzle = \"~lib/builtins/i8x16.swizzle\";\r\n\r\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\r\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\r\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\r\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\r\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\r\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\r\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\r\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\r\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\r\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\r\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\r\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\r\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\r\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\r\n  export const i16x8_add_sat_s = \"~lib/builtins/i16x8.add_sat_s\";\r\n  export const i16x8_add_sat_u = \"~lib/builtins/i16x8.add_sat_u\";\r\n  export const i16x8_sub_sat_s = \"~lib/builtins/i16x8.sub_sat_s\";\r\n  export const i16x8_sub_sat_u = \"~lib/builtins/i16x8.sub_sat_u\";\r\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\r\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\r\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\r\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\r\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\r\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\r\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\r\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\r\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\r\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\r\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\r\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\r\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\r\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\r\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\r\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\r\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\r\n  export const i16x8_extend_low_i8x16_s = \"~lib/builtins/i16x8.extend_low_i8x16_s\";\r\n  export const i16x8_extend_low_i8x16_u = \"~lib/builtins/i16x8.extend_low_i8x16_u\";\r\n  export const i16x8_extend_high_i8x16_s = \"~lib/builtins/i16x8.extend_high_i8x16_s\";\r\n  export const i16x8_extend_high_i8x16_u = \"~lib/builtins/i16x8.extend_high_i8x16_u\";\r\n  export const i16x8_extadd_pairwise_i8x16_s = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_s\";\r\n  export const i16x8_extadd_pairwise_i8x16_u = \"~lib/builtins/i16x8.extadd_pairwise_i8x16_u\";\r\n  export const i16x8_q15mulr_sat_s = \"~lib/builtins/i16x8.q15mulr_sat_s\";\r\n  export const i16x8_extmul_low_i8x16_s = \"~lib/builtins/i16x8.extmul_low_i8x16_s\";\r\n  export const i16x8_extmul_low_i8x16_u = \"~lib/builtins/i16x8.extmul_low_i8x16_u\";\r\n  export const i16x8_extmul_high_i8x16_s = \"~lib/builtins/i16x8.extmul_high_i8x16_s\";\r\n  export const i16x8_extmul_high_i8x16_u = \"~lib/builtins/i16x8.extmul_high_i8x16_u\";\r\n\r\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\r\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\r\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\r\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\r\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\r\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\r\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\r\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\r\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\r\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\r\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\r\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\r\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\r\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\r\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\r\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\r\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\r\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\r\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\r\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\r\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\r\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\r\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\r\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\r\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\r\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\r\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\r\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\r\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\r\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\r\n  export const i32x4_trunc_sat_f64x2_s_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_s_zero\";\r\n  export const i32x4_trunc_sat_f64x2_u_zero = \"~lib/builtins/i32x4.trunc_sat_f64x2_u_zero\";\r\n  export const i32x4_extend_low_i16x8_s = \"~lib/builtins/i32x4.extend_low_i16x8_s\";\r\n  export const i32x4_extend_low_i16x8_u = \"~lib/builtins/i32x4.extend_low_i16x8_u\";\r\n  export const i32x4_extend_high_i16x8_s = \"~lib/builtins/i32x4.extend_high_i16x8_s\";\r\n  export const i32x4_extend_high_i16x8_u = \"~lib/builtins/i32x4.extend_high_i16x8_u\";\r\n  export const i32x4_extadd_pairwise_i16x8_s = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_s\";\r\n  export const i32x4_extadd_pairwise_i16x8_u = \"~lib/builtins/i32x4.extadd_pairwise_i16x8_u\";\r\n  export const i32x4_extmul_low_i16x8_s = \"~lib/builtins/i32x4.extmul_low_i16x8_s\";\r\n  export const i32x4_extmul_low_i16x8_u = \"~lib/builtins/i32x4.extmul_low_i16x8_u\";\r\n  export const i32x4_extmul_high_i16x8_s = \"~lib/builtins/i32x4.extmul_high_i16x8_s\";\r\n  export const i32x4_extmul_high_i16x8_u = \"~lib/builtins/i32x4.extmul_high_i16x8_u\";\r\n\r\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\r\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\r\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\r\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\r\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\";\r\n  export const i64x2_mul = \"~lib/builtins/i64x2.mul\";\r\n  export const i64x2_abs = \"~lib/builtins/i64x2.abs\";\r\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\r\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\r\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\r\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\r\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\";\r\n  export const i64x2_bitmask = \"~lib/builtins/i64x2.bitmask\";\r\n  export const i64x2_eq = \"~lib/builtins/i64x2.eq\";\r\n  export const i64x2_ne = \"~lib/builtins/i64x2.ne\";\r\n  export const i64x2_lt_s = \"~lib/builtins/i64x2.lt_s\";\r\n  export const i64x2_lt_u = \"~lib/builtins/i64x2.lt_u\";\r\n  export const i64x2_le_s = \"~lib/builtins/i64x2.le_s\";\r\n  export const i64x2_le_u = \"~lib/builtins/i64x2.le_u\";\r\n  export const i64x2_gt_s = \"~lib/builtins/i64x2.gt_s\";\r\n  export const i64x2_gt_u = \"~lib/builtins/i64x2.gt_u\";\r\n  export const i64x2_ge_s = \"~lib/builtins/i64x2.ge_s\";\r\n  export const i64x2_ge_u = \"~lib/builtins/i64x2.ge_u\";\r\n  export const i64x2_extend_low_i32x4_s = \"~lib/builtins/i64x2.extend_low_i32x4_s\";\r\n  export const i64x2_extend_low_i32x4_u = \"~lib/builtins/i64x2.extend_low_i32x4_u\";\r\n  export const i64x2_extend_high_i32x4_s = \"~lib/builtins/i64x2.extend_high_i32x4_s\";\r\n  export const i64x2_extend_high_i32x4_u = \"~lib/builtins/i64x2.extend_high_i32x4_u\";\r\n  export const i64x2_extmul_low_i32x4_s = \"~lib/builtins/i64x2.extmul_low_i32x4_s\";\r\n  export const i64x2_extmul_low_i32x4_u = \"~lib/builtins/i64x2.extmul_low_i32x4_u\";\r\n  export const i64x2_extmul_high_i32x4_s = \"~lib/builtins/i64x2.extmul_high_i32x4_s\";\r\n  export const i64x2_extmul_high_i32x4_u = \"~lib/builtins/i64x2.extmul_high_i32x4_u\";\r\n\r\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\r\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\r\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\r\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\r\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\r\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\r\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\r\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\r\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\r\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\r\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\r\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\r\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\r\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\r\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\r\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\r\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\r\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\r\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\r\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\r\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\r\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\r\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\r\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\r\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\r\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\r\n  export const f32x4_demote_f64x2_zero = \"~lib/builtins/f32x4.demote_f64x2_zero\";\r\n\r\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\r\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\r\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\r\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\r\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\r\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\r\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\r\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\r\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\r\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\r\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\r\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\r\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\r\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\r\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\r\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\r\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\r\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\r\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\r\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\r\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\r\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\r\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\r\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\r\n  export const f64x2_convert_low_i32x4_s = \"~lib/builtins/f64x2.convert_low_i32x4_s\";\r\n  export const f64x2_convert_low_i32x4_u = \"~lib/builtins/f64x2.convert_low_i32x4_u\";\r\n  export const f64x2_promote_low_f32x4 = \"~lib/builtins/f64x2.promote_low_f32x4\";\r\n\r\n  export const i31_new = \"~lib/builtins/i31.new\";\r\n  export const i31_get = \"~lib/builtins/i31.get\";\r\n\r\n  // internals\r\n  export const data_end = \"~lib/memory/__data_end\";\r\n  export const stack_pointer = \"~lib/memory/__stack_pointer\";\r\n  export const heap_base = \"~lib/memory/__heap_base\";\r\n  export const rtti_base = \"~lib/rt/__rtti_base\";\r\n  export const visit_globals = \"~lib/rt/__visit_globals\";\r\n  export const visit_members = \"~lib/rt/__visit_members\";\r\n  export const tostack = \"~lib/rt/__tostack\";\r\n\r\n  // std/number.ts\r\n  export const isNaN = \"~lib/number/isNaN\";\r\n  export const isFinite = \"~lib/number/isFinite\";\r\n\r\n  // std/diagnostics.ts\r\n  export const ERROR = \"~lib/diagnostics/ERROR\";\r\n  export const WARNING = \"~lib/diagnostics/WARNING\";\r\n  export const INFO = \"~lib/diagnostics/INFO\";\r\n\r\n  // std/function.ts\r\n  export const Function = \"~lib/function/Function\";\r\n\r\n  // std/memory.ts\r\n  export const memory_size = \"~lib/memory/memory.size\";\r\n  export const memory_grow = \"~lib/memory/memory.grow\";\r\n  export const memory_copy = \"~lib/memory/memory.copy\";\r\n  export const memory_fill = \"~lib/memory/memory.fill\";\r\n  export const memory_data = \"~lib/memory/memory.data\";\r\n\r\n  // std/typedarray.ts\r\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\r\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\r\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\r\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\r\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\r\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\r\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\r\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\r\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\r\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\r\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\r\n\r\n  // std/string.ts\r\n  export const String_raw = \"~lib/string/String.raw\";\r\n\r\n  // std/bindings/wasi.ts\r\n  export const wasiAbort = \"~lib/wasi/index/abort\";\r\n  export const wasiTrace = \"~lib/wasi/index/trace\";\r\n  export const wasiSeed = \"~lib/wasi/index/seed\";\r\n}\r\n\r\n/** Builtin compilation context. */\r\nexport class BuiltinContext {\r\n  constructor(\r\n    /** Compiler reference. */\r\n    public compiler: Compiler,\r\n    /** Prototype being called. */\r\n    public prototype: FunctionPrototype,\r\n    /** Provided type arguments. */\r\n    public typeArguments: Type[] | null,\r\n    /** Provided operands. */\r\n    public operands: Expression[],\r\n    /** Provided this operand, if any. */\r\n    public thisOperand: Expression | null,\r\n    /** Contextual type. */\r\n    public contextualType: Type,\r\n    /** Respective call expression. */\r\n    public reportNode: CallExpression,\r\n    /** Whether originating from inline assembly. */\r\n    public contextIsExact: bool\r\n  ) {}\r\n}\r\n\r\n/** Global builtins map. */\r\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\r\n\r\n/** Function builtins map. */\r\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\r\n\r\n// === Static type evaluation =================================================================\r\n\r\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\r\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isIntegerValue ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\r\n\r\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\r\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isFloatValue ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\r\n\r\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\r\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isBooleanValue ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\r\n\r\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\r\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isSignedIntegerValue ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\r\n\r\n// isReference<T!>() / isReference<T?>(value: T) -> bool\r\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isReference ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\r\n\r\n// isString<T!>() / isString<T?>(value: T) -> bool\r\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  var classReference = type.getClass();\r\n  return module.i32(\r\n    classReference !== null && classReference.isAssignableTo(compiler.program.stringInstance)\r\n      ? 1\r\n      : 0\r\n  );\r\n}\r\nbuiltins.set(BuiltinNames.isString, builtin_isString);\r\n\r\n// isArray<T!>() / isArray<T?>(value: T) -> bool\r\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  var classReference = type.getClass();\r\n  return module.i32(\r\n    classReference !== null && classReference.extends(compiler.program.arrayPrototype)\r\n      ? 1\r\n      : 0\r\n  );\r\n}\r\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\r\n\r\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\r\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  var classReference = type.getClass();\r\n  return module.i32(\r\n    classReference !== null && classReference.isArrayLike\r\n      ? 1\r\n      : 0\r\n  );\r\n}\r\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\r\n\r\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\r\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isFunction ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\r\n\r\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\r\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isNullableReference ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\r\n\r\n// isDefined(expression) -> bool\r\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.bool;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var element = compiler.resolver.lookupExpression(\r\n    ctx.operands[0],\r\n    compiler.currentFlow,\r\n    Type.auto,\r\n    ReportMode.SWALLOW\r\n  );\r\n  return module.i32(element !== null ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\r\n\r\n// isConstant(expression) -> bool\r\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.bool;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var expr = compiler.compileExpression(ctx.operands[0], Type.auto);\r\n  compiler.currentType = Type.bool;\r\n  return module.i32(getExpressionId(expr) == ExpressionId.Const ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\r\n\r\n// isManaged<T!>() -> bool\r\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.isManaged ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\r\n\r\n// isVoid<T!>() -> bool\r\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.bool;\r\n  if (!type) return module.unreachable();\r\n  return module.i32(type.kind == TypeKind.VOID ? 1 : 0);\r\n}\r\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\r\n\r\n// lengthof<T!>() -> i32\r\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.i32;\r\n  if (!type) return module.unreachable();\r\n  var signatureReference = type.signatureReference;\r\n  if (!signatureReference) {\r\n    compiler.error(\r\n      DiagnosticCode.Type_0_has_no_call_signatures,\r\n      ctx.reportNode.range, type.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  return module.i32(signatureReference.parameterTypes.length);\r\n}\r\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\r\n\r\n// sizeof<T!>() -> usize*\r\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = compiler.options.usizeType;\r\n  if (\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 0)\r\n  ) return module.unreachable();\r\n  var type = ctx.typeArguments![0];\r\n  var byteSize = type.byteSize;\r\n  if (!byteSize) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\r\n}\r\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\r\n\r\n// alignof<T!>() -> usize*\r\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = compiler.options.usizeType;\r\n  if (\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 0)\r\n  ) return module.unreachable();\r\n  var type = ctx.typeArguments![0];\r\n  var byteSize = type.byteSize;\r\n  if (!isPowerOf2(byteSize)) { // implies == 0\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\r\n}\r\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\r\n\r\n// offsetof<T!>(fieldName?: string) -> usize*\r\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = compiler.options.usizeType;\r\n  if (\r\n    checkTypeRequired(ctx) |\r\n    checkArgsOptional(ctx, 0, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var contextualType = ctx.contextualType;\r\n  var type = ctx.typeArguments![0];\r\n  var classReference = type.getClassOrWrapper(compiler.program);\r\n  if (!classReference) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\r\n    );\r\n    if (compiler.options.isWasm64) {\r\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\r\n        compiler.currentType = Type.u32;\r\n      }\r\n    } else {\r\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\r\n        compiler.currentType = Type.u64;\r\n      }\r\n    }\r\n    return module.unreachable();\r\n  }\r\n  if (operands.length) {\r\n    let firstOperand = operands[0];\r\n    if (!firstOperand.isLiteralKind(LiteralKind.STRING)) {\r\n      compiler.error(\r\n        DiagnosticCode.String_literal_expected,\r\n        operands[0].range\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\r\n    let classMembers = classReference.members;\r\n    if (classMembers !== null && classMembers.has(fieldName)) {\r\n      let member = assert(classMembers.get(fieldName));\r\n      if (member.kind == ElementKind.FIELD) {\r\n        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);\r\n      }\r\n    }\r\n    compiler.error(\r\n      DiagnosticCode.Type_0_has_no_property_1,\r\n      firstOperand.range, classReference.internalName, fieldName\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\r\n}\r\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\r\n\r\n// nameof<T> -> string\r\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var resultType = evaluateConstantType(ctx);\r\n  if (!resultType) {\r\n    compiler.currentType = compiler.program.stringInstance.type;\r\n    return module.unreachable();\r\n  }\r\n  var value: string;\r\n  if (resultType.isInternalReference) {\r\n    let classReference = resultType.getClass();\r\n    if (classReference) {\r\n      value = classReference.name;\r\n    } else {\r\n      assert(resultType.getSignature());\r\n      value = \"Function\";\r\n    }\r\n  } else {\r\n    value = resultType.toString();\r\n  }\r\n  return compiler.ensureStaticString(value);\r\n}\r\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\r\n\r\n// idof<T> -> u32\r\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var type = evaluateConstantType(ctx);\r\n  compiler.currentType = Type.u32;\r\n  if (!type) return module.unreachable();\r\n  let signatureReference = type.getSignature();\r\n  if (signatureReference) {\r\n    return module.i32(signatureReference.id);\r\n  }\r\n  let classReference = type.getClassOrWrapper(compiler.program);\r\n  if (classReference !== null && !classReference.hasDecorator(DecoratorFlags.UNMANAGED)) {\r\n    return module.i32(classReference.id);\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.idof, builtin_idof);\r\n\r\n// === Math ===================================================================================\r\n\r\n// clz<T?>(value: T) -> T\r\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: // not wrapped\r\n      case TypeKind.I8:\r\n      case TypeKind.U8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.unary(\r\n          compiler.options.isWasm64\r\n            ? UnaryOp.ClzI64\r\n            : UnaryOp.ClzI32,\r\n          arg0\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.clz, builtin_clz);\r\n\r\n// ctz<T?>(value: T) -> T\r\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: // not wrapped\r\n      case TypeKind.I8:\r\n      case TypeKind.U8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.unary(\r\n          compiler.options.isWasm64\r\n            ? UnaryOp.CtzI64\r\n            : UnaryOp.CtzI32,\r\n          arg0\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\r\n\r\n// popcnt<T?>(value: T) -> T\r\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (compiler.currentType.kind) {\r\n      case TypeKind.BOOL: return arg0;\r\n      case TypeKind.I8: // not wrapped\r\n      case TypeKind.U8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.unary(\r\n          compiler.options.isWasm64\r\n            ? UnaryOp.PopcntI64\r\n            : UnaryOp.PopcntI32,\r\n          arg0\r\n        );\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\r\n\r\n// rotl<T?>(value: T, shift: T) -> T\r\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: return arg0;\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16: {\r\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\r\n        let flow = compiler.currentFlow;\r\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\r\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\r\n        let temp2 = flow.getTempLocal(type);\r\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\r\n\r\n        let ret = module.binary(BinaryOp.OrI32,\r\n          module.binary(\r\n            BinaryOp.ShlI32,\r\n            module.local_tee(temp1.index, arg0, false), // i32\r\n            module.binary(\r\n              BinaryOp.AndI32,\r\n              module.local_tee(temp2.index, arg1, false), // i32\r\n              module.i32(type.size - 1)\r\n            )\r\n          ),\r\n          module.binary(\r\n            BinaryOp.ShrU32,\r\n            module.local_get(temp1.index, TypeRef.I32),\r\n            module.binary(\r\n              BinaryOp.AndI32,\r\n              module.binary(\r\n                BinaryOp.SubI32,\r\n                module.i32(0),\r\n                module.local_get(temp2.index, TypeRef.I32)\r\n              ),\r\n              module.i32(type.size - 1)\r\n            )\r\n          )\r\n        );\r\n        flow.freeTempLocal(temp2);\r\n        flow.freeTempLocal(temp1);\r\n\r\n        return ret;\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          compiler.options.isWasm64\r\n            ? BinaryOp.RotlI64\r\n            : BinaryOp.RotlI32,\r\n          arg0, arg1\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\r\n\r\n// rotr<T?>(value: T, shift: T) -> T\r\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: return arg0;\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16: {\r\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\r\n        let flow = compiler.currentFlow;\r\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\r\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\r\n        let temp2 = flow.getTempLocal(type);\r\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\r\n\r\n        let ret = module.binary(BinaryOp.OrI32,\r\n          module.binary(\r\n            BinaryOp.ShrU32,\r\n            module.local_tee(temp1.index, arg0, false), // i32\r\n            module.binary(\r\n              BinaryOp.AndI32,\r\n              module.local_tee(temp2.index, arg1, false), // i32\r\n              module.i32(type.size - 1)\r\n            )\r\n          ),\r\n          module.binary(\r\n            BinaryOp.ShlI32,\r\n            module.local_get(temp1.index, TypeRef.I32),\r\n            module.binary(\r\n              BinaryOp.AndI32,\r\n              module.binary(\r\n                BinaryOp.SubI32,\r\n                module.i32(0),\r\n                module.local_get(temp2.index, TypeRef.I32)\r\n              ),\r\n              module.i32(type.size - 1)\r\n            )\r\n          )\r\n        );\r\n        flow.freeTempLocal(temp2);\r\n        flow.freeTempLocal(temp1);\r\n\r\n        return ret;\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          compiler.options.isWasm64\r\n            ? BinaryOp.RotrI64\r\n            : BinaryOp.RotrI32,\r\n          arg0, arg1\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\r\n\r\n// abs<T?>(value: T) -> T\r\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32: {\r\n        let flow = compiler.currentFlow;\r\n\r\n        // possibly overflows, e.g. abs<i8>(-128) == 128\r\n        let temp1 = flow.getTempLocal(Type.i32);\r\n        let temp2 = flow.getTempLocal(Type.i32);\r\n        // (x + (x >> 31)) ^ (x >> 31)\r\n        let ret = module.binary(BinaryOp.XorI32,\r\n          module.binary(BinaryOp.AddI32,\r\n            module.local_tee(\r\n              temp2.index,\r\n              module.binary(BinaryOp.ShrI32,\r\n                module.local_tee(temp1.index, arg0, false), // i32\r\n                module.i32(31)\r\n              ),\r\n              false // i32\r\n            ),\r\n            module.local_get(temp1.index, TypeRef.I32)\r\n          ),\r\n          module.local_get(temp2.index, TypeRef.I32)\r\n        );\r\n        flow.freeTempLocal(temp2);\r\n        flow.freeTempLocal(temp1);\r\n        return ret;\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        let options = compiler.options;\r\n        let flow = compiler.currentFlow;\r\n        let isWasm64 = options.isWasm64;\r\n\r\n        let temp1 = flow.getTempLocal(options.usizeType);\r\n        let temp2 = flow.getTempLocal(options.usizeType);\r\n        let ret = module.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32,\r\n          module.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32,\r\n            module.local_tee(\r\n              temp2.index,\r\n              module.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32,\r\n                module.local_tee(temp1.index, arg0, false), // i32/i64\r\n                isWasm64 ? module.i64(63) : module.i32(31)\r\n              ),\r\n              false // i32/i64\r\n            ),\r\n            module.local_get(temp1.index, options.sizeTypeRef)\r\n          ),\r\n          module.local_get(temp2.index, options.sizeTypeRef)\r\n        );\r\n        flow.freeTempLocal(temp2);\r\n        flow.freeTempLocal(temp1);\r\n        return ret;\r\n      }\r\n      case TypeKind.I64: {\r\n        let flow = compiler.currentFlow;\r\n\r\n        let temp1 = flow.getTempLocal(Type.i64);\r\n        let temp2 = flow.getTempLocal(Type.i64);\r\n        // (x + (x >> 63)) ^ (x >> 63)\r\n        let ret = module.binary(BinaryOp.XorI64,\r\n          module.binary(BinaryOp.AddI64,\r\n            module.local_tee(\r\n              temp2.index,\r\n              module.binary(BinaryOp.ShrI64,\r\n                module.local_tee(temp1.index, arg0, false), // i64\r\n                module.i64(63)\r\n              ),\r\n              false // i64\r\n            ),\r\n            module.local_get(temp1.index, TypeRef.I64)\r\n          ),\r\n          module.local_get(temp2.index, TypeRef.I64)\r\n        );\r\n        flow.freeTempLocal(temp2);\r\n        flow.freeTempLocal(temp1);\r\n        return ret;\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.BOOL: return arg0;\r\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.abs, builtin_abs);\r\n\r\n// max<T?>(left: T, right: T) -> T\r\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var left = operands[0];\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1: ExpressionRef;\r\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\r\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\r\n      if (compiler.currentType != type) {\r\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\r\n      }\r\n    } else {\r\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\r\n    }\r\n    let op: BinaryOp = -1;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32: { op = BinaryOp.GtI32; break; }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: { op = BinaryOp.GtU32; break; }\r\n      case TypeKind.I64: { op = BinaryOp.GtI64; break; }\r\n      case TypeKind.U64: { op = BinaryOp.GtU64; break; }\r\n      case TypeKind.ISIZE: {\r\n        op = compiler.options.isWasm64\r\n          ? BinaryOp.GtI64\r\n          : BinaryOp.GtI32;\r\n        break;\r\n      }\r\n      case TypeKind.USIZE: {\r\n        op = compiler.options.isWasm64\r\n          ? BinaryOp.GtU64\r\n          : BinaryOp.GtU32;\r\n        break;\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\r\n    }\r\n    if (op as i32 != -1) {\r\n      let flow = compiler.currentFlow;\r\n      let typeRef = type.toRef();\r\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\r\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\r\n      let temp2 = flow.getTempLocal(type);\r\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\r\n      let ret = module.select(\r\n        module.local_tee(temp1.index, arg0, false), // numeric\r\n        module.local_tee(temp2.index, arg1, false), // numeric\r\n        module.binary(op,\r\n          module.local_get(temp1.index, typeRef),\r\n          module.local_get(temp2.index, typeRef)\r\n        )\r\n      );\r\n      flow.freeTempLocal(temp2);\r\n      flow.freeTempLocal(temp1);\r\n      return ret;\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.max, builtin_max);\r\n\r\n// min<T?>(left: T, right: T) -> T\r\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var left = operands[0];\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1: ExpressionRef;\r\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\r\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\r\n      if (compiler.currentType != type) {\r\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\r\n      }\r\n    } else {\r\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\r\n    }\r\n    let op: BinaryOp = -1;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32: { op = BinaryOp.LtI32; break; }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: { op = BinaryOp.LtU32; break; }\r\n      case TypeKind.I64:  { op = BinaryOp.LtI64; break; }\r\n      case TypeKind.U64:  { op = BinaryOp.LtU64; break; }\r\n      case TypeKind.ISIZE: {\r\n        op = compiler.options.isWasm64\r\n          ? BinaryOp.LtI64\r\n          : BinaryOp.LtI32;\r\n        break;\r\n      }\r\n      case TypeKind.USIZE: {\r\n        op = compiler.options.isWasm64\r\n          ? BinaryOp.LtU64\r\n          : BinaryOp.LtU32;\r\n        break;\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\r\n    }\r\n    if (op as i32 != -1) {\r\n      let flow = compiler.currentFlow;\r\n      let typeRef = type.toRef();\r\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\r\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\r\n      let temp2 = flow.getTempLocal(type);\r\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\r\n      let ret = module.select(\r\n        module.local_tee(temp1.index, arg0, false), // numeric\r\n        module.local_tee(temp2.index, arg1, false), // numeric\r\n        module.binary(op,\r\n          module.local_get(temp1.index, typeRef),\r\n          module.local_get(temp2.index, typeRef)\r\n        )\r\n      );\r\n      flow.freeTempLocal(temp2);\r\n      flow.freeTempLocal(temp1);\r\n      return ret;\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.min, builtin_min);\r\n\r\n// ceil<T?>(value: T) -> T\r\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE:\r\n      case TypeKind.BOOL: return arg0; // considered rounded\r\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\r\n\r\n// floor<T?>(value: T) -> T\r\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE:\r\n      case TypeKind.BOOL: return arg0; // considered rounded\r\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.floor, builtin_floor);\r\n\r\n// copysign<T?>(left: T, right: T) -> T\r\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\r\n    switch (type.kind) {\r\n      // TODO: does an integer version make sense?\r\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\r\n\r\n// nearest<T?>(value: T) -> T\r\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE:\r\n      case TypeKind.BOOL: return arg0;\r\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\r\n\r\n// reinterpret<T!>(value: *) -> T\r\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var type = typeArguments![0];\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.CONV_IMPLICIT);\r\n        compiler.currentType = type;\r\n        return module.unary(UnaryOp.ReinterpretF32ToI32, arg0);\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.CONV_IMPLICIT);\r\n        compiler.currentType = type;\r\n        return module.unary(UnaryOp.ReinterpretF64ToI64, arg0);\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        let arg0 = compiler.compileExpression(operands[0],\r\n          compiler.options.isWasm64\r\n            ? Type.f64\r\n            : Type.f32,\r\n          Constraints.CONV_IMPLICIT\r\n        );\r\n        compiler.currentType = type;\r\n        return module.unary(\r\n          compiler.options.isWasm64\r\n            ? UnaryOp.ReinterpretF64ToI64\r\n            : UnaryOp.ReinterpretF32ToI32,\r\n          arg0\r\n        );\r\n      }\r\n      case TypeKind.F32: {\r\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\r\n        compiler.currentType = Type.f32;\r\n        return module.unary(UnaryOp.ReinterpretI32ToF32, arg0);\r\n      }\r\n      case TypeKind.F64: {\r\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.CONV_IMPLICIT);\r\n        compiler.currentType = Type.f64;\r\n        return module.unary(UnaryOp.ReinterpretI64ToF64, arg0);\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\r\n\r\n// sqrt<T?>(value: T) -> T\r\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      // TODO: integer versions (that return f64 or convert)?\r\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\r\n\r\n// trunc<T?>(value: T) -> T\r\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE:\r\n      case TypeKind.BOOL: return arg0; // considered truncated\r\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\r\n\r\n// isNaN<T?>(value: T) -> bool\r\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.bool;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  compiler.currentType = Type.bool;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      // never NaN\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE: {\r\n        return module.maybeDropCondition(arg0, module.i32(0));\r\n      }\r\n      // (t = arg0) != t\r\n      case TypeKind.F32: {\r\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\r\n          return module.binary(BinaryOp.NeF32,\r\n            arg0,\r\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\r\n          );\r\n        }\r\n        let flow = compiler.currentFlow;\r\n        let temp = flow.getTempLocal(Type.f32);\r\n        let ret = module.binary(BinaryOp.NeF32,\r\n          module.local_tee(temp.index, arg0, false), // f32\r\n          module.local_get(temp.index, TypeRef.F32)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.F64: {\r\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\r\n          return module.binary(BinaryOp.NeF64,\r\n            arg0,\r\n            module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\r\n          );\r\n        }\r\n        let flow = compiler.currentFlow;\r\n        let temp = flow.getTempLocal(Type.f64);\r\n        let ret = module.binary(BinaryOp.NeF64,\r\n          module.local_tee(temp.index, arg0, false), // f64\r\n          module.local_get(temp.index, TypeRef.F64)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\r\n\r\n// isFinite<T?>(value: T) -> bool\r\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.bool;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  compiler.currentType = Type.bool;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      // always finite\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE: {\r\n        return module.maybeDropCondition(arg0, module.i32(1));\r\n      }\r\n      // (t = arg0) - t == 0\r\n      case TypeKind.F32: {\r\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\r\n          return module.binary(BinaryOp.EqF32,\r\n            module.binary(BinaryOp.SubF32,\r\n              arg0,\r\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F32)\r\n            ),\r\n            module.f32(0)\r\n          );\r\n        }\r\n        let flow = compiler.currentFlow;\r\n        let temp = flow.getTempLocal(Type.f32);\r\n        let ret = module.binary(BinaryOp.EqF32,\r\n          module.binary(BinaryOp.SubF32,\r\n            module.local_tee(temp.index, arg0, false), // f32\r\n            module.local_get(temp.index, TypeRef.F32)\r\n          ),\r\n          module.f32(0)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.F64: {\r\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\r\n          return module.binary(BinaryOp.EqF64,\r\n            module.binary(BinaryOp.SubF64,\r\n              arg0,\r\n              module.local_get(getLocalGetIndex(arg0), TypeRef.F64)\r\n            ),\r\n            module.f64(0)\r\n          );\r\n        }\r\n        let flow = compiler.currentFlow;\r\n        let temp = flow.getTempLocal(Type.f64);\r\n        let ret = module.binary(BinaryOp.EqF64,\r\n          module.binary(BinaryOp.SubF64,\r\n            module.local_tee(temp.index, arg0, false), // f64\r\n            module.local_get(temp.index, TypeRef.F64)\r\n          ),\r\n          module.f64(0)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\r\n\r\n// === Memory access ==========================================================================\r\n\r\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\r\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 1, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var contextualType = ctx.contextualType;\r\n  var type = typeArguments![0];\r\n  var outType = (\r\n    contextualType != Type.auto &&\r\n    type.isIntegerValue &&\r\n    contextualType.isIntegerValue &&\r\n    contextualType.size > type.size\r\n  ) ? contextualType : type;\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var numOperands = operands.length;\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 2) {\r\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = outType;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 3) {\r\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = outType;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = outType;\r\n  return module.load(\r\n    type.byteSize,\r\n    type.isSignedIntegerValue,\r\n    arg0,\r\n    outType.toRef(),\r\n    immOffset,\r\n    immAlign\r\n  );\r\n}\r\nbuiltins.set(BuiltinNames.load, builtin_load);\r\n\r\n// store<T!>(ptr: usize, value: T*, immOffset?: usize, immAlign?: usize) -> void\r\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.void;\r\n  if (\r\n    checkTypeRequired(ctx) |\r\n    checkArgsOptional(ctx, 2, 4)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var numOperands = operands.length;\r\n  var typeArguments = ctx.typeArguments;\r\n  var contextualType = ctx.contextualType;\r\n  var type = typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = ctx.contextIsExact\r\n    ? compiler.compileExpression(operands[1],\r\n        contextualType,\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        type.isIntegerValue\r\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\r\n          : Constraints.CONV_IMPLICIT\r\n      );\r\n  var inType = compiler.currentType;\r\n  if (\r\n    type.isIntegerValue &&\r\n    (\r\n      !inType.isIntegerValue || // float to int\r\n      inType.size < type.size   // int to larger int (clear garbage bits)\r\n    )\r\n  ) {\r\n    // either conversion or memory operation clears garbage bits\r\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\r\n    inType = type;\r\n  }\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 3) {\r\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = Type.void;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 4) {\r\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = Type.void;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = Type.void;\r\n  return module.store(type.byteSize, arg0, arg1, inType.toRef(), immOffset, immAlign);\r\n}\r\nbuiltins.set(BuiltinNames.store, builtin_store);\r\n\r\n// add<T?>(left: T, right: T) -> T\r\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var left = operands[0];\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(\r\n        left,\r\n        typeArguments[0],\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1: ExpressionRef;\r\n    if (!typeArguments && left.isNumericLiteral) {\r\n      // prefer right type\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type\r\n      );\r\n      if (compiler.currentType != type) {\r\n        arg0 = compiler.compileExpression(\r\n          left,\r\n          (type = compiler.currentType),\r\n          Constraints.CONV_IMPLICIT\r\n        );\r\n      }\r\n    } else {\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n    }\r\n    if (type.isNumericValue) {\r\n      return compiler.makeAdd(arg0, arg1, type);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange,\r\n    \"add\",\r\n    type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.add, builtin_add);\r\n\r\n// sub<T?>(left: T, right: T) -> T\r\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var left = operands[0];\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(\r\n        left,\r\n        typeArguments[0],\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1: ExpressionRef;\r\n    if (!typeArguments && left.isNumericLiteral) {\r\n      // prefer right type\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type\r\n      );\r\n      if (compiler.currentType != type) {\r\n        arg0 = compiler.compileExpression(\r\n          left,\r\n          (type = compiler.currentType),\r\n          Constraints.CONV_IMPLICIT\r\n        );\r\n      }\r\n    } else {\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n    }\r\n    if (type.isNumericValue) {\r\n      return compiler.makeSub(arg0, arg1, type);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange,\r\n    \"sub\",\r\n    type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.sub, builtin_sub);\r\n\r\n// mul<T?>(left: T, right: T) -> T\r\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var left = operands[0];\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(\r\n        left,\r\n        typeArguments[0],\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1: ExpressionRef;\r\n    if (!typeArguments && left.isNumericLiteral) {\r\n      // prefer right type\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type\r\n      );\r\n      if (compiler.currentType != type) {\r\n        arg0 = compiler.compileExpression(\r\n          left,\r\n          (type = compiler.currentType),\r\n          Constraints.CONV_IMPLICIT\r\n        );\r\n      }\r\n    } else {\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n    }\r\n    if (type.isNumericValue) {\r\n      return compiler.makeMul(arg0, arg1, type);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange,\r\n    \"mul\",\r\n    type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.mul, builtin_mul);\r\n\r\n// div<T?>(left: T, right: T) -> T\r\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var left = operands[0];\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(\r\n        left,\r\n        typeArguments[0],\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  if (type.isValue) {\r\n    let arg1: ExpressionRef;\r\n    if (!typeArguments && left.isNumericLiteral) {\r\n      // prefer right type\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type\r\n      );\r\n      if (compiler.currentType != type) {\r\n        arg0 = compiler.compileExpression(\r\n          left,\r\n          (type = compiler.currentType),\r\n          Constraints.CONV_IMPLICIT\r\n        );\r\n      }\r\n    } else {\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n    }\r\n    if (type.isNumericValue) {\r\n      return compiler.makeDiv(arg0, arg1, type);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange,\r\n    \"div\",\r\n    type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.div, builtin_div);\r\n\r\n// === Atomics ================================================================================\r\n\r\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\r\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 1, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var contextualType = ctx.contextualType;\r\n  var type = typeArguments![0];\r\n  var outType = (\r\n    type.isIntegerValue &&\r\n    contextualType.isIntegerValue &&\r\n    contextualType.size > type.size\r\n  ) ? contextualType : type;\r\n  if (!type.isIntegerValue) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\r\n    );\r\n    compiler.currentType = outType;\r\n    return module.unreachable();\r\n  }\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\r\n  if (immOffset < 0) {\r\n    compiler.currentType = outType;\r\n    return module.unreachable();\r\n  }\r\n  compiler.currentType = outType;\r\n  return module.atomic_load(\r\n    type.byteSize,\r\n    arg0,\r\n    outType.toRef(),\r\n    immOffset\r\n  );\r\n}\r\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\r\n\r\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\r\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsOptional(ctx, 2, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var contextualType = ctx.contextualType;\r\n  var type = typeArguments![0];\r\n  if (!type.isIntegerValue) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\r\n    );\r\n    compiler.currentType = Type.void;\r\n    return module.unreachable();\r\n  }\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = ctx.contextIsExact\r\n    ? compiler.compileExpression(\r\n        operands[1],\r\n        contextualType,\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        type.isIntegerValue\r\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\r\n          : Constraints.CONV_IMPLICIT\r\n      );\r\n  var inType = compiler.currentType;\r\n  if (\r\n    type.isIntegerValue &&\r\n    (\r\n      !inType.isIntegerValue|| // float to int\r\n      inType.size < type.size  // int to larger int (clear garbage bits)\r\n    )\r\n  ) {\r\n    // either conversion or memory operation clears garbage bits\r\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\r\n    inType = type;\r\n  }\r\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\r\n  if (immOffset < 0) {\r\n    compiler.currentType = Type.void;\r\n    return module.unreachable();\r\n  }\r\n  compiler.currentType = Type.void;\r\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toRef(), immOffset);\r\n}\r\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\r\n\r\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 2, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var contextualType = ctx.contextualType;\r\n  var type = typeArguments![0];\r\n  if (!type.isIntegerValue || type.size < 8) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  var arg0 = compiler.compileExpression(operands[0],\r\n    compiler.options.usizeType,\r\n    Constraints.CONV_IMPLICIT\r\n  );\r\n  var arg1 = ctx.contextIsExact\r\n    ? compiler.compileExpression(operands[1],\r\n        contextualType,\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        type.isIntegerValue\r\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\r\n          : Constraints.CONV_IMPLICIT\r\n      );\r\n  var inType = compiler.currentType;\r\n  if (\r\n    type.isIntegerValue &&\r\n    (\r\n      !inType.isIntegerValue || // float to int\r\n      inType.size < type.size   // int to larger int (clear garbage bits)\r\n    )\r\n  ) {\r\n    // either conversion or memory operation clears garbage bits\r\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\r\n    inType = type;\r\n  }\r\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\r\n  if (immOffset < 0) {\r\n    compiler.currentType = inType;\r\n    return module.unreachable();\r\n  }\r\n  compiler.currentType = inType;\r\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toRef());\r\n}\r\n\r\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\r\n}\r\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\r\n\r\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\r\n}\r\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\r\n\r\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\r\n}\r\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\r\n\r\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\r\n}\r\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\r\n\r\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\r\n}\r\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\r\n\r\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\r\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\r\n}\r\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\r\n\r\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\r\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 3, 4)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var contextualType = ctx.contextualType;\r\n  var type = typeArguments![0];\r\n  if (!type.isIntegerValue || type.size < 8) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  var arg0 = compiler.compileExpression(operands[0],\r\n    compiler.options.usizeType,\r\n    Constraints.CONV_IMPLICIT\r\n  );\r\n  var arg1 = ctx.contextIsExact\r\n    ? compiler.compileExpression(operands[1],\r\n        contextualType,\r\n        Constraints.CONV_IMPLICIT\r\n      )\r\n    : compiler.compileExpression(\r\n        operands[1],\r\n        type,\r\n        type.isIntegerValue\r\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\r\n          : Constraints.CONV_IMPLICIT\r\n      );\r\n  var inType = compiler.currentType;\r\n  var arg2 = compiler.compileExpression(operands[2],\r\n    inType,\r\n    Constraints.CONV_IMPLICIT\r\n  );\r\n  if (\r\n    type.isIntegerValue &&\r\n    (\r\n      !inType.isIntegerValue || // float to int\r\n      inType.size < type.size   // int to larger int (clear garbage bits)\r\n    )\r\n  ) {\r\n    // either conversion or memory operation clears garbage bits\r\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\r\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\r\n    inType = type;\r\n  }\r\n  var immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\r\n  if (immOffset < 0) {\r\n    compiler.currentType = inType;\r\n    return module.unreachable();\r\n  }\r\n  compiler.currentType = inType;\r\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toRef());\r\n}\r\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\r\n\r\n// atomic.wait<T!>(ptr: usize, expected: T, timeout: i64) -> i32\r\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 3)\r\n  ) {\r\n    compiler.currentType = Type.i32;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var type = typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], Type.i64, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.i32;\r\n  switch (type.kind) {\r\n    case TypeKind.I32:\r\n    case TypeKind.I64:\r\n    case TypeKind.ISIZE:\r\n    case TypeKind.U32:\r\n    case TypeKind.U64:\r\n    case TypeKind.USIZE: return module.atomic_wait(arg0, arg1, arg2, type.toRef());\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\r\n\r\n// atomic.notify(ptr: usize, count: i32) -> i32\r\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.i32;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.i32;\r\n  return module.atomic_notify(arg0, arg1);\r\n}\r\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\r\n\r\n// atomic.fence() -> void\r\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.void;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.THREADS) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 0)\r\n  ) return module.unreachable();\r\n  return module.atomic_fence();\r\n}\r\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\r\n\r\n// === Control flow ===========================================================================\r\n\r\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\r\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsRequired(ctx, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\r\n    : compiler.compileExpression(operands[0], Type.auto);\r\n  var type = compiler.currentType;\r\n  if (!type.isAny(TypeFlags.VALUE | TypeFlags.REFERENCE)) {\r\n    compiler.error(\r\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.makeIsTrueish(\r\n    compiler.compileExpression(operands[2], Type.bool),\r\n    compiler.currentType, // ^\r\n    operands[2]\r\n  );\r\n  compiler.currentType = type;\r\n  return module.select(arg0, arg1, arg2);\r\n}\r\nbuiltins.set(BuiltinNames.select, builtin_select);\r\n\r\n// unreachable() -> *\r\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  checkArgsRequired(ctx, 0);\r\n  return ctx.compiler.module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\r\n\r\n// === Memory =================================================================================\r\n\r\n// memory.size() -> i32\r\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.i32;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 0)\r\n  ) return module.unreachable();\r\n  return module.memory_size();\r\n}\r\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\r\n\r\n// memory.grow(pages: i32) -> i32\r\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.i32;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.CONV_IMPLICIT));\r\n}\r\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\r\n\r\n// memory.copy(dest: usize, src: usize: n: usize) -> void\r\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.void;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\r\n    // use stdlib alternative if not supported\r\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\r\n    compiler.currentType = Type.void;\r\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\r\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\r\n  }\r\n  var usizeType = compiler.options.usizeType;\r\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.void;\r\n  return module.memory_copy(arg0, arg1, arg2);\r\n}\r\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\r\n\r\n// memory.fill(dest: usize, value: u8, n: usize) -> void\r\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.void;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\r\n    // use stdlib alternative if not supported\r\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\r\n    compiler.currentType = Type.void;\r\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\r\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\r\n  }\r\n  var usizeType = compiler.options.usizeType;\r\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.void;\r\n  return module.memory_fill(arg0, arg1, arg2);\r\n}\r\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\r\n\r\n// memory.data(size[, align]) -> usize\r\n// memory.data<T>(values[, align]) -> usize\r\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = Type.i32;\r\n  if (\r\n    checkTypeOptional(ctx) |\r\n    checkArgsOptional(ctx, 1, 2)\r\n  ) return module.unreachable();\r\n  var typeArguments = ctx.typeArguments;\r\n  var operands = ctx.operands;\r\n  var numOperands = operands.length;\r\n  var usizeType = compiler.options.usizeType;\r\n  var offset: i64;\r\n  if (typeArguments !== null && typeArguments.length > 0) { // data<T>(values[, align])\r\n    let elementType = typeArguments[0];\r\n    if (!elementType.isValue) {\r\n      compiler.error(\r\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\r\n      );\r\n      compiler.currentType = usizeType;\r\n      return module.unreachable();\r\n    }\r\n    let valuesOperand = operands[0];\r\n    if (valuesOperand.kind != NodeKind.LITERAL || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.ARRAY) {\r\n      compiler.error(\r\n        DiagnosticCode.Array_literal_expected,\r\n        operands[0].range\r\n      );\r\n      compiler.currentType = usizeType;\r\n      return module.unreachable();\r\n    }\r\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\r\n    let numElements = expressions.length;\r\n    let exprs = new Array<ExpressionRef>(numElements);\r\n    let isStatic = true;\r\n    for (let i = 0; i < numElements; ++i) {\r\n      let elementExpression = expressions[i];\r\n      if (elementExpression.kind != NodeKind.OMITTED) {\r\n        let expr = compiler.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);\r\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n        if (precomp) {\r\n          expr = precomp;\r\n        } else {\r\n          isStatic = false;\r\n        }\r\n        exprs[i] = expr;\r\n      } else {\r\n        exprs[i] = compiler.makeZero(elementType, elementExpression);\r\n      }\r\n    }\r\n    if (!isStatic) {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        valuesOperand.range\r\n      );\r\n      compiler.currentType = usizeType;\r\n      return module.unreachable();\r\n    }\r\n    let align = elementType.byteSize;\r\n    if (numOperands == 2) {\r\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\r\n      if (align < 0) {\r\n        compiler.currentType = usizeType;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    let buf = new Uint8Array(numElements * elementType.byteSize);\r\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\r\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\r\n  } else { // data(size[, align])\r\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (!precomp) {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[0].range\r\n      );\r\n      compiler.currentType = usizeType;\r\n      return module.unreachable();\r\n    }\r\n    let size = getConstValueI32(precomp);\r\n    if (size < 1) {\r\n      compiler.error(\r\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\r\n      );\r\n      compiler.currentType = usizeType;\r\n      return module.unreachable();\r\n    }\r\n    let align = 16;\r\n    if (numOperands == 2) {\r\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\r\n      if (align < 0) {\r\n        compiler.currentType = usizeType;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\r\n  }\r\n  // FIXME: what if recompiles happen? recompiles are bad.\r\n  compiler.currentType = usizeType;\r\n  if (usizeType == Type.usize32) {\r\n    assert(!i64_high(offset));\r\n    return module.i32(i64_low(offset));\r\n  } else {\r\n    return module.i64(i64_low(offset), i64_high(offset));\r\n  }\r\n}\r\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\r\n\r\n// === GC =====================================================================================\r\n\r\nfunction builtin_i31_new(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.i31ref;\r\n  return module.i31_new(arg0);\r\n}\r\nbuiltins.set(BuiltinNames.i31_new, builtin_i31_new);\r\n\r\nfunction builtin_i31_get(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.i31ref, Constraints.CONV_IMPLICIT);\r\n  if (ctx.contextualType.is(TypeFlags.UNSIGNED)) {\r\n    compiler.currentType = Type.u32;\r\n    return module.i31_get(arg0, false);\r\n  } else {\r\n    compiler.currentType = Type.i32;\r\n    return module.i31_get(arg0, true);\r\n  }\r\n}\r\nbuiltins.set(BuiltinNames.i31_get, builtin_i31_get);\r\n\r\n// === Helpers ================================================================================\r\n\r\n// changetype<T!>(value: *) -> T\r\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var toType = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.auto);\r\n  var fromType = compiler.currentType;\r\n  compiler.currentType = toType;\r\n  if (!fromType.isChangeableTo(toType)) {\r\n    compiler.error(\r\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\r\n      ctx.reportNode.range, fromType.toString(), toType.toString()\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  return arg0;\r\n}\r\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\r\n\r\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\r\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  var typeArguments = ctx.typeArguments;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsOptional(ctx, 1, 2)\r\n  ) {\r\n    if (typeArguments) {\r\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\r\n      compiler.currentType = typeArguments[0].nonNullableType;\r\n    }\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var contextualType = ctx.contextualType;\r\n  var arg0 = typeArguments\r\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\r\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MUST_WRAP);\r\n  var type = compiler.currentType;\r\n  compiler.currentType = type.nonNullableType;\r\n\r\n  // omit if assertions are disabled\r\n  if (compiler.options.noAssert) {\r\n    return arg0;\r\n  }\r\n\r\n  // omit if the assertion can be proven statically\r\n  var evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\r\n  if (evaled) {\r\n    switch (<u32>getExpressionType(evaled)) {\r\n      case <u32>TypeRef.I32: {\r\n        if (getConstValueI32(evaled)) {\r\n          return arg0;\r\n        }\r\n        break;\r\n      }\r\n      case <u32>TypeRef.I64: {\r\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\r\n          return arg0;\r\n        }\r\n        break;\r\n      }\r\n      case <u32>TypeRef.F32: {\r\n        if (getConstValueF32(evaled)) {\r\n          return arg0;\r\n        }\r\n        break;\r\n      }\r\n      case <u32>TypeRef.F64: {\r\n        if (getConstValueF64(evaled)) {\r\n          return arg0;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // otherwise call abort if the assertion is false-ish\r\n  var abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\r\n  compiler.currentType = type.nonNullableType;\r\n  if (contextualType == Type.void) { // simplify if dropped anyway\r\n    compiler.currentType = Type.void;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.if(\r\n          module.unary(\r\n            compiler.options.isWasm64\r\n              ? UnaryOp.EqzI64\r\n              : UnaryOp.EqzI32,\r\n            arg0\r\n          ),\r\n          abort\r\n        );\r\n      }\r\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\r\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\r\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n      case TypeKind.ANYREF:\r\n      case TypeKind.EQREF:\r\n      case TypeKind.DATAREF:\r\n      case TypeKind.I31REF: return module.if(module.ref_is(RefIsOp.RefIsNull, arg0), abort);\r\n\r\n    }\r\n  } else {\r\n    compiler.currentType = type.nonNullableType;\r\n    let flow = compiler.currentFlow;\r\n    switch (compiler.currentType.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: {\r\n        let temp = flow.getTempLocal(type);\r\n        flow.setLocalFlag(temp.index, LocalFlags.WRAPPED); // arg0 is wrapped\r\n        let ret = module.if(\r\n          module.local_tee(temp.index, arg0, false), // numeric\r\n          module.local_get(temp.index, TypeRef.I32),\r\n          abort\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        let temp = flow.getTempLocal(Type.i64);\r\n        let ret = module.if(\r\n          module.unary(UnaryOp.EqzI64,\r\n            module.local_tee(temp.index, arg0, false) // i64\r\n          ),\r\n          abort,\r\n          module.local_get(temp.index, TypeRef.I64)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        let temp = flow.getTempLocal(compiler.options.usizeType);\r\n        let ret = module.if(\r\n          module.unary(\r\n            compiler.options.isWasm64\r\n              ? UnaryOp.EqzI64\r\n              : UnaryOp.EqzI32,\r\n            module.local_tee(temp.index, arg0, type.isManaged)\r\n          ),\r\n          abort,\r\n          module.local_get(temp.index, compiler.options.sizeTypeRef)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.F32: {\r\n        let temp = flow.getTempLocal(Type.f32);\r\n        let ret = module.if(\r\n          module.binary(BinaryOp.EqF32,\r\n            module.local_tee(temp.index, arg0, false), // f32\r\n            module.f32(0)\r\n          ),\r\n          abort,\r\n          module.local_get(temp.index, TypeRef.F32)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.F64: {\r\n        let temp = flow.getTempLocal(Type.f64);\r\n        let ret = module.if(\r\n          module.binary(BinaryOp.EqF64,\r\n            module.local_tee(temp.index, arg0, false), // f64\r\n            module.f64(0)\r\n          ),\r\n          abort,\r\n          module.local_get(temp.index, TypeRef.F64)\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n      case TypeKind.ANYREF:\r\n      case TypeKind.EQREF:\r\n      case TypeKind.DATAREF:\r\n      case TypeKind.I31REF: {\r\n        let temp = flow.getTempLocal(type);\r\n        let ret = module.if(\r\n          module.ref_is(RefIsOp.RefIsNull,\r\n            module.local_tee(temp.index, arg0, false) // ref\r\n          ),\r\n          abort,\r\n          module.local_get(temp.index, type.toRef())\r\n        );\r\n        flow.freeTempLocal(temp);\r\n        return ret;\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange,\r\n    \"assert\", compiler.currentType.toString()\r\n  );\r\n  return abort;\r\n}\r\nbuiltins.set(BuiltinNames.assert, builtin_assert);\r\n\r\n// unchecked(expr: *) -> *\r\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) return module.unreachable();\r\n  var flow = compiler.currentFlow;\r\n  var alreadyUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\r\n  flow.set(FlowFlags.UNCHECKED_CONTEXT);\r\n  // eliminate unnecessary tees by preferring contextualType(=void)\r\n  var expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\r\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UNCHECKED_CONTEXT);\r\n  return expr;\r\n}\r\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\r\n\r\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\r\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeOptional(ctx, true) |\r\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var returnType: Type;\r\n  if (typeArguments) {\r\n    assert(typeArguments.length);\r\n    returnType = typeArguments[0];\r\n  } else {\r\n    returnType = ctx.contextualType;\r\n  }\r\n  var indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\r\n  var numOperands = operands.length - 1;\r\n  var operandExprs = new Array<ExpressionRef>(numOperands);\r\n  var paramTypeRefs = new Array<TypeRef>(numOperands);\r\n  for (let i = 0; i < numOperands; ++i) {\r\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\r\n    paramTypeRefs[i] = compiler.currentType.toRef();\r\n  }\r\n  compiler.currentType = returnType;\r\n  return module.call_indirect(indexArg, operandExprs, createType(paramTypeRefs), returnType.toRef());\r\n}\r\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\r\n\r\n// instantiate<T!>(...args: *[]) -> T\r\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeRequired(ctx, true)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var typeArgument = typeArguments[0];\r\n  var classInstance = typeArgument.getClass();\r\n  if (!classInstance) {\r\n    compiler.error(\r\n      DiagnosticCode.This_expression_is_not_constructable,\r\n      ctx.reportNode.expression.range\r\n    );\r\n    return module.unreachable();\r\n  }\r\n  compiler.currentType = classInstance.type;\r\n  var ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\r\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\r\n  return compiler.compileInstantiate(ctor, operands, Constraints.NONE, ctx.reportNode);\r\n}\r\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\r\n\r\n// === User-defined diagnostics ===============================================================\r\n\r\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  checkTypeAbsent(ctx);\r\n  var operands = ctx.operands;\r\n  var reportNode = ctx.reportNode;\r\n  compiler.emitDiagnostic(\r\n    DiagnosticCode.User_defined_0,\r\n    category,\r\n    reportNode.range,\r\n    null,\r\n    operands.length\r\n      ? operands[0].range.toString()\r\n      : reportNode.range.toString()\r\n  );\r\n  return category == DiagnosticCategory.ERROR\r\n    ? module.unreachable()\r\n    : module.nop();\r\n}\r\n\r\n// ERROR(message?)\r\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_diagnostic(ctx, DiagnosticCategory.ERROR);\r\n}\r\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\r\n\r\n// WARNING(message?)\r\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_diagnostic(ctx, DiagnosticCategory.WARNING);\r\n}\r\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\r\n\r\n// INFO(message?)\r\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_diagnostic(ctx, DiagnosticCategory.INFO);\r\n}\r\nbuiltins.set(BuiltinNames.INFO, builtin_info);\r\n\r\n// === Function builtins ======================================================================\r\n\r\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\r\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var parent = ctx.prototype.parent;\r\n  assert(parent.kind == ElementKind.CLASS);\r\n  var classInstance = <Class>parent;\r\n  assert(classInstance.prototype == compiler.program.functionPrototype);\r\n  var typeArguments = assert(classInstance.typeArguments);\r\n  assert(typeArguments.length == 1);\r\n  var ftype = typeArguments[0];\r\n  var signature = assert(ftype.getSignature());\r\n  var returnType = signature.returnType;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\r\n  ) {\r\n    compiler.currentType = returnType;\r\n    return compiler.module.unreachable();\r\n  }\r\n  var functionArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.CONV_IMPLICIT);\r\n  var thisOperand = assert(ctx.operands.shift());\r\n  var thisType = signature.thisType;\r\n  var thisArg: usize = 0;\r\n  if (thisType) {\r\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.CONV_IMPLICIT);\r\n  } else if (thisOperand.kind != NodeKind.NULL) {\r\n    compiler.error(\r\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\r\n      thisOperand.range\r\n    );\r\n    return compiler.module.unreachable();\r\n  }\r\n  return compiler.compileCallIndirect(signature, functionArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\r\n}\r\nfunction_builtins.set(\"call\", builtin_function_call);\r\n\r\n// String.raw(parts: TemplateStringsArray, ...values: unknown[]): string\r\nfunction builtin_string_raw(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  compiler.currentType = ctx.compiler.program.stringInstance.type;\r\n  compiler.error(\r\n    DiagnosticCode.Not_implemented_0,\r\n    ctx.reportNode.range, \"String.raw\"\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.String_raw, builtin_string_raw);\r\n\r\n// === Portable type conversions ==============================================================\r\n\r\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = toType;\r\n    return compiler.module.unreachable();\r\n  }\r\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.CONV_EXPLICIT);\r\n}\r\n\r\n// i8(*) -> i8\r\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.i8);\r\n}\r\nbuiltins.set(BuiltinNames.i8, builtin_i8);\r\n\r\n// i16(*) -> i16\r\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.i16);\r\n}\r\nbuiltins.set(BuiltinNames.i16, builtin_i16);\r\n\r\n// i32(*) -> i32\r\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.i32);\r\n}\r\nbuiltins.set(BuiltinNames.i32, builtin_i32);\r\n\r\n// i64(*) -> i64\r\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.i64);\r\n}\r\nbuiltins.set(BuiltinNames.i64, builtin_i64);\r\n\r\n// isize(*) -> isize\r\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\r\n}\r\nbuiltins.set(BuiltinNames.isize, builtin_isize);\r\n\r\n// u8(*) -> u8\r\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.u8);\r\n}\r\nbuiltins.set(BuiltinNames.u8, builtin_u8);\r\n\r\n// u16(*) -> u16\r\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.u16);\r\n}\r\nbuiltins.set(BuiltinNames.u16, builtin_u16);\r\n\r\n// u32(*) -> u32\r\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.u32);\r\n}\r\nbuiltins.set(BuiltinNames.u32, builtin_u32);\r\n\r\n// u64(*) -> u64\r\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.u64);\r\n}\r\nbuiltins.set(BuiltinNames.u64, builtin_u64);\r\n\r\n// usize(*) -> usize\r\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\r\n}\r\nbuiltins.set(BuiltinNames.usize, builtin_usize);\r\n\r\n// bool(*) -> bool\r\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.bool);\r\n}\r\nbuiltins.set(BuiltinNames.bool, builtin_bool);\r\n\r\n// f32(*) -> f32\r\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.f32);\r\n}\r\nbuiltins.set(BuiltinNames.f32, builtin_f32);\r\n\r\n// f64(*) -> f64\r\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_conversion(ctx, Type.f64);\r\n}\r\nbuiltins.set(BuiltinNames.f64, builtin_f64);\r\n\r\n// TODO: alias for now, splat input integer perhaps?\r\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_i8x16(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128, builtin_v128);\r\n\r\n// === SIMD ===================================================================================\r\n\r\n// i8x16(...values: i8[16]) -> v128\r\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 16)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var bytes = new Uint8Array(16);\r\n  for (let i = 0; i < 16; ++i) {\r\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      writeI8(getConstValueI32(precomp), bytes, i);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[i].range\r\n      );\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  return module.v128(bytes);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\r\n\r\n// i16x8(...values: i16[8]) -> v128\r\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 8)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var bytes = new Uint8Array(16);\r\n  for (let i = 0; i < 8; ++i) {\r\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[i].range\r\n      );\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  return module.v128(bytes);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\r\n\r\n// i32x4(...values: i32[4]) -> v128\r\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 4)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var bytes = new Uint8Array(16);\r\n  for (let i = 0; i < 4; ++i) {\r\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[i].range\r\n      );\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  return module.v128(bytes);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\r\n\r\n// i64x2(...values: i64[2]) -> v128\r\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var bytes = new Uint8Array(16);\r\n  for (let i = 0; i < 2; ++i) {\r\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      let off = i << 3;\r\n      writeI32(getConstValueI64Low(precomp), bytes, off);\r\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[i].range\r\n      );\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  return module.v128(bytes);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\r\n\r\n// f32x4(...values: f32[4]) -> v128\r\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 4)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var bytes = new Uint8Array(16);\r\n  for (let i = 0; i < 4; ++i) {\r\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[i].range\r\n      );\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  return module.v128(bytes);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\r\n\r\n// f64x2(...values: f64[2]) -> v128\r\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var bytes = new Uint8Array(16);\r\n  for (let i = 0; i < 2; ++i) {\r\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        operands[i].range\r\n      );\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  return module.v128(bytes);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\r\n\r\n// v128.splat<T!>(x: T) -> v128\r\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], type, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.unary(\r\n          compiler.options.isWasm64\r\n            ? UnaryOp.SplatI64x2\r\n            : UnaryOp.SplatI32x4,\r\n          arg0\r\n        );\r\n      }\r\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\r\n\r\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\r\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = type;\r\n  var idx = 0;\r\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\r\n  if (precomp) {\r\n    idx = getConstValueI32(precomp);\r\n  } else {\r\n    compiler.error(\r\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n      operands[1].range\r\n    );\r\n  }\r\n  if (type.isValue) {\r\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\r\n    if (idx < 0 || idx > maxIdx) {\r\n      compiler.error(\r\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\r\n      );\r\n      idx = 0;\r\n    }\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\r\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\r\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\r\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.simd_extract(\r\n          compiler.options.isWasm64\r\n            ? SIMDExtractOp.ExtractLaneI64x2\r\n            : SIMDExtractOp.ExtractLaneI32x4,\r\n          arg0, <u8>idx\r\n        );\r\n      }\r\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\r\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\r\n\r\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\r\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 3)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], type, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  var idx = 0;\r\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\r\n  if (precomp) {\r\n    idx = getConstValueI32(precomp);\r\n  } else {\r\n    compiler.error(\r\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n      operands[1].range\r\n    );\r\n  }\r\n  if (type.isValue) {\r\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\r\n    if (idx < 0 || idx > maxIdx) {\r\n      compiler.error(\r\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\r\n      );\r\n      idx = 0;\r\n    }\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.simd_replace(\r\n          compiler.options.isWasm64\r\n            ? SIMDReplaceOp.ReplaceLaneI64x2\r\n            : SIMDReplaceOp.ReplaceLaneI32x4,\r\n          arg0, <u8>idx, arg2\r\n        );\r\n      }\r\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\r\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\r\n\r\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\r\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  if (type.isValue) {\r\n    let laneWidth = type.byteSize;\r\n    let laneCount = 16 / laneWidth;\r\n    assert(isInteger(laneCount) && isPowerOf2(laneCount));\r\n    if (\r\n      checkArgsRequired(ctx, 2 + laneCount)\r\n    ) {\r\n      compiler.currentType = Type.v128;\r\n      return module.unreachable();\r\n    }\r\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.I64:\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE:\r\n      case TypeKind.F32:\r\n      case TypeKind.F64: {\r\n        let mask = new Uint8Array(16);\r\n        let maxIdx = (laneCount << 1) - 1;\r\n        for (let i = 0; i < laneCount; ++i) {\r\n          let operand = operands[2 + i];\r\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.CONV_IMPLICIT);\r\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\r\n          let idx = 0;\r\n          if (precomp) {\r\n            idx = getConstValueI32(precomp);\r\n            if (idx < 0 || idx > maxIdx) {\r\n              compiler.error(\r\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\r\n              );\r\n              idx = 0;\r\n            }\r\n          } else {\r\n            compiler.error(\r\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n              operand.range\r\n            );\r\n          }\r\n          switch (laneWidth) {\r\n            case 1: {\r\n              writeI8(idx, mask, i);\r\n              break;\r\n            }\r\n            case 2: {\r\n              let off8 = i << 1;\r\n              let idx8 = idx << 1;\r\n              writeI8(idx8    , mask, off8);\r\n              writeI8(idx8 + 1, mask, off8 + 1);\r\n              break;\r\n            }\r\n            case 4: {\r\n              let off8 = i << 2;\r\n              let idx8 = idx << 2;\r\n              writeI8(idx8    , mask, off8);\r\n              writeI8(idx8 + 1, mask, off8 + 1);\r\n              writeI8(idx8 + 2, mask, off8 + 2);\r\n              writeI8(idx8 + 3, mask, off8 + 3);\r\n              break;\r\n            }\r\n            case 8: {\r\n              let off8 = i << 3;\r\n              let idx8 = idx << 3;\r\n              writeI8(idx8    , mask, off8);\r\n              writeI8(idx8 + 1, mask, off8 + 1);\r\n              writeI8(idx8 + 2, mask, off8 + 2);\r\n              writeI8(idx8 + 3, mask, off8 + 3);\r\n              writeI8(idx8 + 4, mask, off8 + 4);\r\n              writeI8(idx8 + 5, mask, off8 + 5);\r\n              writeI8(idx8 + 6, mask, off8 + 6);\r\n              writeI8(idx8 + 7, mask, off8 + 7);\r\n              break;\r\n            }\r\n            default: assert(false);\r\n          }\r\n        }\r\n        compiler.currentType = Type.v128;\r\n        return module.simd_shuffle(arg0, arg1, mask);\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\r\n  );\r\n  compiler.currentType = Type.v128;\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\r\n\r\n// v128.swizzle(a: v128, b: v128) -> v128\r\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  return module.binary(BinaryOp.SwizzleI8x16, arg0, arg1);\r\n}\r\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\r\n\r\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\r\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 1, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var numOperands = operands.length;\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 2) {\r\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = Type.v128;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 3) {\r\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = Type.v128;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: {\r\n        return module.simd_load(SIMDLoadOp.Load8Splat, arg0, immOffset, immAlign);\r\n      }\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: {\r\n        return module.simd_load(SIMDLoadOp.Load16Splat, arg0, immOffset, immAlign);\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32:\r\n      case TypeKind.F32: {\r\n        return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        if (!compiler.options.isWasm64) {\r\n          return module.simd_load(SIMDLoadOp.Load32Splat, arg0, immOffset, immAlign);\r\n        }\r\n        // fall-through\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n      case TypeKind.F64: {\r\n        return module.simd_load(SIMDLoadOp.Load64Splat, arg0, immOffset, immAlign);\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\r\n\r\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\r\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 1, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var numOperands = operands.length;\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 2) {\r\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = Type.v128;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 3) {\r\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = Type.v128;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.Load8x8S, arg0, immOffset, immAlign);\r\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.Load8x8U, arg0, immOffset, immAlign);\r\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.Load16x4S, arg0, immOffset, immAlign);\r\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.Load16x4U, arg0, immOffset, immAlign);\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.Load32x2S, arg0, immOffset, immAlign);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.Load32x2U, arg0, immOffset, immAlign);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\r\n\r\n// v128.load_zero<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\r\nfunction builtin_v128_load_zero(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 1, 3)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var numOperands = operands.length;\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 2) {\r\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = Type.v128;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 3) {\r\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = Type.v128;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I32:\r\n      case TypeKind.U32:\r\n      case TypeKind.F32: return module.simd_load(SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n      case TypeKind.F64: return module.simd_load(SIMDLoadOp.Load64Zero, arg0, immOffset, immAlign);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.simd_load(compiler.options.isWasm64 ? SIMDLoadOp.Load64Zero : SIMDLoadOp.Load32Zero, arg0, immOffset, immAlign);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.load_zero\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_load_zero, builtin_v128_load_zero);\r\n\r\n// v128.load_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\r\nfunction builtin_v128_load_lane(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 3, 5)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);\r\n  var idx = 0;\r\n  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\r\n  if (precomp) {\r\n    idx = getConstValueI32(precomp);\r\n  } else {\r\n    compiler.error(\r\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n      operands[2].range\r\n    );\r\n  }\r\n  var numOperands = operands.length;\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 4) {\r\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = Type.v128;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 5) {\r\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = Type.v128;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\r\n    if (idx < 0 || idx > maxIdx) {\r\n      compiler.error(\r\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\r\n      );\r\n      idx = 0;\r\n    }\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32:\r\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Load64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Load64Lane : SIMDLoadStoreLaneOp.Load32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.load_lane\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_load_lane, builtin_v128_load_lane);\r\n\r\n// v128.store_lane<TFrom!>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize) -> v128\r\nfunction builtin_v128_store_lane(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx, true) |\r\n    checkArgsOptional(ctx, 3, 5)\r\n  ) return module.unreachable();\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], Type.u8, Constraints.CONV_IMPLICIT);\r\n  var idx = 0;\r\n  var precomp = module.runExpression(arg2, ExpressionRunnerFlags.PreserveSideeffects);\r\n  if (precomp) {\r\n    idx = getConstValueI32(precomp);\r\n  } else {\r\n    compiler.error(\r\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n      operands[2].range\r\n    );\r\n  }\r\n  var numOperands = operands.length;\r\n  var immOffset = 0;\r\n  var immAlign = type.byteSize;\r\n  if (numOperands >= 4) {\r\n    immOffset = evaluateImmediateOffset(operands[3], compiler); // reports\r\n    if (immOffset < 0) {\r\n      compiler.currentType = Type.v128;\r\n      return module.unreachable();\r\n    }\r\n    if (numOperands == 5) {\r\n      immAlign = evaluateImmediateAlign(operands[4], immAlign, compiler); // reports\r\n      if (immAlign < 0) {\r\n        compiler.currentType = Type.v128;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n  }\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\r\n    if (idx < 0 || idx > maxIdx) {\r\n      compiler.error(\r\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\r\n      );\r\n      idx = 0;\r\n    }\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store8Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store16Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32:\r\n      case TypeKind.F32: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n      case TypeKind.F64: return module.simd_loadstorelane(SIMDLoadStoreLaneOp.Store64Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.simd_loadstorelane(compiler.options.isWasm64 ? SIMDLoadStoreLaneOp.Store64Lane : SIMDLoadStoreLaneOp.Store32Lane, arg0, immOffset, immAlign, <u8>idx, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.store_lane\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_store_lane, builtin_v128_store_lane);\r\n\r\n// v128.add<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          compiler.options.isWasm64\r\n            ? BinaryOp.AddI64x2\r\n            : BinaryOp.AddI32x4,\r\n          arg0, arg1\r\n        );\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\r\n\r\n// v128.sub<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          compiler.options.isWasm64\r\n            ? BinaryOp.SubI64x2\r\n            : BinaryOp.SubI32x4,\r\n          arg0, arg1\r\n        );\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\r\n\r\n// v128.mul<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.MulI64x2, arg0, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.MulI64x2 : BinaryOp.MulI32x4, arg0, arg1);\r\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\r\n\r\n// v128.div<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\r\n\r\n// v128.add_sat<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_add_sat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.add_sat\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_add_sat, builtin_v128_add_sat);\r\n\r\n// v128.sub_sat<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_sub_sat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_sat\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_sub_sat, builtin_v128_sub_sat);\r\n\r\n// v128.min<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\r\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\r\n\r\n// v128.max<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\r\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\r\n\r\n// v128.pmin<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\r\n\r\n// v128.pmax<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\r\n\r\n// v128.dot<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\r\n\r\n// v128.avgr<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\r\n\r\n// v128.eq<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.EqI64x2, arg0, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.EqI64x2 : BinaryOp.EqI32x4, arg0, arg1);\r\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\r\n\r\n// v128.ne<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.binary(BinaryOp.NeI64x2, arg0, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.NeI64x2 : BinaryOp.NeI32x4, arg0, arg1);\r\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\r\n\r\n// v128.lt<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\r\n      case TypeKind.I64: return module.binary(BinaryOp.LtI64x2, arg0, arg1);\r\n      // no LtU64x2\r\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LtI64x2 : BinaryOp.LtI32x4, arg0, arg1);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        return module.binary(BinaryOp.LtU32x4, arg0, arg1);\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\r\n\r\n// v128.le<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\r\n      case TypeKind.I64: return module.binary(BinaryOp.LeI64x2, arg0, arg1);\r\n      // no LeU64x2\r\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.LeI64x2 : BinaryOp.LeI32x4, arg0, arg1);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        return module.binary(BinaryOp.LeU32x4, arg0, arg1);\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\r\n\r\n// v128.gt<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\r\n      case TypeKind.I64: return module.binary(BinaryOp.GtI64x2, arg0, arg1);\r\n      // no GtU64x2\r\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GtI64x2 : BinaryOp.GtI32x4, arg0, arg1);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        return module.binary(BinaryOp.GtU32x4, arg0, arg1);\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\r\n\r\n// v128.ge<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\r\n      case TypeKind.I64: return module.binary(BinaryOp.GeI64x2, arg0, arg1);\r\n      // no GeU64x2\r\n      case TypeKind.ISIZE: return module.binary(compiler.options.isWasm64 ? BinaryOp.GeI64x2 : BinaryOp.GeI32x4, arg0, arg1);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        return module.binary(BinaryOp.GeU32x4, arg0, arg1);\r\n      }\r\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\r\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\r\n\r\n// v128.narrow<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\r\n\r\n// v128.neg<T!>(a: v128) -> v128\r\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.unary(\r\n          compiler.options.isWasm64\r\n            ? UnaryOp.NegI64x2\r\n            : UnaryOp.NegI32x4,\r\n          arg0\r\n        );\r\n      }\r\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\r\n\r\n// v128.abs<T!>(a: v128) -> v128\r\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\r\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\r\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\r\n      case TypeKind.I64: return module.unary(UnaryOp.AbsI64x2, arg0);\r\n      case TypeKind.ISIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.AbsI64x2 : UnaryOp.AbsI32x4, arg0);\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.U64:\r\n      case TypeKind.USIZE: return arg0;\r\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\r\n\r\n// v128.sqrt<T!>(a: v128) -> v128\r\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\r\n\r\n// v128.ceil<T!>(a: v128) -> v128\r\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\r\n\r\n// v128.floor<T!>(a: v128) -> v128\r\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\r\n\r\n// v128.trunc<T!>(a: v128) -> v128\r\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\r\n\r\n// v128.nearest<T!>(a: v128) -> v128\r\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\r\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\r\n\r\n// v128.convert<T!>(a: v128) -> v128\r\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\r\n\r\n// v128.convert_low<T!>(a: v128) -> v128\r\nfunction builtin_v128_convert_low(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertLowI32x4ToF64x2, arg0);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertLowU32x4ToF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.convert_low\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_convert_low, builtin_v128_convert_low);\r\n\r\n// v128.trunc_sat<T!>(a: v128) -> v128\r\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\r\n\r\n// v128.trunc_sat_zero<T!>(a: v128) -> v128\r\nfunction builtin_v128_trunc_sat_zero(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF64x2ToI32x4Zero, arg0);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF64x2ToU32x4Zero, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat_zero\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_trunc_sat_zero, builtin_v128_trunc_sat_zero);\r\n\r\n// v128.extend_low<T!>(a: v128) -> v128\r\nfunction builtin_v128_extend_low(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendLowI8x16ToI16x8, arg0);\r\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendLowU8x16ToU16x8, arg0);\r\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendLowI16x8ToI32x4, arg0);\r\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendLowU16x8ToU32x4, arg0);\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendLowI32x4ToI64x2, arg0);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendLowU32x4ToU64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_low\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_extend_low, builtin_v128_extend_low);\r\n\r\n// v128.extend_high<T!>(a: v128) -> v128\r\nfunction builtin_v128_extend_high(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.unary(UnaryOp.ExtendHighI8x16ToI16x8, arg0);\r\n      case TypeKind.U8: return module.unary(UnaryOp.ExtendHighU8x16ToU16x8, arg0);\r\n      case TypeKind.I16: return module.unary(UnaryOp.ExtendHighI16x8ToI32x4, arg0);\r\n      case TypeKind.U16: return module.unary(UnaryOp.ExtendHighU16x8ToU32x4, arg0);\r\n      case TypeKind.ISIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.I32: return module.unary(UnaryOp.ExtendHighI32x4ToI64x2, arg0);\r\n      case TypeKind.USIZE: {\r\n        if (compiler.options.isWasm64) break;\r\n        // fall-through\r\n      }\r\n      case TypeKind.U32: return module.unary(UnaryOp.ExtendHighU32x4ToU64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.extend_high\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_extend_high, builtin_v128_extend_high);\r\n\r\n// v128.shl<T!>(a: v128, b: i32) -> v128\r\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var type = ctx.typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.simd_shift(\r\n          compiler.options.isWasm64\r\n            ? SIMDShiftOp.ShlI64x2\r\n            : SIMDShiftOp.ShlI32x4,\r\n          arg0, arg1\r\n        );\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\r\n\r\n// v128.shr<T!>(a: v128, b: i32) -> v128\r\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var type = ctx.typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\r\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\r\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\r\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\r\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\r\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\r\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\r\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\r\n      case TypeKind.ISIZE: {\r\n        return module.simd_shift(\r\n          compiler.options.isWasm64\r\n            ? SIMDShiftOp.ShrI64x2\r\n            : SIMDShiftOp.ShrI32x4,\r\n          arg0, arg1\r\n        );\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.simd_shift(\r\n          compiler.options.isWasm64\r\n            ? SIMDShiftOp.ShrU64x2\r\n            : SIMDShiftOp.ShrU32x4,\r\n          arg0, arg1\r\n        );\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\r\n\r\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  return module.binary(op, arg0, arg1);\r\n}\r\n\r\n// v128.and(a: v128, b: v128) -> v128\r\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\r\n}\r\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\r\n\r\n// v128.or(a: v128, b: v128) -> v128\r\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\r\n}\r\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\r\n\r\n// v128.xor(a: v128, b: v128) -> v128\r\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\r\n}\r\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\r\n\r\n// v128.andnot(a: v128, b: v128) -> v128\r\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndnotV128);\r\n}\r\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\r\n\r\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  return module.unary(op, arg0);\r\n}\r\n\r\n// v128.not(a: v128) -> v128\r\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\r\n}\r\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\r\n\r\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 3)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\r\n  return module.simd_ternary(op, arg0, arg1, arg2);\r\n}\r\n\r\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\r\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\r\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\r\n}\r\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\r\n\r\n// v128.any_true(a: v128) -> bool\r\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.bool;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.bool;\r\n  return module.unary(UnaryOp.AnyTrueV128, arg0);\r\n}\r\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\r\n\r\n// v128.all_true<T!>(a: v128) -> bool\r\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.bool;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var type = ctx.typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.bool;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.unary(compiler.options.isWasm64 ? UnaryOp.AllTrueI64x2 : UnaryOp.AllTrueI32x4, arg0);\r\n      }\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\r\n\r\n// v128.bitmask<T!>(a: v128) -> i32\r\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.i32;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var type = ctx.typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.i32;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.unary(UnaryOp.BitmaskI64x2, arg0);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: return module.unary(compiler.options.isWasm64 ? UnaryOp.BitmaskI64x2 : UnaryOp.BitmaskI32x4, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\r\n\r\n// v128.popcnt<T!>(a: v128) -> v128\r\nfunction builtin_v128_popcnt(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var type = ctx.typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.U8: return module.unary(UnaryOp.PopcntI8x16, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.popcnt\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_popcnt, builtin_v128_popcnt);\r\n\r\n// v128.extadd_pairwise<T!>(a: v128) -> v128\r\nfunction builtin_v128_extadd_pairwise(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var type = ctx.typeArguments![0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.unary(UnaryOp.ExtaddPairwiseI8x16ToI16x8, arg0);\r\n      case TypeKind.U8: return module.unary(UnaryOp.ExtaddPairwiseU8x16ToU16x8, arg0);\r\n      case TypeKind.I16: return module.unary(UnaryOp.ExtaddPairwiseI16x8ToI32x4, arg0);\r\n      case TypeKind.U16: return module.unary(UnaryOp.ExtaddPairwiseU16x8ToU32x4, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.extadd_pairwise\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_extadd_pairwise, builtin_v128_extadd_pairwise);\r\n\r\n// v128.demote_zero<T?>(a: v128) -> v128\r\nfunction builtin_v128_demote_zero(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeOptional(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var type = typeArguments ? typeArguments[0] : Type.f64;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F64: return module.unary(UnaryOp.DemoteZeroF64x2ToF32x4, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.demote_zero\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_demote_zero, builtin_v128_demote_zero);\r\n\r\n// v128.promote_low<T?>(a: v128) -> v128\r\nfunction builtin_v128_promote_low(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeOptional(ctx) |\r\n    checkArgsRequired(ctx, 1)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  var type = typeArguments ? typeArguments[0] : Type.f32;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  compiler.currentType = Type.v128;\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.F32: return module.unary(UnaryOp.PromoteLowF32x4ToF64x2, arg0);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.promote_low\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_promote_low, builtin_v128_promote_low);\r\n\r\n// v128.q15mulr_sat<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_q15mulr_sat(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I16: return module.binary(BinaryOp.Q15mulrSatI16x8, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.q15mulr_sat\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_q15mulr_sat, builtin_v128_q15mulr_sat);\r\n\r\n// v128.extmul_low<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_extmul_low(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulLowI16x8, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulLowU16x8, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulLowI32x4, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulLowU32x4, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulLowI64x2, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulLowU64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_low\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_extmul_low, builtin_v128_extmul_low);\r\n\r\n// v128.extmul_high<T!>(a: v128, b: v128) -> v128\r\nfunction builtin_v128_extmul_high(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkFeatureEnabled(ctx, Feature.SIMD) |\r\n    checkTypeRequired(ctx) |\r\n    checkArgsRequired(ctx, 2)\r\n  ) {\r\n    compiler.currentType = Type.v128;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments!;\r\n  var type = typeArguments[0];\r\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\r\n  if (type.isValue) {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return module.binary(BinaryOp.ExtmulHighI16x8, arg0, arg1);\r\n      case TypeKind.U8: return module.binary(BinaryOp.ExtmulHighU16x8, arg0, arg1);\r\n      case TypeKind.I16: return module.binary(BinaryOp.ExtmulHighI32x4, arg0, arg1);\r\n      case TypeKind.U16: return module.binary(BinaryOp.ExtmulHighU32x4, arg0, arg1);\r\n      case TypeKind.I32: return module.binary(BinaryOp.ExtmulHighI64x2, arg0, arg1);\r\n      case TypeKind.U32: return module.binary(BinaryOp.ExtmulHighU64x2, arg0, arg1);\r\n    }\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n    ctx.reportNode.typeArgumentsRange, \"v128.extmul_high\", type.toString()\r\n  );\r\n  return module.unreachable();\r\n}\r\nbuiltins.set(BuiltinNames.v128_extmul_high, builtin_v128_extmul_high);\r\n\r\n// === Internal runtime =======================================================================\r\n\r\n// __visit_globals(cookie: u32) -> void\r\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 1) // cookie\r\n  ) {\r\n    compiler.currentType = Type.void;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\r\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\r\n  compiler.currentType = Type.void;\r\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], TypeRef.None);\r\n}\r\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\r\n\r\n// __visit_members(ref: usize, cookie: u32) -> void\r\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\r\n  var compiler = ctx.compiler;\r\n  var module = compiler.module;\r\n  if (\r\n    checkTypeAbsent(ctx) |\r\n    checkArgsRequired(ctx, 2) // ref, cookie\r\n  ) {\r\n    compiler.currentType = Type.void;\r\n    return module.unreachable();\r\n  }\r\n  var operands = ctx.operands;\r\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\r\n  var arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.CONV_IMPLICIT);\r\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\r\n  compiler.currentType = Type.void;\r\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], TypeRef.None);\r\n}\r\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\r\n\r\n// === Inline assembler =======================================================================\r\n\r\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\r\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\r\n//   and, or, xor, shl, shr_u, shr_s\r\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\r\n\r\n// i32.clz -> clz<i32>\r\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_clz(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\r\n\r\n// i64.clz -> clz<i64>\r\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_clz(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\r\n\r\n// i32.ctz -> ctz<i32>\r\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_ctz(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\r\n\r\n// i64.ctz -> ctz<i64>\r\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_ctz(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\r\n\r\n// i32.popcnt -> popcnt<i32>\r\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_popcnt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\r\n\r\n// i64.popcnt -> popcnt<i64>\r\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_popcnt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\r\n\r\n// i32.rotl -> rotl<i32>\r\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_rotl(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\r\n\r\n// i64.rotl -> rotl<i64>\r\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_rotl(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\r\n\r\n// i32.rotr -> rotr<i32>\r\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_rotr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\r\n\r\n// i64.rotr -> rotr<i64>\r\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_rotr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\r\n\r\n// f32.abs -> abs<f32>\r\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\r\n\r\n// f64.abs -> abs<f64>\r\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\r\n\r\n// f32.max -> max<f32>\r\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\r\n\r\n// f64.max -> max<f64>\r\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\r\n\r\n// f32.min -> min<f32>\r\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\r\n\r\n// f64.min -> min<f64>\r\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\r\n\r\n// f32.ceil -> ceil<f32>\r\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_ceil(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\r\n\r\n// f64.ceil -> ceil<f64>\r\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_ceil(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\r\n\r\n// f32.floor -> floor<f32>\r\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_floor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\r\n\r\n// f64.floor -> floor<f64>\r\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_floor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\r\n\r\n// f32.copysign -> copysign<f32>\r\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_copysign(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\r\n\r\n// f64.copysign -> copysign<f64>\r\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_copysign(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\r\n\r\n// f32.nearest -> nearest<f32>\r\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_nearest(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\r\n\r\n// f64.nearest -> nearest<f64>\r\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_nearest(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\r\n\r\n// i32.reinterpret_f32 -> reinterpret<i32>\r\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_reinterpret(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\r\n\r\n// i64.reinterpret_f64 -> reinterpret<i64>\r\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_reinterpret(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\r\n\r\n// f32.reinterpret_i32 -> reinterpret<f32>\r\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_reinterpret(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\r\n\r\n// f64.reinterpret_i64 -> reinterpret<f64>\r\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_reinterpret(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\r\n\r\n// f32.sqrt -> sqrt<f32>\r\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_sqrt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\r\n\r\n// f64.sqrt -> sqrt<f64>\r\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_sqrt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\r\n\r\n// f32.trunc -> trunc<f32>\r\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_trunc(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\r\n\r\n// f64.trunc -> trunc<f64>\r\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_trunc(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\r\n\r\n// i32.add -> add<i32>\r\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\r\n\r\n// i64.add -> add<i64>\r\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\r\n\r\n// f32.add -> add<f32>\r\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\r\n\r\n// f64.add -> add<f64>\r\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\r\n\r\n// i32.sub -> sub<i32>\r\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\r\n\r\n// i64.sub -> sub<i64>\r\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\r\n\r\n// f32.sub -> sub<f32>\r\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\r\n\r\n// f64.sub -> sub<f64>\r\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\r\n\r\n// i32.mul -> mul<i32>\r\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\r\n\r\n// i64.mul -> mul<i64>\r\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\r\n\r\n// f32.mul -> mul<f32>\r\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\r\n\r\n// f64.mul -> mul<f64>\r\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\r\n\r\n// i32.div_s -> div<i32>\r\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\r\n\r\n// i32.div_u -> div<u32>\r\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.u32;\r\n  return builtin_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\r\n\r\n// i64.div_s -> div_s<i64>\r\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\r\n\r\n// i64.div_u -> div_u<u64>\r\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u64 ];\r\n  ctx.contextualType = Type.u64;\r\n  return builtin_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\r\n\r\n// f32.div -> div<f32>\r\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\r\n\r\n// f64.div -> div<f64>\r\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\r\n\r\n// i32.load8_s -> <i32>load<i8>\r\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\r\n\r\n// i32.load8_u -> <i32>load<u8>\r\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\r\n\r\n// i32.load16_s -> <i32>load<i16>\r\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\r\n\r\n// i32.load16_u -> <i32>load<u16>\r\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\r\n\r\n// i32.load -> <i32>load<i32>\r\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\r\n\r\n// i64.load8_s -> <i64>load<i8>\r\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\r\n\r\n// i64.load8_u -> <i64>load<u8>\r\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\r\n\r\n// i64.load16_s -> <i64>load<i16>\r\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\r\n\r\n// i64.load16_u -> <i64>load<u16>\r\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\r\n\r\n// i64.load32_s -> <i64>load<i32>\r\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\r\n\r\n// i64.load32_u -> <i64>load<u32>\r\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\r\n\r\n// i64.load -> <i64>load<i64>\r\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\r\n\r\n// f32.load -> <f32>load<f32>\r\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\r\n\r\n// f64.load -> <f64>load<f64>\r\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\r\n\r\n// i32.store8 -> store<i8 from i32>\r\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\r\n\r\n// i32.store16 -> store<i16 from i32>\r\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\r\n\r\n// i32.store -> store<i32 from i32>\r\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\r\n\r\n// i64.store8 -> store<i8 from i64>\r\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\r\n\r\n// i64.store16 -> store<i16 from i64>\r\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\r\n\r\n// i64.store32 -> store<i32 from i64>\r\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\r\n\r\n// i64.store -> store<i64 from i64>\r\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\r\n\r\n// f32.store -> store<f32 from f64>\r\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\r\n\r\n// f64.store -> store<f64 from f64>\r\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\r\n\r\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\r\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\r\n\r\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\r\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\r\n\r\n// i32.atomic.load -> <i32>atomic.load<i32>\r\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\r\n\r\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\r\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\r\n\r\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\r\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\r\n\r\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\r\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\r\n\r\n// i64.atomic.load -> <i64>atomic.load<i64>\r\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_atomic_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\r\n\r\n// i32.atomic.store8 -> atomic.store<i8 from i32>\r\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\r\n\r\n// i32.atomic.store16 -> atomic.store<i16 from i32>\r\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\r\n\r\n// i32.atomic.store -> atomic.store<i32 from i32>\r\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\r\n\r\n// i64.atomic.store8 -> atomic.store<i8 from i64>\r\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\r\n\r\n// i64.atomic.store16 -> atomic.store<i16 from i64>\r\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\r\n\r\n// i64.atomic.store32 -> atomic.store<i32 from i64>\r\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\r\n\r\n// i64.atomic.store -> atomic.store<i64 from i64>\r\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\r\n\r\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\r\n\r\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\r\n\r\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\r\n\r\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\r\n\r\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\r\n\r\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\r\n\r\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\r\n\r\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\r\n\r\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\r\n\r\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\r\n\r\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\r\n\r\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\r\n\r\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\r\n\r\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\r\n\r\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\r\n\r\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\r\n\r\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\r\n\r\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\r\n\r\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\r\n\r\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\r\n\r\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_and(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\r\n\r\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\r\n\r\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\r\n\r\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\r\n\r\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\r\n\r\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\r\n\r\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\r\n\r\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_or(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\r\n\r\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\r\n\r\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\r\n\r\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\r\n\r\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\r\n\r\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\r\n\r\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\r\n\r\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\r\n\r\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\r\n\r\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\r\n\r\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\r\n\r\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\r\n\r\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\r\n\r\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\r\n\r\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_xchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\r\n\r\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\r\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\r\n\r\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\r\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\r\n\r\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\r\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\r\n\r\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\r\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\r\n\r\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\r\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\r\n\r\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\r\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\r\n\r\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\r\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  ctx.contextIsExact = true;\r\n  return builtin_atomic_cmpxchg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\r\n\r\n// i32.wait -> atomic.wait<i32>\r\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  return builtin_atomic_wait(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\r\n\r\n// i64.wait -> atomic.wait<i64>\r\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_atomic_wait(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\r\n\r\n// v128.load -> load<v128>\r\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.v128 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_load(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\r\n\r\n// v128.load8x8_s -> v128.load_ext<i8>\r\nfunction builtin_v128_load8x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_ext(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load8x8_s, builtin_v128_load8x8_s);\r\n\r\n// v128.load8x8_u -> v128.load_ext<u8>\r\nfunction builtin_v128_load8x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_ext(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load8x8_u, builtin_v128_load8x8_u);\r\n\r\n// v128.load16x4_s -> v128.load_ext<i16>\r\nfunction builtin_v128_load16x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_ext(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load16x4_s, builtin_v128_load16x4_s);\r\n\r\n// v128.load16x4_u -> v128.load_ext<u16>\r\nfunction builtin_v128_load16x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_ext(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load16x4_u, builtin_v128_load16x4_u);\r\n\r\n// v128.load32x2_s -> v128.load_ext<i32>\r\nfunction builtin_v128_load32x2_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_ext(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load32x2_s, builtin_v128_load32x2_s);\r\n\r\n// v128.load32x2_u -> v128.load_ext<u32>\r\nfunction builtin_v128_load32x2_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_ext(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load32x2_u, builtin_v128_load32x2_u);\r\n\r\n// v128.load8_splat -> v128.load_splat<u8>\r\nfunction builtin_v128_load8_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load8_splat, builtin_v128_load8_splat);\r\n\r\n// v128.load16_splat -> v128.load_splat<u16>\r\nfunction builtin_v128_load16_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load16_splat, builtin_v128_load16_splat);\r\n\r\n// v128.load32_splat -> v128.load_splat<u32>\r\nfunction builtin_v128_load32_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load32_splat, builtin_v128_load32_splat);\r\n\r\n// v128.load64_splat -> v128.load_splat<u64>\r\nfunction builtin_v128_load64_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load64_splat, builtin_v128_load64_splat);\r\n\r\n// v128.load32_zero -> v128.load_zero<u32>\r\nfunction builtin_v128_load32_zero(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_zero(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load32_zero, builtin_v128_load32_zero);\r\n\r\n// v128.load64_zero -> v128.load_zero<u64>\r\nfunction builtin_v128_load64_zero(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_zero(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load64_zero, builtin_v128_load64_zero);\r\n\r\n// v128.load8_lane -> v128.load_lane<u8>\r\nfunction builtin_v128_load8_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load8_lane, builtin_v128_load8_lane);\r\n\r\n// v128.load16_lane -> v128.load_lane<u16>\r\nfunction builtin_v128_load16_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load16_lane, builtin_v128_load16_lane);\r\n\r\n// v128.load32_lane -> v128.load_lane<u32>\r\nfunction builtin_v128_load32_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load32_lane, builtin_v128_load32_lane);\r\n\r\n// v128.load64_lane -> v128.load_lane<u64>\r\nfunction builtin_v128_load64_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_load_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_load64_lane, builtin_v128_load64_lane);\r\n\r\n// v128.store8_lane -> v128.store_lane<u8>\r\nfunction builtin_v128_store8_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_store_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_store8_lane, builtin_v128_store8_lane);\r\n\r\n// v128.store16_lane -> v128.store_lane<u16>\r\nfunction builtin_v128_store16_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_store_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_store16_lane, builtin_v128_store16_lane);\r\n\r\n// v128.store32_lane -> v128.store_lane<u32>\r\nfunction builtin_v128_store32_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_store_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_store32_lane, builtin_v128_store32_lane);\r\n\r\n// v128.store64_lane -> v128.store_lane<u64>\r\nfunction builtin_v128_store64_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_store_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_store64_lane, builtin_v128_store64_lane);\r\n\r\n// v128.store -> store<v128 from v128>\r\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.v128 ];\r\n  ctx.contextualType = Type.v128;\r\n  ctx.contextIsExact = true;\r\n  return builtin_store(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\r\n\r\n// i8x16_splat -> v128.splat<i8>\r\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\r\n\r\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\r\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\r\n\r\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\r\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\r\n\r\n// i8x16.replace_lane -> v128.replace_lane<i8>\r\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_replace_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\r\n\r\n// i8x16.add -> v128.add<i8>\r\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\r\n\r\n// i8x16.sub -> v128.sub<i8>\r\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\r\n\r\n// i8x16.min_s -> v128.min<i8>\r\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\r\n\r\n// i8x16.min_u -> v128.min<u8>\r\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\r\n\r\n// i8x16.max_s -> v128.max<i8>\r\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\r\n\r\n// i8x16.max_u -> v128.max<u8>\r\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\r\n\r\n// i8x16.avgr_u -> v128.avgr<u8>\r\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_avgr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\r\n\r\n// i8x16.abs -> v128.abs<i8>\r\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\r\n\r\n// i8x16.neg -> v128.neg<i8>\r\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_neg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\r\n\r\n// i8x16.add_sat_s -> v128.add_sat<i8>\r\nfunction builtin_i8x16_add_sat_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_add_sat_s, builtin_i8x16_add_sat_s);\r\n\r\n// i8x16.add_sat_u -> v128.add_sat<u8>\r\nfunction builtin_i8x16_add_sat_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_add_sat_u, builtin_i8x16_add_sat_u);\r\n\r\n// i8x16.sub_sat_s -> v128.sub_sat<i8>\r\nfunction builtin_i8x16_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_sub_sat_s, builtin_i8x16_sub_sat_s);\r\n\r\n// i8x16.sub_sat_u -> v128.sub_sat<u8>\r\nfunction builtin_i8x16_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_sub_sat_u, builtin_i8x16_sub_sat_u);\r\n\r\n// i8x16.shl -> v128.shl<i8>\r\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shl(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\r\n\r\n// i8x16.shr_s -> v128.shr<i8>\r\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\r\n\r\n// i8x16.shr_u -> v128.shr<u8>\r\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\r\n\r\n// i8x16.all_true -> v128.all_true<i8>\r\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_all_true(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\r\n\r\n// i8x16.bitmask -> v128.bitmask<i8>\r\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_bitmask(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\r\n\r\n// i8x16.popcnt -> v128.popcnt<i8>\r\nfunction builtin_i8x16_popcnt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_popcnt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_popcnt, builtin_i8x16_popcnt);\r\n\r\n// i8x16.eq -> v128.eq<i8>\r\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_eq(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\r\n\r\n// i8x16.ne -> v128.ne<i8>\r\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ne(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\r\n\r\n// i8x16.lt_s -> v128.lt<i8>\r\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\r\n\r\n// i8x16.lt_u -> v128.lt<u8>\r\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\r\n\r\n// i8x16.le_s -> v128.le<i8>\r\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\r\n\r\n// i8x16.le_u -> v128.le<u8>\r\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\r\n\r\n// i8x16.gt_s -> v128.gt<i8>\r\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\r\n\r\n// i8x16.gt_u -> v128.gt<u8>\r\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\r\n\r\n// i8x16.ge_s -> v128.ge<i8>\r\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\r\n\r\n// i8x16.ge_u -> v128.ge<u8>\r\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\r\n\r\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\r\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_narrow(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\r\n\r\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\r\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_narrow(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\r\n\r\n// i8x16.shuffle -> v128.shuffle<i8>\r\nfunction builtin_i8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shuffle(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_shuffle, builtin_i8x16_shuffle);\r\n\r\n// i8x16.swizzle -> v128.swizzle\r\nfunction builtin_i8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = null;\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_swizzle(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i8x16_swizzle, builtin_i8x16_swizzle);\r\n\r\n// i16x8.splat -> v128.splat<i16>\r\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\r\n\r\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\r\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\r\n\r\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\r\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\r\n\r\n// i16x8.replace_lane -> v128.replace_lane<i16>\r\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_replace_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\r\n\r\n// i16x8.add -> v128.add<i16>\r\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\r\n\r\n// i16x8.sub -> v128.sub<i16>\r\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\r\n\r\n// i16x8.mul -> v128.mul<i16>\r\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\r\n\r\n// i16x8.min_s -> v128.min<i16>\r\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\r\n\r\n// i16x8.min_u -> v128.min<u16>\r\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\r\n\r\n// i16x8.max_s -> v128.max<i16>\r\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\r\n\r\n// i16x8.max_u -> v128.max<u16>\r\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\r\n\r\n// i16x8.avgr_u -> v128.avgr<u16>\r\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_avgr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\r\n\r\n// i16x8.abs -> v128.abs<i16>\r\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\r\n\r\n// i16x8.neg -> v128.neg<i16>\r\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_neg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\r\n\r\n// i16x8.add_sat_s -> v128.add_sat<i16>\r\nfunction builtin_i16x8_add_sat_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_add_sat_s, builtin_i16x8_add_sat_s);\r\n\r\n// i16x8.add_sat_u -> v128.add_sat<u16>\r\nfunction builtin_i16x8_add_sat_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_add_sat_u, builtin_i16x8_add_sat_u);\r\n\r\n// i16x8.sub_sat_s -> v128.sub_sat<i16>\r\nfunction builtin_i16x8_sub_sat_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_sub_sat_s, builtin_i16x8_sub_sat_s);\r\n\r\n// i16x8.sub_sat_u -> v128.sub_sat<u16>\r\nfunction builtin_i16x8_sub_sat_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_sub_sat_u, builtin_i16x8_sub_sat_u);\r\n\r\n// i16x8.shl -> v128.shl<i16>\r\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shl(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\r\n\r\n// i16x8.shr_s -> v128.shr<i16>\r\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\r\n\r\n// i16x8.shr_u -> v128.shr<u16>\r\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\r\n\r\n// i16x8.all_true -> v128.all_true<i16>\r\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_all_true(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\r\n\r\n// i16x8.bitmask -> v128.bitmask<i16>\r\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_bitmask(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\r\n\r\n// i16x8.eq -> v128.eq<i16>\r\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_eq(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\r\n\r\n// i16x8.ne -> v128.ne<i16>\r\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ne(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\r\n\r\n// i16x8.lt_s -> v128.lt<i16>\r\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\r\n\r\n// i16x8.lt_u -> v128.lt<u16>\r\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\r\n\r\n// i16x8.le_s -> v128.le<i16>\r\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\r\n\r\n// i16x8.le_u -> v128.le<u16>\r\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\r\n\r\n// i16x8.gt_s -> v128.gt<i16>\r\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\r\n\r\n// i16x8.gt_u -> v128.gt<u16>\r\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\r\n\r\n// i16x8.ge_s -> v128.ge<i16>\r\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\r\n\r\n// i16x8.ge_u -> v128.ge<u16>\r\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\r\n\r\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\r\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_narrow(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\r\n\r\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\r\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_narrow(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\r\n\r\n// i16x8.extend_low_i8x16_s -> v128.extend_low<i8>\r\nfunction builtin_i16x8_extend_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_s, builtin_i16x8_extend_low_i8x16_s);\r\n\r\n// i16x8.extend_low_i8x16_u -> v128.extend_low<u8>\r\nfunction builtin_i16x8_extend_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extend_low_i8x16_u, builtin_i16x8_extend_low_i8x16_u);\r\n\r\n// i16x8.extend_high_i8x16_s -> v128.extend_high<i8>\r\nfunction builtin_i16x8_extend_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_s, builtin_i16x8_extend_high_i8x16_s);\r\n\r\n// i16x8.extend_high_i8x16_u -> v128.extend_high<u8>\r\nfunction builtin_i16x8_extend_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extend_high_i8x16_u, builtin_i16x8_extend_high_i8x16_u);\r\n\r\n// i16x8.extadd_pairwise_i8x16_s -> v128.extadd_pairwise<i8>\r\nfunction builtin_i16x8_extadd_pairwise_i8x16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extadd_pairwise(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_s, builtin_i16x8_extadd_pairwise_i8x16_s);\r\n\r\n// i16x8.extadd_pairwise_i8x16_u -> v128.extadd_pairwise<u8>\r\nfunction builtin_i16x8_extadd_pairwise_i8x16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extadd_pairwise(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extadd_pairwise_i8x16_u, builtin_i16x8_extadd_pairwise_i8x16_u);\r\n\r\n// i16x8.q15mulr_sat_s -> v128.q15mulr_sat<i16>\r\nfunction builtin_i16x8_q15mulr_sat_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_q15mulr_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_q15mulr_sat_s, builtin_i16x8_q15mulr_sat_s);\r\n\r\n// i16x8.extmul_low_i8x16_s -> v128.extmul_low<i16>\r\nfunction builtin_i16x8_extmul_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_s, builtin_i16x8_extmul_low_i8x16_s);\r\n\r\n// i16x8.extmul_low_i8x16_u -> v128.extmul_low<u16>\r\nfunction builtin_i16x8_extmul_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extmul_low_i8x16_u, builtin_i16x8_extmul_low_i8x16_u);\r\n\r\n// i16x8.extmul_high_i8x16_s -> v128.extmul_high<i16>\r\nfunction builtin_i16x8_extmul_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_s, builtin_i16x8_extmul_high_i8x16_s);\r\n\r\n// i16x8.extmul_high_i8x16_u -> v128.extmul_high<u16>\r\nfunction builtin_i16x8_extmul_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u8 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i16x8_extmul_high_i8x16_u, builtin_i16x8_extmul_high_i8x16_u);\r\n\r\n// i32x4.splat -> v128.splat<i32>\r\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\r\n\r\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\r\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\r\n\r\n// i32x4.replace_lane -> v128.replace_lane<i32>\r\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_replace_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\r\n\r\n// i32x4.add -> v128.add<i32>\r\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\r\n\r\n// i32x4.sub -> v128.sub<i32>\r\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\r\n\r\n// i32x4.mul -> v128.mul<i32>\r\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\r\n\r\n// i32x4.min_s -> v128.min<i32>\r\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\r\n\r\n// i32x4.min_u -> v128.min<u32>\r\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\r\n\r\n// i32x4.max_s -> v128.max<i32>\r\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\r\n\r\n// i32x4.max_u -> v128.max<u32>\r\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\r\n\r\n// i32x4.dot_i16x8_s -> v128.dot<i16>\r\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_dot(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\r\n\r\n// i32x4.abs -> v128.abs<i32>\r\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\r\n\r\n// i32x4.neg -> v128.neg<i32>\r\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_neg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\r\n\r\n// i32x4.shl -> v128.shl<i32>\r\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shl(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\r\n\r\n// i32x4.shr_s -> v128.shr<i32>\r\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\r\n\r\n// i32x4.shr_u -> v128.shr<u32>\r\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\r\n\r\n// i32x4.all_true -> v128.all_true<i32>\r\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_all_true(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\r\n\r\n// i32x4.bitmask -> v128.bitmask<i32>\r\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_bitmask(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\r\n\r\n// i32x4.eq -> v128.eq<i32>\r\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_eq(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\r\n\r\n// i32x4.ne -> v128.ne<i32>\r\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ne(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\r\n\r\n// i32x4.lt_s -> v128.lt<i32>\r\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\r\n\r\n// i32x4.lt_u -> v128.lt<u32>\r\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\r\n\r\n// i32x4.le_s -> v128.le<i32>\r\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\r\n\r\n// i32x4.le_u -> v128.le<u32>\r\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\r\n\r\n// i32x4.gt_s -> v128.gt<i32>\r\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\r\n\r\n// i32x4.gt_u -> v128.gt<u32>\r\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\r\n\r\n// i32x4.ge_s -> v128.ge<i32>\r\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\r\n\r\n// i32x4.ge_u -> v128.ge<u32>\r\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\r\n\r\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\r\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_trunc_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\r\n\r\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\r\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_trunc_sat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\r\n\r\n// i32x4.trunc_sat_f64x2_s_zero -> v128.trunc_sat_zero<i32>\r\nfunction builtin_i32x4_trunc_sat_f64x2_s_zero(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_trunc_sat_zero(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_s_zero, builtin_i32x4_trunc_sat_f64x2_s_zero);\r\n\r\n// i32x4.trunc_sat_f64x2_u_zero -> v128.trunc_sat_zero<u32>\r\nfunction builtin_i32x4_trunc_sat_f64x2_u_zero(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_trunc_sat_zero(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f64x2_u_zero, builtin_i32x4_trunc_sat_f64x2_u_zero);\r\n\r\n// i32x4.extend_low_i16x8_s -> // v128.extend_low<i16>\r\nfunction builtin_i32x4_extend_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_s, builtin_i32x4_extend_low_i16x8_s);\r\n\r\n// i32x4.extend_low_i16x8_u -> v128.extend_low<u16>\r\nfunction builtin_i32x4_extend_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extend_low_i16x8_u, builtin_i32x4_extend_low_i16x8_u);\r\n\r\n// i32x4.extend_high_i16x8_s -> v128.extend_high<i16>\r\nfunction builtin_i32x4_extend_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_s, builtin_i32x4_extend_high_i16x8_s);\r\n\r\n// i32x4.extend_high_i16x8_u -> v128.extend_high<u16>\r\nfunction builtin_i32x4_extend_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extend_high_i16x8_u, builtin_i32x4_extend_high_i16x8_u);\r\n\r\n// i32x4.extadd_pairwise_i16x8_s -> v128.extadd_pairwise<i16>\r\nfunction builtin_i32x4_extadd_pairwise_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extadd_pairwise(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_s, builtin_i32x4_extadd_pairwise_i16x8_s);\r\n\r\n// i32x4.extadd_pairwise_i16x8_u -> v128.extadd_pairwise<u16>\r\nfunction builtin_i32x4_extadd_pairwise_i16x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extadd_pairwise(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extadd_pairwise_i16x8_u, builtin_i32x4_extadd_pairwise_i16x8_u);\r\n\r\n// i32x4.extmul_low_i16x8_s -> v128.extmul_low<i16>\r\nfunction builtin_i32x4_extmul_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_s, builtin_i32x4_extmul_low_i16x8_s);\r\n\r\n// i32x4.extmul_low_i16x8_u -> v128.extmul_low<u16>\r\nfunction builtin_i32x4_extmul_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extmul_low_i16x8_u, builtin_i32x4_extmul_low_i16x8_u);\r\n\r\n// i32x4.extmul_high_i16x8_s -> v128.extmul_high<i16>\r\nfunction builtin_i32x4_extmul_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_s, builtin_i32x4_extmul_high_i16x8_s);\r\n\r\n// i32x4.extmul_high_i16x8_u -> v128.extmul_high<u16>\r\nfunction builtin_i32x4_extmul_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u16 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i32x4_extmul_high_i16x8_u, builtin_i32x4_extmul_high_i16x8_u);\r\n\r\n// i64x2.splat -> v128.splat<i64>\r\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\r\n\r\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\r\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i64;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\r\n\r\n// i64x2.replace_lane -> v128.replace_lane<i64>\r\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_replace_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\r\n\r\n// i64x2.add -> v128.add<i64>\r\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\r\n\r\n// i64x2.sub -> v128.sub<i64>\r\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\r\n\r\n// i64x2.mul -> v128.mul<i64>\r\nfunction builtin_i64x2_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_mul, builtin_i64x2_mul);\r\n\r\n// i64x2.abs -> v128.abs<i64>\r\nfunction builtin_i64x2_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_abs, builtin_i64x2_abs);\r\n\r\n// i64x2.neg -> v128.neg<i64>\r\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_neg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\r\n\r\n// i64x2.shl -> v128.shl<i64>\r\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shl(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\r\n\r\n// i64x2.shr_s -> v128.shr<i64>\r\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\r\n\r\n// i64x2.shr_u -> v128.shr<u64>\r\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_shr(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\r\n\r\n// i64x2.all_true -> v128.all_true<i64>\r\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_all_true(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\r\n\r\n// i64x2.bitmask -> v128.bitmask<i64>\r\nfunction builtin_i64x2_bitmask(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.i32;\r\n  return builtin_v128_bitmask(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_bitmask, builtin_i64x2_bitmask);\r\n\r\n// i64x2.eq -> v128.eq<i64>\r\nfunction builtin_i64x2_eq(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_eq(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_eq, builtin_i64x2_eq);\r\n\r\n// i64x2.ne -> v128.ne<i64>\r\nfunction builtin_i64x2_ne(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ne(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_ne, builtin_i64x2_ne);\r\n\r\n// i64x2.lt_s -> v128.lt<i64>\r\nfunction builtin_i64x2_lt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_lt_s, builtin_i64x2_lt_s);\r\n\r\n// i64x2.le_s -> v128.le<i64>\r\nfunction builtin_i64x2_le_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_le_s, builtin_i64x2_le_s);\r\n\r\n// i64x2.gt_s -> v128.gt<i64>\r\nfunction builtin_i64x2_gt_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_gt_s, builtin_i64x2_gt_s);\r\n\r\n// i64x2.ge_s -> v128.ge<i64>\r\nfunction builtin_i64x2_ge_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_ge_s, builtin_i64x2_ge_s);\r\n\r\n// i64x2.extend_low_i32x4_s -> // v128.extend_low<i32>\r\nfunction builtin_i64x2_extend_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_s, builtin_i64x2_extend_low_i32x4_s);\r\n\r\n// i64x2.extend_low_i32x4_u -> v128.extend_low<u32>\r\nfunction builtin_i64x2_extend_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extend_low_i32x4_u, builtin_i64x2_extend_low_i32x4_u);\r\n\r\n// i64x2.extend_high_i32x4_s -> v128.extend_high<i32>\r\nfunction builtin_i64x2_extend_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_s, builtin_i64x2_extend_high_i32x4_s);\r\n\r\n// i64x2.extend_high_i32x4_u -> v128.extend_high<u32>\r\nfunction builtin_i64x2_extend_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extend_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extend_high_i32x4_u, builtin_i64x2_extend_high_i32x4_u);\r\n\r\n// i64x2.extmul_low_i32x4_s -> v128.extmul_low<i32>\r\nfunction builtin_i64x2_extmul_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_s, builtin_i64x2_extmul_low_i32x4_s);\r\n\r\n// i64x2.extmul_low_i32x4_u -> v128.extmul_low<u32>\r\nfunction builtin_i64x2_extmul_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extmul_low_i32x4_u, builtin_i64x2_extmul_low_i32x4_u);\r\n\r\n// i64x2.extmul_high_i32x4_s -> v128.extmul_high<i32>\r\nfunction builtin_i64x2_extmul_high_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_s, builtin_i64x2_extmul_high_i32x4_s);\r\n\r\n// i64x2.extmul_high_i32x4_u -> v128.extmul_high<u32>\r\nfunction builtin_i64x2_extmul_high_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_extmul_high(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.i64x2_extmul_high_i32x4_u, builtin_i64x2_extmul_high_i32x4_u);\r\n\r\n// f32x4.splat -> v128.splat<f32>\r\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\r\n\r\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\r\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.f32;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\r\n\r\n// f32x4.replace_lane -> v128.replace_lane<f32>\r\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_replace_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\r\n\r\n// f32x4.add -> v128.add<f32>\r\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\r\n\r\n// f32x4.sub -> v128.sub<f32>\r\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\r\n\r\n// f32x4.mul -> v128.mul<f32>\r\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\r\n\r\n// f32x4.div -> v128.div<f32>\r\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\r\n\r\n// f32x4.neg -> v128.neg<f32>\r\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_neg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\r\n\r\n// f32x4.min -> v128.min<f32>\r\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\r\n\r\n// f32x4.max -> v128.max<f32>\r\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\r\n\r\n// f32x4.pmin -> v128.pmin<f32>\r\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_pmin(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\r\n\r\n// f32x4.pmax -> v128.pmax<f32>\r\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_pmax(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\r\n\r\n// f32x4.abs -> v128.abs<f32>\r\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\r\n\r\n// f32x4.sqrt -> v128.sqrt<f32>\r\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sqrt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\r\n\r\n// f32x4.ceil -> v128.ceil<f32>\r\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ceil(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\r\n\r\n// f32x4.floor -> v128.floor<f32>\r\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_floor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\r\n\r\n// f32x4.trunc -> v128.trunc<f32>\r\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_trunc(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\r\n\r\n// f32x4.nearest -> v128.nearest<f32>\r\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_nearest(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\r\n\r\n// f32x4.eq -> v128.eq<f32>\r\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_eq(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\r\n\r\n// f32x4.ne -> v128.ne<f32>\r\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ne(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\r\n\r\n// f32x4.lt -> v128.lt<f32>\r\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\r\n\r\n// f32x4.le -> v128.le<f32>\r\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\r\n\r\n// f32x4.gt -> v128.gt<f32>\r\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\r\n\r\n// f32x4.ge -> v128.ge<f32>\r\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\r\n\r\n// f32x4.convert_i32x4_s -> v128.convert<i32>\r\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_convert(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\r\n\r\n// f32x4.convert_i32x4_u -> v128.convert<u32>\r\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_convert(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\r\n\r\n// f32x4.demote_f64x2_zero -> v128.demote_zero<f64>\r\nfunction builtin_f32x4_demote_f64x2_zero(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_demote_zero(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f32x4_demote_f64x2_zero, builtin_f32x4_demote_f64x2_zero);\r\n\r\n// f64x2.splat -> v128.splat<f64>\r\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_splat(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\r\n\r\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\r\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.f64;\r\n  return builtin_v128_extract_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\r\n\r\n// f64x2.replace_lane -> v128.replace_lane\r\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_replace_lane(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\r\n\r\n// f64x2.add -> v128.add<f64>\r\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_add(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\r\n\r\n// f64x2.sub -> v128.sub<f64>\r\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sub(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\r\n\r\n// f64x2.mul -> v128.mul<f64>\r\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_mul(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\r\n\r\n// f64x2.div -> v128.div<f64>\r\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_div(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\r\n\r\n// f64x2.neg -> v128.neg<f64>\r\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_neg(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\r\n\r\n// f64x2.min -> v128.min<f64>\r\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_min(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\r\n\r\n// f64x2.max -> v128.max<f64>\r\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_max(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\r\n\r\n// f64x2.pmin -> v128.pmin<f64>\r\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_pmin(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\r\n\r\n// f64x2.pmax -> v128.pmax<f64>\r\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_pmax(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\r\n\r\n// f64x2.abs -> v128.abs<f64>\r\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_abs(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\r\n\r\n// f64x2.sqrt -> v128.sqrt<f64>\r\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_sqrt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\r\n\r\n// f64x2.ceil -> v128.ceil<f64>\r\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ceil(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\r\n\r\n// f64x2.floor -> v128.floor<f64>\r\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_floor(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\r\n\r\n// f64x2.trunc -> v128.trunc<f64>\r\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_trunc(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\r\n\r\n// f64x2.nearest -> v128.nearest<f64>\r\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_nearest(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\r\n\r\n// f64x2.eq -> v128.eq<f64>\r\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_eq(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\r\n\r\n// f64x2.ne -> v128.ne<f64>\r\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ne(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\r\n\r\n// f64x2.lt -> v128.lt<f64>\r\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_lt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\r\n\r\n// f64x2.le -> v128.le<f64>\r\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_le(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\r\n\r\n// f64x2.gt -> v128.gt<f64>\r\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_gt(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\r\n\r\n// f64x2.ge -> v128.ge<f64>\r\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f64 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_ge(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\r\n\r\n// f64x2.convert_low_i32x4_s -> v128.convert_low<i32>\r\nfunction builtin_f64x2_convert_low_i32x4_s(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.i32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_convert_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_s, builtin_f64x2_convert_low_i32x4_s);\r\n\r\n// f64x2.convert_low_i32x4_u -> v128.convert_low<u32>\r\nfunction builtin_f64x2_convert_low_i32x4_u(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.u32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_convert_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_convert_low_i32x4_u, builtin_f64x2_convert_low_i32x4_u);\r\n\r\n// f64x2.promote_low_f32x4 -> v128.promote_low<f32>\r\nfunction builtin_f64x4_promote_low_f32x4(ctx: BuiltinContext): ExpressionRef {\r\n  checkTypeAbsent(ctx);\r\n  ctx.typeArguments = [ Type.f32 ];\r\n  ctx.contextualType = Type.v128;\r\n  return builtin_v128_promote_low(ctx);\r\n}\r\nbuiltins.set(BuiltinNames.f64x2_promote_low_f32x4, builtin_f64x4_promote_low_f32x4);\r\n\r\n// === Internal helpers =======================================================================\r\n\r\n/** Compiles the `visit_globals` function. */\r\nexport function compileVisitGlobals(compiler: Compiler): void {\r\n  var module = compiler.module;\r\n  var exprs = new Array<ExpressionRef>();\r\n  var sizeTypeRef = compiler.options.sizeTypeRef;\r\n  var visitInstance = assert(compiler.program.visitInstance);\r\n\r\n  // this function is @lazy: make sure it exists\r\n  compiler.compileFunction(visitInstance, true);\r\n\r\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\r\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\r\n    let element = unchecked(_values[i]);\r\n    if (element.kind != ElementKind.GLOBAL) continue;\r\n    let global = <Global>element;\r\n    let globalType = global.type;\r\n    let classReference = globalType.getClass();\r\n    if (\r\n      classReference !== null &&\r\n      !classReference.hasDecorator(DecoratorFlags.UNMANAGED) &&\r\n      global.is(CommonFlags.COMPILED)\r\n    ) {\r\n      if (global.is(CommonFlags.INLINED)) {\r\n        let value = global.constantIntegerValue;\r\n        if (i64_low(value) || i64_high(value)) {\r\n          exprs.push(\r\n            module.call(visitInstance.internalName, [\r\n              compiler.options.isWasm64\r\n                ? module.i64(i64_low(value), i64_high(value))\r\n                : module.i32(i64_low(value)),\r\n              module.local_get(0, TypeRef.I32) // cookie\r\n            ], TypeRef.None)\r\n          );\r\n        }\r\n      } else {\r\n        exprs.push(\r\n          module.if(\r\n            module.local_tee(1,\r\n              module.global_get(global.internalName, sizeTypeRef),\r\n              false // internal\r\n            ),\r\n            module.call(visitInstance.internalName, [\r\n              module.local_get(1, sizeTypeRef), // tempRef != null\r\n              module.local_get(0, TypeRef.I32) // cookie\r\n            ], TypeRef.None)\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n  module.addFunction(BuiltinNames.visit_globals,\r\n    TypeRef.I32,  // cookie\r\n    TypeRef.None, // => void\r\n    [ sizeTypeRef ],\r\n    exprs.length\r\n      ? module.block(null, exprs)\r\n      : module.nop()\r\n  );\r\n}\r\n\r\n/** Ensures that the visitor function of the specified class is compiled. */\r\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\r\n  assert(instance.type.isManaged);\r\n  if (instance.visitRef) return;\r\n\r\n  var program = compiler.program;\r\n  var module = compiler.module;\r\n  var usizeType = program.options.usizeType;\r\n  var sizeTypeRef = usizeType.toRef();\r\n  var sizeTypeSize = usizeType.byteSize;\r\n  var visitInstance = assert(program.visitInstance);\r\n  var body = new Array<ExpressionRef>();\r\n\r\n  // If the class has a base class, call its visitor first\r\n  var base = instance.base;\r\n  if (base) {\r\n    body.push(\r\n      module.call(base.internalName + \"~visit\", [\r\n        module.local_get(0, sizeTypeRef), // this\r\n        module.local_get(1, TypeRef.I32)  // cookie\r\n      ], TypeRef.None)\r\n    );\r\n  }\r\n\r\n  // Some standard library components provide a custom visitor implementation,\r\n  // for example to visit all members of a collection, e.g. arrays and maps.\r\n  var hasVisitImpl = false;\r\n  if (instance.isDeclaredInLibrary) {\r\n    let visitPrototype = instance.lookupInSelf(\"__visit\");\r\n    if (visitPrototype) {\r\n      assert(visitPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\r\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\r\n        body.push(\r\n          module.unreachable()\r\n        );\r\n      } else {\r\n        let visitSignature = visitInstance.signature;\r\n        let visitThisType = assert(visitSignature.thisType);\r\n        assert(\r\n          visitSignature.parameterTypes.length == 1 &&\r\n          visitSignature.parameterTypes[0] == Type.u32 &&\r\n          visitSignature.returnType == Type.void &&\r\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\r\n        );\r\n        body.push(\r\n          module.call(visitInstance.internalName, [\r\n            module.local_get(0, sizeTypeRef), // this\r\n            module.local_get(1, TypeRef.I32)  // cookie\r\n          ], TypeRef.None)\r\n        );\r\n      }\r\n      hasVisitImpl = true;\r\n    }\r\n  }\r\n\r\n  // Otherwise, if there is no custom visitor, generate a visitor function\r\n  // according to class layout, visiting all _own_ managed members.\r\n  var needsTempValue = false;\r\n  if (!hasVisitImpl) {\r\n    let members = instance.members;\r\n    if (members) {\r\n      // TODO: for (let member of members.values()) {\r\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\r\n        let member = unchecked(_values[j]);\r\n        if (member.kind == ElementKind.FIELD) {\r\n          if ((<Field>member).parent === instance) {\r\n            let fieldType = (<Field>member).type;\r\n            if (fieldType.isManaged) {\r\n              let fieldOffset = (<Field>member).memoryOffset;\r\n              assert(fieldOffset >= 0);\r\n              needsTempValue = true;\r\n              body.push(\r\n                // if ($2 = value) __visit($2, $1)\r\n                module.if(\r\n                  module.local_tee(2,\r\n                    module.load(sizeTypeSize, false,\r\n                      module.local_get(0, sizeTypeRef),\r\n                      sizeTypeRef, fieldOffset\r\n                    ),\r\n                    false // internal\r\n                  ),\r\n                  module.call(visitInstance.internalName, [\r\n                    module.local_get(2, sizeTypeRef), // value\r\n                    module.local_get(1, TypeRef.I32)  // cookie\r\n                  ], TypeRef.None)\r\n                )\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create the visitor function\r\n  instance.visitRef = module.addFunction(instance.internalName + \"~visit\",\r\n    createType([sizeTypeRef, TypeRef.I32]),\r\n    TypeRef.None,\r\n    needsTempValue ? [ sizeTypeRef ] : null,\r\n    module.flatten(body, TypeRef.None)\r\n  );\r\n\r\n  // And make sure the base visitor function exists\r\n  if (base) ensureVisitMembersOf(compiler, base);\r\n}\r\n\r\n/** Compiles the `__visit_members` function. */\r\nexport function compileVisitMembers(compiler: Compiler): void {\r\n  var program = compiler.program;\r\n  var module = compiler.module;\r\n  var usizeType = program.options.usizeType;\r\n  var sizeTypeRef = usizeType.toRef();\r\n  var managedClasses = program.managedClasses;\r\n  var visitInstance = assert(program.visitInstance);\r\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\r\n\r\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\r\n  // the respective sequential (0..N) class id.\r\n  var names = new Array<string>();\r\n  var cases = new Array<ExpressionRef>();\r\n  var nextId = 0;\r\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\r\n    let instanceId = _keys[i];\r\n    assert(instanceId == nextId++);\r\n    let instance = assert(managedClasses.get(instanceId));\r\n    names[i] = instance.internalName;\r\n    if (instance.isPointerfree) {\r\n      cases[i] = module.return();\r\n    } else {\r\n      cases[i] = module.block(null, [\r\n        module.call(instance.internalName + \"~visit\", [\r\n          module.local_get(0, sizeTypeRef), // this\r\n          module.local_get(1, TypeRef.I32)  // cookie\r\n        ], TypeRef.None),\r\n        module.return()\r\n      ], TypeRef.None);\r\n      ensureVisitMembersOf(compiler, instance);\r\n    }\r\n  }\r\n\r\n  // Make a br_table of the mapping, calling visitor functions by unique class id\r\n  var current = module.block(names[0], [\r\n    module.switch(names, \"invalid\",\r\n      // load<u32>(changetype<usize>(this) - 8)\r\n      module.load(4, false,\r\n        sizeTypeRef == TypeRef.I64\r\n          ? module.binary(BinaryOp.SubI64,\r\n              module.local_get(0, sizeTypeRef),\r\n              module.i64(8)\r\n            )\r\n          : module.binary(BinaryOp.SubI32,\r\n              module.local_get(0, sizeTypeRef),\r\n              module.i32(8) // rtId is at -8\r\n            ),\r\n        TypeRef.I32, 0\r\n      )\r\n    )\r\n  ], TypeRef.None);\r\n\r\n  // Wrap blocks in order\r\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\r\n    current = module.block(names[i + 1], [\r\n      current,\r\n      cases[i]\r\n    ], TypeRef.None);\r\n  }\r\n\r\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\r\n  current = module.block(\"invalid\", [\r\n    current,\r\n    cases[names.length - 1]\r\n  ], TypeRef.None);\r\n\r\n  // Add the function, executing an unreachable if breaking to 'invalid'\r\n  module.addFunction(BuiltinNames.visit_members,\r\n    createType([ sizeTypeRef, TypeRef.I32 ]), // this, cookie\r\n    TypeRef.None, // => void\r\n    null,\r\n    module.flatten([\r\n      current,\r\n      module.unreachable()\r\n    ])\r\n  );\r\n}\r\n\r\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\r\n  var flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\r\n  if (type.is(TypeFlags.SIGNED)) flags |= TypeinfoFlags.VALUE_SIGNED;\r\n  if (type.is(TypeFlags.FLOAT)) flags |= TypeinfoFlags.VALUE_FLOAT;\r\n  if (type.is(TypeFlags.NULLABLE)) flags |= TypeinfoFlags.VALUE_NULLABLE;\r\n  if (type.isManaged) flags |= TypeinfoFlags.VALUE_MANAGED;\r\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\r\n}\r\n\r\n/** Compiles runtime type information for use by stdlib. */\r\nexport function compileRTTI(compiler: Compiler): void {\r\n  var program = compiler.program;\r\n  var module = compiler.module;\r\n  var managedClasses = program.managedClasses;\r\n  var count = managedClasses.size;\r\n  var size = 4 + 8 * count;\r\n  var data = new Uint8Array(size);\r\n  writeI32(count, data, 0);\r\n  var off = 4;\r\n  var abvInstance = program.arrayBufferViewInstance;\r\n  var abvPrototype = abvInstance.prototype;\r\n  var arrayPrototype = program.arrayPrototype;\r\n  var setPrototype = program.setPrototype;\r\n  var mapPrototype = program.mapPrototype;\r\n  var staticArrayPrototype = program.staticArrayPrototype;\r\n  var lastId = 0;\r\n  // TODO: for (let [instanceId, instance] of managedClasses) {\r\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\r\n    let instanceId = unchecked(_keys[i]);\r\n    let instance = assert(managedClasses.get(instanceId));\r\n    assert(instanceId == lastId++);\r\n    let flags: TypeinfoFlags = 0;\r\n    if (instance.isPointerfree) flags |= TypeinfoFlags.POINTERFREE;\r\n    if (instance !== abvInstance && instance.extends(abvPrototype)) {\r\n      let valueType = instance.getArrayValueType();\r\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\r\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\r\n    } else if (instance.extends(arrayPrototype)) {\r\n      let valueType = instance.getArrayValueType();\r\n      flags |= TypeinfoFlags.ARRAY;\r\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\r\n    } else if (instance.extends(setPrototype)) {\r\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\r\n      assert(typeArguments.length == 1);\r\n      flags |= TypeinfoFlags.SET;\r\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\r\n    } else if (instance.extends(mapPrototype)) {\r\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\r\n      assert(typeArguments.length == 2);\r\n      flags |= TypeinfoFlags.MAP;\r\n      flags |= TypeinfoFlags.KEY_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\r\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\r\n    } else if (instance.extends(staticArrayPrototype)) {\r\n      let valueType = instance.getArrayValueType();\r\n      flags |= TypeinfoFlags.STATICARRAY;\r\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\r\n    }\r\n    writeI32(flags, data, off); off += 4;\r\n    instance.rttiFlags = flags;\r\n    let base = instance.base;\r\n    writeI32(base ? base.id : 0, data, off); off += 4;\r\n  }\r\n  assert(off == size);\r\n  var usizeType = program.options.usizeType;\r\n  var segment = compiler.addAlignedMemorySegment(data);\r\n  if (usizeType.size == 8) {\r\n    let offset = segment.offset;\r\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, false, module.i64(i64_low(offset), i64_high(offset)));\r\n  } else {\r\n    module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, false, module.i32(i64_low(segment.offset)));\r\n  }\r\n}\r\n\r\n/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */\r\nexport function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {\r\n  var module = compiler.module;\r\n  var sizeTypeRef = compiler.options.sizeTypeRef;\r\n  var instanceofInstance = assert(prototype.program.instanceofInstance);\r\n  compiler.compileFunction(instanceofInstance);\r\n\r\n  var stmts = new Array<ExpressionRef>();\r\n\r\n  // if (!ref) return false\r\n  stmts.push(\r\n    module.if(\r\n      module.unary(\r\n        sizeTypeRef == TypeRef.I64\r\n          ? UnaryOp.EqzI64\r\n          : UnaryOp.EqzI32,\r\n        module.local_get(0, sizeTypeRef)\r\n      ),\r\n      module.return(\r\n        module.i32(0)\r\n      )\r\n    )\r\n  );\r\n\r\n  // if (__instanceof(ref, ID[i])) return true\r\n  var instances = prototype.instances;\r\n  if (instances !== null && instances.size > 0) {\r\n    // TODO: for (let instance of instances.values()) {\r\n    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\r\n      let instance = unchecked(_values[i]);\r\n      stmts.push(\r\n        module.if(\r\n          module.call(instanceofInstance.internalName, [\r\n            module.local_get(0, sizeTypeRef),\r\n            module.i32(instance.id)\r\n          ], TypeRef.I32),\r\n          module.return(\r\n            module.i32(1)\r\n          )\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  // return false\r\n  stmts.push(\r\n    module.return(\r\n      module.i32(0)\r\n    )\r\n  );\r\n\r\n  module.addFunction(prototype.internalName + \"~instanceof\", sizeTypeRef, TypeRef.I32, null, module.flatten(stmts));\r\n}\r\n\r\n// Helpers\r\n\r\n/** Evaluates the constant type of a type argument *or* expression. */\r\nfunction evaluateConstantType(ctx: BuiltinContext): Type | null {\r\n  var compiler = ctx.compiler;\r\n  var operands = ctx.operands;\r\n  var typeArguments = ctx.typeArguments;\r\n  if (operands.length == 0) { // requires type argument\r\n    if (!typeArguments || typeArguments.length != 1) {\r\n      compiler.error(\r\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\r\n      );\r\n      return null;\r\n    }\r\n    return typeArguments[0];\r\n  }\r\n  if (operands.length == 1) { // optional type argument\r\n    if (typeArguments !== null && typeArguments.length > 0) {\r\n      if (typeArguments.length > 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\r\n        );\r\n        return null;\r\n      }\r\n      compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT);\r\n    } else {\r\n      compiler.compileExpression(operands[0], Type.auto);\r\n    }\r\n    return compiler.currentType;\r\n  }\r\n  if (typeArguments !== null && typeArguments.length > 1) {\r\n    compiler.error(\r\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\r\n    );\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Expected_0_arguments_but_got_1,\r\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\r\n  );\r\n  return null;\r\n}\r\n\r\n/** Evaluates a compile-time constant immediate offset argument.*/\r\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\r\n  var module = compiler.module;\r\n  var value: i32;\r\n  if (compiler.options.isWasm64) {\r\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      assert(getConstValueI64High(precomp) == 0); // TODO\r\n      value = getConstValueI64Low(precomp);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        expression.range\r\n      );\r\n      value = -1;\r\n    }\r\n  } else {\r\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.CONV_IMPLICIT);\r\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n    if (precomp) {\r\n      value = getConstValueI32(precomp);\r\n    } else {\r\n      compiler.error(\r\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\r\n        expression.range\r\n      );\r\n      value = -1;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n/** Evaluates a compile-time constant immediate align argument. */\r\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\r\n  var align = evaluateImmediateOffset(expression, compiler);\r\n  if (align < 0) return align;\r\n  if (align < 1 || naturalAlign > 16) {\r\n    compiler.error(\r\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\r\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\r\n    );\r\n    return -1;\r\n  }\r\n  if (!isPowerOf2(align)) {\r\n    compiler.error(\r\n      DiagnosticCode._0_must_be_a_power_of_two,\r\n      expression.range, \"Alignment\"\r\n    );\r\n    return -1;\r\n  }\r\n  return align;\r\n}\r\n\r\n/** Checks that the specified feature is enabled. */\r\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\r\n  var compiler = ctx.compiler;\r\n  if (!compiler.options.hasFeature(feature)) {\r\n    compiler.error(\r\n      DiagnosticCode.Feature_0_is_not_enabled,\r\n      ctx.reportNode.range, featureToString(feature)\r\n    );\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/** Checks a call with a single required type argument. Returns `1` on error. */\r\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\r\n  var compiler = ctx.compiler;\r\n  var typeArguments = ctx.typeArguments;\r\n  if (typeArguments) {\r\n    let numTypeArguments = typeArguments.length;\r\n    if (numTypeArguments == 1) return 0;\r\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\r\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\r\n    compiler.error(\r\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\r\n    );\r\n  } else {\r\n    compiler.error(\r\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n      ctx.reportNode.range, \"1\", \"0\"\r\n    );\r\n  }\r\n  return 1;\r\n}\r\n\r\n/** Checks a call with a single optional type argument. Returns `1` on error. */\r\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\r\n  var typeArguments = ctx.typeArguments;\r\n  if (typeArguments) {\r\n    let compiler = ctx.compiler;\r\n    let numTypeArguments = typeArguments.length;\r\n    if (numTypeArguments == 1) return 0;\r\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\r\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\r\n    compiler.error(\r\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\r\n    );\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/** Checks a call that is not generic. Returns `1` on error. */\r\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\r\n  var typeArguments = ctx.typeArguments;\r\n  if (typeArguments) {\r\n    let prototype = ctx.prototype;\r\n    prototype.program.error(\r\n      DiagnosticCode.Type_0_is_not_generic,\r\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\r\n    );\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\r\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\r\n  var operands = ctx.operands;\r\n  if (operands.length != expected) {\r\n    ctx.compiler.error(\r\n      DiagnosticCode.Expected_0_arguments_but_got_1,\r\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\r\n    );\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\r\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\r\n  var operands = ctx.operands;\r\n  var numOperands = operands.length;\r\n  if (numOperands < expectedMinimum) {\r\n    ctx.compiler.error(\r\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\r\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\r\n    );\r\n    return 1;\r\n  } else if (numOperands > expectedMaximum) {\r\n    ctx.compiler.error(\r\n      DiagnosticCode.Expected_0_arguments_but_got_1,\r\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\r\n    );\r\n    return 1;\r\n  }\r\n  return 0;\r\n}\r\n\r\n/** Makes an usize constant matching contextual type if reasonable. */\r\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\r\n  var module = compiler.module;\r\n  // Check if contextual type fits\r\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\r\n    switch (contextualType.kind) {\r\n      case TypeKind.I32: {\r\n        if (i64_is_i32(value)) {\r\n          compiler.currentType = Type.i32;\r\n          return module.i32(i64_low(value));\r\n        }\r\n        break;\r\n      }\r\n      case TypeKind.U32: {\r\n        if (i64_is_u32(value)) {\r\n          compiler.currentType = Type.u32;\r\n          return module.i32(i64_low(value));\r\n        }\r\n        break;\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        compiler.currentType = contextualType;\r\n        return module.i64(i64_low(value), i64_high(value));\r\n      }\r\n      // isize/usize falls through\r\n      // small int is probably not intended\r\n    }\r\n  }\r\n  // Default to usize\r\n  if (compiler.options.isWasm64) {\r\n    compiler.currentType = Type.usize64;\r\n    return module.i64(i64_low(value), i64_high(value));\r\n  } else {\r\n    compiler.currentType = Type.usize32;\r\n    assert(!i64_high(value));\r\n    return module.i32(i64_low(value));\r\n  }\r\n}\r\n","/**\r\n * @fileoverview Common constants used by various parts of the compiler.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** Indicates traits of a {@link Node} or {@link Element}. */\r\nexport enum CommonFlags {\r\n  /** No flags set. */\r\n  NONE = 0,\r\n\r\n  // Basic modifiers\r\n\r\n  /** Has an `import` modifier. */\r\n  IMPORT = 1 << 0,\r\n  /** Has an `export` modifier. */\r\n  EXPORT = 1 << 1,\r\n  /** Has a `declare` modifier. */\r\n  DECLARE = 1 << 2,\r\n  /** Has a `const` modifier. */\r\n  CONST = 1 << 3,\r\n  /** Has a `let` modifier. */\r\n  LET = 1 << 4,\r\n  /** Has a `static` modifier. */\r\n  STATIC = 1 << 5,\r\n  /** Has a `readonly` modifier. */\r\n  READONLY = 1 << 6,\r\n  /** Has an `abstract` modifier. */\r\n  ABSTRACT = 1 << 7,\r\n  /** Has a `public` modifier. */\r\n  PUBLIC = 1 << 8,\r\n  /** Has a `private` modifier. */\r\n  PRIVATE = 1 << 9,\r\n  /** Has a `protected` modifier. */\r\n  PROTECTED = 1 << 10,\r\n  /** Has a `get` modifier. */\r\n  GET = 1 << 11,\r\n  /** Has a `set` modifier. */\r\n  SET = 1 << 12,\r\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\r\n  DEFINITELY_ASSIGNED = 1 << 13,\r\n\r\n  // Extended modifiers usually derived from basic modifiers\r\n\r\n  /** Is ambient, that is either declared or nested in a declared element. */\r\n  AMBIENT = 1 << 14,\r\n  /** Is generic. */\r\n  GENERIC = 1 << 15,\r\n  /** Is part of a generic context. */\r\n  GENERIC_CONTEXT = 1 << 16,\r\n  /** Is an instance member. */\r\n  INSTANCE = 1 << 17,\r\n  /** Is a constructor. */\r\n  CONSTRUCTOR = 1 << 18,\r\n  /** Is a module export. */\r\n  MODULE_EXPORT = 1 << 19,\r\n  /** Is a module import. */\r\n  MODULE_IMPORT = 1 << 20,\r\n\r\n  // Compilation states\r\n\r\n  /** Is resolved. */\r\n  RESOLVED = 1 << 21,\r\n  /** Is compiled. */\r\n  COMPILED = 1 << 22,\r\n  /** Did error. */\r\n  ERRORED = 1 << 23,\r\n  /** Has a constant value and is therefore inlined. */\r\n  INLINED = 1 << 24,\r\n  /** Is scoped. */\r\n  SCOPED = 1 << 25,\r\n  /** Is a stub. */\r\n  STUB = 1 << 26,\r\n  /** Is a virtual method. */\r\n  VIRTUAL = 1 << 27,\r\n  /** Is (part of) a closure. */\r\n  CLOSURE = 1 << 28,\r\n\r\n  // Other\r\n\r\n  /** Is quoted. */\r\n  QUOTED = 1 << 29\r\n}\r\n\r\n/** Path delimiter inserted between file system levels. */\r\nexport const PATH_DELIMITER = \"/\";\r\n/** Substitution used to indicate the parent directory. */\r\nexport const PARENT_SUBST = \"..\";\r\n/** Function name prefix used for getters. */\r\nexport const GETTER_PREFIX = \"get:\";\r\n/** Function name prefix used for setters. */\r\nexport const SETTER_PREFIX = \"set:\";\r\n/** Delimiter used between class names and instance members. */\r\nexport const INSTANCE_DELIMITER = \"#\";\r\n/** Delimiter used between class and namespace names and static members. */\r\nexport const STATIC_DELIMITER = \".\";\r\n/** Delimiter used between a function and its inner elements. */\r\nexport const INNER_DELIMITER = \"~\";\r\n/** Substitution used to indicate a library directory. */\r\nexport const LIBRARY_SUBST = \"~lib\";\r\n/** Library directory prefix. */\r\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\r\n/** Path index suffix. */\r\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\r\n/** Stub function delimiter. */\r\nexport const STUB_DELIMITER = \"@\";\r\n\r\n/** Common names. */\r\nexport namespace CommonNames {\r\n  // special\r\n  export const EMPTY = \"\";\r\n  // types\r\n  export const i8 = \"i8\";\r\n  export const i16 = \"i16\";\r\n  export const i32 = \"i32\";\r\n  export const i64 = \"i64\";\r\n  export const isize = \"isize\";\r\n  export const u8 = \"u8\";\r\n  export const u16 = \"u16\";\r\n  export const u32 = \"u32\";\r\n  export const u64 = \"u64\";\r\n  export const usize = \"usize\";\r\n  export const bool = \"bool\";\r\n  export const f32 = \"f32\";\r\n  export const f64 = \"f64\";\r\n  export const v128 = \"v128\";\r\n  export const funcref = \"funcref\";\r\n  export const externref = \"externref\";\r\n  export const anyref = \"anyref\";\r\n  export const eqref = \"eqref\";\r\n  export const i31ref = \"i31ref\";\r\n  export const dataref = \"dataref\";\r\n  export const i8x16 = \"i8x16\";\r\n  export const u8x16 = \"u8x16\";\r\n  export const i16x8 = \"i16x8\";\r\n  export const u16x8 = \"u16x8\";\r\n  export const i32x4 = \"i32x4\";\r\n  export const u32x4 = \"u32x4\";\r\n  export const i64x2 = \"i64x2\";\r\n  export const u64x2 = \"u64x2\";\r\n  export const f32x4 = \"f32x4\";\r\n  export const f64x2 = \"f64x2\";\r\n  export const void_ = \"void\";\r\n  export const number = \"number\";\r\n  export const boolean = \"boolean\";\r\n  export const string = \"string\";\r\n  export const native = \"native\";\r\n  export const indexof = \"indexof\";\r\n  export const valueof = \"valueof\";\r\n  export const returnof = \"returnof\";\r\n  export const nonnull = \"nonnull\";\r\n  // aliases\r\n  export const null_ = \"null\";\r\n  export const true_ = \"true\";\r\n  export const false_ = \"false\";\r\n  // objects\r\n  export const this_ = \"this\";\r\n  export const super_ = \"super\";\r\n  export const constructor = \"constructor\";\r\n  // constants\r\n  export const ASC_TARGET = \"ASC_TARGET\";\r\n  export const ASC_NO_TREESHAKING = \"ASC_NO_TREESHAKING\";\r\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\r\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\r\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\r\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\r\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\r\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\r\n  export const ASC_EXPORT_RUNTIME = \"ASC_EXPORT_RUNTIME\";\r\n  export const ASC_WASI = \"ASC_WASI\";\r\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\r\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\r\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\r\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\r\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\r\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\r\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\r\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\r\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\r\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\r\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\r\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\r\n  export const ASC_VERSION_MAJOR = \"ASC_VERSION_MAJOR\";\r\n  export const ASC_VERSION_MINOR = \"ASC_VERSION_MINOR\";\r\n  export const ASC_VERSION_PATCH = \"ASC_VERSION_PATCH\";\r\n  // classes\r\n  export const I8 = \"I8\";\r\n  export const I16 = \"I16\";\r\n  export const I32 = \"I32\";\r\n  export const I64 = \"I64\";\r\n  export const Isize = \"Isize\";\r\n  export const U8 = \"U8\";\r\n  export const U16 = \"U16\";\r\n  export const U32 = \"U32\";\r\n  export const U64 = \"U64\";\r\n  export const Usize = \"Usize\";\r\n  export const Bool = \"Bool\";\r\n  export const F32 = \"F32\";\r\n  export const F64 = \"F64\";\r\n  export const V128 = \"V128\";\r\n  export const Funcref = \"Funcref\";\r\n  export const Externref = \"Externref\";\r\n  export const Anyref = \"Anyref\";\r\n  export const Eqref = \"Eqref\";\r\n  export const I31ref = \"I31ref\";\r\n  export const Dataref = \"Dataref\";\r\n  export const String = \"String\";\r\n  export const Object = \"Object\";\r\n  export const Array = \"Array\";\r\n  export const StaticArray = \"StaticArray\";\r\n  export const Set = \"Set\";\r\n  export const Map = \"Map\";\r\n  export const Function = \"Function\";\r\n  export const ArrayBufferView = \"ArrayBufferView\";\r\n  export const ArrayBuffer = \"ArrayBuffer\";\r\n  export const Math = \"Math\";\r\n  export const Mathf = \"Mathf\";\r\n  export const NativeMath = \"NativeMath\";\r\n  export const NativeMathf = \"NativeMathf\";\r\n  export const Int8Array = \"Int8Array\";\r\n  export const Int16Array = \"Int16Array\";\r\n  export const Int32Array = \"Int32Array\";\r\n  export const Int64Array = \"Int64Array\";\r\n  export const Uint8Array = \"Uint8Array\";\r\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\r\n  export const Uint16Array = \"Uint16Array\";\r\n  export const Uint32Array = \"Uint32Array\";\r\n  export const Uint64Array = \"Uint64Array\";\r\n  export const Float32Array = \"Float32Array\";\r\n  export const Float64Array = \"Float64Array\";\r\n  export const TemplateStringsArray = \"TemplateStringsArray\";\r\n  export const Error = \"Error\";\r\n  // runtime\r\n  export const abort = \"abort\";\r\n  export const trace = \"trace\";\r\n  export const seed = \"seed\";\r\n  export const pow = \"pow\";\r\n  export const ipow32 = \"ipow32\";\r\n  export const ipow64 = \"ipow64\";\r\n  export const mod = \"mod\";\r\n  export const alloc = \"__alloc\";\r\n  export const realloc = \"__realloc\";\r\n  export const free = \"__free\";\r\n  export const new_ = \"__new\";\r\n  export const renew = \"__renew\";\r\n  export const link = \"__link\";\r\n  export const collect = \"__collect\";\r\n  export const typeinfo = \"__typeinfo\";\r\n  export const instanceof_ = \"__instanceof\";\r\n  export const visit = \"__visit\";\r\n  export const newBuffer = \"__newBuffer\";\r\n  export const newArray = \"__newArray\";\r\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\r\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\r\n}\r\n\r\n// shared\r\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\r\nexport { Target } from \"../std/assembly/shared/target\";\r\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\r\n","/**\r\n * @fileoverview The AssemblyScript compiler.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  BuiltinNames,\r\n  BuiltinContext,\r\n  builtins,\r\n  function_builtins,\r\n  compileVisitGlobals,\r\n  compileVisitMembers,\r\n  compileRTTI,\r\n  compileClassInstanceOf\r\n} from \"./builtins\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Module,\r\n  MemorySegment,\r\n  ExpressionRef,\r\n  UnaryOp,\r\n  BinaryOp,\r\n  RefIsOp,\r\n  TypeRef,\r\n  FunctionRef,\r\n  ExpressionId,\r\n  GlobalRef,\r\n  FeatureFlags,\r\n  Index,\r\n  getExpressionId,\r\n  getExpressionType,\r\n  getConstValueI32,\r\n  getConstValueI64Low,\r\n  getConstValueI64High,\r\n  getConstValueF32,\r\n  getConstValueF64,\r\n  getBlockChildCount,\r\n  getBlockChildAt,\r\n  getBlockName,\r\n  needsExplicitUnreachable,\r\n  getLocalSetValue,\r\n  getGlobalGetName,\r\n  isGlobalMutable,\r\n  createType,\r\n  getSideEffects,\r\n  SideEffects,\r\n  SwitchBuilder,\r\n  ExpressionRunnerFlags,\r\n  isConstZero\r\n} from \"./module\";\r\n\r\nimport {\r\n  CommonFlags,\r\n  INSTANCE_DELIMITER,\r\n  STATIC_DELIMITER,\r\n  GETTER_PREFIX,\r\n  SETTER_PREFIX,\r\n  INDEX_SUFFIX,\r\n  CommonNames,\r\n  Feature,\r\n  Target,\r\n  featureToString\r\n} from \"./common\";\r\n\r\nimport {\r\n  Program,\r\n  ClassPrototype,\r\n  Class,\r\n  Element,\r\n  ElementKind,\r\n  Enum,\r\n  Field,\r\n  FunctionPrototype,\r\n  Function,\r\n  Global,\r\n  Local,\r\n  EnumValue,\r\n  Property,\r\n  VariableLikeElement,\r\n  ConstantValueKind,\r\n  OperatorKind,\r\n  DecoratorFlags,\r\n  PropertyPrototype,\r\n  IndexSignature,\r\n  File,\r\n  mangleInternalName,\r\n  DeclaredElement\r\n} from \"./program\";\r\n\r\nimport {\r\n  FlowFlags,\r\n  Flow,\r\n  LocalFlags,\r\n  FieldFlags,\r\n  ConditionKind,\r\n  findUsedLocals\r\n} from \"./flow\";\r\n\r\nimport {\r\n  Resolver,\r\n  ReportMode\r\n} from \"./resolver\";\r\n\r\nimport {\r\n  Token,\r\n  Range,\r\n  operatorTokenToString\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  Node,\r\n  NodeKind,\r\n  DecoratorKind,\r\n  AssertionKind,\r\n  SourceKind,\r\n  FunctionTypeNode,\r\n\r\n  Statement,\r\n  BlockStatement,\r\n  BreakStatement,\r\n  ClassDeclaration,\r\n  ContinueStatement,\r\n  DeclarationStatement,\r\n  DoStatement,\r\n  EmptyStatement,\r\n  EnumDeclaration,\r\n  ExportDefaultStatement,\r\n  ExportStatement,\r\n  ExpressionStatement,\r\n  FieldDeclaration,\r\n  ForStatement,\r\n  ForOfStatement,\r\n  FunctionDeclaration,\r\n  IfStatement,\r\n  ImportStatement,\r\n  InstanceOfExpression,\r\n  NamespaceDeclaration,\r\n  ReturnStatement,\r\n  SwitchStatement,\r\n  ThrowStatement,\r\n  TryStatement,\r\n  VariableStatement,\r\n  VoidStatement,\r\n  WhileStatement,\r\n\r\n  Expression,\r\n  AssertionExpression,\r\n  BinaryExpression,\r\n  CallExpression,\r\n  CommaExpression,\r\n  ElementAccessExpression,\r\n  FloatLiteralExpression,\r\n  FunctionExpression,\r\n  IdentifierExpression,\r\n  IntegerLiteralExpression,\r\n  LiteralExpression,\r\n  LiteralKind,\r\n  NewExpression,\r\n  ObjectLiteralExpression,\r\n  ParenthesizedExpression,\r\n  PropertyAccessExpression,\r\n  TernaryExpression,\r\n  ArrayLiteralExpression,\r\n  StringLiteralExpression,\r\n  TemplateLiteralExpression,\r\n  UnaryPostfixExpression,\r\n  UnaryPrefixExpression,\r\n  CompiledExpression,\r\n\r\n  TypeNode,\r\n  NamedTypeNode,\r\n\r\n  findDecorator,\r\n  isTypeOmitted\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Type,\r\n  TypeKind,\r\n  TypeFlags,\r\n  Signature,\r\n  typesToRefs\r\n} from \"./types\";\r\n\r\nimport {\r\n  writeI8,\r\n  writeI16,\r\n  writeI32,\r\n  writeI64,\r\n  writeF32,\r\n  writeF64,\r\n  uniqueMap,\r\n  isPowerOf2,\r\n  v128_zero,\r\n  readI32\r\n} from \"./util\";\r\n\r\nimport {\r\n  RtraceMemory\r\n} from \"./passes/rtrace\";\r\n\r\nimport {\r\n  ShadowStackPass\r\n} from \"./passes/shadowstack\";\r\n\r\n/** Compiler options. */\r\nexport class Options {\r\n\r\n  /** WebAssembly target. Defaults to {@link Target.WASM32}. */\r\n  target: Target = Target.WASM32;\r\n  /** If true, replaces assertions with nops. */\r\n  noAssert: bool = false;\r\n  /** It true, exports the memory to the embedder. */\r\n  exportMemory: bool = true;\r\n  /** If true, imports the memory provided by the embedder. */\r\n  importMemory: bool = false;\r\n  /** Initial memory size, in pages. */\r\n  initialMemory: u32 = 0;\r\n  /** Maximum memory size, in pages. */\r\n  maximumMemory: u32 = 0;\r\n  /** If true, memory is declared as shared. */\r\n  sharedMemory: bool = false;\r\n  /** If true, imports the function table provided by the embedder. */\r\n  importTable: bool = false;\r\n  /** If true, exports the function table. */\r\n  exportTable: bool = false;\r\n  /** If true, generates information necessary for source maps. */\r\n  sourceMap: bool = false;\r\n  /** If true, generates an explicit start function. */\r\n  explicitStart: bool = false;\r\n  /** Static memory start offset. */\r\n  memoryBase: u32 = 0;\r\n  /** Static table start offset. */\r\n  tableBase: u32 = 0;\r\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\r\n  globalAliases: Map<string,string> | null = null;\r\n  /** Features to activate by default. These are the finished proposals. */\r\n  features: Feature = Feature.MUTABLE_GLOBALS | Feature.SIGN_EXTENSION;\r\n  /** If true, disallows unsafe features in user code. */\r\n  noUnsafe: bool = false;\r\n  /** If true, enables pedantic diagnostics. */\r\n  pedantic: bool = false;\r\n  /** Indicates a very low (<64k) memory limit. */\r\n  lowMemoryLimit: u32 = 0;\r\n  /** If true, exports the runtime helpers. */\r\n  exportRuntime: bool = false;\r\n  /** Stack size in bytes, if using a stack. */\r\n  stackSize: i32 = 0;\r\n  /** Semantic major bundle version from root package.json */\r\n  bundleMajorVersion: i32 = 0;\r\n  /** Semantic minor bundle version from root package.json */\r\n  bundleMinorVersion: i32 = 0;\r\n  /** Semantic patch bundle version from root package.json */\r\n  bundlePatchVersion: i32 = 0;\r\n\r\n  /** Hinted optimize level. Not applied by the compiler itself. */\r\n  optimizeLevelHint: i32 = 0;\r\n  /** Hinted shrink level. Not applied by the compiler itself. */\r\n  shrinkLevelHint: i32 = 0;\r\n\r\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\r\n  get isWasm64(): bool {\r\n    return this.target == Target.WASM64;\r\n  }\r\n\r\n  /** Gets the unsigned size type matching the target. */\r\n  get usizeType(): Type {\r\n    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;\r\n  }\r\n\r\n  /** Gets the signed size type matching the target. */\r\n  get isizeType(): Type {\r\n    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;\r\n  }\r\n\r\n  /** Gets the size type reference matching the target. */\r\n  get sizeTypeRef(): TypeRef {\r\n    return this.target == Target.WASM64 ? TypeRef.I64 : TypeRef.I32;\r\n  }\r\n\r\n  /** Gets if any optimizations will be performed. */\r\n  get willOptimize(): bool {\r\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\r\n  }\r\n\r\n  /** Tests if a specific feature is activated. */\r\n  hasFeature(feature: Feature): bool {\r\n    return (this.features & feature) != 0;\r\n  }\r\n}\r\n\r\n/** Various constraints in expression compilation. */\r\nexport const enum Constraints {\r\n  NONE = 0,\r\n\r\n  /** Must implicitly convert to the target type. */\r\n  CONV_IMPLICIT = 1 << 0,\r\n  /** Must explicitly convert to the target type. */\r\n  CONV_EXPLICIT = 1 << 1,\r\n  /** Must wrap small integer values to match the target type. */\r\n  MUST_WRAP = 1 << 2,\r\n\r\n  /** Indicates that the value will be dropped immediately. */\r\n  WILL_DROP = 1 << 3,\r\n  /** Indicates that static data is preferred. */\r\n  PREFER_STATIC = 1 << 4,\r\n  /** Indicates that the value will become `this` of a property access or instance call. */\r\n  IS_THIS = 1 << 5\r\n}\r\n\r\n/** Runtime features to be activated by the compiler. */\r\nexport const enum RuntimeFeatures {\r\n  NONE = 0,\r\n  /** Requires data setup. */\r\n  DATA = 1 << 0,\r\n  /** Requires a stack. */\r\n  STACK = 1 << 1,\r\n  /** Requires heap setup. */\r\n  HEAP = 1 << 2,\r\n  /** Requires runtime type information setup. */\r\n  RTTI = 1 << 3,\r\n  /** Requires the built-in globals visitor. */\r\n  visitGlobals = 1 << 4,\r\n  /** Requires the built-in members visitor. */\r\n  visitMembers = 1 << 5,\r\n  /** Requires the setArgumentsLength export. */\r\n  setArgumentsLength = 1 << 6\r\n}\r\n\r\n/** Exported names of compiler-generated elements. */\r\nexport namespace ExportNames {\r\n  /** Name of the explicit start function, if applicable. */\r\n  export const start = \"_start\"; // match WASI\r\n  /** Name of the argumentsLength varargs helper global. */\r\n  export const argumentsLength = \"__argumentsLength\";\r\n  /** Name of the alternative argumentsLength setter function. */\r\n  export const setArgumentsLength = \"__setArgumentsLength\";\r\n  /** Name of the memory instance, if exported. */\r\n  export const memory = \"memory\";\r\n  /** Name of the table instance, if exported. */\r\n  export const table = \"table\";\r\n}\r\n\r\n/** Functions to export if `--exportRuntime` is set. */\r\nconst runtimeFunctions = [ \"__new\", \"__pin\", \"__unpin\", \"__collect\" ];\r\n/** Globals to export if `--exportRuntime` is set. */\r\nconst runtimeGlobals = [ \"__rtti_base\" ];\r\n\r\n/** Compiler interface. */\r\nexport class Compiler extends DiagnosticEmitter {\r\n\r\n  /** Program reference. */\r\n  program: Program;\r\n  /** Resolver reference. */\r\n  get resolver(): Resolver { return this.program.resolver; }\r\n  /** Provided options. */\r\n  get options(): Options { return this.program.options; }\r\n  /** Module instance being compiled. */\r\n  module: Module;\r\n\r\n  /** Current control flow. */\r\n  currentFlow: Flow;\r\n  /** Current parent element if not a function, i.e. an enum or namespace. */\r\n  currentParent: Element | null = null;\r\n  /** Current type in compilation. */\r\n  currentType: Type = Type.void;\r\n  /** Start function statements. */\r\n  currentBody: ExpressionRef[];\r\n  /** Counting memory offset. */\r\n  memoryOffset: i64;\r\n  /** Memory segments being compiled. */\r\n  memorySegments: MemorySegment[] = [];\r\n  /** Map of already compiled static string segments. */\r\n  stringSegments: Map<string,MemorySegment> = new Map();\r\n  /** Function table being compiled. First elem is blank. */\r\n  functionTable: Function[] = [];\r\n  /** Arguments length helper global. */\r\n  builtinArgumentsLength: GlobalRef = 0;\r\n  /** Requires runtime features. */\r\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.NONE;\r\n  /** Current inline functions stack. */\r\n  inlineStack: Function[] = [];\r\n  /** Lazily compiled functions. */\r\n  lazyFunctions: Set<Function> = new Set();\r\n  /** Pending class-specific instanceof helpers. */\r\n  pendingClassInstanceOf: Set<ClassPrototype> = new Set();\r\n  /** Functions potentially involving a virtual call. */\r\n  virtualCalls: Set<Function> = new Set();\r\n  /** Elements currently undergoing compilation. */\r\n  pendingElements: Set<Element> = new Set();\r\n  /** Elements, that are module exports, already processed */\r\n  doneModuleExports: Set<Element> = new Set();\r\n  /** Shadow stack reference. */\r\n  shadowStack!: ShadowStackPass;\r\n\r\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\r\n  static compile(program: Program): Module {\r\n    return new Compiler(program).compile();\r\n  }\r\n\r\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\r\n  constructor(program: Program) {\r\n    super(program.diagnostics);\r\n    this.program = program;\r\n    var options = program.options;\r\n    var module = Module.create(options.stackSize > 0, options.sizeTypeRef);\r\n    this.module = module;\r\n    if (options.memoryBase) {\r\n      this.memoryOffset = i64_new(options.memoryBase);\r\n      module.setLowMemoryUnused(false);\r\n    } else {\r\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\r\n        this.memoryOffset = i64_new(1024);\r\n        module.setLowMemoryUnused(true);\r\n      } else {\r\n        this.memoryOffset = i64_new(8);\r\n        module.setLowMemoryUnused(false);\r\n      }\r\n    }\r\n    var featureFlags: FeatureFlags = 0;\r\n    if (options.hasFeature(Feature.SIGN_EXTENSION)) featureFlags |= FeatureFlags.SignExt;\r\n    if (options.hasFeature(Feature.MUTABLE_GLOBALS)) featureFlags |= FeatureFlags.MutableGloabls;\r\n    if (options.hasFeature(Feature.NONTRAPPING_F2I)) featureFlags |= FeatureFlags.NontrappingFPToInt;\r\n    if (options.hasFeature(Feature.BULK_MEMORY)) featureFlags |= FeatureFlags.BulkMemory;\r\n    if (options.hasFeature(Feature.SIMD)) featureFlags |= FeatureFlags.SIMD128;\r\n    if (options.hasFeature(Feature.THREADS)) featureFlags |= FeatureFlags.Atomics;\r\n    if (options.hasFeature(Feature.EXCEPTION_HANDLING)) featureFlags |= FeatureFlags.ExceptionHandling;\r\n    if (options.hasFeature(Feature.TAIL_CALLS)) featureFlags |= FeatureFlags.TailCall;\r\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) featureFlags |= FeatureFlags.ReferenceTypes;\r\n    if (options.hasFeature(Feature.MULTI_VALUE)) featureFlags |= FeatureFlags.MultiValue;\r\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\r\n    if (options.hasFeature(Feature.MEMORY64)) featureFlags |= FeatureFlags.Memory64;\r\n    module.setFeatures(featureFlags);\r\n\r\n    // set up the main start function\r\n    var startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));\r\n    startFunctionInstance.internalName = BuiltinNames.start;\r\n    this.currentFlow = startFunctionInstance.flow;\r\n    this.currentBody = new Array<ExpressionRef>();\r\n    this.shadowStack = new ShadowStackPass(this);\r\n  }\r\n\r\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\r\n  compile(): Module {\r\n    var options = this.options;\r\n    var module = this.module;\r\n    var program = this.program;\r\n    var hasShadowStack = options.stackSize > 0; // implies runtime=incremental\r\n\r\n    // initialize lookup maps, built-ins, imports, exports, etc.\r\n    this.program.initialize();\r\n\r\n    // obtain the main start function\r\n    var startFunctionInstance = this.currentFlow.actualFunction;\r\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\r\n    var startFunctionBody = this.currentBody;\r\n    assert(startFunctionBody.length == 0);\r\n\r\n    // add mutable data, heap and rtti offset dummies\r\n    if (options.isWasm64) {\r\n      module.addGlobal(BuiltinNames.data_end, TypeRef.I64, true, module.i64(0));\r\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, true, module.i64(0));\r\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I64, true, module.i64(0));\r\n    } else {\r\n      module.addGlobal(BuiltinNames.data_end, TypeRef.I32, true, module.i32(0));\r\n      module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, true, module.i32(0));\r\n      module.addGlobal(BuiltinNames.rtti_base, TypeRef.I32, true, module.i32(0));\r\n    }\r\n\r\n    // compile entry file(s) while traversing reachable elements\r\n    var files = program.filesByName;\r\n    // TODO: for (let file of files.values()) {\r\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\r\n      let file = unchecked(_values[i]);\r\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\r\n        this.compileFile(file);\r\n        this.compileExports(file);\r\n      }\r\n    }\r\n\r\n    // set up module exports\r\n    // TODO: for (let file of this.program.filesByName.values()) {\r\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\r\n      let file = unchecked(_values[i]);\r\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.ensureModuleExports(file);\r\n    }\r\n\r\n    // compile and export runtime if requested\r\n    if (this.options.exportRuntime) {\r\n      for (let i = 0, k = runtimeFunctions.length; i < k; ++i) {\r\n        let name = runtimeFunctions[i];\r\n        let instance = program.requireFunction(name);\r\n        if (this.compileFunction(instance) && !module.hasExport(name)) {\r\n          module.addFunctionExport(instance.internalName, name);\r\n        }\r\n      }\r\n      for (let i = 0, k = runtimeGlobals.length; i < k; ++i) {\r\n        let name = runtimeGlobals[i];\r\n        let instance = program.requireGlobal(name);\r\n        if (this.compileGlobal(instance) && !module.hasExport(name)) {\r\n          module.addGlobalExport(instance.internalName, name);\r\n        }\r\n      }\r\n    }\r\n\r\n    // compile lazy functions\r\n    var lazyFunctions = this.lazyFunctions;\r\n    do {\r\n      let functionsToCompile = new Array<Function>();\r\n      // TODO: for (let instance of lazyLibraryFunctions) {\r\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\r\n        let instance = unchecked(_values[i]);\r\n        functionsToCompile.push(instance);\r\n      }\r\n      lazyFunctions.clear();\r\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\r\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\r\n      }\r\n    } while (lazyFunctions.size);\r\n\r\n    // compile pending class-specific instanceof helpers\r\n    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {\r\n    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {\r\n      let prototype = unchecked(_values[i]);\r\n      compileClassInstanceOf(this, prototype);\r\n    }\r\n\r\n    // set up virtual lookup tables\r\n    var functionTable = this.functionTable;\r\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\r\n      let instance = functionTable[i];\r\n      if (instance.is(CommonFlags.VIRTUAL)) {\r\n        assert(instance.is(CommonFlags.INSTANCE));\r\n        functionTable[i] = this.ensureVirtualStub(instance); // incl. varargs\r\n        this.finalizeVirtualStub(instance);\r\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\r\n        functionTable[i] = this.ensureVarargsStub(instance);\r\n      }\r\n    }\r\n    var virtualCalls = this.virtualCalls;\r\n    while (virtualCalls.size) {\r\n      // finalizing a stub may discover more virtual calls, so do this in a loop\r\n      for (let _values = Set_values(virtualCalls), i = 0, k = _values.length; i < k; ++i) {\r\n        let instance = unchecked(_values[i]);\r\n        this.finalizeVirtualStub(instance);\r\n        virtualCalls.delete(instance);\r\n      }\r\n    }\r\n\r\n    // finalize runtime features\r\n    module.removeGlobal(BuiltinNames.rtti_base);\r\n    if (this.runtimeFeatures & RuntimeFeatures.RTTI) compileRTTI(this);\r\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\r\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\r\n\r\n    var memoryOffset = i64_align(this.memoryOffset, options.usizeType.byteSize);\r\n\r\n    // finalize data\r\n    module.removeGlobal(BuiltinNames.data_end);\r\n    if ((this.runtimeFeatures & RuntimeFeatures.DATA) != 0 || hasShadowStack) {\r\n      if (options.isWasm64) {\r\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I64, false,\r\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\r\n        );\r\n      } else {\r\n        module.addGlobal(BuiltinNames.data_end, TypeRef.I32, false,\r\n          module.i32(i64_low(memoryOffset))\r\n        );\r\n      }\r\n    }\r\n\r\n    // finalize stack (grows down from __heap_base to __data_end)\r\n    module.removeGlobal(BuiltinNames.stack_pointer);\r\n    if ((this.runtimeFeatures & RuntimeFeatures.STACK) != 0 || hasShadowStack) {\r\n      memoryOffset = i64_align(\r\n        i64_add(memoryOffset, i64_new(options.stackSize)),\r\n        options.usizeType.byteSize\r\n      );\r\n      if (options.isWasm64) {\r\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I64, true,\r\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\r\n        );\r\n      } else {\r\n        module.addGlobal(BuiltinNames.stack_pointer, TypeRef.I32, true,\r\n          module.i32(i64_low(memoryOffset))\r\n        );\r\n      }\r\n    }\r\n\r\n    // finalize heap\r\n    module.removeGlobal(BuiltinNames.heap_base);\r\n    if ((this.runtimeFeatures & RuntimeFeatures.HEAP) != 0 || hasShadowStack) {\r\n      if (options.isWasm64) {\r\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I64, false,\r\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\r\n        );\r\n      } else {\r\n        module.addGlobal(BuiltinNames.heap_base, TypeRef.I32, false,\r\n          module.i32(i64_low(memoryOffset))\r\n        );\r\n      }\r\n    }\r\n\r\n    this.memoryOffset = memoryOffset;\r\n\r\n    // check that we didn't exceed lowMemoryLimit already\r\n    var lowMemoryLimit32 = this.options.lowMemoryLimit;\r\n    if (lowMemoryLimit32) {\r\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\r\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\r\n        this.error(\r\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\r\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\r\n        );\r\n      }\r\n    }\r\n\r\n    // set up memory\r\n    var initialPages: u32 = 0;\r\n    if (this.options.memoryBase /* is specified */ || this.memorySegments.length) {\r\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\r\n    }\r\n    if (options.initialMemory) {\r\n      if (options.initialMemory < initialPages) {\r\n        this.error(\r\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\r\n          null,\r\n          initialPages.toString()\r\n        );\r\n      } else {\r\n        initialPages = options.initialMemory;\r\n      }\r\n    }\r\n    var maximumPages = Module.UNLIMITED_MEMORY;\r\n    if (options.maximumMemory) {\r\n      if (options.maximumMemory < initialPages) {\r\n        this.error(\r\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\r\n          null,\r\n          initialPages.toString()\r\n        );\r\n      } else {\r\n        maximumPages = options.maximumMemory;\r\n      }\r\n    }\r\n    var isSharedMemory = false;\r\n    if (options.sharedMemory) {\r\n      isSharedMemory = true;\r\n      if (!options.maximumMemory) {\r\n        this.error(\r\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\r\n          null\r\n        );\r\n        isSharedMemory = false;\r\n      }\r\n      if (!options.hasFeature(Feature.THREADS)) {\r\n        this.error(\r\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\r\n          null\r\n        );\r\n        isSharedMemory = false;\r\n      }\r\n    }\r\n    module.setMemory(\r\n      initialPages,\r\n      maximumPages,\r\n      this.memorySegments,\r\n      options.target,\r\n      options.exportMemory ? ExportNames.memory : null,\r\n      isSharedMemory\r\n    );\r\n\r\n    // import memory if requested (default memory is named '0' by Binaryen)\r\n    if (options.importMemory) module.addMemoryImport(\"0\", \"env\", \"memory\", isSharedMemory);\r\n\r\n    // import and/or export table if requested (default table is named '0' by Binaryen)\r\n    if (options.importTable) {\r\n      module.addTableImport(\"0\", \"env\", \"table\");\r\n      if (options.pedantic && options.willOptimize) {\r\n        this.pedantic(\r\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\r\n          null\r\n        );\r\n      }\r\n    }\r\n    if (options.exportTable) {\r\n      module.addTableExport(\"0\", ExportNames.table);\r\n      if (options.pedantic && options.willOptimize) {\r\n        this.pedantic(\r\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\r\n          null\r\n        );\r\n      }\r\n    }\r\n\r\n    // set up function table (first elem is blank)\r\n    var tableBase = this.options.tableBase;\r\n    if (!tableBase) tableBase = 1; // leave first elem blank\r\n    var functionTableNames = new Array<string>(functionTable.length);\r\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\r\n      functionTableNames[i] = functionTable[i].internalName;\r\n    }\r\n    module.addFunctionTable(\"0\", tableBase + functionTable.length, Module.UNLIMITED_TABLE, functionTableNames, module.i32(tableBase));\r\n\r\n    // expose the arguments length helper if there are varargs exports\r\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\r\n      module.addFunction(BuiltinNames.setArgumentsLength, TypeRef.I32, TypeRef.None, null,\r\n        module.global_set(this.ensureArgumentsLength(), module.local_get(0, TypeRef.I32))\r\n      );\r\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\r\n    }\r\n\r\n    // NOTE: no more element compiles from here. may go to the start function!\r\n\r\n    // compile the start function if not empty or if explicitly requested\r\n    var startIsEmpty = !startFunctionBody.length;\r\n    var explicitStart = program.isWasi || options.explicitStart;\r\n    if (!startIsEmpty || explicitStart) {\r\n      let signature = startFunctionInstance.signature;\r\n      if (!startIsEmpty && explicitStart) {\r\n        module.addGlobal(BuiltinNames.started, TypeRef.I32, true, module.i32(0));\r\n        startFunctionBody.unshift(\r\n          module.global_set(BuiltinNames.started, module.i32(1))\r\n        );\r\n        startFunctionBody.unshift(\r\n          module.if(\r\n            module.global_get(BuiltinNames.started, TypeRef.I32),\r\n            module.return()\r\n          )\r\n        );\r\n      }\r\n      let funcRef = module.addFunction(\r\n        startFunctionInstance.internalName,\r\n        signature.paramRefs,\r\n        signature.resultRefs,\r\n        typesToRefs(startFunctionInstance.additionalLocals),\r\n        module.flatten(startFunctionBody)\r\n      );\r\n      startFunctionInstance.finalize(module, funcRef);\r\n      if (!explicitStart) module.setStart(funcRef);\r\n      else module.addFunctionExport(startFunctionInstance.internalName, ExportNames.start);\r\n    }\r\n\r\n    // Run custom passes\r\n    if (hasShadowStack) {\r\n      this.shadowStack.walkModule();\r\n    }\r\n    if (program.lookup(\"ASC_RTRACE\") != null) {\r\n      new RtraceMemory(this).walkModule();\r\n    }\r\n\r\n    return module;\r\n  }\r\n\r\n  // === Exports ==================================================================================\r\n\r\n  /** Applies the respective module exports for the specified file. */\r\n  private ensureModuleExports(file: File): void {\r\n    var exports = file.exports;\r\n    if (exports) {\r\n      // TODO: for (let [elementName, element] of exports) {\r\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\r\n        let elementName = unchecked(_keys[i]);\r\n        let element = assert(exports.get(elementName));\r\n        this.ensureModuleExport(elementName, element);\r\n      }\r\n    }\r\n    var exportsStar = file.exportsStar;\r\n    if (exportsStar)  {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        this.ensureModuleExports(exportsStar[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Applies the respective module export(s) for the specified element. */\r\n  private ensureModuleExport(name: string, element: Element, prefix: string = \"\"): void {\r\n    var module = this.module;\r\n    switch (element.kind) {\r\n\r\n      // traverse instances\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        let functionPrototype = <FunctionPrototype>element;\r\n        let functionInstances = functionPrototype.instances;\r\n        if (functionInstances !== null && functionInstances.size > 0) {\r\n          // TODO: for (let instance of instances.values()) {\r\n          for (let _values = Map_values(functionInstances), i = 0, k = _values.length; i < k; ++i) {\r\n            let instance = unchecked(_values[i]);\r\n            let instanceName = name;\r\n            if (instance.is(CommonFlags.GENERIC)) {\r\n              let fullName = instance.internalName;\r\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\r\n            }\r\n            this.ensureModuleExport(instanceName, instance, prefix);\r\n          }\r\n        } else if (functionPrototype.is(CommonFlags.GENERIC)) {\r\n          if (this.options.pedantic) {\r\n            this.pedantic(\r\n              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\r\n              functionPrototype.identifierNode.range\r\n            );\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.CLASS_PROTOTYPE: {\r\n        let classPrototype = <ClassPrototype>element;\r\n        let classInstances = classPrototype.instances;\r\n        if (classInstances !== null && classInstances.size > 0) {\r\n          // TODO: for (let instance of instances.values()) {\r\n          for (let _values = Map_values(classInstances), i = 0, k = _values.length; i < k; ++i) {\r\n            let instance = unchecked(_values[i]);\r\n            let instanceName = name;\r\n            if (instance.is(CommonFlags.GENERIC)) {\r\n              let fullName = instance.internalName;\r\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\r\n            }\r\n            this.ensureModuleExport(instanceName, instance, prefix);\r\n          }\r\n        } else if (classPrototype.is(CommonFlags.GENERIC)) {\r\n          if (this.options.pedantic) {\r\n            this.pedantic(\r\n              DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\r\n              classPrototype.identifierNode.range\r\n            );\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyInstance = (<PropertyPrototype>element).instance;\r\n        if (propertyInstance) this.ensureModuleExport(name, propertyInstance, prefix);\r\n        break;\r\n      }\r\n\r\n      // export concrete elements\r\n      case ElementKind.GLOBAL: {\r\n        let global = <Global>element;\r\n        let isConst = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\r\n        if (!isConst && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_export_a_mutable_global,\r\n            global.identifierNode.range\r\n          );\r\n        } else if (global.is(CommonFlags.COMPILED)) {\r\n          let exportName = prefix + name;\r\n          if (!module.hasExport(exportName)) {\r\n            module.addGlobalExport(element.internalName, exportName);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.ENUMVALUE: {\r\n        let enumValue = <EnumValue>element;\r\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_export_a_mutable_global,\r\n            enumValue.identifierNode.range\r\n          );\r\n        } else if (enumValue.is(CommonFlags.COMPILED)) {\r\n          let exportName = prefix + name;\r\n          if (!module.hasExport(exportName)) {\r\n            module.addGlobalExport(element.internalName, exportName);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.FUNCTION: {\r\n        let functionInstance = <Function>element;\r\n        if (!functionInstance.hasDecorator(DecoratorFlags.BUILTIN)) {\r\n          let signature = functionInstance.signature;\r\n          if (signature.requiredParameters < signature.parameterTypes.length) {\r\n            // utilize varargs stub to fill in omitted arguments\r\n            functionInstance = this.ensureVarargsStub(functionInstance);\r\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\r\n          }\r\n          if (functionInstance.is(CommonFlags.COMPILED)) {\r\n            let exportName = prefix + name;\r\n            if (!module.hasExport(exportName)) {\r\n              module.addFunctionExport(functionInstance.internalName, exportName);\r\n              if (signature.hasManagedOperands) {\r\n                this.shadowStack.noteExport(exportName, signature.getManagedOperandIndices());\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY: {\r\n        let propertyInstance = <Property>element;\r\n        let getterInstance = propertyInstance.getterInstance;\r\n        if (getterInstance) this.ensureModuleExport(GETTER_PREFIX + name, getterInstance, prefix);\r\n        let setterInstance = propertyInstance.setterInstance;\r\n        if (setterInstance) this.ensureModuleExport(SETTER_PREFIX + name, setterInstance, prefix);\r\n        break;\r\n      }\r\n      case ElementKind.FIELD: {\r\n        let fieldInstance = <Field>element;\r\n        if (element.is(CommonFlags.COMPILED)) {\r\n          let getterExportName = prefix + GETTER_PREFIX + name;\r\n          if (this.compileFieldGetter(fieldInstance) && !module.hasExport(getterExportName)) {\r\n            module.addFunctionExport(fieldInstance.internalGetterName, getterExportName);\r\n            let signature = fieldInstance.internalGetterSignature;\r\n            if (signature.hasManagedOperands) {\r\n              this.shadowStack.noteExport(getterExportName, signature.getManagedOperandIndices());\r\n            }\r\n          }\r\n          if (!element.is(CommonFlags.READONLY)) {\r\n            let setterExportName = prefix + SETTER_PREFIX + name;\r\n            if (this.compileFieldSetter(fieldInstance) && !module.hasExport(setterExportName)) {\r\n              module.addFunctionExport(fieldInstance.internalSetterName, setterExportName);\r\n              let signature = fieldInstance.internalSetterSignature;\r\n              if (signature.hasManagedOperands) {\r\n                this.shadowStack.noteExport(setterExportName, signature.getManagedOperandIndices());\r\n              }\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.CLASS: {\r\n        let classInstance = <Class>element;\r\n        // make the class name itself represent its runtime id\r\n        if (!classInstance.type.isUnmanaged) {\r\n          let module = this.module;\r\n          let internalName = classInstance.internalName;\r\n\r\n          if (!this.doneModuleExports.has(element)) {\r\n            module.addGlobal(internalName, TypeRef.I32, false, module.i32(classInstance.id));\r\n            this.doneModuleExports.add(element);\r\n          }\r\n          module.addGlobalExport(internalName, prefix + name);\r\n        }\r\n        break;\r\n      }\r\n\r\n      // just traverse members below\r\n      case ElementKind.ENUM:\r\n      case ElementKind.INTERFACE_PROTOTYPE:\r\n      case ElementKind.NAMESPACE:\r\n      case ElementKind.TYPEDEFINITION:\r\n      case ElementKind.INDEXSIGNATURE: break;\r\n\r\n      default: assert(false); // unexpected module export\r\n    }\r\n\r\n    // traverse members\r\n    var members = element.members;\r\n    if (members) {\r\n      let subPrefix = prefix + name + (element.kind == ElementKind.CLASS\r\n        ? INSTANCE_DELIMITER\r\n        : STATIC_DELIMITER\r\n      );\r\n      if (element.kind == ElementKind.NAMESPACE) {\r\n        let implicitExport = element.is(CommonFlags.SCOPED);\r\n        // TODO: for (let [memberName, member] of members) {\r\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\r\n          let memberName = unchecked(_keys[i]);\r\n          let member = assert(members.get(memberName));\r\n          if (implicitExport || member.is(CommonFlags.EXPORT)) {\r\n            this.ensureModuleExport(memberName, member, subPrefix);\r\n          }\r\n        }\r\n      } else {\r\n        // TODO: for (let [memberName, member] of members) {\r\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\r\n          let memberName = unchecked(_keys[i]);\r\n          let member = assert(members.get(memberName));\r\n          if (!member.is(CommonFlags.PRIVATE)) {\r\n            this.ensureModuleExport(memberName, member, subPrefix);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // === Elements =================================================================================\r\n\r\n  /** Compiles any element. */\r\n  compileElement(element: Element, compileMembers: bool = true): void {\r\n    switch (element.kind) {\r\n      case ElementKind.GLOBAL: {\r\n        this.compileGlobal(<Global>element);\r\n        break;\r\n      }\r\n      case ElementKind.ENUM: {\r\n        this.compileEnum(<Enum>element);\r\n        break;\r\n      }\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        if (!element.is(CommonFlags.GENERIC)) {\r\n          let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\r\n          if (functionInstance) this.compileFunction(functionInstance);\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.CLASS_PROTOTYPE: {\r\n        if (!element.is(CommonFlags.GENERIC)) {\r\n          let classInstance = this.resolver.resolveClass(<ClassPrototype>element, null);\r\n          if (classInstance) this.compileClass(classInstance);\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\r\n        if (propertyInstance) this.compileProperty(propertyInstance);\r\n        break;\r\n      }\r\n      case ElementKind.INTERFACE_PROTOTYPE:\r\n      case ElementKind.NAMESPACE:\r\n      case ElementKind.TYPEDEFINITION:\r\n      case ElementKind.ENUMVALUE:\r\n      case ElementKind.INDEXSIGNATURE: break;\r\n      default: assert(false);\r\n    }\r\n    if (compileMembers) {\r\n      let members = element.members;\r\n      if (members) {\r\n        // TODO: for (let element of members.values()) {\r\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n          let element = unchecked(_values[i]);\r\n          this.compileElement(element);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Compiles a file's exports. */\r\n  compileExports(file: File): void {\r\n    var exports = file.exports;\r\n    if (exports) {\r\n      // TODO: for (let element of exports.values()) {\r\n      for (let _values = Map_values(exports), i = 0, k = _values.length; i < k; ++i) {\r\n        let element = unchecked(_values[i]);\r\n        if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileElement(element);\r\n      }\r\n    }\r\n    var exportsStar = file.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        let exportStar = unchecked(exportsStar[i]);\r\n        this.compileFile(exportStar);\r\n        this.compileExports(exportStar);\r\n      }\r\n    }\r\n  }\r\n\r\n  // files\r\n\r\n  /** Compiles the file matching the specified path. */\r\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\r\n    var file: File;\r\n    var filesByName = this.program.filesByName;\r\n    var pathWithIndex: string;\r\n    if (filesByName.has(normalizedPathWithoutExtension)) {\r\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\r\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\r\n      file = assert(filesByName.get(pathWithIndex));\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.File_0_not_found,\r\n        reportNode.range, normalizedPathWithoutExtension\r\n      );\r\n      return;\r\n    }\r\n    this.compileFile(file);\r\n  }\r\n\r\n  /** Compiles the specified file. */\r\n  compileFile(file: File): void {\r\n    if (file.is(CommonFlags.COMPILED)) return;\r\n    file.set(CommonFlags.COMPILED);\r\n\r\n    // compile top-level statements within the file's start function\r\n    var startFunction = file.startFunction;\r\n    var startSignature = startFunction.signature;\r\n    var previousBody = this.currentBody;\r\n    var startFunctionBody = new Array<ExpressionRef>();\r\n    this.currentBody = startFunctionBody;\r\n\r\n    // compile top-level statements\r\n    var previousFlow = this.currentFlow;\r\n    var flow = startFunction.flow;\r\n    this.currentFlow = flow;\r\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\r\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\r\n    }\r\n    // no need to insert unreachable since last statement should have done that\r\n    this.currentFlow = previousFlow;\r\n    this.currentBody = previousBody;\r\n\r\n    // if top-level statements are present, make the per-file start function and call it in start\r\n    if (startFunctionBody.length) {\r\n      let module = this.module;\r\n      let locals = startFunction.localsByIndex;\r\n      let numLocals = locals.length;\r\n      let varTypes = new Array<TypeRef>(numLocals);\r\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toRef();\r\n      module.addFunction(\r\n        startFunction.internalName,\r\n        startSignature.paramRefs,\r\n        startSignature.resultRefs,\r\n        varTypes,\r\n        module.flatten(startFunctionBody)\r\n      );\r\n      previousBody.push(\r\n        module.call(startFunction.internalName, null, TypeRef.None)\r\n      );\r\n    }\r\n  }\r\n\r\n  // === Globals ==================================================================================\r\n\r\n  /** Compiles a global variable. */\r\n  compileGlobal(global: Global): bool {\r\n    if (global.is(CommonFlags.COMPILED)) return !global.is(CommonFlags.ERRORED);\r\n    global.set(CommonFlags.COMPILED);\r\n\r\n    var pendingElements = this.pendingElements;\r\n    pendingElements.add(global);\r\n\r\n    var module = this.module;\r\n    var initExpr: ExpressionRef = 0;\r\n    var typeNode = global.typeNode;\r\n    var initializerNode = global.initializerNode;\r\n\r\n    if (!global.is(CommonFlags.RESOLVED)) {\r\n\r\n      // Resolve type if annotated\r\n      if (typeNode) {\r\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\r\n        if (!resolvedType) {\r\n          global.set(CommonFlags.ERRORED);\r\n          pendingElements.delete(global);\r\n          return false;\r\n        }\r\n        if (resolvedType == Type.void) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            typeNode.range\r\n          );\r\n          global.set(CommonFlags.ERRORED);\r\n          pendingElements.delete(global);\r\n          return false;\r\n        }\r\n        global.setType(resolvedType);\r\n        this.checkTypeSupported(global.type, typeNode);\r\n\r\n      // Otherwise infer type from initializer\r\n      } else if (initializerNode) {\r\n        let previousFlow = this.currentFlow;\r\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\r\n          this.currentFlow = global.file.startFunction.flow;\r\n        }\r\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\r\n          Constraints.MUST_WRAP | Constraints.PREFER_STATIC\r\n        );\r\n        this.currentFlow = previousFlow;\r\n        if (this.currentType == Type.void) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\r\n          );\r\n          global.set(CommonFlags.ERRORED);\r\n          pendingElements.delete(global);\r\n          return false;\r\n        }\r\n        global.setType(this.currentType);\r\n\r\n      // Error if there's neither a type nor an initializer\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          global.identifierNode.range.atEnd\r\n        );\r\n        global.set(CommonFlags.ERRORED);\r\n        pendingElements.delete(global);\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\r\n    if (global.is(CommonFlags.AMBIENT) && global.hasDecorator(DecoratorFlags.BUILTIN)) {\r\n      let internalName = global.internalName;\r\n      if (internalName == BuiltinNames.data_end) this.runtimeFeatures |= RuntimeFeatures.DATA;\r\n      else if (internalName == BuiltinNames.stack_pointer) this.runtimeFeatures |= RuntimeFeatures.STACK;\r\n      else if (internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.HEAP;\r\n      else if (internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.RTTI;\r\n      pendingElements.delete(global);\r\n      return true;\r\n    }\r\n\r\n    var type = global.type;\r\n    var typeRef = type.toRef();\r\n    var isDeclaredConstant = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\r\n    var isDeclaredInline = global.hasDecorator(DecoratorFlags.INLINE);\r\n\r\n    // Handle imports\r\n    if (global.is(CommonFlags.AMBIENT)) {\r\n\r\n      // Constant global or mutable globals enabled\r\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\r\n        global.set(CommonFlags.MODULE_IMPORT);\r\n        mangleImportName(global, global.declaration);\r\n        module.addGlobalImport(\r\n          global.internalName,\r\n          mangleImportName_moduleName,\r\n          mangleImportName_elementName,\r\n          typeRef,\r\n          !isDeclaredConstant\r\n        );\r\n        pendingElements.delete(global);\r\n        return true;\r\n      }\r\n\r\n      // Importing mutable globals is not supported in the MVP\r\n      this.error(\r\n        DiagnosticCode.Feature_0_is_not_enabled,\r\n        global.declaration.range, \"mutable-globals\"\r\n      );\r\n      global.set(CommonFlags.ERRORED);\r\n      pendingElements.delete(global);\r\n      return false;\r\n    }\r\n\r\n    // The MVP does not yet support initializer expressions other than constants and gets of\r\n    // imported immutable globals, hence such initializations must be performed in the start.\r\n    var initializeInStart = false;\r\n\r\n    // Evaluate initializer if present\r\n    if (initializerNode) {\r\n      if (!initExpr) {\r\n        let previousFlow = this.currentFlow;\r\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\r\n          this.currentFlow = global.file.startFunction.flow;\r\n        }\r\n        initExpr = this.compileExpression(initializerNode, type,\r\n          Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP | Constraints.PREFER_STATIC\r\n        );\r\n        this.currentFlow = previousFlow;\r\n      }\r\n\r\n      // If not a constant, attempt to precompute\r\n      if (getExpressionId(initExpr) != ExpressionId.Const) {\r\n        if (isDeclaredConstant) {\r\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\r\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\r\n            if (precomp) {\r\n              initExpr = precomp;\r\n            } else {\r\n              initializeInStart = true;\r\n            }\r\n          }\r\n        } else {\r\n          initializeInStart = true;\r\n        }\r\n      }\r\n\r\n      // Handle special case of initializing from imported immutable global\r\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\r\n        let fromName = assert(getGlobalGetName(initExpr));\r\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\r\n          let elementsByName = this.program.elementsByName;\r\n          if (elementsByName.has(fromName)) {\r\n            let global = assert(elementsByName.get(fromName));\r\n            if (global.is(CommonFlags.AMBIENT)) initializeInStart = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Explicitly inline if annotated\r\n      if (isDeclaredInline) {\r\n        if (initializeInStart) {\r\n          this.warning(\r\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\r\n            initializerNode.range\r\n          );\r\n        } else {\r\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\r\n          let exprType = getExpressionType(initExpr);\r\n          switch (<u32>exprType) {\r\n            case <u32>TypeRef.I32: {\r\n              global.constantValueKind = ConstantValueKind.INTEGER;\r\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\r\n              break;\r\n            }\r\n            case <u32>TypeRef.I64: {\r\n              global.constantValueKind = ConstantValueKind.INTEGER;\r\n              global.constantIntegerValue = i64_new(\r\n                getConstValueI64Low(initExpr),\r\n                getConstValueI64High(initExpr)\r\n              );\r\n              break;\r\n            }\r\n            case <u32>TypeRef.F32: {\r\n              global.constantValueKind = ConstantValueKind.FLOAT;\r\n              global.constantFloatValue = getConstValueF32(initExpr);\r\n              break;\r\n            }\r\n            case <u32>TypeRef.F64: {\r\n              global.constantValueKind = ConstantValueKind.FLOAT;\r\n              global.constantFloatValue = getConstValueF64(initExpr);\r\n              break;\r\n            }\r\n            default: {\r\n              assert(false);\r\n              global.set(CommonFlags.ERRORED);\r\n              pendingElements.delete(global);\r\n              return false;\r\n            }\r\n          }\r\n          global.set(CommonFlags.INLINED); // inline the value from now on\r\n        }\r\n      }\r\n\r\n    // Initialize to zero if there's no initializer\r\n    } else {\r\n      if (global.is(CommonFlags.INLINED)) {\r\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PREFER_STATIC);\r\n      } else {\r\n        initExpr = this.makeZero(type, global.declaration);\r\n      }\r\n    }\r\n\r\n    var internalName = global.internalName;\r\n\r\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\r\n      if (isDeclaredInline) {\r\n        this.error(\r\n          DiagnosticCode.Decorator_0_is_not_valid_here,\r\n          findDecorator(DecoratorKind.INLINE, global.decoratorNodes)!.range, \"inline\"\r\n        );\r\n      }\r\n      module.addGlobal(internalName, typeRef, true, this.makeZero(type, global.declaration));\r\n      this.currentBody.push(\r\n        module.global_set(internalName, initExpr)\r\n      );\r\n    } else if (!isDeclaredInline) { // compile normally\r\n      module.addGlobal(internalName, typeRef, !isDeclaredConstant, initExpr);\r\n    }\r\n    pendingElements.delete(global);\r\n    return true;\r\n  }\r\n\r\n  // === Enums ====================================================================================\r\n\r\n  /** Compiles an enum. */\r\n  compileEnum(element: Enum): bool {\r\n    if (element.is(CommonFlags.COMPILED)) return !element.is(CommonFlags.ERRORED);\r\n    element.set(CommonFlags.COMPILED);\r\n\r\n    var pendingElements = this.pendingElements;\r\n    pendingElements.add(element);\r\n\r\n    var module = this.module;\r\n    var previousParent = this.currentParent;\r\n    this.currentParent = element;\r\n    var previousValue: EnumValue | null = null;\r\n    var previousValueIsMut = false;\r\n    var isInline = element.is(CommonFlags.CONST) || element.hasDecorator(DecoratorFlags.INLINE);\r\n\r\n    var members = element.members;\r\n    if (members) {\r\n      // TODO: for (let member of element.members.values()) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace\r\n        let initInStart = false;\r\n        let enumValue = <EnumValue>member;\r\n        let valueNode = enumValue.valueNode;\r\n        enumValue.set(CommonFlags.COMPILED);\r\n        let previousFlow = this.currentFlow;\r\n        if (element.hasDecorator(DecoratorFlags.LAZY)) {\r\n          this.currentFlow = element.file.startFunction.flow;\r\n        }\r\n        let initExpr: ExpressionRef;\r\n        if (valueNode) {\r\n          initExpr = this.compileExpression(valueNode, Type.i32,\r\n            Constraints.CONV_IMPLICIT\r\n          );\r\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\r\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\r\n            if (precomp) {\r\n              initExpr = precomp;\r\n            } else {\r\n              if (element.is(CommonFlags.CONST)) {\r\n                this.error(\r\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\r\n                  valueNode.range\r\n                );\r\n              }\r\n              initInStart = true;\r\n            }\r\n          }\r\n        } else if (previousValue == null) {\r\n          initExpr = module.i32(0);\r\n        } else {\r\n          if (previousValueIsMut) {\r\n            this.error(\r\n              DiagnosticCode.Enum_member_must_have_initializer,\r\n              enumValue.identifierNode.range.atEnd\r\n            );\r\n          }\r\n          if (isInline) {\r\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\r\n            assert(!i64_high(value));\r\n            initExpr = module.i32(i64_low(value));\r\n          } else {\r\n            initExpr = module.binary(BinaryOp.AddI32,\r\n              module.global_get(previousValue.internalName, TypeRef.I32),\r\n              module.i32(1)\r\n            );\r\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\r\n            if (precomp) {\r\n              initExpr = precomp;\r\n            } else {\r\n              if (element.is(CommonFlags.CONST)) {\r\n                this.error(\r\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\r\n                  member.declaration.range\r\n                );\r\n              }\r\n              initInStart = true;\r\n            }\r\n          }\r\n        }\r\n        this.currentFlow = previousFlow;\r\n        if (initInStart) {\r\n          module.addGlobal(enumValue.internalName, TypeRef.I32, true, module.i32(0));\r\n          this.currentBody.push(\r\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\r\n          );\r\n          previousValueIsMut = true;\r\n        } else {\r\n          if (isInline) {\r\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\r\n            if (enumValue.is(CommonFlags.MODULE_EXPORT)) {\r\n              module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\r\n            }\r\n          } else {\r\n            module.addGlobal(enumValue.internalName, TypeRef.I32, false, initExpr);\r\n          }\r\n          enumValue.isImmutable = true;\r\n          previousValueIsMut = false;\r\n        }\r\n        previousValue = enumValue;\r\n      }\r\n    }\r\n    this.currentParent = previousParent;\r\n    pendingElements.delete(element);\r\n    return true;\r\n  }\r\n\r\n  // === Functions ================================================================================\r\n\r\n  /** Compiles a priorly resolved function. */\r\n  compileFunction(\r\n    /** Function to compile. */\r\n    instance: Function,\r\n    /** Force compilation of stdlib alternative if a builtin. */\r\n    forceStdAlternative: bool = false\r\n  ): bool {\r\n    if (instance.is(CommonFlags.COMPILED)) return !instance.is(CommonFlags.ERRORED);\r\n\r\n    if (!forceStdAlternative) {\r\n      if (instance.hasDecorator(DecoratorFlags.BUILTIN)) return true;\r\n      if (instance.hasDecorator(DecoratorFlags.LAZY)) {\r\n        this.lazyFunctions.add(instance);\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // ensure the function hasn't duplicate parameters\r\n    var parameters = instance.prototype.functionTypeNode.parameters;\r\n    var numParameters = parameters.length;\r\n    if (numParameters >= 2) {\r\n      let visited = new Set<string>();\r\n      visited.add(parameters[0].name.text);\r\n      for (let i = 1; i < numParameters; i++) {\r\n        let paramIdentifier = parameters[i].name;\r\n        let paramName = paramIdentifier.text;\r\n        if (!visited.has(paramName)) {\r\n          visited.add(paramName);\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            paramIdentifier.range, paramName\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    instance.set(CommonFlags.COMPILED);\r\n    var pendingElements = this.pendingElements;\r\n    pendingElements.add(instance);\r\n\r\n    var previousType = this.currentType;\r\n    var module = this.module;\r\n    var signature = instance.signature;\r\n    var bodyNode = instance.prototype.bodyNode;\r\n    var declarationNode = instance.declaration;\r\n    assert(declarationNode.kind == NodeKind.FUNCTIONDECLARATION || declarationNode.kind == NodeKind.METHODDECLARATION);\r\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\r\n\r\n    var funcRef: FunctionRef;\r\n\r\n    // concrete function\r\n    if (bodyNode) {\r\n\r\n      // must not be ambient\r\n      if (instance.is(CommonFlags.AMBIENT)) {\r\n        this.error(\r\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\r\n          instance.identifierNode.range\r\n        );\r\n      }\r\n\r\n      // cannot have an annotated external name\r\n      if (instance.hasDecorator(DecoratorFlags.EXTERNAL)) {\r\n        let decoratorNodes = instance.decoratorNodes;\r\n        let decorator = assert(findDecorator(DecoratorKind.EXTERNAL, decoratorNodes));\r\n        this.error(\r\n          DiagnosticCode.Decorator_0_is_not_valid_here,\r\n          decorator.range, \"external\"\r\n        );\r\n      }\r\n\r\n      // compile body in this function's context\r\n      let previousFlow = this.currentFlow;\r\n      let flow = instance.flow;\r\n      this.currentFlow = flow;\r\n      let stmts = new Array<ExpressionRef>();\r\n\r\n      if (!this.compileFunctionBody(instance, stmts)) {\r\n        stmts.push(module.unreachable());\r\n      }\r\n\r\n      this.currentFlow = previousFlow;\r\n\r\n      // create the function\r\n      funcRef = module.addFunction(\r\n        instance.internalName,\r\n        signature.paramRefs,\r\n        signature.resultRefs,\r\n        typesToRefs(instance.additionalLocals),\r\n        module.flatten(stmts, instance.signature.returnType.toRef())\r\n      );\r\n\r\n    // imported function\r\n    } else if (instance.is(CommonFlags.AMBIENT)) {\r\n      instance.set(CommonFlags.MODULE_IMPORT);\r\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\r\n      module.addFunctionImport(\r\n        instance.internalName,\r\n        mangleImportName_moduleName,\r\n        mangleImportName_elementName,\r\n        signature.paramRefs,\r\n        signature.resultRefs\r\n      );\r\n      funcRef = module.getFunction(instance.internalName);\r\n\r\n    // abstract or interface function\r\n    } else if (instance.is(CommonFlags.ABSTRACT) || instance.parent.kind == ElementKind.INTERFACE) {\r\n      funcRef = module.addFunction(\r\n        instance.internalName,\r\n        signature.paramRefs,\r\n        signature.resultRefs,\r\n        null,\r\n        module.unreachable()\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n        instance.identifierNode.range\r\n      );\r\n      funcRef = 0; // TODO?\r\n      instance.set(CommonFlags.ERRORED);\r\n    }\r\n\r\n    instance.finalize(module, funcRef);\r\n    this.currentType = previousType;\r\n    pendingElements.delete(instance);\r\n    return true;\r\n  }\r\n\r\n  /** Compiles the body of a function within the specified flow. */\r\n  private compileFunctionBody(\r\n    /** Function to compile. */\r\n    instance: Function,\r\n    /** Target array of statements also being returned. Creates a new array if omitted. */\r\n    stmts: ExpressionRef[]\r\n  ): bool {\r\n    var module = this.module;\r\n    var bodyNode = assert(instance.prototype.bodyNode);\r\n    var returnType = instance.signature.returnType;\r\n    var flow = this.currentFlow;\r\n    var thisLocal = instance.signature.thisType\r\n      ? assert(flow.lookupLocal(CommonNames.this_))\r\n      : null;\r\n    var bodyStartIndex = stmts.length;\r\n\r\n    // compile statements\r\n    if (bodyNode.kind == NodeKind.BLOCK) {\r\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);\r\n    } else {\r\n      // must be an expression statement if not a block\r\n      assert(bodyNode.kind == NodeKind.EXPRESSION);\r\n\r\n      // must be an arrow function\r\n      assert(instance.prototype.arrowKind);\r\n\r\n      // none of the following can be an arrow function\r\n      assert(!instance.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.GET | CommonFlags.SET));\r\n\r\n      let expr = this.compileExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.CONV_IMPLICIT);\r\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\r\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\r\n\r\n      if (!stmts) stmts = [ expr ];\r\n      else stmts.push(expr);\r\n\r\n      if (!flow.is(FlowFlags.TERMINATES)) {\r\n        if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\r\n        if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\r\n        flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\r\n      }\r\n    }\r\n\r\n    // Make constructors return their instance pointer, and prepend a conditional\r\n    // allocation if any code path accesses `this`.\r\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\r\n      assert(instance.is(CommonFlags.INSTANCE));\r\n      thisLocal = assert(thisLocal);\r\n      let parent = assert(instance.parent);\r\n      assert(parent.kind == ElementKind.CLASS);\r\n      let classInstance = <Class>parent;\r\n\r\n      if (flow.isAny(FlowFlags.ACCESSES_THIS | FlowFlags.CONDITIONALLY_ACCESSES_THIS) || !flow.is(FlowFlags.TERMINATES)) {\r\n\r\n        // Allocate `this` if not a super call, and initialize fields\r\n        let allocStmts = new Array<ExpressionRef>();\r\n        allocStmts.push(\r\n          this.makeConditionalAllocation(classInstance, thisLocal.index)\r\n        );\r\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\r\n\r\n        // Insert right before the body\r\n        for (let i = stmts.length - 1; i >= bodyStartIndex; --i) {\r\n          stmts[i + 1] = stmts[i];\r\n        }\r\n        stmts[bodyStartIndex] = module.flatten(allocStmts, TypeRef.None);\r\n\r\n        // Just prepended allocation is dropped when returning non-'this'\r\n        if (flow.is(FlowFlags.MAY_RETURN_NONTHIS)) {\r\n          if (this.options.pedantic) {\r\n            this.pedantic(\r\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\r\n              instance.identifierNode.range\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      // Returning something else than 'this' would break 'super()' calls\r\n      if (flow.is(FlowFlags.MAY_RETURN_NONTHIS) && !classInstance.hasDecorator(DecoratorFlags.FINAL)) {\r\n        this.error(\r\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\r\n          classInstance.identifierNode.range\r\n        );\r\n      }\r\n\r\n      // Implicitly return `this` if the flow falls through\r\n      if (!flow.is(FlowFlags.TERMINATES)) {\r\n        stmts.push(\r\n          module.local_get(thisLocal.index, this.options.sizeTypeRef)\r\n        );\r\n        flow.set(FlowFlags.RETURNS | FlowFlags.RETURNS_NONNULL | FlowFlags.TERMINATES);\r\n      }\r\n\r\n      // check that super has been called if this is a derived class\r\n      if (classInstance.base !== null && !flow.is(FlowFlags.CALLS_SUPER)) {\r\n        this.error(\r\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\r\n          instance.prototype.declaration.range\r\n        );\r\n      }\r\n\r\n    // if this is a normal function, make sure that all branches terminate\r\n    } else if (returnType != Type.void && !flow.is(FlowFlags.TERMINATES)) {\r\n      this.error(\r\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\r\n        instance.prototype.functionTypeNode.returnType.range\r\n      );\r\n      return false; // not recoverable\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // === Classes ==================================================================================\r\n\r\n  /** Compiles a priorly resolved class. */\r\n  compileClass(instance: Class): bool {\r\n    if (instance.is(CommonFlags.COMPILED)) return true;\r\n    instance.set(CommonFlags.COMPILED);\r\n    var prototype = instance.prototype;\r\n    var staticMembers = (<ClassPrototype>prototype).members;\r\n    if (staticMembers) {\r\n      // TODO: for (let element of staticMembers.values()) {\r\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\r\n        let element = unchecked(_values[i]);\r\n        switch (element.kind) {\r\n          case ElementKind.GLOBAL: {\r\n            this.compileGlobal(<Global>element);\r\n            break;\r\n          }\r\n          case ElementKind.FUNCTION_PROTOTYPE: {\r\n            if (element.is(CommonFlags.GENERIC)) break;\r\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\r\n            if (!functionInstance) break;\r\n            element = functionInstance;\r\n            // fall-through\r\n          }\r\n          case ElementKind.FUNCTION: {\r\n            this.compileFunction(<Function>element);\r\n            break;\r\n          }\r\n          case ElementKind.PROPERTY_PROTOTYPE: {\r\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\r\n            if (!propertyInstance) break;\r\n            element = propertyInstance;\r\n            // fall-through\r\n          }\r\n          case ElementKind.PROPERTY: {\r\n            this.compileProperty(<Property>element);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.ensureConstructor(instance, instance.identifierNode);\r\n    this.checkFieldInitialization(instance);\r\n\r\n    var instanceMembers = instance.members;\r\n    if (instanceMembers) {\r\n      // TODO: for (let element of instanceMembers.values()) {\r\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\r\n        let element = unchecked(_values[i]);\r\n        switch (element.kind) {\r\n          case ElementKind.FUNCTION_PROTOTYPE: {\r\n            if (element.is(CommonFlags.GENERIC)) break;\r\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\r\n            if (!functionInstance) break;\r\n            element = functionInstance;\r\n            // fall-through\r\n          }\r\n          case ElementKind.FUNCTION: {\r\n            this.compileFunction(<Function>element);\r\n            break;\r\n          }\r\n          case ElementKind.FIELD: {\r\n            this.compileField(<Field>element);\r\n            break;\r\n          }\r\n          case ElementKind.PROPERTY_PROTOTYPE: {\r\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\r\n            if (!propertyInstance) break;\r\n            element = propertyInstance;\r\n            // fall-through\r\n          }\r\n          case ElementKind.PROPERTY: {\r\n            this.compileProperty(<Property>element);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Compiles an instance field to a getter and a setter. */\r\n  compileField(instance: Field): bool {\r\n    this.compileFieldGetter(instance);\r\n    this.compileFieldSetter(instance);\r\n    return instance.is(CommonFlags.COMPILED);\r\n  }\r\n\r\n  /** Compiles the getter of the specified instance field. */\r\n  compileFieldGetter(instance: Field): bool {\r\n    if (instance.getterRef) return true;\r\n    var module = this.module;\r\n    var valueType = instance.type;\r\n    var valueTypeRef = valueType.toRef();\r\n    var thisTypeRef = this.options.sizeTypeRef;\r\n    // return this.field\r\n    instance.getterRef = module.addFunction(instance.internalGetterName, thisTypeRef, valueTypeRef, null,\r\n      module.load(valueType.byteSize, valueType.isSignedIntegerValue,\r\n        module.local_get(0, thisTypeRef),\r\n        valueTypeRef, instance.memoryOffset\r\n      )\r\n    );\r\n    if (instance.setterRef) {\r\n      instance.set(CommonFlags.COMPILED);\r\n    } else {\r\n      let typeNode = instance.typeNode;\r\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Compiles the setter of the specified instance field. */\r\n  compileFieldSetter(instance: Field): bool {\r\n    if (instance.setterRef) return true;\r\n    var type = instance.type;\r\n    var thisTypeRef = this.options.sizeTypeRef;\r\n    var valueTypeRef = type.toRef();\r\n    var module = this.module;\r\n    // void(this.field = value)\r\n    var bodyExpr = module.store(type.byteSize,\r\n      module.local_get(0, thisTypeRef),\r\n      module.local_get(1, valueTypeRef),\r\n      valueTypeRef, instance.memoryOffset\r\n    );\r\n    if (type.isManaged) {\r\n      let parent = instance.parent;\r\n      assert(parent.kind == ElementKind.CLASS);\r\n      if ((<Class>parent).type.isManaged) {\r\n        let linkInstance = this.program.linkInstance;\r\n        this.compileFunction(linkInstance);\r\n        bodyExpr = module.block(null, [\r\n          bodyExpr,\r\n          module.call(linkInstance.internalName, [\r\n            module.local_get(0, thisTypeRef),\r\n            module.local_get(1, valueTypeRef),\r\n            module.i32(0)\r\n          ], TypeRef.None)\r\n        ], TypeRef.None);\r\n      }\r\n    }\r\n    instance.setterRef = module.addFunction(instance.internalSetterName, createType([ thisTypeRef, valueTypeRef ]), TypeRef.None, null,\r\n      bodyExpr\r\n    );\r\n    if (instance.getterRef) {\r\n      instance.set(CommonFlags.COMPILED);\r\n    } else {\r\n      let typeNode = instance.typeNode;\r\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Compiles a property to a getter and potentially a setter. */\r\n  compileProperty(instance: Property): bool {\r\n    this.compilePropertyGetter(instance);\r\n    this.compilePropertySetter(instance);\r\n    return instance.is(CommonFlags.COMPILED);\r\n  }\r\n\r\n  /* Compiles the getter of the specified property. */\r\n  compilePropertyGetter(instance: Property): bool {\r\n    var getterInstance = instance.getterInstance;\r\n    if (getterInstance) {\r\n      let ret = this.compileFunction(getterInstance);\r\n      let setterInstance = instance.setterInstance;\r\n      if (getterInstance.is(CommonFlags.COMPILED) && (!setterInstance || setterInstance.is(CommonFlags.COMPILED))) {\r\n        instance.set(CommonFlags.COMPILED);\r\n      }\r\n      return ret;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Compiles the setter of the specified property. */\r\n  compilePropertySetter(instance: Property): bool {\r\n    var setterInstance = instance.setterInstance;\r\n    if (setterInstance) {\r\n      let ret = this.compileFunction(setterInstance);\r\n      let getterInstance = instance.getterInstance;\r\n      if (getterInstance !== null && getterInstance.is(CommonFlags.COMPILED) && setterInstance.is(CommonFlags.COMPILED)) {\r\n        instance.set(CommonFlags.COMPILED);\r\n      }\r\n      return ret;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // === Memory ===================================================================================\r\n\r\n  /** Adds a static memory segment with the specified data. */\r\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\r\n    assert(isPowerOf2(alignment));\r\n    var memoryOffset = i64_align(this.memoryOffset, alignment);\r\n    var segment = new MemorySegment(buffer, memoryOffset);\r\n    this.memorySegments.push(segment);\r\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\r\n    return segment;\r\n  }\r\n\r\n  /** Adds a static memory segment representing a runtime object. */\r\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\r\n    var memoryOffset = this.program.computeBlockStart64(this.memoryOffset);\r\n    var segment = new MemorySegment(buffer, memoryOffset);\r\n    this.memorySegments.push(segment);\r\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length));\r\n    return segment;\r\n  }\r\n\r\n  /** Ensures that a string exists in static memory and returns a pointer expression. Deduplicates. */\r\n  ensureStaticString(stringValue: string): ExpressionRef {\r\n    var ptr = this.ensureStaticStringPtr(stringValue);\r\n    this.currentType = this.program.stringInstance.type;\r\n    return this.module.usize(ptr);\r\n  }\r\n\r\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\r\n  ensureStaticStringPtr(stringValue: string): i64 {\r\n    var program = this.program;\r\n    var totalOverhead = program.totalOverhead;\r\n    var stringInstance = assert(program.stringInstance);\r\n    var stringSegment: MemorySegment;\r\n    var segments = this.stringSegments;\r\n    if (segments.has(stringValue)) {\r\n      stringSegment = assert(segments.get(stringValue)); // reuse\r\n    } else {\r\n      let len = stringValue.length;\r\n      let buf = stringInstance.createBuffer(len << 1);\r\n      for (let i = 0; i < len; ++i) {\r\n        writeI16(stringValue.charCodeAt(i), buf, totalOverhead + (i << 1));\r\n      }\r\n      stringSegment = this.addRuntimeMemorySegment(buf);\r\n      segments.set(stringValue, stringSegment);\r\n    }\r\n    return i64_add(stringSegment.offset, i64_new(totalOverhead));\r\n  }\r\n\r\n  /** Writes a series of static values of the specified type to a buffer. */\r\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\r\n    var length = values.length;\r\n    var byteSize = elementType.byteSize;\r\n    var elementTypeRef = elementType.toRef();\r\n    switch (<u32>elementTypeRef) {\r\n      case <u32>TypeRef.I32: {\r\n        switch (byteSize) {\r\n          case 1: {\r\n            for (let i = 0; i < length; ++i) {\r\n              let value = values[i];\r\n              assert(getExpressionType(value) == elementTypeRef);\r\n              assert(getExpressionId(value) == ExpressionId.Const);\r\n              writeI8(getConstValueI32(value), buf, pos);\r\n              pos += 1;\r\n            }\r\n            break;\r\n          }\r\n          case 2: {\r\n            for (let i = 0; i < length; ++i) {\r\n              let value = values[i];\r\n              assert(getExpressionType(value) == elementTypeRef);\r\n              assert(getExpressionId(value) == ExpressionId.Const);\r\n              writeI16(getConstValueI32(value), buf, pos);\r\n              pos += 2;\r\n            }\r\n            break;\r\n          }\r\n          case 4: {\r\n            for (let i = 0; i < length; ++i) {\r\n              let value = values[i];\r\n              assert(getExpressionType(value) == elementTypeRef);\r\n              assert(getExpressionId(value) == ExpressionId.Const);\r\n              writeI32(getConstValueI32(value), buf, pos);\r\n              pos += 4;\r\n            }\r\n            break;\r\n          }\r\n          default: assert(false);\r\n        }\r\n        break;\r\n      }\r\n      case <u32>TypeRef.I64: {\r\n        for (let i = 0; i < length; ++i) {\r\n          let value = values[i];\r\n          assert(getExpressionType(value) == elementTypeRef);\r\n          assert(getExpressionId(value) == ExpressionId.Const);\r\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\r\n          pos += 8;\r\n        }\r\n        break;\r\n      }\r\n      case <u32>TypeRef.F32: {\r\n        for (let i = 0; i < length; ++i) {\r\n          let value = values[i];\r\n          assert(getExpressionType(value) == elementTypeRef);\r\n          assert(getExpressionId(value) == ExpressionId.Const);\r\n          writeF32(getConstValueF32(value), buf, pos);\r\n          pos += 4;\r\n        }\r\n        break;\r\n      }\r\n      case <u32>TypeRef.F64: {\r\n        for (let i = 0; i < length; ++i) {\r\n          let value = values[i];\r\n          assert(getExpressionType(value) == elementTypeRef);\r\n          assert(getExpressionId(value) == ExpressionId.Const);\r\n          writeF64(getConstValueF64(value), buf, pos);\r\n          pos += 8;\r\n        }\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n    return pos;\r\n  }\r\n\r\n  /** Adds a buffer to static memory and returns the created segment. */\r\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\r\n    var program = this.program;\r\n    var arrayBufferInstance = program.arrayBufferInstance;\r\n    var buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\r\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\r\n    this.writeStaticBuffer(buf, program.totalOverhead, elementType, values);\r\n    return this.addRuntimeMemorySegment(buf);\r\n  }\r\n\r\n  /** Adds an array header to static memory and returns the created segment. */\r\n  private addStaticArrayHeader(\r\n    elementType: Type,\r\n    bufferSegment: MemorySegment,\r\n    /** Optional array instance override. */\r\n    arrayInstance: Class | null = null\r\n  ): MemorySegment {\r\n    var program = this.program;\r\n    if (!arrayInstance) {\r\n      arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ elementType ]));\r\n    }\r\n    var bufferLength = readI32(bufferSegment.buffer, program.OBJECTInstance.offsetof(\"rtSize\"));\r\n    var arrayLength = i32(bufferLength / elementType.byteSize);\r\n    var bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\r\n    var buf = arrayInstance.createBuffer();\r\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\r\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\r\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\r\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\r\n    return this.addRuntimeMemorySegment(buf);\r\n  }\r\n\r\n  // === Table ====================================================================================\r\n\r\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\r\n  ensureRuntimeFunction(instance: Function): i64 {\r\n    assert(instance.is(CommonFlags.COMPILED) && !instance.is(CommonFlags.STUB));\r\n    var program = this.program;\r\n    var memorySegment = instance.memorySegment;\r\n    if (!memorySegment) {\r\n\r\n      // Add to the function table\r\n      let functionTable = this.functionTable;\r\n      let tableBase = this.options.tableBase;\r\n      if (!tableBase) tableBase = 1; // leave first elem blank\r\n      let index = tableBase + functionTable.length;\r\n      functionTable.push(instance);\r\n\r\n      // Create runtime function\r\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\r\n      let buf = rtInstance.createBuffer();\r\n      assert(rtInstance.writeField(\"_index\", index, buf));\r\n      assert(rtInstance.writeField(\"_env\", 0, buf));\r\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\r\n    }\r\n    return i64_add(memorySegment.offset, i64_new(program.totalOverhead));\r\n  }\r\n\r\n  // === Statements ===============================================================================\r\n\r\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\r\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\r\n    switch (statement.kind) {\r\n      case NodeKind.CLASSDECLARATION: {\r\n        let memberStatements = (<ClassDeclaration>statement).members;\r\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\r\n          this.compileTopLevelStatement(memberStatements[i], body);\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.ENUMDECLARATION: {\r\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\r\n        if (element) {\r\n          assert(element.kind == ElementKind.ENUM);\r\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileEnum(<Enum>element);\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.NAMESPACEDECLARATION: {\r\n        let declaration = <NamespaceDeclaration>statement;\r\n        let element = this.program.getElementByDeclaration(declaration);\r\n        if (element) {\r\n          // any potentiall merged element\r\n          let previousParent = this.currentParent;\r\n          this.currentParent = element;\r\n          let memberStatements = declaration.members;\r\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\r\n            this.compileTopLevelStatement(memberStatements[i], body);\r\n          }\r\n          this.currentParent = previousParent;\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.VARIABLE: {\r\n        let declarations = (<VariableStatement>statement).declarations;\r\n        for (let i = 0, k = declarations.length; i < k; ++i) {\r\n          let element = this.program.getElementByDeclaration(declarations[i]);\r\n          if (element) {\r\n            assert(element.kind == ElementKind.GLOBAL);\r\n            if (\r\n              !element.is(CommonFlags.AMBIENT) && // delay imports\r\n              !element.hasDecorator(DecoratorFlags.LAZY)\r\n            ) this.compileGlobal(<Global>element);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.FIELDDECLARATION: {\r\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\r\n        if (element !== null && element.kind == ElementKind.GLOBAL) { // static\r\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileGlobal(<Global>element);\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.EXPORT: {\r\n        let exportStatement = <ExportStatement>statement;\r\n        let internalPath = exportStatement.internalPath;\r\n        if (internalPath !== null) {\r\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\r\n        }\r\n        break;\r\n      }\r\n      case NodeKind.EXPORTDEFAULT: {\r\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\r\n        break;\r\n      }\r\n      case NodeKind.IMPORT: {\r\n        let importStatement = <ImportStatement>statement;\r\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTIONDECLARATION:\r\n      case NodeKind.METHODDECLARATION:\r\n      case NodeKind.INTERFACEDECLARATION:\r\n      case NodeKind.INDEXSIGNATURE:\r\n      case NodeKind.TYPEDECLARATION: break;\r\n      default: { // otherwise a top-level statement that is part of the start function's body\r\n        let stmt = this.compileStatement(statement);\r\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Compiles a statement. */\r\n  compileStatement(\r\n    /** Statement to compile. */\r\n    statement: Statement,\r\n    /** Whether this is the last statement of the body, if known. */\r\n    isLastInBody: bool = false\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var stmt: ExpressionRef;\r\n    switch (statement.kind) {\r\n      case NodeKind.BLOCK: {\r\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.BREAK: {\r\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.CONTINUE: {\r\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.DO: {\r\n        stmt = this.compileDoStatement(<DoStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.EMPTY: {\r\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.EXPRESSION: {\r\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.FOR: {\r\n        stmt = this.compileForStatement(<ForStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.FOROF: {\r\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.IF: {\r\n        stmt = this.compileIfStatement(<IfStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.RETURN: {\r\n        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);\r\n        break;\r\n      }\r\n      case NodeKind.SWITCH: {\r\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.THROW: {\r\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.TRY: {\r\n        stmt = this.compileTryStatement(<TryStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.VARIABLE: {\r\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\r\n        if (!stmt) stmt = module.nop();\r\n        break;\r\n      }\r\n      case NodeKind.VOID: {\r\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.WHILE: {\r\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\r\n        break;\r\n      }\r\n      case NodeKind.TYPEDECLARATION: {\r\n        // TODO: integrate inner type declaration into flow\r\n        this.error(\r\n          DiagnosticCode.Not_implemented_0,\r\n          statement.range,\r\n          \"Inner type alias\"\r\n        );\r\n        stmt = module.unreachable();\r\n        break;\r\n      }\r\n      default: {\r\n        assert(false);\r\n        stmt = module.unreachable();\r\n      }\r\n    }\r\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\r\n    return stmt;\r\n  }\r\n\r\n  /** Compiles a series of statements. */\r\n  compileStatements(\r\n    /** Statements to compile. */\r\n    statements: Statement[],\r\n    /** Whether this is an immediate body statement. */\r\n    isBody: bool = false,\r\n    /** Statements to append to that is also returned. Created if omitted. */\r\n    stmts: ExpressionRef[] | null = null\r\n  ): ExpressionRef[] {\r\n    var numStatements = statements.length;\r\n    if (!stmts) {\r\n      stmts = new Array<ExpressionRef>(numStatements);\r\n      stmts.length = 0;\r\n    }\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    for (let i = 0; i < numStatements; ++i) {\r\n      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);\r\n      switch (getExpressionId(stmt)) {\r\n        case ExpressionId.Block: {\r\n          if (!getBlockName(stmt)) {\r\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\r\n            break;\r\n          }\r\n          // fall-through\r\n        }\r\n        default: stmts.push(stmt);\r\n        case ExpressionId.Nop:\r\n      }\r\n      if (flow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\r\n        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());\r\n        break;\r\n      }\r\n    }\r\n    return stmts;\r\n  }\r\n\r\n  private compileBlockStatement(\r\n    statement: BlockStatement\r\n  ): ExpressionRef {\r\n    var statements = statement.statements;\r\n    var outerFlow = this.currentFlow;\r\n    var innerFlow = outerFlow.fork();\r\n    this.currentFlow = innerFlow;\r\n\r\n    var stmts = this.compileStatements(statements);\r\n    innerFlow.freeScopedLocals();\r\n    outerFlow.inherit(innerFlow);\r\n    this.currentFlow = outerFlow;\r\n    return this.module.flatten(stmts);\r\n  }\r\n\r\n  private compileBreakStatement(\r\n    statement: BreakStatement\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var labelNode = statement.label;\r\n    if (labelNode) {\r\n      this.error(\r\n        DiagnosticCode.Not_implemented_0,\r\n        labelNode.range,\r\n        \"Break label\"\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    var flow = this.currentFlow;\r\n    var breakLabel = flow.breakLabel;\r\n    if (breakLabel == null) {\r\n      this.error(\r\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\r\n        statement.range\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    flow.freeScopedLocals();\r\n    flow.set(FlowFlags.BREAKS);\r\n    return module.br(breakLabel);\r\n  }\r\n\r\n  private compileContinueStatement(\r\n    statement: ContinueStatement\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var label = statement.label;\r\n    if (label) {\r\n      this.error(\r\n        DiagnosticCode.Not_implemented_0,\r\n        label.range,\r\n        \"Continue label\"\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    // Check if 'continue' is allowed here\r\n    var flow = this.currentFlow;\r\n    var continueLabel = flow.continueLabel;\r\n    if (continueLabel == null) {\r\n      this.error(\r\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\r\n        statement.range\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    flow.set(FlowFlags.CONTINUES | FlowFlags.TERMINATES);\r\n    flow.freeScopedLocals();\r\n    return module.br(continueLabel);\r\n  }\r\n\r\n  private compileDoStatement(\r\n    /** Statement to compile. */\r\n    statement: DoStatement\r\n  ): ExpressionRef {\r\n    return this.doCompileDoStatement(statement, null);\r\n  }\r\n\r\n  private doCompileDoStatement(\r\n    /** Statement to compile. */\r\n    statement: DoStatement,\r\n    /** If recompiling, the flow with differing local flags that triggered it. */\r\n    flowAfter: Flow | null\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var outerFlow = this.currentFlow;\r\n\r\n    // (block $break                           flow\r\n    //  (loop $continue                          recompile?\r\n    //   (body)                                  bodyFlow \r\n    //                                                    \r\n    //                                                   breaks or terminates?\r\n    //   (local.set $tcond (condition))         condFlow \r\n    //                                                   \r\n    //   (br_if (local.get $tcond) $continue)  condition?\r\n    //  )                                     \r\n    // )                                      \r\n\r\n    var label = outerFlow.pushBreakLabel();\r\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\r\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\r\n    var flowBefore = flow.fork();\r\n    this.currentFlow = flow;\r\n\r\n    var breakLabel = \"do-break|\" + label;\r\n    flow.breakLabel = breakLabel;\r\n    var continueLabel = \"do-continue|\" + label;\r\n    flow.continueLabel = continueLabel;\r\n\r\n    // Compile the body (always executes)\r\n    var bodyFlow = flow.fork();\r\n    this.currentFlow = bodyFlow;\r\n    var bodyStmts = new Array<ExpressionRef>();\r\n    var body = statement.statement;\r\n    if (body.kind == NodeKind.BLOCK) {\r\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\r\n    } else {\r\n      bodyStmts.push(this.compileStatement(body));\r\n    }\r\n\r\n    // Shortcut if body never falls through\r\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\r\n      bodyStmts.push(\r\n        module.unreachable()\r\n      );\r\n      flow.inherit(bodyFlow);\r\n\r\n    // Otherwise evaluate the condition\r\n    } else {\r\n      let condFlow = flow.fork();\r\n      this.currentFlow = condFlow;\r\n      let condExpr = this.makeIsTrueish(\r\n        this.compileExpression(statement.condition, Type.i32),\r\n        this.currentType,\r\n        statement.condition\r\n      );\r\n      let condKind = this.evaluateCondition(condExpr);\r\n\r\n      // Shortcut if condition is always false\r\n      if (condKind == ConditionKind.FALSE) {\r\n        bodyStmts.push(\r\n          module.drop(condExpr)\r\n        );\r\n        flow.inherit(bodyFlow);\r\n\r\n      // Terminate if condition is always true and body never breaks\r\n      } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\r\n        bodyStmts.push(\r\n          module.drop(condExpr)\r\n        );\r\n        bodyStmts.push(\r\n          module.br(continueLabel)\r\n        );\r\n        flow.set(FlowFlags.TERMINATES);\r\n\r\n      } else {\r\n        let tcond = condFlow.getTempLocal(Type.bool);\r\n        bodyStmts.push(\r\n          module.local_set(tcond.index, condExpr, false) // bool\r\n        );\r\n        bodyStmts.push(\r\n          module.br(continueLabel,\r\n            module.local_get(tcond.index, TypeRef.I32)\r\n          )\r\n        );\r\n        condFlow.freeTempLocal(tcond);\r\n        flow.inherit(condFlow);\r\n\r\n        // Detect if local flags are incompatible before and after looping, and\r\n        // if so recompile by unifying local flags between iterations. Note that\r\n        // this may be necessary multiple times where locals depend on each other.\r\n        if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\r\n          outerFlow.popBreakLabel();\r\n          this.currentFlow = outerFlow;\r\n          return this.doCompileDoStatement(statement, flow);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Finalize\r\n    assert(!flow.hasScopedLocals);\r\n    outerFlow.inherit(flow);\r\n    outerFlow.popBreakLabel();\r\n    this.currentFlow = outerFlow;\r\n    var expr = module.block(breakLabel, [\r\n      module.loop(continueLabel,\r\n        module.flatten(bodyStmts)\r\n      )\r\n    ]);\r\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\r\n      expr = module.block(null, [ expr, module.unreachable() ]);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  private compileEmptyStatement(\r\n    statement: EmptyStatement\r\n  ): ExpressionRef {\r\n    return this.module.nop();\r\n  }\r\n\r\n  private compileExpressionStatement(\r\n    statement: ExpressionStatement\r\n  ): ExpressionRef {\r\n    return this.compileExpression(statement.expression, Type.void, Constraints.CONV_IMPLICIT);\r\n  }\r\n\r\n  private compileForStatement(\r\n    /** Statement to compile. */\r\n    statement: ForStatement\r\n  ): ExpressionRef {\r\n    return this.doCompileForStatement(statement, null);\r\n  }\r\n\r\n  private doCompileForStatement(\r\n    /** Statement to compile. */\r\n    statement: ForStatement,\r\n    /** If recompiling, the flow with differing local flags that triggered it. */\r\n    flowAfter: Flow | null\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var outerFlow = this.currentFlow;\r\n\r\n    // (initializer)                   flow\r\n    // (block $break                    \r\n    //  (loop $loop                      recompile?\r\n    //   (local.set $tcond (condition))  condFlow \r\n    //                                            \r\n    //   (if (local.get $tcond)                    condition?\r\n    //    (block $continue                         \r\n    //     (body)                       bodyFlow \r\n    //                                           \r\n    //    )                                      breaks or terminates?\r\n    //    (incrementor)                 incrFlow \r\n    //                                           \r\n    //                                 \r\n    //    (br $loop)                  \r\n    //   )                              \r\n    //  )                               \r\n    // )                                \r\n    //                                \r\n\r\n    var label = outerFlow.pushBreakLabel();\r\n    var stmts = new Array<ExpressionRef>();\r\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\r\n    this.currentFlow = flow;\r\n\r\n    var breakLabel = \"for-break\" + label;\r\n    flow.breakLabel = breakLabel;\r\n    var continueLabel = \"for-continue|\" + label;\r\n    flow.continueLabel = continueLabel;\r\n    var loopLabel = \"for-loop|\" + label;\r\n\r\n    // Compile initializer if present\r\n    var initializer = statement.initializer;\r\n    if (initializer) {\r\n      assert(\r\n        initializer.kind == NodeKind.EXPRESSION ||\r\n        initializer.kind == NodeKind.VARIABLE\r\n      );\r\n      stmts.push(this.compileStatement(initializer));\r\n    }\r\n\r\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\r\n    var flowBefore = flow.fork();\r\n\r\n    // Precompute the condition\r\n    var condFlow = flow.fork();\r\n    this.currentFlow = condFlow;\r\n    var condExpr: ExpressionRef;\r\n    var condKind: ConditionKind;\r\n    var condition = statement.condition;\r\n    if (condition) {\r\n      condExpr = this.makeIsTrueish(\r\n        this.compileExpression(condition, Type.bool),\r\n        this.currentType,\r\n        condition\r\n      );\r\n      condKind = this.evaluateCondition(condExpr);\r\n\r\n      // Shortcut if condition is always false (body never runs)\r\n      if (condKind == ConditionKind.FALSE) {\r\n        stmts.push(\r\n          module.drop(condExpr)\r\n        );\r\n        condFlow.freeScopedLocals();\r\n        flow.inherit(condFlow);\r\n        flow.freeScopedLocals();\r\n        outerFlow.inherit(flow);\r\n        outerFlow.popBreakLabel();\r\n        this.currentFlow = outerFlow;\r\n        return module.flatten(stmts);\r\n      }\r\n    } else {\r\n      condExpr = module.i32(1);\r\n      condKind = ConditionKind.TRUE;\r\n    }\r\n\r\n    // From here on condition is either always true or unknown\r\n\r\n    // Store condition result in a temp\r\n    var tcond = flow.getTempLocal(Type.bool);\r\n    var loopStmts = new Array<ExpressionRef>();\r\n    loopStmts.push(\r\n      module.local_set(tcond.index, condExpr, false) // bool\r\n    );\r\n    condFlow.freeScopedLocals();\r\n\r\n    flow.inherit(condFlow); // always executes\r\n    this.currentFlow = flow;\r\n\r\n    // Compile the body assuming the condition turned out true\r\n    var bodyFlow = flow.fork();\r\n    bodyFlow.inheritNonnullIfTrue(condExpr);\r\n    this.currentFlow = bodyFlow;\r\n    var bodyStmts = new Array<ExpressionRef>();\r\n    var body = statement.statement;\r\n    if (body.kind == NodeKind.BLOCK) {\r\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\r\n    } else {\r\n      bodyStmts.push(this.compileStatement(body));\r\n    }\r\n\r\n    // Check if body terminates\r\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\r\n      bodyStmts.push(module.unreachable());\r\n    }\r\n    if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\r\n    else flow.inheritBranch(bodyFlow);\r\n    bodyFlow.freeScopedLocals();\r\n\r\n    var ifStmts = new Array<ExpressionRef>();\r\n    ifStmts.push(\r\n      module.block(continueLabel, bodyStmts)\r\n    );\r\n\r\n    // Compile the incrementor if it runs\r\n    // Can still fall through to here if body continues, hence is already known to terminate\r\n    if (!bodyFlow.is(FlowFlags.TERMINATES) || bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES)) {\r\n      let incrementor = statement.incrementor;\r\n      if (incrementor) {\r\n        let incrFlow = flow.fork();\r\n        this.currentFlow = incrFlow;\r\n        ifStmts.push(\r\n          this.compileExpression(incrementor, Type.void, Constraints.CONV_IMPLICIT | Constraints.WILL_DROP)\r\n        );\r\n        incrFlow.freeScopedLocals();\r\n        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing\r\n        this.currentFlow = flow;\r\n      }\r\n\r\n      ifStmts.push(\r\n        module.br(loopLabel)\r\n      );\r\n\r\n      // Detect if local flags are incompatible before and after looping, and if\r\n      // so recompile by unifying local flags between iterations. Note that this\r\n      // may be necessary multiple times where locals depend on each other.\r\n      if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\r\n        assert(!bodyFlow.hasScopedLocals);\r\n        flow.freeScopedLocals();\r\n        outerFlow.popBreakLabel();\r\n        this.currentFlow = outerFlow;\r\n        return this.doCompileForStatement(statement, flow);\r\n      }\r\n    }\r\n    loopStmts.push(\r\n      module.if(module.local_get(tcond.index, TypeRef.I32),\r\n        module.flatten(ifStmts)\r\n      )\r\n    );\r\n\r\n    stmts.push(\r\n      module.block(breakLabel, [\r\n        module.loop(loopLabel,\r\n          module.flatten(loopStmts)\r\n        )\r\n      ])\r\n    );\r\n    flow.freeTempLocal(tcond);\r\n    this.currentFlow = flow;\r\n\r\n    // Finalize\r\n    flow.freeScopedLocals();\r\n    outerFlow.inherit(flow);\r\n    outerFlow.popBreakLabel();\r\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\r\n      stmts.push(module.unreachable());\r\n    }\r\n    this.currentFlow = outerFlow;\r\n    return module.flatten(stmts);\r\n  }\r\n\r\n  private compileForOfStatement(\r\n    statement: ForOfStatement\r\n  ): ExpressionRef {\r\n    this.error(\r\n      DiagnosticCode.Not_implemented_0,\r\n      statement.range,\r\n      \"Iterators\"\r\n    );\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  private compileIfStatement(\r\n    statement: IfStatement\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var ifTrue = statement.ifTrue;\r\n    var ifFalse = statement.ifFalse;\r\n\r\n    // (if               flow\r\n    //  (condition)       condition?\r\n    //  (block                       \r\n    //   (ifTrue)         thenFlow \r\n    //                             \r\n    //  )                          \r\n    //  (block                      present?\r\n    //   (ifFalse)                   elseFlow\r\n    //                              \r\n    //  )                           \r\n    // )                 \r\n    // ...              \r\n\r\n    // Precompute the condition (always executes)\r\n    var condExpr = this.makeIsTrueish(\r\n      this.compileExpression(statement.condition, Type.bool),\r\n      this.currentType,\r\n      statement.condition\r\n    );\r\n    var condKind = this.evaluateCondition(condExpr);\r\n\r\n    // Shortcut if the condition is constant\r\n    switch (condKind) {\r\n      case ConditionKind.TRUE: {\r\n        return module.block(null, [\r\n          module.drop(condExpr),\r\n          this.compileStatement(ifTrue)\r\n        ]);\r\n      }\r\n      case ConditionKind.FALSE: {\r\n        return ifFalse\r\n          ? module.block(null, [\r\n              module.drop(condExpr),\r\n              this.compileStatement(ifFalse)\r\n            ])\r\n          : module.drop(condExpr);\r\n      }\r\n    }\r\n\r\n    // From here on condition is always unknown\r\n\r\n    var flow = this.currentFlow;\r\n\r\n    // Compile ifTrue assuming the condition turned out true\r\n    var thenStmts = new Array<ExpressionRef>();\r\n    var thenFlow = flow.fork();\r\n    this.currentFlow = thenFlow;\r\n    thenFlow.inheritNonnullIfTrue(condExpr);\r\n    if (ifTrue.kind == NodeKind.BLOCK) {\r\n      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);\r\n    } else {\r\n      thenStmts.push(this.compileStatement(ifTrue));\r\n    }\r\n    var thenTerminates = thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\r\n    if (thenTerminates) {\r\n      thenStmts.push(module.unreachable());\r\n    }\r\n    thenFlow.freeScopedLocals();\r\n    this.currentFlow = flow;\r\n\r\n    // Compile ifFalse assuming the condition turned out false, if present\r\n    if (ifFalse) {\r\n      let elseStmts = new Array<ExpressionRef>();\r\n      let elseFlow = flow.fork();\r\n      this.currentFlow = elseFlow;\r\n      elseFlow.inheritNonnullIfFalse(condExpr);\r\n      if (ifFalse.kind == NodeKind.BLOCK) {\r\n        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);\r\n      } else {\r\n        elseStmts.push(this.compileStatement(ifFalse));\r\n      }\r\n      let elseTerminates = elseFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\r\n      if (elseTerminates) {\r\n        elseStmts.push(module.unreachable());\r\n      }\r\n      elseFlow.freeScopedLocals();\r\n      this.currentFlow = flow;\r\n      flow.inheritMutual(thenFlow, elseFlow);\r\n      return module.if(condExpr,\r\n        module.flatten(thenStmts),\r\n        module.flatten(elseStmts)\r\n      );\r\n    } else {\r\n      flow.inheritBranch(thenFlow);\r\n      flow.inheritNonnullIfFalse(condExpr,\r\n        thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)\r\n          ? null     // thenFlow terminates: just inherit\r\n          : thenFlow // must become nonnull in thenFlow otherwise\r\n      );\r\n      return module.if(condExpr,\r\n        module.flatten(thenStmts)\r\n      );\r\n    }\r\n  }\r\n\r\n  private compileReturnStatement(\r\n    statement: ReturnStatement,\r\n    isLastInBody: bool\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var expr: ExpressionRef = 0;\r\n    var flow = this.currentFlow;\r\n    var returnType = flow.returnType;\r\n\r\n    var valueExpression = statement.value;\r\n    if (valueExpression) {\r\n      if (returnType == Type.void) {\r\n        this.error(\r\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n          valueExpression.range, this.currentType.toString(), returnType.toString()\r\n        );\r\n        this.currentType = Type.void;\r\n        return module.unreachable();\r\n      }\r\n      let constraints = Constraints.CONV_IMPLICIT;\r\n      if (flow.actualFunction.is(CommonFlags.MODULE_EXPORT)) constraints |= Constraints.MUST_WRAP;\r\n\r\n      expr = this.compileExpression(valueExpression, returnType, constraints);\r\n      if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\r\n      if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\r\n      if (flow.actualFunction.is(CommonFlags.CONSTRUCTOR) && valueExpression.kind != NodeKind.THIS) {\r\n        flow.set(FlowFlags.MAY_RETURN_NONTHIS);\r\n      }\r\n    } else if (returnType != Type.void) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        statement.range, \"void\", returnType.toString()\r\n      );\r\n      this.currentType = returnType;\r\n      return module.unreachable();\r\n    }\r\n    flow.freeScopedLocals();\r\n\r\n    // Remember that this flow returns\r\n    flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\r\n\r\n    // Handle inline return\r\n    if (flow.isInline) {\r\n      return isLastInBody && expr != 0\r\n        ? expr\r\n        : module.br(assert(flow.inlineReturnLabel), 0, expr);\r\n    }\r\n\r\n    // Otherwise emit a normal return\r\n    return isLastInBody && expr != 0\r\n      ? expr\r\n      : module.return(expr);\r\n  }\r\n\r\n  private compileSwitchStatement(\r\n    statement: SwitchStatement\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n\r\n    var cases = statement.cases;\r\n    var numCases = cases.length;\r\n    if (!numCases) {\r\n      return this.compileExpression(statement.condition, Type.void,\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n    }\r\n\r\n    // Everything within a switch uses the same break context\r\n    var outerFlow = this.currentFlow;\r\n    var context = outerFlow.pushBreakLabel();\r\n\r\n    // introduce a local for evaluating the condition (exactly once)\r\n    var tempLocal = outerFlow.getTempLocal(Type.u32);\r\n    var tempLocalIndex = tempLocal.index;\r\n\r\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\r\n    var breaks = new Array<ExpressionRef>(1 + numCases);\r\n    breaks[0] = module.local_set( // initializer\r\n      tempLocalIndex,\r\n      this.compileExpression(statement.condition, Type.u32,\r\n        Constraints.CONV_IMPLICIT\r\n      ),\r\n      false // u32\r\n    );\r\n\r\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\r\n    var breakIndex = 1;\r\n    var defaultIndex = -1;\r\n    for (let i = 0; i < numCases; ++i) {\r\n      let case_ = cases[i];\r\n      let label = case_.label;\r\n      if (label) {\r\n        breaks[breakIndex++] = module.br(\"case\" + i.toString() + \"|\" + context,\r\n          module.binary(BinaryOp.EqI32,\r\n            module.local_get(tempLocalIndex, TypeRef.I32),\r\n            this.compileExpression(label, Type.u32,\r\n              Constraints.CONV_IMPLICIT\r\n            )\r\n          )\r\n        );\r\n      } else {\r\n        defaultIndex = i;\r\n      }\r\n    }\r\n\r\n    outerFlow.freeTempLocal(tempLocal);\r\n\r\n    // otherwise br to default respectively out of the switch if there is no default case\r\n    breaks[breakIndex] = module.br((defaultIndex >= 0\r\n      ? \"case\" + defaultIndex.toString()\r\n      : \"break\"\r\n    ) + \"|\" + context);\r\n\r\n    // nest blocks in order\r\n    var currentBlock = module.block(\"case0|\" + context, breaks, TypeRef.None);\r\n    var commonCategorical = FlowFlags.ANY_CATEGORICAL;\r\n    var commonConditional = 0;\r\n    for (let i = 0; i < numCases; ++i) {\r\n      let case_ = cases[i];\r\n      let statements = case_.statements;\r\n      let numStatements = statements.length;\r\n\r\n      // Each switch case initiates a new branch\r\n      let innerFlow = outerFlow.fork();\r\n      this.currentFlow = innerFlow;\r\n      let breakLabel = \"break|\" + context;\r\n      innerFlow.breakLabel = breakLabel;\r\n\r\n      let isLast = i == numCases - 1;\r\n      let nextLabel = isLast ? breakLabel : \"case\" + (i + 1).toString() + \"|\" + context;\r\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\r\n      stmts[0] = currentBlock;\r\n      let count = 1;\r\n      let terminates = false;\r\n      for (let j = 0; j < numStatements; ++j) {\r\n        let stmt = this.compileStatement(statements[j]);\r\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\r\n          stmts[count++] = stmt;\r\n        }\r\n        if (innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\r\n          if (innerFlow.is(FlowFlags.TERMINATES)) terminates = true;\r\n          break;\r\n        }\r\n      }\r\n      stmts.length = count;\r\n      if (terminates || isLast || innerFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\r\n        commonCategorical &= innerFlow.flags;\r\n      }\r\n      commonConditional |= innerFlow.flags & FlowFlags.ANY_CONDITIONAL;\r\n\r\n      // Switch back to the parent flow\r\n      innerFlow.unset(\r\n        FlowFlags.BREAKS |\r\n        FlowFlags.CONDITIONALLY_BREAKS\r\n      );\r\n      innerFlow.freeScopedLocals();\r\n      this.currentFlow = outerFlow;\r\n      currentBlock = module.block(nextLabel, stmts, TypeRef.None); // must be a labeled block\r\n    }\r\n    outerFlow.popBreakLabel();\r\n\r\n    // If the switch has a default (guaranteed to handle any value), propagate common flags\r\n    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.BREAKS;\r\n    outerFlow.flags |= commonConditional & ~FlowFlags.CONDITIONALLY_BREAKS;\r\n    // TODO: what about local states?\r\n    return currentBlock;\r\n  }\r\n\r\n  private compileThrowStatement(\r\n    statement: ThrowStatement\r\n  ): ExpressionRef {\r\n    // TODO: requires exception-handling spec.\r\n    var flow = this.currentFlow;\r\n\r\n    // Remember that this branch throws\r\n    flow.set(FlowFlags.THROWS | FlowFlags.TERMINATES);\r\n\r\n    var stmts = new Array<ExpressionRef>();\r\n    var value = statement.value;\r\n    var message: Expression | null = null;\r\n    if (value.kind == NodeKind.NEW) {\r\n      let newArgs = (<NewExpression>value).args;\r\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\r\n    }\r\n    stmts.push(\r\n      this.makeAbort(message, statement)\r\n    );\r\n    flow.freeScopedLocals();\r\n    return this.module.flatten(stmts);\r\n  }\r\n\r\n  private compileTryStatement(\r\n    statement: TryStatement\r\n  ): ExpressionRef {\r\n    // TODO: can't yet support something like: try { return ... } finally { ... }\r\n    // worthwhile to investigate lowering returns to block results (here)?\r\n    this.error(\r\n      DiagnosticCode.Not_implemented_0,\r\n      statement.range,\r\n      \"Exceptions\"\r\n    );\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\r\n  private compileVariableStatement(\r\n    statement: VariableStatement\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var declarations = statement.declarations;\r\n    var numDeclarations = declarations.length;\r\n    var flow = this.currentFlow;\r\n    var initializers = new Array<ExpressionRef>();\r\n    var resolver = this.resolver;\r\n\r\n    for (let i = 0; i < numDeclarations; ++i) {\r\n      let declaration = declarations[i];\r\n      let name = declaration.name.text;\r\n      let type: Type | null = null;\r\n      let initExpr: ExpressionRef = 0;\r\n\r\n      // Resolve type if annotated\r\n      let typeNode = declaration.type;\r\n      let initializerNode = declaration.initializer;\r\n      if (typeNode) {\r\n        type = resolver.resolveType( // reports\r\n          typeNode,\r\n          flow.actualFunction,\r\n          uniqueMap(flow.contextualTypeArguments)\r\n        );\r\n        if (!type) continue;\r\n        this.checkTypeSupported(type, typeNode);\r\n\r\n        if (initializerNode) {\r\n          let pendingElements = this.pendingElements;\r\n          let dummy = flow.addScopedDummyLocal(name, type); // pending dummy\r\n          pendingElements.add(dummy);\r\n          initExpr = this.compileExpression(initializerNode, type, // reports\r\n            Constraints.CONV_IMPLICIT\r\n          );\r\n          pendingElements.delete(dummy);\r\n          flow.freeScopedDummyLocal(name);\r\n        }\r\n\r\n      // Otherwise infer type from initializer\r\n      } else if (initializerNode) {\r\n        let pendingElements = this.pendingElements;\r\n        let temp = flow.addScopedDummyLocal(name, Type.auto); // pending dummy\r\n        pendingElements.add(temp);\r\n        initExpr = this.compileExpression(initializerNode, Type.auto); // reports\r\n        pendingElements.delete(temp);\r\n        flow.freeScopedDummyLocal(name);\r\n\r\n        if (this.currentType == Type.void) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            declaration.range, this.currentType.toString(), \"<auto>\"\r\n          );\r\n          continue;\r\n        }\r\n        type = this.currentType;\r\n\r\n      // Error if there's neither a type nor an initializer\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          declaration.name.range.atEnd\r\n        );\r\n        continue;\r\n      }\r\n\r\n      // Handle constants, and try to inline if value is static\r\n      let isConst = declaration.is(CommonFlags.CONST);\r\n      let isStatic = false;\r\n      if (isConst) {\r\n        if (initExpr) {\r\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\r\n          if (precomp) {\r\n            initExpr = precomp; // always use precomputed initExpr\r\n            let local: Local | null = null;\r\n            switch (<u32>getExpressionType(initExpr)) {\r\n              case <u32>TypeRef.I32: {\r\n                local = new Local(name, -1, type, flow.parentFunction);\r\n                local.setConstantIntegerValue(\r\n                  i64_new(\r\n                    getConstValueI32(initExpr),\r\n                    0\r\n                  ),\r\n                  type\r\n                );\r\n                break;\r\n              }\r\n              case <u32>TypeRef.I64: {\r\n                local = new Local(name, -1, type, flow.parentFunction);\r\n                local.setConstantIntegerValue(\r\n                  i64_new(\r\n                    getConstValueI64Low(initExpr),\r\n                    getConstValueI64High(initExpr)\r\n                  ),\r\n                  type\r\n                );\r\n                break;\r\n              }\r\n              case <u32>TypeRef.F32: {\r\n                local = new Local(name, -1, type, flow.parentFunction);\r\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\r\n                break;\r\n              }\r\n              case <u32>TypeRef.F64: {\r\n                local = new Local(name, -1, type, flow.parentFunction);\r\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\r\n                break;\r\n              }\r\n            }\r\n            if (local) {\r\n              // Add as a virtual local that doesn't actually exist in WebAssembly\r\n              let scopedLocals = flow.scopedLocals;\r\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\r\n              else if (scopedLocals.has(name)) {\r\n                let existing = assert(scopedLocals.get(name));\r\n                this.errorRelated(\r\n                  DiagnosticCode.Duplicate_identifier_0,\r\n                  declaration.name.range,\r\n                  existing.declaration.name.range,\r\n                  name\r\n                );\r\n                return this.module.unreachable();\r\n              }\r\n              scopedLocals.set(name, local);\r\n              isStatic = true;\r\n            }\r\n          }\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._const_declarations_must_be_initialized,\r\n            declaration.range\r\n          );\r\n        }\r\n      }\r\n\r\n      // Otherwise compile as mutable\r\n      if (!isStatic) {\r\n        let local: Local;\r\n        if (\r\n          declaration.isAny(CommonFlags.LET | CommonFlags.CONST) ||\r\n          flow.isInline\r\n        ) { // here: not top-level\r\n          let existingLocal = flow.getScopedLocal(name);\r\n          if (existingLocal) {\r\n            if (!existingLocal.declaration.range.source.isNative) {\r\n              this.errorRelated(\r\n                DiagnosticCode.Duplicate_identifier_0,\r\n                declaration.name.range,\r\n                existingLocal.declaration.name.range,\r\n                name\r\n              );\r\n            } else { // scoped locals are shared temps that don't track declarations\r\n              this.error(\r\n                DiagnosticCode.Duplicate_identifier_0,\r\n                declaration.name.range, name\r\n              );\r\n            }\r\n            local = existingLocal;\r\n          } else {\r\n            local = flow.addScopedLocal(name, type);\r\n          }\r\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\r\n        } else {\r\n          let existing = flow.lookupLocal(name);\r\n          if (existing) {\r\n            this.errorRelated(\r\n              DiagnosticCode.Duplicate_identifier_0,\r\n              declaration.name.range,\r\n              existing.declaration.name.range,\r\n              name\r\n            );\r\n            continue;\r\n          }\r\n          local = flow.parentFunction.addLocal(type, name, declaration);\r\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\r\n        }\r\n        if (initExpr) {\r\n          initializers.push(\r\n            this.makeLocalAssignment(local, initExpr, type, false)\r\n          );\r\n        } else {\r\n          // no need to assign zero\r\n          if (local.type.isShortIntegerValue) {\r\n            flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.currentType = Type.void;\r\n    return initializers.length == 0\r\n      ? 0\r\n      : module.flatten(initializers);\r\n  }\r\n\r\n  private compileVoidStatement(\r\n    statement: VoidStatement\r\n  ): ExpressionRef {\r\n    return this.compileExpression(statement.expression, Type.void,\r\n      Constraints.CONV_EXPLICIT | Constraints.WILL_DROP\r\n    );\r\n  }\r\n\r\n  private compileWhileStatement(\r\n    /** Statement to compile. */\r\n    statement: WhileStatement\r\n  ): ExpressionRef {\r\n    return this.doCompileWhileStatement(statement, null);\r\n  }\r\n\r\n  private doCompileWhileStatement(\r\n    /** Statement to compile. */\r\n    statement: WhileStatement,\r\n    /** If recompiling, the flow with differing local flags that triggered it. */\r\n    flowAfter: Flow | null\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var outerFlow = this.currentFlow;\r\n\r\n    // (block $break                   flow\r\n    //  (loop $continue                  recompile?\r\n    //   (local.set $tcond (condition))  condFlow \r\n    //                                            \r\n    //   (if (local.get $tcond)                    condition?\r\n    //    (body)                        bodyFlow \r\n    //                                           \r\n    //                                           breaks or terminates?\r\n    //    (br $continue)               \r\n    //   )                            \r\n    //  )                               \r\n    // )                              \r\n\r\n    var label = outerFlow.pushBreakLabel();\r\n    var stmts = new Array<ExpressionRef>();\r\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\r\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\r\n    var flowBefore = flow.fork();\r\n    this.currentFlow = flow;\r\n\r\n    var breakLabel = \"while-break|\" + label;\r\n    flow.breakLabel = breakLabel;\r\n    var continueLabel = \"while-continue|\" + label;\r\n    flow.continueLabel = continueLabel;\r\n\r\n    // Precompute the condition\r\n    var condFlow = flow.fork();\r\n    this.currentFlow = condFlow;\r\n    var condExpr = this.makeIsTrueish(\r\n      this.compileExpression(statement.condition, Type.bool),\r\n      this.currentType,\r\n      statement.condition\r\n    );\r\n    var condKind = this.evaluateCondition(condExpr);\r\n\r\n    // Shortcut if condition is always false (body never runs)\r\n    if (condKind == ConditionKind.FALSE) {\r\n      stmts.push(\r\n        module.drop(condExpr)\r\n      );\r\n      assert(!flow.hasScopedLocals);\r\n      outerFlow.popBreakLabel();\r\n      this.currentFlow = outerFlow;\r\n      return module.flatten(stmts);\r\n    }\r\n\r\n    // From here on condition is either always true or unknown\r\n\r\n    // Store condition result in a temp\r\n    var tcond = flow.getTempLocal(Type.bool);\r\n    stmts.push(\r\n      module.local_set(tcond.index, condExpr, false) // bool\r\n    );\r\n    condFlow.freeScopedLocals();\r\n\r\n    flow.inherit(condFlow); // always executes\r\n    this.currentFlow = flow;\r\n\r\n    // Compile the body assuming the condition turned out true\r\n    var bodyFlow = flow.fork();\r\n    bodyFlow.inheritNonnullIfTrue(condExpr);\r\n    this.currentFlow = bodyFlow;\r\n    var bodyStmts = new Array<ExpressionRef>();\r\n    var body = statement.statement;\r\n    if (body.kind == NodeKind.BLOCK) {\r\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\r\n    } else {\r\n      bodyStmts.push(this.compileStatement(body));\r\n    }\r\n\r\n    // Simplify if body always terminates\r\n    if (bodyFlow.is(FlowFlags.TERMINATES)) {\r\n      bodyStmts.push(\r\n        module.unreachable()\r\n      );\r\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\r\n      else flow.inheritBranch(bodyFlow);\r\n\r\n    // Terminate if condition is always true and body never breaks\r\n    } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\r\n      bodyStmts.push(\r\n        module.br(continueLabel)\r\n      );\r\n      flow.set(FlowFlags.TERMINATES);\r\n\r\n    } else {\r\n      let breaks = bodyFlow.is(FlowFlags.BREAKS);\r\n      if (breaks) {\r\n        bodyStmts.push(\r\n          module.unreachable()\r\n        );\r\n      } else {\r\n        bodyStmts.push(\r\n          module.br(continueLabel)\r\n        );\r\n      }\r\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\r\n      else flow.inheritBranch(bodyFlow);\r\n\r\n      // Detect if local flags are incompatible before and after looping, and\r\n      // if so recompile by unifying local flags between iterations. Note that\r\n      // this may be necessary multiple times where locals depend on each other.\r\n      // Here: Only relevant if flow does not always break.\r\n      if (!breaks && Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\r\n        flow.freeTempLocal(tcond);\r\n        outerFlow.popBreakLabel();\r\n        this.currentFlow = outerFlow;\r\n        return this.doCompileWhileStatement(statement, flow);\r\n      }\r\n    }\r\n    stmts.push(\r\n      module.if(module.local_get(tcond.index, TypeRef.I32),\r\n        module.flatten(bodyStmts)\r\n      )\r\n    );\r\n    flow.freeTempLocal(tcond);\r\n    this.currentFlow = flow;\r\n\r\n    // Finalize\r\n    assert(!flow.hasScopedLocals);\r\n    outerFlow.inherit(flow);\r\n    outerFlow.popBreakLabel();\r\n    this.currentFlow = outerFlow;\r\n    var expr = module.block(breakLabel, [\r\n      module.loop(continueLabel,\r\n        module.flatten(stmts)\r\n      )\r\n    ]);\r\n    if (condKind == ConditionKind.TRUE && outerFlow.is(FlowFlags.TERMINATES)) {\r\n      expr = module.block(null, [ expr, module.unreachable() ]);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // === Expressions ==============================================================================\r\n\r\n  /** Compiles the value of an inlined constant element. */\r\n  compileInlineConstant(\r\n    element: VariableLikeElement,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    assert(element.is(CommonFlags.INLINED | CommonFlags.RESOLVED));\r\n    var type = element.type;\r\n    switch (\r\n      !(constraints & (Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT)) &&\r\n      type.isIntegerValue &&\r\n      contextualType.isIntegerValue &&\r\n      type.size < contextualType.size\r\n        ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension\r\n        : (this.currentType = type).kind\r\n    ) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        let shift = type.computeSmallIntegerShift(Type.i32);\r\n        return this.module.i32(\r\n          element.constantValueKind == ConstantValueKind.INTEGER\r\n            ? i64_low(element.constantIntegerValue) << shift >> shift\r\n            : 0\r\n        ); // recognized by canOverflow\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\r\n        return this.module.i32(\r\n          element.constantValueKind == ConstantValueKind.INTEGER\r\n            ? i64_low(element.constantIntegerValue) & mask\r\n            : 0\r\n        ); // recognized by canOverflow\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return this.module.i32(\r\n          element.constantValueKind == ConstantValueKind.INTEGER\r\n            ? i64_low(element.constantIntegerValue)\r\n            : 0\r\n        );\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        if (!element.program.options.isWasm64) {\r\n          return this.module.i32(\r\n            element.constantValueKind == ConstantValueKind.INTEGER\r\n              ? i64_low(element.constantIntegerValue)\r\n              : 0\r\n          );\r\n        }\r\n        // fall-through\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return element.constantValueKind == ConstantValueKind.INTEGER\r\n          ? this.module.i64(\r\n              i64_low(element.constantIntegerValue),\r\n              i64_high(element.constantIntegerValue)\r\n            )\r\n          : this.module.i64(0);\r\n      }\r\n      case TypeKind.F64: {\r\n        // monkey-patch for converting built-in floats to f32 implicitly\r\n        if (!(element.hasDecorator(DecoratorFlags.BUILTIN) && contextualType == Type.f32)) {\r\n          return this.module.f64(element.constantFloatValue);\r\n        }\r\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\r\n        this.currentType = Type.f32;\r\n      }\r\n      case TypeKind.F32: {\r\n        return this.module.f32(<f32>element.constantFloatValue);\r\n      }\r\n      default: {\r\n        assert(false);\r\n        return this.module.unreachable();\r\n      }\r\n    }\r\n  }\r\n\r\n  compileExpression(\r\n    expression: Expression,\r\n    contextualType: Type,\r\n    constraints: Constraints = Constraints.NONE\r\n  ): ExpressionRef {\r\n    while (expression.kind == NodeKind.PARENTHESIZED) { // skip\r\n      expression = (<ParenthesizedExpression>expression).expression;\r\n    }\r\n    this.currentType = contextualType;\r\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\r\n    var expr: ExpressionRef;\r\n    switch (expression.kind) {\r\n      case NodeKind.ASSERTION: {\r\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.BINARY: {\r\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.CALL: {\r\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.COMMA: {\r\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.ELEMENTACCESS: {\r\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTION: {\r\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.IDENTIFIER:\r\n      case NodeKind.FALSE:\r\n      case NodeKind.NULL:\r\n      case NodeKind.THIS:\r\n      case NodeKind.SUPER:\r\n      case NodeKind.TRUE: {\r\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.INSTANCEOF: {\r\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.LITERAL: {\r\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.NEW: {\r\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.PROPERTYACCESS: {\r\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.TERNARY: {\r\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.UNARYPOSTFIX: {\r\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.UNARYPREFIX: {\r\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\r\n        break;\r\n      }\r\n      case NodeKind.COMPILED: {\r\n        let compiled = <CompiledExpression>expression;\r\n        expr = compiled.expr;\r\n        this.currentType = compiled.type;\r\n        break;\r\n      }\r\n      default: {\r\n        assert(false);\r\n        expr = this.module.unreachable();\r\n      }\r\n    }\r\n    // ensure conversion and wrapping in case the respective function doesn't on its own\r\n    var currentType = this.currentType;\r\n    var wrap = (constraints & Constraints.MUST_WRAP) != 0;\r\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\r\n      if (constraints & Constraints.CONV_EXPLICIT) {\r\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\r\n        this.currentType = currentType = contextualType;\r\n      } else if (constraints & Constraints.CONV_IMPLICIT) {\r\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\r\n        this.currentType = currentType = contextualType;\r\n      }\r\n    }\r\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\r\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\r\n    // must go through this function, with the respective per-kind functions not being used directly.\r\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\r\n    return expr;\r\n  }\r\n\r\n  /** Converts an expression's result from one type to another. */\r\n  convertExpression(\r\n    expr: ExpressionRef,\r\n    /** Original type. */\r\n    fromType: Type,\r\n    /** New type. */\r\n    toType: Type,\r\n    /** Whether the conversion is explicit. */\r\n    explicit: bool,\r\n    /** Report node. */\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n\r\n    // void to any\r\n    if (fromType.kind == TypeKind.VOID) {\r\n      assert(toType.kind != TypeKind.VOID); // convertExpression should not be called with void -> void\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        reportNode.range, fromType.toString(), toType.toString()\r\n      );\r\n      return module.unreachable();\r\n    }\r\n\r\n    // any to void\r\n    if (toType.kind == TypeKind.VOID) return module.drop(expr);\r\n\r\n    // reference involved\r\n    if (fromType.isReference || toType.isReference) {\r\n      if (this.currentFlow.isNonnull(expr, fromType)) {\r\n        fromType = fromType.nonNullableType;\r\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\r\n        // explicit conversion from nullable to non-nullable requires a runtime\r\n        // check here because nonnull state above already didn't know better\r\n        if (!this.options.noAssert) {\r\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\r\n        }\r\n        fromType = fromType.nonNullableType;\r\n      }\r\n      if (fromType.isAssignableTo(toType)) { // downcast or same\r\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\r\n        this.currentType = toType;\r\n        return expr;\r\n      }\r\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // upcast\r\n        // <Cat | null>(<Animal>maybeCat)\r\n        if (toType.isExternalReference) {\r\n          this.error(\r\n            DiagnosticCode.Not_implemented_0,\r\n            reportNode.range,\r\n            \"ref.cast\"\r\n          );\r\n          this.currentType = toType;\r\n          return module.unreachable();\r\n        }\r\n        assert(fromType.kind == toType.kind);\r\n        if (!this.options.noAssert) {\r\n          expr = this.makeRuntimeUpcastCheck(expr, fromType, toType, reportNode);\r\n        }\r\n        this.currentType = toType;\r\n        return expr;\r\n      }\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        reportNode.range, fromType.toString(), toType.toString()\r\n      );\r\n      this.currentType = toType;\r\n      return module.unreachable();\r\n    }\r\n\r\n    // not dealing with references from here on\r\n    assert(!fromType.isReference && !toType.isReference);\r\n\r\n    if (!fromType.isAssignableTo(toType)) {\r\n      if (!explicit) {\r\n        this.error(\r\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\r\n          reportNode.range, fromType.toString(), toType.toString()\r\n        ); // recoverable\r\n      }\r\n    }\r\n\r\n    if (fromType.isFloatValue) {\r\n\r\n      // float to float\r\n      if (toType.isFloatValue) {\r\n        if (fromType.kind == TypeKind.F32) {\r\n\r\n          // f32 to f64\r\n          if (toType.kind == TypeKind.F64) {\r\n            expr = module.unary(UnaryOp.PromoteF32ToF64, expr);\r\n          }\r\n\r\n          // otherwise f32 to f32\r\n\r\n        // f64 to f32\r\n        } else if (toType.kind == TypeKind.F32) {\r\n          expr = module.unary(UnaryOp.DemoteF64ToF32, expr);\r\n        }\r\n\r\n        // otherwise f64 to f64\r\n\r\n      // float to int\r\n      } else if (toType.isIntegerValue) {\r\n\r\n        // f32 to int\r\n        if (fromType.kind == TypeKind.F32) {\r\n          if (toType.isBooleanValue) {\r\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\r\n          } else if (toType.isSignedIntegerValue) {\r\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\r\n            if (toType.isLongIntegerValue) {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI64 : UnaryOp.TruncF32ToI64, expr);\r\n            } else {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToI32 : UnaryOp.TruncF32ToI32, expr);\r\n            }\r\n          } else {\r\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\r\n            if (toType.isLongIntegerValue) {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU64 : UnaryOp.TruncF32ToU64, expr);\r\n            } else {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF32ToU32 : UnaryOp.TruncF32ToU32, expr);\r\n            }\r\n          }\r\n\r\n        // f64 to int\r\n        } else {\r\n          if (toType.isBooleanValue) {\r\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\r\n          } else if (toType.isSignedIntegerValue) {\r\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\r\n            if (toType.isLongIntegerValue) {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI64 : UnaryOp.TruncF64ToI64, expr);\r\n            } else {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToI32 : UnaryOp.TruncF64ToI32, expr);\r\n            }\r\n          } else {\r\n            let saturating = this.options.hasFeature(Feature.NONTRAPPING_F2I);\r\n            if (toType.isLongIntegerValue) {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU64 : UnaryOp.TruncF64ToU64, expr);\r\n            } else {\r\n              expr = module.unary(saturating ? UnaryOp.TruncSatF64ToU32 : UnaryOp.TruncF64ToU32, expr);\r\n            }\r\n          }\r\n        }\r\n\r\n      // float to void\r\n      } else {\r\n        assert(toType.flags == TypeFlags.NONE, \"void type expected\");\r\n        expr = module.drop(expr);\r\n      }\r\n\r\n    // int to float\r\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\r\n\r\n      // int to f32\r\n      if (toType.kind == TypeKind.F32) {\r\n        if (fromType.isLongIntegerValue) {\r\n          expr = module.unary(\r\n            fromType.isSignedIntegerValue\r\n              ? UnaryOp.ConvertI64ToF32\r\n              : UnaryOp.ConvertU64ToF32,\r\n            expr\r\n          );\r\n        } else {\r\n          expr = module.unary(\r\n            fromType.isSignedIntegerValue\r\n              ? UnaryOp.ConvertI32ToF32\r\n              : UnaryOp.ConvertU32ToF32,\r\n            expr\r\n          );\r\n        }\r\n\r\n      // int to f64\r\n      } else {\r\n        if (fromType.isLongIntegerValue) {\r\n          expr = module.unary(\r\n            fromType.isSignedIntegerValue\r\n              ? UnaryOp.ConvertI64ToF64\r\n              : UnaryOp.ConvertU64ToF64,\r\n            expr\r\n          );\r\n        } else {\r\n          expr = module.unary(\r\n            fromType.isSignedIntegerValue\r\n              ? UnaryOp.ConvertI32ToF64\r\n              : UnaryOp.ConvertU32ToF64,\r\n            expr\r\n          );\r\n        }\r\n      }\r\n\r\n    // int to int\r\n    } else {\r\n      // i64 to ...\r\n      if (fromType.isLongIntegerValue) {\r\n\r\n        // i64 to i32 or smaller\r\n        if (toType.isBooleanValue) {\r\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\r\n        } else if (!toType.isLongIntegerValue) {\r\n          expr = module.unary(UnaryOp.WrapI64ToI32, expr); // discards upper bits\r\n        }\r\n\r\n      // i32 or smaller to i64\r\n      } else if (toType.isLongIntegerValue) {\r\n        expr = module.unary(\r\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32ToI64 : UnaryOp.ExtendU32ToU64,\r\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\r\n        );\r\n\r\n      // i32 to i32\r\n      } else {\r\n        // small i32 to ...\r\n        if (fromType.isShortIntegerValue) {\r\n          // small i32 to larger i32\r\n          if (fromType.size < toType.size) {\r\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\r\n          }\r\n        // same size\r\n        } else {\r\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\r\n            this.warning(\r\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\r\n              reportNode.range, fromType.toString(), toType.toString()\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.currentType = toType;\r\n    return expr;\r\n  }\r\n\r\n  private compileAssertionExpression(\r\n    expression: AssertionExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var inheritedConstraints = constraints & ~(Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT);\r\n    switch (expression.assertionKind) {\r\n      case AssertionKind.PREFIX:\r\n      case AssertionKind.AS: {\r\n        let flow = this.currentFlow;\r\n        let toType = this.resolver.resolveType( // reports\r\n          assert(expression.toType),\r\n          flow.actualFunction,\r\n          uniqueMap(flow.contextualTypeArguments)\r\n        );\r\n        if (!toType) return this.module.unreachable();\r\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.CONV_EXPLICIT);\r\n      }\r\n      case AssertionKind.NONNULL: {\r\n        assert(!expression.toType);\r\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\r\n        let type = this.currentType;\r\n        if (this.currentFlow.isNonnull(expr, type)) {\r\n          this.info(\r\n            DiagnosticCode.Expression_is_never_null,\r\n            expression.expression.range\r\n          );\r\n        } else if (!this.options.noAssert) {\r\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\r\n        }\r\n        this.currentType = type.nonNullableType;\r\n        return expr;\r\n      }\r\n      case AssertionKind.CONST: {\r\n        // TODO: decide on the layout of ReadonlyArray first\r\n        // let operand = expression.expression;\r\n        // if (operand.kind == NodeKind.LITERAL && (<LiteralExpression>operand).literalKind == LiteralKind.ARRAY) {\r\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\r\n        //   if (!element) return this.module.unreachable();\r\n        //   if (element.kind == ElementKind.CLASS) {\r\n        //     let arrayInstance = <Class>element;\r\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\r\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\r\n        //     }\r\n        //   }\r\n        // }\r\n        this.error(\r\n          DiagnosticCode.Not_implemented_0,\r\n          expression.range,\r\n          \"Const assertion\"\r\n        );\r\n        return this.module.unreachable();\r\n      }\r\n      default: assert(false);\r\n    }\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  private f32ModInstance: Function | null = null;\r\n  private f64ModInstance: Function | null = null;\r\n  private f32PowInstance: Function | null = null;\r\n  private f64PowInstance: Function | null = null;\r\n  private i32PowInstance: Function | null = null;\r\n  private i64PowInstance: Function | null = null;\r\n\r\n  private compileBinaryExpression(\r\n    expression: BinaryExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var left = expression.left;\r\n    var right = expression.right;\r\n\r\n    var leftExpr: ExpressionRef;\r\n    var leftType: Type;\r\n    var rightExpr: ExpressionRef;\r\n    var rightType: Type;\r\n    var commonType: Type | null;\r\n\r\n    var expr: ExpressionRef;\r\n    var compound = false;\r\n\r\n    var operator = expression.operator;\r\n    switch (operator) {\r\n      case Token.LESSTHAN: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.LT);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType);\r\n        rightType = this.currentType;\r\n        commonType = Type.commonDenominator(leftType, rightType, true);\r\n        if (!commonType || !commonType.isNumericValue) {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, \"<\", leftType.toString(), rightType.toString()\r\n          );\r\n          this.currentType = contextualType;\r\n          return module.unreachable();\r\n        }\r\n\r\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n        leftType = commonType;\r\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n        rightType = commonType;\r\n\r\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n      case Token.GREATERTHAN: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.GT);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType);\r\n        rightType = this.currentType;\r\n        commonType = Type.commonDenominator(leftType, rightType, true);\r\n        if (!commonType || !commonType.isNumericValue) {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, \">\", leftType.toString(), rightType.toString()\r\n          );\r\n          this.currentType = contextualType;\r\n          return module.unreachable();\r\n        }\r\n\r\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n        leftType = commonType;\r\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n        rightType = commonType;\r\n\r\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n      case Token.LESSTHAN_EQUALS: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.LE);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType);\r\n        rightType = this.currentType;\r\n        commonType = Type.commonDenominator(leftType, rightType, true);\r\n        if (!commonType || !commonType.isNumericValue) {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\r\n          );\r\n          this.currentType = contextualType;\r\n          return module.unreachable();\r\n        }\r\n\r\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n        leftType = commonType;\r\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n        rightType = commonType;\r\n\r\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n      case Token.GREATERTHAN_EQUALS: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.GE);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType);\r\n        rightType = this.currentType;\r\n        commonType = Type.commonDenominator(leftType, rightType, true);\r\n        if (!commonType || !commonType.isNumericValue) {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, \">=\", leftType.toString(), rightType.toString()\r\n          );\r\n          this.currentType = contextualType;\r\n          return module.unreachable();\r\n        }\r\n\r\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n        leftType = commonType;\r\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n        rightType = commonType;\r\n\r\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n\r\n      case Token.EQUALS_EQUALS_EQUALS:\r\n      case Token.EQUALS_EQUALS: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        if (operator == Token.EQUALS_EQUALS) { // can't overload '==='\r\n          let classReference = leftType.getClassOrWrapper(this.program);\r\n          if (classReference) {\r\n            let overload = classReference.lookupOverload(OperatorKind.EQ);\r\n            if (overload) {\r\n              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n              break;\r\n            }\r\n          }\r\n          // fall back to compare by value\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType);\r\n        rightType = this.currentType;\r\n        commonType = Type.commonDenominator(leftType, rightType, false);\r\n        if (!commonType) {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\r\n          );\r\n          this.currentType = contextualType;\r\n          return module.unreachable();\r\n        }\r\n\r\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n        leftType = commonType;\r\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n        rightType = commonType;\r\n\r\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n      case Token.EXCLAMATION_EQUALS_EQUALS:\r\n      case Token.EXCLAMATION_EQUALS: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        if (operator == Token.EXCLAMATION_EQUALS) { // can't overload '!=='\r\n          let classReference = leftType.getClass();\r\n          if (classReference) {\r\n            let overload = classReference.lookupOverload(OperatorKind.NE);\r\n            if (overload) {\r\n              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n              break;\r\n            }\r\n          }\r\n          // fall back to compare by value\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType);\r\n        rightType = this.currentType;\r\n        commonType = Type.commonDenominator(leftType, rightType, false);\r\n        if (!commonType) {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\r\n          );\r\n          this.currentType = contextualType;\r\n          return module.unreachable();\r\n        }\r\n\r\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n        leftType = commonType;\r\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n        rightType = commonType;\r\n\r\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n      case Token.EQUALS: {\r\n        return this.compileAssignment(left, right, contextualType);\r\n      }\r\n      case Token.PLUS_EQUALS: compound = true;\r\n      case Token.PLUS: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.ADD);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n        if (compound) {\r\n          if (!leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"+\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"+\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n      case Token.MINUS_EQUALS: compound = true;\r\n      case Token.MINUS: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.SUB);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"-\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"-\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n      case Token.ASTERISK_EQUALS: compound = true;\r\n      case Token.ASTERISK: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.MUL);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"*\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"*\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n      case Token.ASTERISK_ASTERISK_EQUALS: compound = true;\r\n      case Token.ASTERISK_ASTERISK: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.POW);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"**\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"**\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\r\n        break;\r\n      }\r\n      case Token.SLASH_EQUALS: compound = true;\r\n      case Token.SLASH: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.DIV);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"/\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"/\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n      case Token.PERCENT_EQUALS: compound = true;\r\n      case Token.PERCENT: {\r\n        leftExpr = this.compileExpression(left, contextualType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.REM);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"%\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isNumericValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"%\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\r\n        break;\r\n      }\r\n      case Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;\r\n      case Token.LESSTHAN_LESSTHAN: {\r\n        leftExpr = this.compileExpression(left, contextualType.intType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHL);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n        if (!leftType.isIntegerValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"<<\", leftType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n        rightType = this.currentType;\r\n\r\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\r\n        break;\r\n      }\r\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\r\n      case Token.GREATERTHAN_GREATERTHAN: {\r\n        leftExpr = this.compileExpression(left, contextualType.intType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n        if (!leftType.isIntegerValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \">>\", leftType.toString()\r\n          );\r\n          return this.module.unreachable();\r\n        }\r\n\r\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n        rightType = this.currentType;\r\n\r\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\r\n        break;\r\n      }\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\r\n        leftExpr = this.compileExpression(left, contextualType.intType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR_U);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n        if (!leftType.isIntegerValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \">>>\", leftType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n        rightType = this.currentType;\r\n\r\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\r\n        break;\r\n      }\r\n      case Token.AMPERSAND_EQUALS: compound = true;\r\n      case Token.AMPERSAND: {\r\n        leftExpr = this.compileExpression(left, contextualType.intType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overloadd\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_AND);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isIntegerValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"&\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isIntegerValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"&\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n      case Token.BAR_EQUALS: compound = true;\r\n      case Token.BAR: {\r\n        leftExpr = this.compileExpression(left, contextualType.intType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_OR);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isIntegerValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"|\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isIntegerValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"|\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n      case Token.CARET_EQUALS: compound = true;\r\n      case Token.CARET: {\r\n        leftExpr = this.compileExpression(left, contextualType.intType);\r\n        leftType = this.currentType;\r\n\r\n        // check operator overload\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_XOR);\r\n          if (overload) {\r\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (compound) {\r\n          if (!leftType.isIntegerValue) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"^\", leftType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\r\n          rightType = commonType = this.currentType;\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType);\r\n          rightType = this.currentType;\r\n          commonType = Type.commonDenominator(leftType, rightType, false);\r\n          if (!commonType || !commonType.isIntegerValue) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              expression.range, \"^\", leftType.toString(), rightType.toString()\r\n            );\r\n            this.currentType = contextualType;\r\n            return module.unreachable();\r\n          }\r\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\r\n          leftType = commonType;\r\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\r\n          rightType = commonType;\r\n        }\r\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\r\n        break;\r\n      }\r\n\r\n      // logical (no overloading)\r\n\r\n      case Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t\r\n        let flow = this.currentFlow;\r\n        let inheritedConstraints = constraints & Constraints.MUST_WRAP;\r\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\r\n        leftType = this.currentType;\r\n\r\n        let rightFlow = flow.fork();\r\n        this.currentFlow = rightFlow;\r\n        rightFlow.inheritNonnullIfTrue(leftExpr);\r\n\r\n        // simplify if only interested in true or false\r\n        if (contextualType == Type.bool || contextualType == Type.void) {\r\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\r\n\r\n          // shortcut if lhs is always false\r\n          let condKind = this.evaluateCondition(leftExpr);\r\n          if (condKind == ConditionKind.FALSE) {\r\n            expr = leftExpr;\r\n          } else {\r\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\r\n            rightType = this.currentType;\r\n            rightFlow.freeScopedLocals();\r\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\r\n\r\n            // simplify if lhs is always true\r\n            if (condKind == ConditionKind.TRUE) {\r\n              expr = rightExpr;\r\n            } else {\r\n              expr = module.if(leftExpr, rightExpr, module.i32(0));\r\n            }\r\n          }\r\n          this.currentFlow = flow;\r\n          this.currentType = Type.bool;\r\n\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\r\n          rightType = this.currentType;\r\n          rightFlow.freeScopedLocals();\r\n          this.currentFlow = flow;\r\n\r\n          // simplify if cloning left without side effects is possible\r\n          if (expr = module.cloneExpression(leftExpr, true, 0)) {\r\n            expr = module.if(\r\n              this.makeIsTrueish(leftExpr, this.currentType, left),\r\n              rightExpr,\r\n              expr\r\n            );\r\n\r\n          // if not possible, tee left to a temp\r\n          } else {\r\n            let tempLocal = flow.getTempLocal(leftType);\r\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.WRAPPED);\r\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NONNULL);\r\n            expr = module.if(\r\n              this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr, leftType.isManaged), leftType, left),\r\n              rightExpr,\r\n              module.local_get(tempLocal.index, leftType.toRef())\r\n            );\r\n            flow.freeTempLocal(tempLocal);\r\n          }\r\n          this.currentType = leftType;\r\n        }\r\n        break;\r\n      }\r\n      case Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)\r\n        let flow = this.currentFlow;\r\n        let inheritedConstraints = constraints & Constraints.MUST_WRAP;\r\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\r\n        leftType = this.currentType;\r\n\r\n        let rightFlow = flow.fork();\r\n        this.currentFlow = rightFlow;\r\n        rightFlow.inheritNonnullIfFalse(leftExpr);\r\n\r\n        // simplify if only interested in true or false\r\n        if (contextualType == Type.bool || contextualType == Type.void) {\r\n          leftExpr = this.makeIsTrueish(leftExpr, leftType, left);\r\n\r\n          // shortcut if lhs is always true\r\n          let condKind = this.evaluateCondition(leftExpr);\r\n          if (condKind == ConditionKind.TRUE) {\r\n            expr = leftExpr;\r\n          } else {\r\n            rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\r\n            rightType = this.currentType;\r\n            rightFlow.freeScopedLocals();\r\n            rightExpr = this.makeIsTrueish(rightExpr, rightType, right);\r\n\r\n            // simplify if lhs is always false\r\n            if (condKind == ConditionKind.FALSE) {\r\n              expr = rightExpr;\r\n            } else {\r\n              expr = module.if(leftExpr, module.i32(1), rightExpr);\r\n            }\r\n          }\r\n          this.currentFlow = flow;\r\n          this.currentType = Type.bool;\r\n\r\n        } else {\r\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\r\n          rightType = this.currentType;\r\n          rightFlow.freeScopedLocals();\r\n          this.currentFlow = flow;\r\n\r\n          // simplify if cloning left without side effects is possible\r\n          if (expr = module.cloneExpression(leftExpr, true, 0)) {\r\n            expr = module.if(\r\n              this.makeIsTrueish(leftExpr, leftType, left),\r\n              expr,\r\n              rightExpr\r\n            );\r\n\r\n          // if not possible, tee left to a temp. local\r\n          } else {\r\n            let temp = flow.getTempLocal(leftType);\r\n            if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\r\n            if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\r\n            expr = module.if(\r\n              this.makeIsTrueish(module.local_tee(temp.index, leftExpr, leftType.isManaged), leftType, left),\r\n              module.local_get(temp.index, leftType.toRef()),\r\n              rightExpr\r\n            );\r\n            flow.freeTempLocal(temp);\r\n          }\r\n          this.currentType = leftType;\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        assert(false);\r\n        expr = this.module.unreachable();\r\n      }\r\n    }\r\n    if (!compound) return expr;\r\n    var resolver = this.resolver;\r\n    var target = resolver.lookupExpression(left, this.currentFlow);\r\n    if (!target) return module.unreachable();\r\n    var targetType = resolver.getTypeOfElement(target);\r\n    if (!targetType) targetType = Type.void;\r\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        expression.range, this.currentType.toString(), targetType.toString()\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    return this.makeAssignment(\r\n      target,\r\n      expr,\r\n      this.currentType,\r\n      right,\r\n      resolver.currentThisExpression,\r\n      resolver.currentElementExpression,\r\n      contextualType != Type.void\r\n    );\r\n  }\r\n\r\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.LtI64\r\n            : BinaryOp.LtI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.LtU64\r\n            : BinaryOp.LtU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.GtI64\r\n            : BinaryOp.GtI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.GtU64\r\n            : BinaryOp.GtU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.LeI64\r\n            : BinaryOp.LeI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.LeU64\r\n            : BinaryOp.LeU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.GeI64\r\n            : BinaryOp.GeI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.GeU64\r\n            : BinaryOp.GeU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\r\n    // Cares about garbage bits\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.EqI64\r\n            : BinaryOp.EqI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.V128: {\r\n        return module.unary(UnaryOp.AllTrueI8x16,\r\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\r\n        );\r\n      }\r\n      case TypeKind.EQREF:\r\n      case TypeKind.I31REF:\r\n      case TypeKind.DATAREF: {\r\n        return module.ref_eq(leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n      case TypeKind.ANYREF: {\r\n        this.error(\r\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n          reportNode.range,\r\n          \"ref.eq\",\r\n          type.toString()\r\n        );\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\r\n    // Cares about garbage bits\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.NeI64\r\n            : BinaryOp.NeI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.V128: {\r\n        return module.unary(UnaryOp.AnyTrueV128,\r\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\r\n        );\r\n      }\r\n      case TypeKind.EQREF:\r\n      case TypeKind.I31REF:\r\n      case TypeKind.DATAREF: {\r\n        return module.unary(UnaryOp.EqzI32,\r\n          module.ref_eq(leftExpr, rightExpr)\r\n        );\r\n      }\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n      case TypeKind.ANYREF: {\r\n        this.error(\r\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\r\n          reportNode.range,\r\n          \"ref.eq\",\r\n          type.toString()\r\n        );\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Does not care about garbage bits or signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL:\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.AddI64\r\n            : BinaryOp.AddI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Does not care about garbage bits or signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL:\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.SubI64\r\n            : BinaryOp.SubI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Does not care about garbage bits or signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL:\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.MulI64\r\n            : BinaryOp.MulI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\r\n    // Cares about garbage bits\r\n    let module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: {\r\n        return module.select(\r\n          module.i32(1),\r\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\r\n          leftExpr\r\n        );\r\n      }\r\n      case TypeKind.I8:\r\n      case TypeKind.U8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        let instance = this.i32PowInstance;\r\n        if (!instance) {\r\n          let prototype = this.program.lookup(CommonNames.ipow32);\r\n          if (!prototype) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"ipow32\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n        if (type.size < 32) {\r\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\r\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\r\n          expr = this.ensureSmallIntegerWrap(expr, type);\r\n        }\r\n        return expr;\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        let instance = this.i64PowInstance;\r\n        if (!instance) {\r\n          let prototype = this.program.lookup(CommonNames.ipow64);\r\n          if (!prototype) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"ipow64\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        let isWasm64 = this.options.isWasm64;\r\n        let instance = isWasm64 ? this.i64PowInstance : this.i32PowInstance;\r\n        if (!instance) {\r\n          let prototype = this.program.lookup(isWasm64 ? CommonNames.ipow64 : CommonNames.ipow32);\r\n          if (!prototype) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n          if (isWasm64) {\r\n            this.i64PowInstance = instance;\r\n          } else {\r\n            this.i32PowInstance = instance;\r\n          }\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n      }\r\n      case TypeKind.F32: {\r\n        let instance = this.f32PowInstance;\r\n        if (!instance) {\r\n          let namespace = this.program.lookup(CommonNames.Mathf);\r\n          if (!namespace) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Mathf\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let namespaceMembers = namespace.members;\r\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Mathf.pow\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n      }\r\n      // Math.pow otherwise (result is f64)\r\n      case TypeKind.F64: {\r\n        let instance = this.f64PowInstance;\r\n        if (!instance) {\r\n          let namespace = this.program.lookup(CommonNames.Math);\r\n          if (!namespace) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Math\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let namespaceMembers = namespace.members;\r\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Math.pow\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.DivI64\r\n            : BinaryOp.DivI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.DivU64\r\n            : BinaryOp.DivU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F64: {\r\n        return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\r\n    // Cares about garbage bits and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.RemI64\r\n            : BinaryOp.RemI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\r\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\r\n        // falls through\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.RemU64\r\n            : BinaryOp.RemU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.F32: {\r\n        let instance = this.f32ModInstance;\r\n        if (!instance) {\r\n          let namespace = this.program.lookup(CommonNames.Mathf);\r\n          if (!namespace) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Mathf\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let namespaceMembers = namespace.members;\r\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Mathf.mod\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n      }\r\n      case TypeKind.F64: {\r\n        let instance = this.f64ModInstance;\r\n        if (!instance) {\r\n          let namespace = this.program.lookup(CommonNames.Math);\r\n          if (!namespace) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Math\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let namespaceMembers = namespace.members;\r\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              reportNode.range, \"Math.mod\"\r\n            );\r\n            return module.unreachable();\r\n          }\r\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\r\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n        }\r\n        if (!instance || !this.compileFunction(instance)) {\r\n          return module.unreachable();\r\n        }\r\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: return leftExpr;\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16: {\r\n        // leftExpr << (rightExpr & (7|15))\r\n        return module.binary(\r\n          BinaryOp.ShlI32,\r\n          leftExpr,\r\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\r\n        );\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.ShlI64\r\n            : BinaryOp.ShlI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\r\n    // and signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: return leftExpr;\r\n      case TypeKind.I8:\r\n      case TypeKind.I16: {\r\n        // leftExpr >> (rightExpr & (7|15))\r\n        return module.binary(\r\n          BinaryOp.ShrI32,\r\n          this.ensureSmallIntegerWrap(leftExpr, type),\r\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\r\n        );\r\n      }\r\n      case TypeKind.U8:\r\n      case TypeKind.U16: {\r\n        // leftExpr >>> (rightExpr & (7|15))\r\n        return module.binary(\r\n          BinaryOp.ShrU32,\r\n          this.ensureSmallIntegerWrap(leftExpr, type),\r\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\r\n        );\r\n      }\r\n      case TypeKind.I32: {\r\n        return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64: {\r\n        return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.ShrI64\r\n            : BinaryOp.ShrI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.ShrU64\r\n            : BinaryOp.ShrU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.BOOL: return leftExpr;\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16: {\r\n        // leftExpr >>> (rightExpr & (7|15))\r\n        return module.binary(\r\n          BinaryOp.ShrU32,\r\n          this.ensureSmallIntegerWrap(leftExpr, type),\r\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\r\n        );\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.ShrU64\r\n            : BinaryOp.ShrU32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Does not care about garbage bits or signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.AndI64\r\n            : BinaryOp.AndI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Does not care about garbage bits or signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.OrI64\r\n            : BinaryOp.OrI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\r\n    // Does not care about garbage bits or signedness\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL: {\r\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\r\n      }\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: {\r\n        return module.binary(\r\n          this.options.isWasm64\r\n            ? BinaryOp.XorI64\r\n            : BinaryOp.XorI32,\r\n          leftExpr,\r\n          rightExpr\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  private compileUnaryOverload(\r\n    operatorInstance: Function,\r\n    value: Expression,\r\n    valueExpr: ExpressionRef,\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\r\n    // is a bad idea currently. so this assumes that the type matches.\r\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\r\n  }\r\n\r\n  private compileBinaryOverload(\r\n    operatorInstance: Function,\r\n    left: Expression,\r\n    leftExpr: ExpressionRef,\r\n    right: Expression,\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    var rightType: Type;\r\n    if (operatorInstance.is(CommonFlags.INSTANCE)) {\r\n      let classInstance = assert(operatorInstance.parent); assert(classInstance.kind == ElementKind.CLASS);\r\n      rightType = operatorInstance.signature.parameterTypes[0];\r\n    } else {\r\n      // FIXME: if LHS type differs we can't recompile left because that'd completely confuse\r\n      // local states, like having local flags that actually do not even exist, possibly\r\n      // releasing something random in that local before and evil things like that. Hence this\r\n      // assumes that LHS type matches, which in turn means that static overloads must be\r\n      // guaranteed to never mismatch LHS type, which in turn means that we can't have shiny\r\n      // things like multiple static overloads for different combinations of LHS/RHS types.\r\n      // We might want that at some point of course, but requires to complete the resolver so\r\n      // it can actually resolve every kind of expression without ever having to recompile.\r\n      rightType = operatorInstance.signature.parameterTypes[1];\r\n    }\r\n    var rightExpr = this.compileExpression(right, rightType, Constraints.CONV_IMPLICIT);\r\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\r\n  }\r\n\r\n  private compileAssignment(\r\n    expression: Expression,\r\n    valueExpression: Expression,\r\n    contextualType: Type\r\n  ): ExpressionRef {\r\n    var program = this.program;\r\n    var resolver = program.resolver;\r\n    var flow = this.currentFlow;\r\n    var target = resolver.lookupExpression(expression, flow); // reports\r\n    if (!target) return this.module.unreachable();\r\n    var thisExpression = resolver.currentThisExpression;\r\n    var elementExpression = resolver.currentElementExpression;\r\n\r\n    // to compile just the value, we need to know the target's type\r\n    var targetType: Type;\r\n    switch (target.kind) {\r\n      case ElementKind.GLOBAL: {\r\n        // not yet compiled if a static field compiled as a global\r\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\r\n        // fall-through\r\n      }\r\n      case ElementKind.LOCAL:\r\n      case ElementKind.FIELD: {\r\n        if (this.pendingElements.has(target)) {\r\n          this.error(\r\n            DiagnosticCode.Variable_0_used_before_its_declaration,\r\n            expression.range,\r\n            target.internalName\r\n          );\r\n          return this.module.unreachable();\r\n        }\r\n        targetType = (<VariableLikeElement>target).type;\r\n        if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyPrototype = <PropertyPrototype>target;\r\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\r\n        if (!propertyInstance) return this.module.unreachable();\r\n        target = propertyInstance;\r\n        // fall-through\r\n      }\r\n      case ElementKind.PROPERTY: {\r\n        let propertyInstance = <Property>target;\r\n        let setterInstance = propertyInstance.setterInstance;\r\n        if (!setterInstance) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            expression.range, propertyInstance.internalName\r\n          );\r\n          return this.module.unreachable();\r\n        }\r\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\r\n        targetType = setterInstance.signature.parameterTypes[0];\r\n        if (setterInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\r\n        break;\r\n      }\r\n      case ElementKind.INDEXSIGNATURE: {\r\n        let parent = (<IndexSignature>target).parent;\r\n        assert(parent.kind == ElementKind.CLASS);\r\n        let classInstance = <Class>parent;\r\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\r\n        let indexedSet = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\r\n        if (!indexedSet) {\r\n          let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\r\n          if (!indexedGet) {\r\n            this.error(\r\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n              expression.range, classInstance.internalName\r\n            );\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\r\n              expression.range, classInstance.internalName\r\n            );\r\n          }\r\n          return this.module.unreachable();\r\n        }\r\n        assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this\r\n        targetType = indexedSet.signature.parameterTypes[1];     // 2nd parameter is the element\r\n        if (indexedSet.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\r\n        if (!isUnchecked && this.options.pedantic) {\r\n          this.pedantic(\r\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\r\n            expression.range\r\n          );\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        this.error(\r\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n          expression.range, target.internalName\r\n        );\r\n        return this.module.unreachable();\r\n      }\r\n    }\r\n\r\n    // compile the value and do the assignment\r\n    assert(targetType != Type.void);\r\n    var valueExpr = this.compileExpression(valueExpression, targetType);\r\n    var valueType = this.currentType;\r\n    return this.makeAssignment(\r\n      target,\r\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\r\n      valueType,\r\n      valueExpression,\r\n      thisExpression,\r\n      elementExpression,\r\n      contextualType != Type.void\r\n    );\r\n  }\r\n\r\n  /** Makes an assignment expression or block, assigning a value to a target. */\r\n  makeAssignment(\r\n    /** Target element, e.g. a Local. */\r\n    target: Element,\r\n    /** Value expression that has been compiled in a previous step already. */\r\n    valueExpr: ExpressionRef,\r\n    /** Value expression type. */\r\n    valueType: Type,\r\n    /** Expression reference. Has already been compiled to `valueExpr`. */\r\n    valueExpression: Expression,\r\n    /** `this` expression reference if a field or property set. */\r\n    thisExpression: Expression | null,\r\n    /** Index expression reference if an indexed set. */\r\n    indexExpression: Expression | null,\r\n    /** Whether to tee the value. */\r\n    tee: bool\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n\r\n    switch (target.kind) {\r\n      case ElementKind.LOCAL: {\r\n        let local = <Local>target;\r\n        if (flow.isLocalFlag(local.index, LocalFlags.CONSTANT, true)) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            valueExpression.range, target.internalName\r\n          );\r\n          this.currentType = tee ? local.type : Type.void;\r\n          return module.unreachable();\r\n        }\r\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\r\n      }\r\n      case ElementKind.GLOBAL: {\r\n        let global = <Global>target;\r\n        if (!this.compileGlobal(global)) return module.unreachable();\r\n        if (target.isAny(CommonFlags.CONST | CommonFlags.READONLY)) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            valueExpression.range,\r\n            target.internalName\r\n          );\r\n          this.currentType = tee ? global.type : Type.void;\r\n          return module.unreachable();\r\n        }\r\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\r\n      }\r\n      case ElementKind.FIELD: {\r\n        let fieldInstance = <Field>target;\r\n        let initializerNode = fieldInstance.initializerNode;\r\n        let isConstructor = flow.actualFunction.is(CommonFlags.CONSTRUCTOR);\r\n\r\n        // Cannot assign to readonly fields except in constructors if there's no initializer\r\n        if (fieldInstance.is(CommonFlags.READONLY)) {\r\n          if (!isConstructor || initializerNode !== null) {\r\n            this.error(\r\n              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n              valueExpression.range, fieldInstance.internalName\r\n            );\r\n            return module.unreachable();\r\n          }\r\n        }\r\n\r\n        // Mark initialized fields in constructors\r\n        thisExpression = assert(thisExpression);\r\n        if (isConstructor && thisExpression.kind == NodeKind.THIS) {\r\n          flow.setThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED);\r\n        }\r\n\r\n        let fieldParent = fieldInstance.parent;\r\n        assert(fieldParent.kind == ElementKind.CLASS);\r\n        return this.makeFieldAssignment(fieldInstance,\r\n          valueExpr,\r\n          valueType,\r\n          this.compileExpression(\r\n            thisExpression,\r\n            (<Class>fieldParent).type,\r\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n          ),\r\n          tee\r\n        );\r\n      }\r\n      case ElementKind.PROPERTY: {\r\n        let propertyInstance = <Property>target;\r\n        let setterInstance = propertyInstance.setterInstance;\r\n        if (!setterInstance) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            valueExpression.range, target.internalName\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        assert(setterInstance.signature.parameterTypes.length == 1);\r\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\r\n          let thisType = assert(setterInstance.signature.thisType);\r\n          let thisExpr = this.compileExpression(\r\n            assert(thisExpression),\r\n            thisType,\r\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n          );\r\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\r\n          let getterInstance = assert((<Property>target).getterInstance);\r\n          assert(getterInstance.signature.thisType == thisType);\r\n          let returnType = getterInstance.signature.returnType;\r\n          let returnTypeRef = returnType.toRef();\r\n          let tempThis = flow.getTempLocal(returnType);\r\n          let ret = module.block(null, [\r\n            this.makeCallDirect(setterInstance, [\r\n              module.local_tee(tempThis.index, thisExpr, returnType.isManaged),\r\n              valueExpr\r\n            ], valueExpression),\r\n            this.makeCallDirect(getterInstance, [\r\n              module.local_get(tempThis.index, returnTypeRef)\r\n            ], valueExpression)\r\n          ], returnTypeRef);\r\n          flow.freeTempLocal(tempThis);\r\n          return ret;\r\n        } else {\r\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\r\n          let getterInstance = assert((<Property>target).getterInstance);\r\n          return module.block(null, [\r\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\r\n            this.makeCallDirect(getterInstance, null, valueExpression)\r\n          ], getterInstance.signature.returnType.toRef());\r\n        }\r\n      }\r\n      case ElementKind.INDEXSIGNATURE: {\r\n        let indexSignature = <IndexSignature>target;\r\n        let parent = indexSignature.parent;\r\n        assert(parent.kind == ElementKind.CLASS);\r\n        let classInstance = <Class>parent;\r\n        assert(classInstance.kind == ElementKind.CLASS);\r\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\r\n        let getterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\r\n        if (!getterInstance) {\r\n          this.error(\r\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n            valueExpression.range, classInstance.internalName\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        let setterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\r\n        if (!setterInstance) {\r\n          this.error(\r\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\r\n            valueExpression.range, classInstance.internalName\r\n          );\r\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\r\n          return module.unreachable();\r\n        }\r\n        assert(setterInstance.signature.parameterTypes.length == 2);\r\n        let thisType = classInstance.type;\r\n        let thisExpr = this.compileExpression(\r\n          assert(thisExpression),\r\n          thisType,\r\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n        );\r\n        let elementExpr = this.compileExpression(assert(indexExpression), Type.i32, Constraints.CONV_IMPLICIT);\r\n        let elementType = this.currentType;\r\n        if (tee) {\r\n          let tempTarget = flow.getTempLocal(thisType);\r\n          let tempElement = flow.getTempLocal(elementType);\r\n          let returnType = getterInstance.signature.returnType;\r\n          let ret = module.block(null, [\r\n            this.makeCallDirect(setterInstance, [\r\n              module.local_tee(tempTarget.index, thisExpr, thisType.isManaged),\r\n              module.local_tee(tempElement.index, elementExpr, elementType.isManaged),\r\n              valueExpr\r\n            ], valueExpression),\r\n            this.makeCallDirect(getterInstance, [\r\n              module.local_get(tempTarget.index, tempTarget.type.toRef()),\r\n              module.local_get(tempElement.index, tempElement.type.toRef())\r\n            ], valueExpression)\r\n          ], returnType.toRef());\r\n          flow.freeTempLocal(tempElement);\r\n          flow.freeTempLocal(tempTarget);\r\n          return ret;\r\n        } else {\r\n          return this.makeCallDirect(setterInstance, [\r\n            thisExpr,\r\n            elementExpr,\r\n            valueExpr\r\n          ], valueExpression);\r\n        }\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  /** Makes an assignment to a local, keeping track of wrap and null states. */\r\n  private makeLocalAssignment(\r\n    /** Local to assign to. */\r\n    local: Local,\r\n    /** Value to assign. */\r\n    valueExpr: ExpressionRef,\r\n    /** Value type. */\r\n    valueType: Type,\r\n    /** Whether to tee the value. */\r\n    tee: bool\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var type = local.type;\r\n    assert(type != Type.void);\r\n    var localIndex = local.index;\r\n\r\n    if (type.isNullableReference) {\r\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NONNULL);\r\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NONNULL);\r\n    }\r\n    flow.setLocalFlag(localIndex, LocalFlags.INITIALIZED);\r\n    if (type.isShortIntegerValue) {\r\n      if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.WRAPPED);\r\n      else flow.unsetLocalFlag(localIndex, LocalFlags.WRAPPED);\r\n    }\r\n    if (tee) { // local = value\r\n      this.currentType = type;\r\n      return module.local_tee(localIndex, valueExpr, type.isManaged);\r\n    } else { // void(local = value)\r\n      this.currentType = Type.void;\r\n      return module.local_set(localIndex, valueExpr, type.isManaged);\r\n    }\r\n  }\r\n\r\n  /** Makes an assignment to a global. */\r\n  private makeGlobalAssignment(\r\n    /** The global variable to assign to. */\r\n    global: VariableLikeElement,\r\n    /** The value to assign. */\r\n    valueExpr: ExpressionRef,\r\n    /** The type of the value to assign. */\r\n    valueType: Type,\r\n    /** Whether to tee the value. */\r\n    tee: bool\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var type = global.type;\r\n    assert(type != Type.void);\r\n    var typeRef = type.toRef();\r\n\r\n    valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\r\n    if (tee) { // (global = value), global\r\n      this.currentType = type;\r\n      return module.block(null, [\r\n        module.global_set(global.internalName, valueExpr),\r\n        module.global_get(global.internalName, typeRef)\r\n      ], typeRef);\r\n    } else { // global = value\r\n      this.currentType = Type.void;\r\n      return module.global_set(global.internalName,\r\n        valueExpr\r\n      );\r\n    }\r\n  }\r\n\r\n  /** Makes an assignment to a field. */\r\n  private makeFieldAssignment(\r\n    /** The field to assign to. */\r\n    field: Field,\r\n    /** The value to assign. */\r\n    valueExpr: ExpressionRef,\r\n    /** The type of the value to assign. */\r\n    valueType: Type,\r\n    /** The value of `this`. */\r\n    thisExpr: ExpressionRef,\r\n    /** Whether to tee the value. */\r\n    tee: bool\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var fieldType = field.type;\r\n    var fieldTypeRef = fieldType.toRef();\r\n    assert(field.parent.kind == ElementKind.CLASS);\r\n    var thisType = (<Class>field.parent).type;\r\n\r\n    if (!field.is(CommonFlags.COMPILED)) {\r\n      field.set(CommonFlags.COMPILED);\r\n      let typeNode = field.typeNode;\r\n      if (typeNode) this.checkTypeSupported(field.type, typeNode);\r\n    }\r\n\r\n    if (tee) {\r\n      this.compileField(field);\r\n      let tempThis = flow.getTempLocal(thisType);\r\n      let expr = module.block(null, [\r\n        module.call(field.internalSetterName, [ module.local_tee(tempThis.index, thisExpr, thisType.isManaged), valueExpr ], TypeRef.None),\r\n        module.call(field.internalGetterName, [ module.local_get(tempThis.index, thisType.toRef()) ], fieldTypeRef)\r\n      ], fieldTypeRef);\r\n      flow.freeTempLocal(tempThis);\r\n      this.currentType = fieldType;\r\n      return expr;\r\n    } else {\r\n      this.compileFieldSetter(field);\r\n      let expr = module.call(field.internalSetterName, [ thisExpr, valueExpr ], TypeRef.None);\r\n      this.currentType = Type.void;\r\n      return expr;\r\n    }\r\n  }\r\n\r\n  /** Compiles a call expression according to the specified context. */\r\n  private compileCallExpression(\r\n    /** Call expression to compile. */\r\n    expression: CallExpression,\r\n    /** Contextual type indicating the return type the caller expects, if any. */\r\n    contextualType: Type,\r\n    /** Constraints indicating contextual conditions. */\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n\r\n    // handle call to super\r\n    if (expression.expression.kind == NodeKind.SUPER) {\r\n      let flow = this.currentFlow;\r\n      let actualFunction = flow.actualFunction;\r\n      if (!actualFunction.is(CommonFlags.CONSTRUCTOR)) {\r\n        this.error(\r\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\r\n          expression.range\r\n        );\r\n        return module.unreachable();\r\n      }\r\n\r\n      let parent = assert(actualFunction.parent);\r\n      assert(parent.kind == ElementKind.CLASS);\r\n      let classInstance = <Class>parent;\r\n      let baseClassInstance = classInstance.base;\r\n      if (!baseClassInstance) {\r\n        this.error(\r\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\r\n          expression.expression.range\r\n        );\r\n        return module.unreachable();\r\n      }\r\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\r\n      let sizeTypeRef = this.options.sizeTypeRef;\r\n\r\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\r\n      this.checkFieldInitialization(baseClassInstance, expression);\r\n      let superCall = this.compileCallDirect(\r\n        baseCtorInstance,\r\n        expression.args,\r\n        expression,\r\n        module.local_get(thisLocal.index, sizeTypeRef)\r\n      );\r\n\r\n      // check that super had been called before accessing `this`\r\n      if (flow.isAny(\r\n        FlowFlags.ACCESSES_THIS |\r\n        FlowFlags.CONDITIONALLY_ACCESSES_THIS\r\n      )) {\r\n        this.error(\r\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\r\n          expression.range\r\n        );\r\n        return module.unreachable();\r\n      }\r\n      flow.set(FlowFlags.ACCESSES_THIS | FlowFlags.CALLS_SUPER);\r\n      this.currentType = Type.void;\r\n      return module.local_set(thisLocal.index, superCall, classInstance.type.isManaged);\r\n    }\r\n\r\n    // otherwise resolve normally\r\n    var target = this.resolver.lookupExpression(expression.expression, flow); // reports\r\n    if (!target) return module.unreachable();\r\n    var thisExpression = this.resolver.currentThisExpression;\r\n\r\n    var signature: Signature | null;\r\n    var functionArg: ExpressionRef;\r\n    switch (target.kind) {\r\n\r\n      // direct call: concrete function\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        let functionPrototype = <FunctionPrototype>target;\r\n        if (functionPrototype.hasDecorator(DecoratorFlags.BUILTIN)) {\r\n          // builtins handle present respectively omitted type arguments on their own\r\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\r\n        }\r\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\r\n        if (!functionInstance) return this.module.unreachable();\r\n        target = functionInstance;\r\n        // fall-through\r\n      }\r\n      case ElementKind.FUNCTION: {\r\n        let functionInstance = <Function>target;\r\n        let thisArg: ExpressionRef = 0;\r\n        if (functionInstance.is(CommonFlags.INSTANCE)) {\r\n          thisArg = this.compileExpression(\r\n            assert(thisExpression),\r\n            assert(functionInstance.signature.thisType),\r\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n          );\r\n        }\r\n        return this.compileCallDirect(\r\n          functionInstance,\r\n          expression.args,\r\n          expression,\r\n          thisArg,\r\n          constraints\r\n        );\r\n      }\r\n\r\n      // indirect call: first-class function (non-generic, can't be inlined)\r\n      case ElementKind.LOCAL: {\r\n        let local = <Local>target;\r\n        signature = local.type.signatureReference;\r\n        if (signature) {\r\n          if (local.is(CommonFlags.INLINED)) {\r\n            let inlinedValue = local.constantIntegerValue;\r\n            if (this.options.isWasm64) {\r\n              functionArg = module.i64(i64_low(inlinedValue), i64_high(inlinedValue));\r\n            } else {\r\n              assert(!i64_high(inlinedValue));\r\n              functionArg = module.i32(i64_low(inlinedValue));\r\n            }\r\n          } else {\r\n            functionArg = module.local_get(local.index, this.options.sizeTypeRef);\r\n          }\r\n          break;\r\n        }\r\n        this.error(\r\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n          expression.range, local.type.toString()\r\n        );\r\n        return module.unreachable();\r\n      }\r\n      case ElementKind.GLOBAL: {\r\n        let global = <Global>target;\r\n        signature = global.type.signatureReference;\r\n        if (signature) {\r\n          functionArg = module.global_get(global.internalName, global.type.toRef());\r\n          break;\r\n        }\r\n        this.error(\r\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n          expression.range, global.type.toString()\r\n        );\r\n        return module.unreachable();\r\n      }\r\n      case ElementKind.FIELD: {\r\n        let fieldInstance = <Field>target;\r\n        let fieldType = fieldInstance.type;\r\n        signature = fieldType.signatureReference;\r\n        if (signature) {\r\n          let fieldParent = fieldInstance.parent;\r\n          assert(fieldParent.kind == ElementKind.CLASS);\r\n          let usizeType = this.options.usizeType;\r\n          functionArg = module.load(usizeType.byteSize, false,\r\n            this.compileExpression(\r\n              assert(thisExpression),\r\n              (<Class>fieldParent).type,\r\n              Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n            ),\r\n            usizeType.toRef(),\r\n            fieldInstance.memoryOffset\r\n          );\r\n          break;\r\n        }\r\n        this.error(\r\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n          expression.range, fieldType.toString()\r\n        );\r\n        return module.unreachable();\r\n      }\r\n\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\r\n        if (!propertyInstance) return module.unreachable();\r\n        target = propertyInstance;\r\n        // fall-through\r\n      }\r\n      case ElementKind.PROPERTY: {\r\n        let propertyInstance = <Property>target;\r\n        let getterInstance = propertyInstance.getterInstance;\r\n        let type = assert(this.resolver.getTypeOfElement(target));\r\n\r\n        if (!getterInstance) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n            expression.range, type.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        let thisArg: ExpressionRef = 0;\r\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\r\n          thisArg = this.compileExpression(\r\n            assert(thisExpression),\r\n            assert(getterInstance.signature.thisType),\r\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n          );\r\n        }\r\n        functionArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);\r\n        signature = this.currentType.signatureReference;\r\n        if (!signature) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n            expression.range, this.currentType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.CLASS: {\r\n        let classInstance = <Class>target;\r\n        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);\r\n        if (typeArguments !== null && typeArguments.length > 0) {\r\n          let ftype = typeArguments[0];\r\n          signature = ftype.getSignature();\r\n          functionArg = this.compileExpression(expression.expression, ftype, Constraints.CONV_IMPLICIT);\r\n          break;\r\n        }\r\n        // fall-through\r\n      }\r\n\r\n      // not supported\r\n      default: {\r\n        let type = this.resolver.getTypeOfElement(target);\r\n        if (type) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_has_no_call_signatures,\r\n            expression.range, type.toString()\r\n          );\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n            expression.range\r\n          );\r\n        }\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    return this.compileCallIndirect(\r\n      assert(signature), // FIXME: bootstrap can't see this yet\r\n      functionArg,\r\n      expression.args,\r\n      expression,\r\n      0,\r\n      contextualType == Type.void\r\n    );\r\n  }\r\n\r\n  /** Compiles the given arguments like a call expression according to the specified context. */\r\n  private compileCallExpressionLike(\r\n    /** Called expression. */\r\n    expression: Expression,\r\n    /** Call type arguments. */\r\n    typeArguments: TypeNode[] | null,\r\n    /** Call arguments. */\r\n    args: Expression[],\r\n    /** Diagnostic range. */\r\n    range: Range,\r\n    /** Contextual type indicating the return type the caller expects, if any. */\r\n    contextualType: Type,\r\n    /** Constraints indicating contextual conditions. */\r\n    constraints: Constraints = Constraints.NONE\r\n  ): ExpressionRef {\r\n    // Desugaring like this can happen many times. Let's cache the intermediate allocation.\r\n    var call = this._reusableCallExpression;\r\n    if (call) {\r\n      call.expression = expression;\r\n      call.typeArguments = typeArguments;\r\n      call.args = args;\r\n      call.range = range;\r\n    } else {\r\n      this._reusableCallExpression = call = Node.createCallExpression(expression, typeArguments, args, range);\r\n    }\r\n    return this.compileCallExpression(call, contextualType, constraints);\r\n  }\r\n  private _reusableCallExpression: CallExpression | null = null;\r\n\r\n  private compileCallExpressionBuiltin(\r\n    prototype: FunctionPrototype,\r\n    expression: CallExpression,\r\n    contextualType: Type\r\n  ): ExpressionRef {\r\n    if (prototype.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\r\n\r\n    var typeArguments: Type[] | null = null;\r\n\r\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\r\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\r\n    var typeParameterNodes = prototype.typeParameterNodes;\r\n    var typeArgumentNodes = expression.typeArguments;\r\n    if (expression.typeArguments) {\r\n      if (!prototype.is(CommonFlags.GENERIC)) {\r\n        this.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          expression.range, prototype.internalName\r\n        );\r\n      }\r\n      typeArguments = this.resolver.resolveTypeArguments(\r\n        assert(typeParameterNodes),\r\n        typeArgumentNodes,\r\n        this.currentFlow.actualFunction.parent,\r\n        uniqueMap<string,Type>(this.currentFlow.contextualTypeArguments), // don't update\r\n        expression\r\n      );\r\n    }\r\n    var callee = expression.expression;\r\n    var ctx = new BuiltinContext(\r\n      this,\r\n      prototype,\r\n      typeArguments,\r\n      expression.args,\r\n      callee.kind == NodeKind.PROPERTYACCESS\r\n        ? (<PropertyAccessExpression>callee).expression\r\n        : null,\r\n      contextualType,\r\n      expression,\r\n      false\r\n    );\r\n    // global builtins\r\n    var internalName = prototype.internalName;\r\n    if (builtins.has(internalName)) {\r\n      let fn = assert(builtins.get(internalName));\r\n      return fn(ctx);\r\n    }\r\n    // class builtins\r\n    var parent = prototype.parent;\r\n    if (parent.kind == ElementKind.CLASS) {\r\n      let classPrototype = (<Class>parent).prototype;\r\n      if (classPrototype == this.program.functionPrototype) {\r\n        let methodName = prototype.name;\r\n        if (function_builtins.has(methodName)) {\r\n          let fn = assert(function_builtins.get(methodName));\r\n          return fn(ctx);\r\n        }\r\n      }\r\n    }\r\n    assert(false);\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  /**\r\n   * Checks that a call with the given number as arguments can be performed according to the\r\n   * specified signature.\r\n   */\r\n  checkCallSignature(\r\n    signature: Signature,\r\n    numArguments: i32,\r\n    hasThis: bool,\r\n    reportNode: Node\r\n  ): bool {\r\n\r\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\r\n    var thisType = signature.thisType;\r\n    if (hasThis != (thisType != null)) {\r\n      this.error(\r\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\r\n        reportNode.range\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\r\n    var hasRest = signature.hasRest;\r\n    if (hasRest) {\r\n      this.error(\r\n        DiagnosticCode.Not_implemented_0,\r\n        reportNode.range, \"Rest parameters\"\r\n      );\r\n      return false;\r\n    }\r\n\r\n    var minimum = signature.requiredParameters;\r\n    var maximum = signature.parameterTypes.length;\r\n\r\n    // must at least be called with required arguments\r\n    if (numArguments < minimum) {\r\n      this.error(\r\n        minimum < maximum\r\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\r\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\r\n        reportNode.range, minimum.toString(), numArguments.toString()\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // must not be called with more than the maximum arguments\r\n    if (numArguments > maximum && !hasRest) {\r\n      this.error(\r\n        DiagnosticCode.Expected_0_arguments_but_got_1,\r\n        reportNode.range, maximum.toString(), numArguments.toString()\r\n      );\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /** Checks that an unsafe expression is allowed. */\r\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\r\n    // Library files may always use unsafe features\r\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\r\n      if (relatedReportNode) {\r\n        this.errorRelated(\r\n          DiagnosticCode.Operation_is_unsafe,\r\n          reportNode.range, relatedReportNode.range\r\n        );\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Operation_is_unsafe,\r\n          reportNode.range\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Compiles a direct call to a concrete function. */\r\n  compileCallDirect(\r\n    instance: Function,\r\n    argumentExpressions: Expression[],\r\n    reportNode: Node,\r\n    thisArg: ExpressionRef = 0,\r\n    constraints: Constraints = Constraints.NONE\r\n  ): ExpressionRef {\r\n    var numArguments = argumentExpressions.length;\r\n    var signature = instance.signature;\r\n    if (!this.checkCallSignature( // reports\r\n      signature,\r\n      numArguments,\r\n      thisArg != 0,\r\n      reportNode\r\n    )) {\r\n      this.currentType = signature.returnType;\r\n      return this.module.unreachable();\r\n    }\r\n    if (instance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\r\n\r\n    // handle call on `this` in constructors\r\n    let actualFunction = this.currentFlow.actualFunction;\r\n    if (actualFunction.is(CommonFlags.CONSTRUCTOR) && reportNode.isAccessOnThis) {\r\n      let parent = actualFunction.parent;\r\n      assert(parent.kind == ElementKind.CLASS);\r\n      this.checkFieldInitialization(<Class>parent, reportNode);\r\n    }\r\n\r\n    // Inline if explicitly requested\r\n    if (instance.hasDecorator(DecoratorFlags.INLINE) && (!instance.is(CommonFlags.VIRTUAL) || reportNode.isAccessOnSuper)) {\r\n      assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\r\n      let inlineStack = this.inlineStack;\r\n      if (inlineStack.includes(instance)) {\r\n        this.warning(\r\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\r\n          reportNode.range, instance.internalName\r\n        );\r\n      } else {\r\n        inlineStack.push(instance);\r\n        let parameterTypes = signature.parameterTypes;\r\n        assert(numArguments <= parameterTypes.length);\r\n        // compile argument expressions\r\n        let args = new Array<ExpressionRef>(numArguments);\r\n        for (let i = 0; i < numArguments; ++i) {\r\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i], Constraints.CONV_IMPLICIT);\r\n        }\r\n        // make the inlined call\r\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WILL_DROP) != 0);\r\n        inlineStack.pop();\r\n        return expr;\r\n      }\r\n    }\r\n\r\n    // Otherwise compile to just a call\r\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\r\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\r\n    var index = 0;\r\n    if (thisArg) {\r\n      operands[0] = thisArg;\r\n      index = 1;\r\n    }\r\n    var parameterTypes = signature.parameterTypes;\r\n    for (let i = 0; i < numArguments; ++i, ++index) {\r\n      let paramType = parameterTypes[i];\r\n      let paramExpr = this.compileExpression(argumentExpressions[i], paramType, Constraints.CONV_IMPLICIT);\r\n      operands[index] = paramExpr;\r\n    }\r\n    assert(index == numArgumentsInclThis);\r\n    return this.makeCallDirect(instance, operands, reportNode, (constraints & Constraints.WILL_DROP) != 0);\r\n  }\r\n\r\n  makeCallInline(\r\n    instance: Function,\r\n    operands: ExpressionRef[] | null,\r\n    thisArg: ExpressionRef = 0,\r\n    immediatelyDropped: bool = false\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var numArguments = operands ? operands.length : 0;\r\n    var signature = instance.signature;\r\n    var parameterTypes = signature.parameterTypes;\r\n    var numParameters = parameterTypes.length;\r\n\r\n    // Create a new inline flow and use it to compile the function as a block\r\n    var previousFlow = this.currentFlow;\r\n    var flow = Flow.createInline(previousFlow.parentFunction, instance);\r\n    var body = [];\r\n    var usedLocals = new Set<i32>();\r\n\r\n    // Prepare compiled arguments right to left, keeping track of used locals.\r\n    for (let i = numArguments - 1; i >= 0; --i) {\r\n      // This is necessary because a later expression must not set an earlier argument local, which\r\n      // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where\r\n      // the right expression would reassign the foregoing argument local. So, we iterate from right\r\n      // to left, remembering what's used later, and don't use these for earlier arguments, making\r\n      // the example above essentially `t2=1, t1=(t1 = 2)`.\r\n      let paramExpr = operands![i];\r\n      let paramType = parameterTypes[i];\r\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType, usedLocals);\r\n      findUsedLocals(paramExpr, usedLocals);\r\n      // inlining is aware of wrap/nonnull states:\r\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\r\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\r\n      body.unshift(\r\n        module.local_set(argumentLocal.index, paramExpr, paramType.isManaged)\r\n      );\r\n    }\r\n    if (thisArg) {\r\n      let parent = assert(instance.parent);\r\n      assert(parent.kind == ElementKind.CLASS);\r\n      let classInstance = <Class>parent;\r\n      let thisType = assert(instance.signature.thisType);\r\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType, usedLocals);\r\n      body.unshift(\r\n        module.local_set(thisLocal.index, thisArg, thisType.isManaged)\r\n      );\r\n      let base = classInstance.base;\r\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\r\n    } else {\r\n      assert(!instance.signature.thisType);\r\n    }\r\n\r\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\r\n    // side-effects within earlier expressions because these already happened on set.\r\n    this.currentFlow = flow;\r\n    var isConstructor = instance.is(CommonFlags.CONSTRUCTOR);\r\n    if (isConstructor) flow.set(FlowFlags.CTORPARAM_CONTEXT);\r\n    for (let i = numArguments; i < numParameters; ++i) {\r\n      let initType = parameterTypes[i];\r\n      let initExpr = this.compileExpression(\r\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\r\n        initType,\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\r\n      body.push(\r\n        this.makeLocalAssignment(argumentLocal, initExpr, initType, false)\r\n      );\r\n    }\r\n    flow.unset(FlowFlags.CTORPARAM_CONTEXT);\r\n\r\n    // Compile the called function's body in the scope of the inlined flow\r\n    this.compileFunctionBody(instance, body);\r\n\r\n    // If a constructor, perform field init checks on its flow directly\r\n    if (isConstructor) {\r\n      let parent = instance.parent;\r\n      assert(parent.kind == ElementKind.CLASS);\r\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\r\n    }\r\n\r\n    // Free any new scoped locals and reset to the original flow\r\n    flow.freeScopedLocals();\r\n    var returnType = flow.returnType;\r\n    this.currentFlow = previousFlow;\r\n\r\n    // Create an outer block that we can break to when returning a value out of order\r\n    this.currentType = returnType;\r\n    return module.block(flow.inlineReturnLabel, body, returnType.toRef());\r\n  }\r\n\r\n  /** Makes sure that the arguments length helper global is present. */\r\n  ensureArgumentsLength(): string {\r\n    var name = BuiltinNames.argumentsLength;\r\n    if (!this.builtinArgumentsLength) {\r\n      let module = this.module;\r\n      this.builtinArgumentsLength = module.addGlobal(name, TypeRef.I32, true, module.i32(0));\r\n    }\r\n    return name;\r\n  }\r\n\r\n  /** Ensures compilation of the varargs stub for the specified function. */\r\n  ensureVarargsStub(original: Function): Function {\r\n    // A varargs stub is a function called with omitted arguments being zeroed,\r\n    // reading the `argumentsLength` helper global to decide which initializers\r\n    // to inject before calling the original function. It is typically attempted\r\n    // to circumvent the varargs stub where possible, for example where omitted\r\n    // arguments are constants and can be inlined into the original call.\r\n    var stub = original.varargsStub;\r\n    if (stub) return stub;\r\n\r\n    var originalSignature = original.signature;\r\n    var originalParameterTypes = originalSignature.parameterTypes;\r\n    var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\r\n    var returnType = originalSignature.returnType;\r\n    var isInstance = original.is(CommonFlags.INSTANCE);\r\n\r\n    // arguments excl. `this`, operands incl. `this`\r\n    var minArguments = originalSignature.requiredParameters;\r\n    var minOperands = minArguments;\r\n    var maxArguments = originalParameterTypes.length;\r\n    var maxOperands = maxArguments;\r\n    if (isInstance) {\r\n      ++minOperands;\r\n      ++maxOperands;\r\n    }\r\n    var numOptional = assert(maxOperands - minOperands);\r\n\r\n    var forwardedOperands = new Array<ExpressionRef>(minOperands);\r\n    var operandIndex = 0;\r\n    var stmts = new Array<ExpressionRef>();\r\n\r\n    // forward `this` if applicable\r\n    var module = this.module;\r\n    var thisType = originalSignature.thisType;\r\n    if (thisType) {\r\n      forwardedOperands[0] = module.local_get(0, thisType.toRef());\r\n      operandIndex = 1;\r\n    }\r\n\r\n    // forward required arguments\r\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\r\n      let paramType = originalParameterTypes[i];\r\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, paramType.toRef());\r\n    }\r\n    assert(operandIndex == minOperands);\r\n\r\n    // create the varargs stub\r\n    stub = original.newStub(\"varargs\");\r\n    stub.signature.requiredParameters = maxArguments;\r\n    original.varargsStub = stub;\r\n\r\n    // compile initializers of omitted arguments in the scope of the stub,\r\n    // accounting for additional locals and a proper `this` context.\r\n    var previousFlow = this.currentFlow;\r\n    var flow = stub.flow;\r\n    if (original.is(CommonFlags.CONSTRUCTOR)) flow.set(FlowFlags.CTORPARAM_CONTEXT);\r\n    this.currentFlow = flow;\r\n\r\n    // create a br_table switching over the number of optional parameters provided\r\n    var numNames = numOptional + 1; // incl. outer block\r\n    var names = new Array<string>(numNames);\r\n    var ofN = \"of\" + numOptional.toString();\r\n    for (let i = 0; i < numNames; ++i) {\r\n      let label = i.toString() + ofN;\r\n      names[i] = label;\r\n    }\r\n    var argumentsLength = this.ensureArgumentsLength();\r\n    var table = module.block(names[0], [\r\n      module.block(\"outOfRange\", [\r\n        module.switch(names, \"outOfRange\",\r\n          // condition is number of provided optional arguments, so subtract required arguments\r\n          minArguments\r\n            ? module.binary(\r\n                BinaryOp.SubI32,\r\n                module.global_get(argumentsLength, TypeRef.I32),\r\n                module.i32(minArguments)\r\n              )\r\n            : module.global_get(argumentsLength, TypeRef.I32)\r\n        )\r\n      ]),\r\n      module.unreachable()\r\n    ]);\r\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\r\n      let type = originalParameterTypes[minArguments + i];\r\n      let declaration = originalParameterDeclarations[minArguments + i];\r\n      let initializer = declaration.initializer;\r\n      let initExpr: ExpressionRef;\r\n      if (initializer) {\r\n        initExpr = this.compileExpression(\r\n          initializer,\r\n          type,\r\n          Constraints.CONV_IMPLICIT\r\n        );\r\n        initExpr = module.local_set(operandIndex, initExpr, type.isManaged);\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\r\n          declaration.range\r\n        );\r\n        initExpr = module.unreachable();\r\n      }\r\n      table = module.block(names[i + 1], [\r\n        table,\r\n        initExpr,\r\n      ]);\r\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toRef());\r\n    }\r\n    assert(operandIndex == maxOperands);\r\n\r\n    stmts.push(\r\n      table\r\n    );\r\n    stmts.push(\r\n      // assume this will always succeed (can just use name as the reportNode)\r\n      this.makeCallDirect(original, forwardedOperands, original.declaration.name)\r\n    );\r\n    flow.freeScopedLocals();\r\n    this.currentFlow = previousFlow;\r\n\r\n    var funcRef = module.addFunction(\r\n      stub.internalName,\r\n      stub.signature.paramRefs,\r\n      stub.signature.resultRefs,\r\n      typesToRefs(stub.additionalLocals),\r\n      module.flatten(stmts, returnType.toRef())\r\n    );\r\n    stub.set(CommonFlags.COMPILED);\r\n    stub.finalize(module, funcRef);\r\n    return stub;\r\n  }\r\n\r\n  /** Ensures compilation of the virtual stub for the specified function. */\r\n  ensureVirtualStub(original: Function): Function {\r\n    // A virtual stub is a function redirecting virtual calls to the actual\r\n    // overload targeted by the call. It utilizes varargs stubs where necessary\r\n    // and as such has the same semantics as one. Here, we only make sure that\r\n    // a placeholder exist, with actual code being generated as a finalization\r\n    // step once module compilation is otherwise complete.\r\n    var stub = original.virtualStub;\r\n    if (stub) return stub;\r\n    stub = original.newStub(\"virtual\");\r\n    original.virtualStub = stub;\r\n    var module = this.module;\r\n    stub.ref = module.addFunction(\r\n      stub.internalName,\r\n      stub.signature.paramRefs,\r\n      stub.signature.resultRefs,\r\n      null,\r\n      module.unreachable()\r\n    );\r\n    this.virtualCalls.add(original);\r\n    return stub;\r\n  }\r\n\r\n  /** Finalizes the virtual stub of the specified function. */\r\n  private finalizeVirtualStub(instance: Function): void {\r\n    var stub = this.ensureVirtualStub(instance);\r\n    if (stub.is(CommonFlags.COMPILED)) return;\r\n\r\n    // Wouldn't be here if there wasn't at least one overload\r\n    var overloadPrototypes = assert(instance.prototype.overloads);\r\n\r\n    assert(instance.parent.kind == ElementKind.CLASS || instance.parent.kind == ElementKind.INTERFACE);\r\n    var parentClassInstance = <Class>instance.parent;\r\n    var module = this.module;\r\n    var usizeType = this.options.usizeType;\r\n    var sizeTypeRef = usizeType.toRef();\r\n    var parameterTypes = instance.signature.parameterTypes;\r\n    var returnType = instance.signature.returnType;\r\n    var numParameters = parameterTypes.length;\r\n    var tempIndex = 1 + parameterTypes.length; // incl. `this`\r\n\r\n    // Switch over this's rtId and map it to the respective overload\r\n    var builder = new SwitchBuilder(this.module,\r\n      module.load(4, false,\r\n        module.binary(\r\n          sizeTypeRef == TypeRef.I64\r\n            ? BinaryOp.SubI64\r\n            : BinaryOp.SubI32,\r\n          module.local_get(0, sizeTypeRef),\r\n          sizeTypeRef == TypeRef.I64\r\n            ? module.i64(8) // rtId offset = -8\r\n            : module.i32(8)\r\n        ),\r\n        TypeRef.I32\r\n      )\r\n    );\r\n\r\n    // A method's `overloads` property contains its unbound overload prototypes\r\n    // so we first have to find the concrete classes it became bound to, obtain\r\n    // their bound prototypes and make sure these are resolved and compiled as\r\n    // we are going to call them conditionally based on this's class id.\r\n    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {\r\n      let unboundOverloadPrototype = _values[i];\r\n      assert(!unboundOverloadPrototype.isBound);\r\n      let unboundOverloadParent = unboundOverloadPrototype.parent;\r\n      let isProperty = unboundOverloadParent.kind == ElementKind.PROPERTY_PROTOTYPE;\r\n      let classInstances: Map<string,Class> | null;\r\n      if (isProperty) {\r\n        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;\r\n        assert(propertyParent.kind == ElementKind.CLASS_PROTOTYPE);\r\n        classInstances = (<ClassPrototype>propertyParent).instances;\r\n      } else {\r\n        assert(unboundOverloadParent.kind == ElementKind.CLASS_PROTOTYPE);\r\n        classInstances = (<ClassPrototype>unboundOverloadParent).instances;\r\n      }\r\n      if (classInstances) {\r\n        for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\r\n          let classInstance = _values[j];\r\n          // Chcek if the parent class is a subtype of instance's class\r\n          if (!classInstance.isAssignableTo(parentClassInstance)) continue;\r\n          let overloadInstance: Function | null;\r\n          if (isProperty) {\r\n            let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));\r\n            assert(boundProperty.kind == ElementKind.PROPERTY_PROTOTYPE);\r\n            let boundPropertyInstance = this.resolver.resolveProperty(<PropertyPrototype>boundProperty);\r\n            if (!boundPropertyInstance) continue;\r\n            if (instance.is(CommonFlags.GET)) {\r\n              overloadInstance = boundPropertyInstance.getterInstance;\r\n            } else {\r\n              assert(instance.is(CommonFlags.SET));\r\n              overloadInstance = boundPropertyInstance.setterInstance;\r\n            }\r\n          } else {\r\n            let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));\r\n            assert(boundPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n            overloadInstance = this.resolver.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\r\n          }\r\n          if (!overloadInstance || !this.compileFunction(overloadInstance)) continue;\r\n          let overloadType = overloadInstance.type;\r\n          let originalType = instance.type;\r\n          if (!overloadType.isAssignableTo(originalType)) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n              overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()\r\n            );\r\n            continue;\r\n          }\r\n          // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\r\n          let overloadSignature = overloadInstance.signature;\r\n          let overloadParameterTypes = overloadSignature.parameterTypes;\r\n          let overloadNumParameters = overloadParameterTypes.length;\r\n          let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);\r\n          paramExprs[0] = module.local_get(0, sizeTypeRef); // this\r\n          for (let n = 1; n <= numParameters; ++n) {\r\n            paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toRef());\r\n          }\r\n          let needsVarargsStub = false;\r\n          for (let n = numParameters; n < overloadNumParameters; ++n) {\r\n            // TODO: inline constant initializers and skip varargs stub\r\n            paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n], overloadInstance.declaration);\r\n            needsVarargsStub = true;\r\n          }\r\n          let calledName = needsVarargsStub\r\n            ? this.ensureVarargsStub(overloadInstance).internalName\r\n            : overloadInstance.internalName;\r\n          let returnTypeRef = overloadSignature.returnType.toRef();\r\n          let stmts = new Array<ExpressionRef>();\r\n          if (needsVarargsStub) {\r\n            // Safe to prepend since paramExprs are local.get's\r\n            stmts.push(module.global_set(this.ensureArgumentsLength(), module.i32(numParameters)));\r\n          }\r\n          if (returnType == Type.void) {\r\n            stmts.push(\r\n              module.call(calledName, paramExprs, returnTypeRef)\r\n            );\r\n            stmts.push(\r\n              module.return()\r\n            );\r\n          } else {\r\n            stmts.push(\r\n              module.return(\r\n                module.call(calledName, paramExprs, returnTypeRef)\r\n              )\r\n            );\r\n          }\r\n          builder.addCase(classInstance.id, stmts);\r\n          // Also alias each extendee inheriting this exact overload\r\n          let extendees = classInstance.getAllExtendees(\r\n            isProperty\r\n              ? unboundOverloadParent.name\r\n              : instance.prototype.name\r\n          );\r\n          for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {\r\n            let extendee = _values[a];\r\n            builder.addCase(extendee.id, stmts);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Call the original function if no other id matches and the method is not\r\n    // abstract or part of an interface. Note that doing so will not catch an\r\n    // invalid id, but can reduce code size significantly since we also don't\r\n    // have to add branches for extendees inheriting the original function.\r\n    var body: ExpressionRef;\r\n    if (instance.prototype.bodyNode) {\r\n      let paramExprs = new Array<ExpressionRef>(numParameters);\r\n      paramExprs[0] = module.local_get(0, sizeTypeRef); // this\r\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toRef());\r\n      }\r\n      body = module.call(instance.internalName, paramExprs, returnType.toRef());\r\n\r\n    // Otherwise trap\r\n    } else {\r\n      body = module.unreachable();\r\n    }\r\n\r\n    // Create the virtual stub function\r\n    var ref = stub.ref;\r\n    if (ref) module.removeFunction(stub.internalName);\r\n    stub.ref = module.addFunction(\r\n      stub.internalName,\r\n      stub.signature.paramRefs,\r\n      stub.signature.resultRefs,\r\n      [ TypeRef.I32 ],\r\n      module.block(null, [\r\n        builder.render(tempIndex),\r\n        body\r\n      ], returnType.toRef())\r\n    );\r\n    stub.set(CommonFlags.COMPILED);\r\n  }\r\n\r\n  /** Marks managed call operands for the shadow stack. */\r\n  private operandsTostack(signature: Signature, operands: ExpressionRef[]): void {\r\n    if (!this.options.stackSize) return;\r\n    var module = this.module;\r\n    var operandIndex = 0;\r\n    var thisType = signature.thisType;\r\n    if (thisType) {\r\n      if (thisType.isManaged) {\r\n        let operand = operands[0];\r\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\r\n        if (!isConstZero(precomp)) { // otherwise unnecessary\r\n          operands[operandIndex] = module.tostack(operand);\r\n        }\r\n      }\r\n      ++operandIndex;\r\n    }\r\n    var parameterIndex = 0;\r\n    var parameterTypes = signature.parameterTypes;\r\n    assert(parameterTypes.length >= operands.length - operandIndex);\r\n    while (operandIndex < operands.length) {\r\n      let paramType = parameterTypes[parameterIndex];\r\n      if (paramType.isManaged) {\r\n        let operand = operands[operandIndex];\r\n        let precomp = module.runExpression(operand, ExpressionRunnerFlags.Default);\r\n        if (!isConstZero(precomp)) { // otherwise unnecessary\r\n          operands[operandIndex] = module.tostack(operand);\r\n        }\r\n      }\r\n      ++operandIndex;\r\n      ++parameterIndex;\r\n    }\r\n  }\r\n\r\n  /** Creates a direct call to the specified function. */\r\n  makeCallDirect(\r\n    instance: Function,\r\n    operands: ExpressionRef[] | null,\r\n    reportNode: Node,\r\n    immediatelyDropped: bool = false\r\n  ): ExpressionRef {\r\n    if (instance.hasDecorator(DecoratorFlags.INLINE)) {\r\n      if (!instance.is(CommonFlags.VIRTUAL)) {\r\n        assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\r\n        let inlineStack = this.inlineStack;\r\n        if (inlineStack.includes(instance)) {\r\n          this.warning(\r\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\r\n            reportNode.range, instance.internalName\r\n          );\r\n        } else {\r\n          inlineStack.push(instance);\r\n          let expr: ExpressionRef;\r\n          if (instance.is(CommonFlags.INSTANCE)) {\r\n            let theOperands = assert(operands);\r\n            assert(theOperands.length);\r\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\r\n          } else {\r\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\r\n          }\r\n          inlineStack.pop();\r\n          return expr;\r\n        }\r\n      } else {\r\n        this.warning(\r\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\r\n          reportNode.range, instance.internalName\r\n        );\r\n      }\r\n    }\r\n    var module = this.module;\r\n    var numOperands = operands ? operands.length : 0;\r\n    var numArguments = numOperands;\r\n    var minArguments = instance.signature.requiredParameters;\r\n    var minOperands = minArguments;\r\n    var parameterTypes = instance.signature.parameterTypes;\r\n    var maxArguments = parameterTypes.length;\r\n    var maxOperands = maxArguments;\r\n    if (instance.is(CommonFlags.INSTANCE)) {\r\n      ++minOperands;\r\n      ++maxOperands;\r\n      --numArguments;\r\n    }\r\n    assert(numOperands >= minOperands);\r\n\r\n    if (!this.compileFunction(instance)) return module.unreachable();\r\n    var returnType = instance.signature.returnType;\r\n\r\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\r\n    if (numOperands < maxOperands) {\r\n      if (!operands) {\r\n        operands = new Array(maxOperands);\r\n        operands.length = 0;\r\n      }\r\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\r\n      assert(parameterNodes.length == parameterTypes.length);\r\n      let allOptionalsAreConstant = true;\r\n      for (let i = numArguments; i < maxArguments; ++i) {\r\n        let initializer = parameterNodes[i].initializer;\r\n        if (initializer) {\r\n          if (initializer.compilesToConst) {\r\n            operands.push(this.compileExpression(\r\n              initializer,\r\n              parameterTypes[i],\r\n              Constraints.CONV_IMPLICIT\r\n            ));\r\n            continue;\r\n          }\r\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.SWALLOW);\r\n          if (resolved) {\r\n            if (resolved.kind == ElementKind.GLOBAL) {\r\n              let global = <Global>resolved;\r\n              if (this.compileGlobal(global)) {\r\n                if (global.is(CommonFlags.INLINED)) {\r\n                  operands.push(\r\n                    this.compileInlineConstant(global, parameterTypes[i], Constraints.CONV_IMPLICIT)\r\n                  );\r\n                } else {\r\n                  operands.push(\r\n                    this.convertExpression(\r\n                      module.global_get(global.internalName, global.type.toRef()),\r\n                      global.type, parameterTypes[i], false, initializer\r\n                    )\r\n                  );\r\n                }\r\n                continue;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        operands.push(this.makeZero(parameterTypes[i], instance.declaration));\r\n        allOptionalsAreConstant = false;\r\n      }\r\n      if (!allOptionalsAreConstant && !instance.is(CommonFlags.MODULE_IMPORT)) {\r\n        let original = instance;\r\n        instance = this.ensureVarargsStub(instance);\r\n        if (!this.compileFunction(instance)) return module.unreachable();\r\n        instance.flow.flags = original.flow.flags;\r\n        let returnTypeRef = returnType.toRef();\r\n        // We know the last operand is optional and omitted, so inject setting\r\n        // ~argumentsLength into that operand, which is always safe.\r\n        let lastOperand = operands[maxOperands - 1];\r\n        assert(!(getSideEffects(lastOperand) & SideEffects.WritesGlobal));\r\n        let lastOperandType = parameterTypes[maxArguments - 1];\r\n        operands[maxOperands - 1] = module.block(null, [\r\n          module.global_set(this.ensureArgumentsLength(), module.i32(numArguments)),\r\n          lastOperand\r\n        ], lastOperandType.toRef());\r\n        this.operandsTostack(instance.signature, operands);\r\n        let expr = module.call(instance.internalName, operands, returnTypeRef);\r\n        if (returnType != Type.void && immediatelyDropped) {\r\n          expr = module.drop(expr);\r\n          this.currentType = Type.void;\r\n        } else {\r\n          this.currentType = returnType;\r\n        }\r\n        return expr;\r\n      }\r\n    }\r\n\r\n    // Call the virtual stub with the vtable if the function has overloads\r\n    if (instance.is(CommonFlags.VIRTUAL) && !reportNode.isAccessOnSuper) {\r\n      instance = this.ensureVirtualStub(instance);\r\n    }\r\n\r\n    if (operands) this.operandsTostack(instance.signature, operands);\r\n    var expr = module.call(instance.internalName, operands, returnType.toRef());\r\n    this.currentType = returnType;\r\n    return expr;\r\n  }\r\n\r\n  /** Compiles an indirect call to a first-class function. */\r\n  compileCallIndirect(\r\n    signature: Signature,\r\n    functionArg: ExpressionRef,\r\n    argumentExpressions: Expression[],\r\n    reportNode: Node,\r\n    thisArg: ExpressionRef = 0,\r\n    immediatelyDropped: bool = false\r\n  ): ExpressionRef {\r\n    var numArguments = argumentExpressions.length;\r\n\r\n    if (!this.checkCallSignature( // reports\r\n      signature,\r\n      numArguments,\r\n      thisArg != 0,\r\n      reportNode\r\n    )) {\r\n      return this.module.unreachable();\r\n    }\r\n\r\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\r\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\r\n    var index = 0;\r\n    if (thisArg) {\r\n      operands[0] = thisArg;\r\n      index = 1;\r\n    }\r\n    var parameterTypes = signature.parameterTypes;\r\n    for (let i = 0; i < numArguments; ++i, ++index) {\r\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\r\n        Constraints.CONV_IMPLICIT\r\n      );\r\n    }\r\n    assert(index == numArgumentsInclThis);\r\n    return this.makeCallIndirect(signature, functionArg, reportNode, operands, immediatelyDropped);\r\n  }\r\n\r\n  /** Creates an indirect call to a first-class function. */\r\n  makeCallIndirect(\r\n    signature: Signature,\r\n    functionArg: ExpressionRef,\r\n    reportNode: Node,\r\n    operands: ExpressionRef[] | null = null,\r\n    immediatelyDropped: bool = false,\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var numOperands = operands ? operands.length : 0;\r\n    var numArguments = numOperands;\r\n    var minArguments = signature.requiredParameters;\r\n    var minOperands = minArguments;\r\n    var parameterTypes = signature.parameterTypes;\r\n    var returnType = signature.returnType;\r\n    var maxArguments = parameterTypes.length;\r\n    var maxOperands = maxArguments;\r\n    if (signature.thisType) {\r\n      ++minOperands;\r\n      ++maxOperands;\r\n      --numArguments;\r\n    }\r\n    assert(numOperands >= minOperands);\r\n\r\n    // fill up omitted arguments with zeroes\r\n    if (numOperands < maxOperands) {\r\n      if (!operands) {\r\n        operands = new Array(maxOperands);\r\n        operands.length = 0;\r\n      }\r\n      let parameterTypes = signature.parameterTypes;\r\n      for (let i = numArguments; i < maxArguments; ++i) {\r\n        operands.push(this.makeZero(parameterTypes[i], reportNode));\r\n      }\r\n    }\r\n\r\n    // We might be calling a varargs stub here, even if all operands have been\r\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\r\n    // into the index argument, which becomes executed last after any operands.\r\n    var argumentsLength = this.ensureArgumentsLength();\r\n    var sizeTypeRef = this.options.sizeTypeRef;\r\n    if (getSideEffects(functionArg) & SideEffects.WritesGlobal) {\r\n      let flow = this.currentFlow;\r\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(functionArg));\r\n      functionArg = module.block(null, [\r\n        module.local_set(temp.index, functionArg, true), // Function\r\n        module.global_set(argumentsLength, module.i32(numArguments)),\r\n        module.local_get(temp.index, sizeTypeRef)\r\n      ], sizeTypeRef);\r\n      flow.freeTempLocal(temp);\r\n    } else { // simplify\r\n      functionArg = module.block(null, [\r\n        module.global_set(argumentsLength, module.i32(numArguments)),\r\n        functionArg\r\n      ], sizeTypeRef);\r\n    }\r\n    if (operands) this.operandsTostack(signature, operands);\r\n    var expr = module.call_indirect(\r\n      module.load(4, false, functionArg, TypeRef.I32), // ._index\r\n      operands,\r\n      signature.paramRefs,\r\n      signature.resultRefs\r\n    );\r\n    this.currentType = returnType;\r\n    return expr;\r\n  }\r\n\r\n  private compileCommaExpression(\r\n    expression: CommaExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var expressions = expression.expressions;\r\n    var numExpressions = expressions.length;\r\n    var exprs = new Array<ExpressionRef>(numExpressions--);\r\n    for (let i = 0; i < numExpressions; ++i) {\r\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\r\n        Constraints.CONV_IMPLICIT | Constraints.WILL_DROP\r\n      );\r\n    }\r\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\r\n    return this.module.flatten(exprs, this.currentType.toRef());\r\n  }\r\n\r\n  private compileElementAccessExpression(\r\n    expression: ElementAccessExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var targetExpression = expression.expression;\r\n    var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\r\n    if (targetType) {\r\n      let classReference = targetType.getClassOrWrapper(this.program);\r\n      if (classReference) {\r\n        let isUnchecked = this.currentFlow.is(FlowFlags.UNCHECKED_CONTEXT);\r\n        let indexedGet = classReference.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\r\n        if (indexedGet) {\r\n          let thisType = assert(indexedGet.signature.thisType);\r\n          let thisArg = this.compileExpression(targetExpression, thisType,\r\n            Constraints.CONV_IMPLICIT\r\n          );\r\n          if (!isUnchecked && this.options.pedantic) {\r\n            this.pedantic(\r\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\r\n              expression.range\r\n            );\r\n          }\r\n          return this.compileCallDirect(indexedGet, [\r\n            expression.elementExpression\r\n          ], expression, thisArg, constraints);\r\n        }\r\n      }\r\n      this.error(\r\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n        expression.expression.range, targetType.toString()\r\n      );\r\n    }\r\n    return module.unreachable();\r\n  }\r\n\r\n  private compileFunctionExpression(\r\n    expression: FunctionExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var declaration = expression.declaration.clone(); // generic contexts can have multiple\r\n    assert(!declaration.typeParameters); // function expression cannot be generic\r\n    var flow = this.currentFlow;\r\n    var actualFunction = flow.actualFunction;\r\n    var isNamed = declaration.name.text.length > 0;\r\n    var isSemanticallyAnonymous = !isNamed || contextualType != Type.void;\r\n    var prototype = new FunctionPrototype(\r\n      isSemanticallyAnonymous\r\n        ? (isNamed ? declaration.name.text + \"|\" : \"anonymous|\") + (actualFunction.nextAnonymousId++).toString()\r\n        : declaration.name.text,\r\n      actualFunction,\r\n      declaration,\r\n      DecoratorFlags.NONE\r\n    );\r\n    var instance: Function | null;\r\n    var contextualTypeArguments = uniqueMap(flow.contextualTypeArguments);\r\n    var module = this.module;\r\n\r\n    // compile according to context. this differs from a normal function in that omitted parameter\r\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\r\n    var contextualSignature = contextualType.signatureReference;\r\n    if (contextualSignature) {\r\n      let signatureNode = prototype.functionTypeNode;\r\n      let parameterNodes = signatureNode.parameters;\r\n      let numPresentParameters = parameterNodes.length;\r\n\r\n      // must not require more than the maximum number of parameters\r\n      let parameterTypes = contextualSignature.parameterTypes;\r\n      let numParameters = parameterTypes.length;\r\n      if (numPresentParameters > numParameters) {\r\n        this.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          expression.range, numParameters.toString(), numPresentParameters.toString()\r\n        );\r\n        return module.unreachable();\r\n      }\r\n\r\n      // check non-omitted parameter types\r\n      for (let i = 0; i < numPresentParameters; ++i) {\r\n        let parameterNode = parameterNodes[i];\r\n        if (!isTypeOmitted(parameterNode.type)) {\r\n          let resolvedType = this.resolver.resolveType(\r\n            parameterNode.type,\r\n            actualFunction.parent,\r\n            contextualTypeArguments\r\n          );\r\n          if (!resolvedType) return module.unreachable();\r\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n        }\r\n        // any unused parameters are inherited but ignored\r\n      }\r\n\r\n      // check non-omitted return type\r\n      let returnType = contextualSignature.returnType;\r\n      if (!isTypeOmitted(signatureNode.returnType)) {\r\n        let resolvedType = this.resolver.resolveType(\r\n          signatureNode.returnType,\r\n          actualFunction.parent,\r\n          contextualTypeArguments\r\n        );\r\n        if (!resolvedType) return module.unreachable();\r\n        if (\r\n          returnType == Type.void\r\n            ? resolvedType != Type.void\r\n            : !resolvedType.isStrictlyAssignableTo(returnType)\r\n        ) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n      }\r\n\r\n      // check explicit this type\r\n      let thisType = contextualSignature.thisType;\r\n      let thisTypeNode = signatureNode.explicitThisType;\r\n      if (thisTypeNode) {\r\n        if (!thisType) {\r\n          this.error(\r\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\r\n            thisTypeNode.range\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        let resolvedType = this.resolver.resolveType(\r\n          thisTypeNode,\r\n          actualFunction.parent,\r\n          contextualTypeArguments\r\n        );\r\n        if (!resolvedType) return module.unreachable();\r\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n      }\r\n\r\n      let signature = new Signature(this.program, parameterTypes, returnType, thisType);\r\n      signature.requiredParameters = numParameters; // !\r\n      instance = new Function(\r\n        prototype.name,\r\n        prototype,\r\n        null,\r\n        signature,\r\n        contextualTypeArguments\r\n      );\r\n      instance.flow.outer = flow;\r\n      let worked = this.compileFunction(instance);\r\n      this.currentType = contextualSignature.type;\r\n      if (!worked) return module.unreachable();\r\n\r\n    // otherwise compile like a normal function\r\n    } else {\r\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\r\n      if (!instance) return this.module.unreachable();\r\n      instance.flow.outer = flow;\r\n      let worked = this.compileFunction(instance);\r\n      this.currentType = instance.signature.type;\r\n      if (!worked) return module.unreachable();\r\n    }\r\n\r\n    var offset = this.ensureRuntimeFunction(instance); // reports\r\n    var expr = this.options.isWasm64\r\n      ? module.i64(i64_low(offset), i64_high(offset))\r\n      : module.i32(i64_low(offset));\r\n\r\n    // add a constant local referring to the function if applicable\r\n    if (!isSemanticallyAnonymous) {\r\n      let fname = instance.name;\r\n      let existingLocal = flow.getScopedLocal(fname);\r\n      if (existingLocal) {\r\n        if (!existingLocal.declaration.range.source.isNative) {\r\n          this.errorRelated(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range,\r\n            existingLocal.declaration.name.range,\r\n            fname\r\n          );\r\n        } else { // scoped locals are shared temps that don't track declarations\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, fname\r\n          );\r\n        }\r\n      } else {\r\n        let ftype = instance.type;\r\n        let local = flow.addScopedLocal(instance.name, ftype);\r\n        flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\r\n        expr = module.local_tee(local.index, expr, ftype.isManaged);\r\n      }\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\r\n  private maybeCompileEnclosingSource(expression: Expression): void {\r\n    var internalPath = expression.range.source.internalPath;\r\n    var filesByName = this.program.filesByName;\r\n    assert(filesByName.has(internalPath));\r\n    var enclosingFile = assert(filesByName.get(internalPath));\r\n    if (!enclosingFile.is(CommonFlags.COMPILED)) {\r\n      this.compileFileByPath(internalPath, expression);\r\n    }\r\n  }\r\n\r\n  private compileIdentifierExpression(\r\n    expression: IdentifierExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var actualFunction = flow.actualFunction;\r\n\r\n    // check special keywords first\r\n    switch (expression.kind) {\r\n      case NodeKind.NULL: {\r\n        let options = this.options;\r\n        if (contextualType.isReference) {\r\n          let classReference = contextualType.getClass();\r\n          if (classReference) {\r\n            this.currentType = classReference.type.asNullable();\r\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\r\n          }\r\n          let signatureReference = contextualType.getSignature();\r\n          if (signatureReference) {\r\n            this.currentType = signatureReference.type.asNullable();\r\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\r\n          }\r\n          return this.makeZero(contextualType, expression);\r\n        }\r\n        this.currentType = options.usizeType;\r\n        this.warning(\r\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\r\n          expression.range, this.currentType.toString()\r\n        );\r\n        return options.isWasm64\r\n          ? module.i64(0)\r\n          : module.i32(0);\r\n      }\r\n      case NodeKind.TRUE: {\r\n        this.currentType = Type.bool;\r\n        return module.i32(1);\r\n      }\r\n      case NodeKind.FALSE: {\r\n        this.currentType = Type.bool;\r\n        return module.i32(0);\r\n      }\r\n      case NodeKind.THIS: {\r\n        let thisType = actualFunction.signature.thisType;\r\n        if (!thisType) {\r\n          this.error(\r\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\r\n            expression.range\r\n          );\r\n          this.currentType = this.options.usizeType;\r\n          return module.unreachable();\r\n        }\r\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\r\n          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {\r\n            this.error(\r\n              DiagnosticCode._this_cannot_be_referenced_in_constructor_arguments,\r\n              expression.range\r\n            );\r\n          }\r\n          if (!(constraints & Constraints.IS_THIS)) {\r\n            let parent = actualFunction.parent;\r\n            assert(parent.kind == ElementKind.CLASS);\r\n            this.checkFieldInitialization(<Class>parent, expression);\r\n          }\r\n        }\r\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\r\n        flow.set(FlowFlags.ACCESSES_THIS);\r\n        this.currentType = thisType;\r\n        return module.local_get(thisLocal.index, thisType.toRef());\r\n      }\r\n      case NodeKind.SUPER: {\r\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\r\n          if (flow.is(FlowFlags.CTORPARAM_CONTEXT)) {\r\n            this.error(\r\n              DiagnosticCode._super_cannot_be_referenced_in_constructor_arguments,\r\n              expression.range\r\n            );\r\n          } else if (!flow.is(FlowFlags.CALLS_SUPER)) {\r\n            // TS1034 in the parser effectively limits this to property accesses\r\n            this.error(\r\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\r\n              expression.range\r\n            );\r\n          }\r\n        }\r\n        if (flow.isInline) {\r\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\r\n          if (scopedThis) {\r\n            let scopedThisClass = assert(scopedThis.type.getClass());\r\n            let base = scopedThisClass.base;\r\n            if (base) {\r\n              this.currentType = base.type;\r\n              return module.local_get(scopedThis.index, base.type.toRef());\r\n            }\r\n          }\r\n        }\r\n        if (actualFunction.is(CommonFlags.INSTANCE)) {\r\n          let parent = assert(actualFunction.parent);\r\n          assert(parent.kind == ElementKind.CLASS);\r\n          let classInstance = <Class>parent;\r\n          let baseClassInstance = classInstance.base;\r\n          if (baseClassInstance) {\r\n            let superType = baseClassInstance.type;\r\n            this.currentType = superType;\r\n            return module.local_get(0, superType.toRef());\r\n          }\r\n        }\r\n        this.error(\r\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\r\n          expression.range\r\n        );\r\n        this.currentType = this.options.usizeType;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n\r\n    this.maybeCompileEnclosingSource(expression);\r\n\r\n    // otherwise resolve\r\n    var currentParent = this.currentParent;\r\n    if (!currentParent) currentParent = actualFunction;\r\n    var target = this.resolver.lookupIdentifierExpression( // reports\r\n      expression,\r\n      flow,\r\n      currentParent\r\n    );\r\n    if (!target) {\r\n      // make a guess to avoid assertions in calling code\r\n      if (this.currentType == Type.void) this.currentType = Type.i32;\r\n      return module.unreachable();\r\n    }\r\n\r\n    switch (target.kind) {\r\n      case ElementKind.LOCAL: {\r\n        let local = <Local>target;\r\n        let localType = local.type;\r\n        assert(localType != Type.void);\r\n        if (this.pendingElements.has(local)) {\r\n          this.error(\r\n            DiagnosticCode.Variable_0_used_before_its_declaration,\r\n            expression.range,\r\n            local.internalName\r\n          );\r\n          this.currentType = localType;\r\n          return module.unreachable();\r\n        }\r\n        if (local.is(CommonFlags.INLINED)) {\r\n          return this.compileInlineConstant(local, contextualType, constraints);\r\n        }\r\n        let localIndex = local.index;\r\n        assert(localIndex >= 0);\r\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NONNULL, false)) {\r\n          localType = localType.nonNullableType;\r\n        }\r\n        this.currentType = localType;\r\n\r\n        if (target.parent != flow.parentFunction) {\r\n          // TODO: closures\r\n          this.error(\r\n            DiagnosticCode.Not_implemented_0,\r\n            expression.range,\r\n            \"Closures\"\r\n          );\r\n          return module.unreachable();\r\n        }\r\n        return module.local_get(localIndex, localType.toRef());\r\n      }\r\n      case ElementKind.GLOBAL: {\r\n        let global = <Global>target;\r\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\r\n          return module.unreachable();\r\n        }\r\n        let globalType = global.type;\r\n        if (this.pendingElements.has(global)) {\r\n          this.error(\r\n            DiagnosticCode.Variable_0_used_before_its_declaration,\r\n            expression.range,\r\n            global.internalName\r\n          );\r\n          this.currentType = globalType;\r\n          return module.unreachable();\r\n        }\r\n        assert(globalType != Type.void);\r\n        if (global.is(CommonFlags.INLINED)) {\r\n          return this.compileInlineConstant(global, contextualType, constraints);\r\n        }\r\n        this.currentType = globalType;\r\n        return module.global_get(global.internalName, globalType.toRef());\r\n      }\r\n      case ElementKind.ENUMVALUE: { // here: if referenced from within the same enum\r\n        let enumValue = <EnumValue>target;\r\n        if (!target.is(CommonFlags.COMPILED)) {\r\n          this.error(\r\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\r\n            expression.range\r\n          );\r\n          this.currentType = Type.i32;\r\n          return module.unreachable();\r\n        }\r\n        this.currentType = Type.i32;\r\n        if (enumValue.is(CommonFlags.INLINED)) {\r\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\r\n          return module.i32(i64_low(enumValue.constantIntegerValue));\r\n        }\r\n        return module.global_get(enumValue.internalName, TypeRef.I32);\r\n      }\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        let functionPrototype = <FunctionPrototype>target;\r\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\r\n\r\n        if (typeParameterNodes !== null && typeParameterNodes.length != 0) {\r\n          this.error(\r\n            DiagnosticCode.Expected_0_arguments_but_got_1,\r\n            expression.range, typeParameterNodes.length.toString(), \"0\"\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        let functionInstance = this.resolver.resolveFunction(\r\n          functionPrototype,\r\n          null,\r\n          uniqueMap<string,Type>(flow.contextualTypeArguments)\r\n        );\r\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\r\n        if (contextualType.isExternalReference) {\r\n          this.currentType = Type.funcref;\r\n          return module.ref_func(functionInstance.internalName, TypeRef.Funcref); // TODO\r\n        }\r\n        let offset = this.ensureRuntimeFunction(functionInstance);\r\n        this.currentType = functionInstance.signature.type;\r\n        return this.options.isWasm64\r\n          ? module.i64(i64_low(offset), i64_high(offset))\r\n          : module.i32(i64_low(offset));\r\n      }\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,\r\n      expression.range\r\n    );\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  private compileInstanceOfExpression(\r\n    expression: InstanceOfExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var flow = this.currentFlow;\r\n    var isType = expression.isType;\r\n\r\n    // Mimic `instanceof CLASS`\r\n    if (isType.kind == NodeKind.NAMEDTYPE) {\r\n      let namedType = <NamedTypeNode>isType;\r\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\r\n        let element = this.resolver.resolveTypeName(namedType.name, flow.actualFunction, ReportMode.SWALLOW);\r\n        if (element !== null && element.kind == ElementKind.CLASS_PROTOTYPE) {\r\n          let prototype = <ClassPrototype>element;\r\n          if (prototype.is(CommonFlags.GENERIC)) {\r\n            return this.makeInstanceofClass(expression, prototype);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fall back to `instanceof TYPE`\r\n    var expectedType = this.resolver.resolveType(\r\n      expression.isType,\r\n      flow.actualFunction,\r\n      uniqueMap(flow.contextualTypeArguments)\r\n    );\r\n    if (!expectedType) {\r\n      this.currentType = Type.bool;\r\n      return this.module.unreachable();\r\n    }\r\n    return this.makeInstanceofType(expression, expectedType);\r\n  }\r\n\r\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var expr = this.compileExpression(expression.expression, expectedType);\r\n    var actualType = this.currentType;\r\n    this.currentType = Type.bool;\r\n\r\n    // instanceof <value> - must be exact\r\n    if (expectedType.isValue) {\r\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\r\n    }\r\n\r\n    // <value> instanceof <nonValue> - always false\r\n    if (actualType.isValue) {\r\n      return module.maybeDropCondition(expr, module.i32(0));\r\n    }\r\n\r\n    // both LHS and RHS are references now\r\n    var sizeTypeRef = actualType.toRef();\r\n\r\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\r\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\r\n\r\n      // downcast - check statically\r\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\r\n        return module.binary(\r\n          sizeTypeRef == TypeRef.I64\r\n            ? BinaryOp.NeI64\r\n            : BinaryOp.NeI32,\r\n          expr,\r\n          this.makeZero(actualType, expression.expression)\r\n        );\r\n      }\r\n\r\n      // upcast - check dynamically\r\n      if (expectedType.isAssignableTo(actualType)) {\r\n        let program = this.program;\r\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\r\n          let temp = flow.getTempLocal(actualType);\r\n          let instanceofInstance = assert(program.instanceofInstance);\r\n          this.compileFunction(instanceofInstance);\r\n          let ret = module.if(\r\n            module.unary(\r\n              sizeTypeRef == TypeRef.I64\r\n                ? UnaryOp.EqzI64\r\n                : UnaryOp.EqzI32,\r\n              module.local_tee(temp.index, expr, actualType.isManaged),\r\n            ),\r\n            module.i32(0),\r\n            this.makeCallDirect(instanceofInstance, [\r\n              module.local_get(temp.index, sizeTypeRef),\r\n              module.i32(expectedType.classReference!.id)\r\n            ], expression)\r\n          );\r\n          flow.freeTempLocal(temp);\r\n          if (this.options.pedantic) {\r\n            this.pedantic(\r\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\r\n              expression.range\r\n            );\r\n          }\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\r\n          );\r\n        }\r\n      }\r\n\r\n    // either none or both nullable\r\n    } else {\r\n\r\n      // downcast - check statically\r\n      if (actualType.isAssignableTo(expectedType)) {\r\n        return module.maybeDropCondition(expr, module.i32(1));\r\n\r\n      // upcast - check dynamically\r\n      } else if (expectedType.isAssignableTo(actualType)) {\r\n        let program = this.program;\r\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\r\n          // FIXME: the temp local and the if can be removed here once flows\r\n          // perform null checking, which would error earlier when checking\r\n          // uninitialized (thus zero) `var a: A` to be an instance of something.\r\n          let temp = flow.getTempLocal(actualType);\r\n          let instanceofInstance = assert(program.instanceofInstance);\r\n          this.compileFunction(instanceofInstance);\r\n          let ret = module.if(\r\n            module.unary(\r\n              sizeTypeRef == TypeRef.I64\r\n                ? UnaryOp.EqzI64\r\n                : UnaryOp.EqzI32,\r\n              module.local_tee(temp.index, expr, actualType.isManaged),\r\n            ),\r\n            module.i32(0),\r\n            this.makeCallDirect(instanceofInstance, [\r\n              module.local_get(temp.index, sizeTypeRef),\r\n              module.i32(expectedType.classReference!.id)\r\n            ], expression)\r\n          );\r\n          flow.freeTempLocal(temp);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // false\r\n    return module.maybeDropCondition(expr, module.i32(0));\r\n  }\r\n\r\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\r\n    var module = this.module;\r\n    var expr = this.compileExpression(expression.expression, Type.auto);\r\n    var actualType = this.currentType;\r\n    var sizeTypeRef = actualType.toRef();\r\n\r\n    this.currentType = Type.bool;\r\n\r\n    // exclusively interested in class references here\r\n    var classReference = actualType.getClass();\r\n    if (classReference) {\r\n\r\n      // static check\r\n      if (classReference.extends(prototype)) {\r\n\r\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\r\n        if (actualType.isNullableReference) {\r\n          return module.binary(\r\n            sizeTypeRef == TypeRef.I64\r\n              ? BinaryOp.NeI64\r\n              : BinaryOp.NeI32,\r\n            expr,\r\n            this.makeZero(actualType, expression.expression)\r\n          );\r\n\r\n        // <nonNullable> is just `true`\r\n        } else {\r\n          return module.maybeDropCondition(expr, module.i32(1));\r\n        }\r\n\r\n      // dynamic check against all possible concrete ids\r\n      } else if (prototype.extends(classReference.prototype)) {\r\n        this.pendingClassInstanceOf.add(prototype);\r\n        return module.call(prototype.internalName + \"~instanceof\", [ expr ], TypeRef.I32);\r\n      }\r\n    }\r\n\r\n    // false\r\n    return module.maybeDropCondition(expr, module.i32(0));\r\n  }\r\n\r\n  private compileLiteralExpression(\r\n    expression: LiteralExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints,\r\n    implicitlyNegate: bool = false\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    switch (expression.literalKind) {\r\n      case LiteralKind.ARRAY: {\r\n        assert(!implicitlyNegate);\r\n        return this.compileArrayLiteral(\r\n          <ArrayLiteralExpression>expression,\r\n          contextualType,\r\n          constraints\r\n        );\r\n      }\r\n      case LiteralKind.FLOAT: {\r\n        let floatValue = (<FloatLiteralExpression>expression).value;\r\n        if (implicitlyNegate) {\r\n          floatValue = -floatValue;\r\n        }\r\n        if (contextualType == Type.f32) {\r\n          return module.f32(<f32>floatValue);\r\n        }\r\n        this.currentType = Type.f64;\r\n        return module.f64(floatValue);\r\n      }\r\n      case LiteralKind.INTEGER: {\r\n        let intValue = (<IntegerLiteralExpression>expression).value;\r\n        if (implicitlyNegate) {\r\n          intValue = i64_sub(\r\n            i64_new(0),\r\n            intValue\r\n          );\r\n        }\r\n        let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);\r\n        this.currentType = type;\r\n        switch (type.kind) {\r\n          case TypeKind.ISIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\r\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\r\n          case TypeKind.USIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\r\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\r\n          case TypeKind.F32: return module.f32(i64_to_f32(intValue));\r\n          case TypeKind.F64: return module.f64(i64_to_f64(intValue));\r\n          default: return module.i32(i64_low(intValue));\r\n        }\r\n      }\r\n      case LiteralKind.STRING: {\r\n        assert(!implicitlyNegate);\r\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\r\n      }\r\n      case LiteralKind.TEMPLATE: {\r\n        assert(!implicitlyNegate);\r\n        return this.compileTemplateLiteral(<TemplateLiteralExpression>expression, constraints);\r\n      }\r\n      case LiteralKind.OBJECT: {\r\n        assert(!implicitlyNegate);\r\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\r\n      }\r\n      case LiteralKind.REGEXP: {\r\n        this.error(\r\n          DiagnosticCode.Not_implemented_0,\r\n          expression.range,\r\n          \"Regular expressions\"\r\n        );\r\n        this.currentType = contextualType;\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    assert(false);\r\n    return module.unreachable();\r\n  }\r\n\r\n  private compileStringLiteral(\r\n    expression: StringLiteralExpression,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    return this.ensureStaticString(expression.value);\r\n  }\r\n\r\n  private compileTemplateLiteral(\r\n    expression: TemplateLiteralExpression,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var tag = expression.tag;\r\n    var parts = expression.parts;\r\n    var numParts = parts.length;\r\n    var expressions = expression.expressions;\r\n    assert(numParts - 1 == expressions.length);\r\n\r\n    // Shortcut if just a (multi-line) string\r\n    if (tag === null && numParts == 1) {\r\n      return this.ensureStaticString(parts[0]);\r\n    }\r\n\r\n    var module = this.module;\r\n    var stringType = this.program.stringInstance.type;\r\n\r\n    // Compile to a `StaticArray<string>#join(\"\")` if untagged\r\n    if (tag === null) {\r\n      let length = 2 * numParts - 1;\r\n      let values = new Array<usize>(length);\r\n      values[0] = this.ensureStaticString(parts[0]);\r\n      for (let i = 1; i < numParts; ++i) {\r\n        values[2 * i - 1] = module.usize(0);\r\n        values[2 * i] = this.ensureStaticString(parts[i]);\r\n      }\r\n      let arrayInstance = assert(this.resolver.resolveClass(this.program.staticArrayPrototype, [ stringType ]));\r\n      let segment = this.addStaticBuffer(stringType, values, arrayInstance.id);\r\n      let offset = i64_add(segment.offset, i64_new(this.program.totalOverhead));\r\n      let joinInstance = assert(arrayInstance.getMethod(\"join\"));\r\n      let indexedSetInstance = assert(arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true));\r\n      let stmts = new Array<ExpressionRef>();\r\n      for (let i = 0, k = numParts - 1; i < k; ++i) {\r\n        let expression = expressions[i];\r\n        stmts.push(\r\n          this.makeCallDirect(indexedSetInstance, [\r\n            module.usize(offset),\r\n            module.i32(2 * i + 1),\r\n            this.makeToString(\r\n              this.compileExpression(expression, stringType),\r\n              this.currentType, expression\r\n            )\r\n          ], expression)\r\n        );\r\n      }\r\n      stmts.push(\r\n        this.makeCallDirect(joinInstance, [\r\n          module.usize(offset),\r\n          this.ensureStaticString(\"\")\r\n        ], expression)\r\n      );\r\n      return module.flatten(stmts, stringType.toRef());\r\n    }\r\n\r\n    // Try to find out whether the template function takes a full-blown TemplateStringsArray or if\r\n    // it is sufficient to compile to a normal array. While technically incorrect, this allows us\r\n    // to avoid generating unnecessary static data that is not explicitly signaled to be used.\r\n    var tsaArrayInstance = this.program.templateStringsArrayInstance;\r\n    var arrayInstance = tsaArrayInstance;\r\n    var target = this.resolver.lookupExpression(tag, this.currentFlow, Type.auto, ReportMode.SWALLOW);\r\n    if (target) {\r\n      switch (target.kind) {\r\n        case ElementKind.FUNCTION_PROTOTYPE: {\r\n          let instance = this.resolver.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);\r\n          if (!instance) break;\r\n          target = instance;\r\n          // fall-through\r\n        }\r\n        case ElementKind.FUNCTION: {\r\n          let instance = <Function>target;\r\n          let parameterTypes = instance.signature.parameterTypes;\r\n          if (parameterTypes.length) {\r\n            let first = parameterTypes[0].getClass();\r\n            if (first !== null && !first.extends(tsaArrayInstance.prototype)) {\r\n              arrayInstance = assert(this.resolver.resolveClass(this.program.arrayPrototype, [ stringType ]));\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Compile to a call to the tag function\r\n    var rawParts = expression.rawParts;\r\n    assert(rawParts.length == numParts);\r\n    var partExprs = new Array<ExpressionRef>(numParts);\r\n    for (let i = 0; i < numParts; ++i) {\r\n      partExprs[i] = this.ensureStaticString(parts[i]);\r\n    }\r\n    var arraySegment: MemorySegment;\r\n    if (arrayInstance == tsaArrayInstance) {\r\n      var rawExprs = new Array<ExpressionRef>(numParts);\r\n      for (let i = 0; i < numParts; ++i) {\r\n        rawExprs[i] = this.ensureStaticString(rawParts[i]);\r\n      }\r\n      arraySegment = this.addStaticArrayHeader(stringType,\r\n        this.addStaticBuffer(this.options.usizeType, partExprs),\r\n        arrayInstance\r\n      );\r\n      var rawHeaderSegment = this.addStaticArrayHeader(stringType,\r\n        this.addStaticBuffer(this.options.usizeType, rawExprs)\r\n      );\r\n      arrayInstance.writeField(\"raw\",\r\n        i64_add(rawHeaderSegment.offset, i64_new(this.program.totalOverhead)),\r\n        arraySegment.buffer\r\n      );\r\n    } else {\r\n      arraySegment = this.addStaticArrayHeader(stringType,\r\n        this.addStaticBuffer(this.options.usizeType, partExprs),\r\n        arrayInstance\r\n      );\r\n    }\r\n\r\n    // Desugar to compileCallExpression\r\n    var args = expressions.slice();\r\n    args.unshift(\r\n      Node.createCompiledExpression(\r\n        module.usize(i64_add(arraySegment.offset, i64_new(this.program.totalOverhead))),\r\n        arrayInstance.type,\r\n        this.program.nativeRange\r\n      )\r\n    );\r\n    // TODO: Requires ReadonlyArray to be safe\r\n    this.error(\r\n      DiagnosticCode.Not_implemented_0,\r\n      expression.range, \"Tagged template literals\"\r\n    );\r\n    return this.compileCallExpressionLike(tag, null, args, expression.range, stringType);\r\n  }\r\n\r\n  private compileArrayLiteral(\r\n    expression: ArrayLiteralExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var program = this.program;\r\n\r\n    // handle static arrays\r\n    let contextualClass = contextualType.getClass();\r\n    if (contextualClass !== null && contextualClass.extends(program.staticArrayPrototype)) {\r\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\r\n    }\r\n\r\n    // handle normal arrays\r\n    var element = this.resolver.lookupExpression(expression, flow, this.currentType);\r\n    if (!element) return module.unreachable();\r\n    assert(element.kind == ElementKind.CLASS);\r\n    var arrayInstance = <Class>element;\r\n    var arrayType = arrayInstance.type;\r\n    var elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\r\n    var arrayBufferInstance = assert(program.arrayBufferInstance);\r\n\r\n    // block those here so compiling expressions doesn't conflict\r\n    var tempThis = flow.getTempLocal(this.options.usizeType);\r\n    var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\r\n\r\n    // compile value expressions and find out whether all are constant\r\n    var expressions = expression.elementExpressions;\r\n    var length = expressions.length;\r\n    var values = new Array<ExpressionRef>(length);\r\n    var isStatic = !elementType.isExternalReference;\r\n    for (let i = 0; i < length; ++i) {\r\n      let elementExpression = expressions[i];\r\n      if (elementExpression.kind != NodeKind.OMITTED) {\r\n        let expr = this.compileExpression(<Expression>elementExpression, elementType, Constraints.CONV_IMPLICIT);\r\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n        if (precomp) {\r\n          expr = precomp;\r\n        } else {\r\n          isStatic = false;\r\n        }\r\n        values[i] = expr;\r\n      } else {\r\n        values[i] = this.makeZero(elementType, elementExpression);\r\n      }\r\n    }\r\n\r\n    // if the array is static, make a static arraybuffer segment\r\n    if (isStatic) {\r\n      flow.freeTempLocal(tempThis);\r\n      flow.freeTempLocal(tempDataStart);\r\n\r\n      let totalOverhead = program.totalOverhead;\r\n      let bufferSegment = this.addStaticBuffer(elementType, values);\r\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(totalOverhead));\r\n\r\n      // make both the buffer and array header static if assigned to a global. this can't be done\r\n      // if inside of a function because each invocation must create a new array reference then.\r\n      if (constraints & Constraints.PREFER_STATIC) {\r\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\r\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(totalOverhead));\r\n        this.currentType = arrayType;\r\n        return program.options.isWasm64\r\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\r\n          : this.module.i32(i64_low(arrayAddress));\r\n\r\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\r\n      } else {\r\n        // __newArray(length, alignLog2, classId, staticBuffer)\r\n        let expr = this.makeCallDirect(program.newArrayInstance, [\r\n          module.i32(length),\r\n          program.options.isWasm64\r\n            ? module.i64(elementType.alignLog2)\r\n            : module.i32(elementType.alignLog2),\r\n          module.i32(arrayInstance.id),\r\n          program.options.isWasm64\r\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\r\n            : module.i32(i64_low(bufferAddress))\r\n        ], expression);\r\n        this.currentType = arrayType;\r\n        return expr;\r\n      }\r\n    }\r\n\r\n    // otherwise compile an explicit instantiation with indexed sets\r\n    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\r\n    if (!indexedSet) {\r\n      flow.freeTempLocal(tempThis);\r\n      flow.freeTempLocal(tempDataStart);\r\n      this.error(\r\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\r\n        expression.range, arrayInstance.internalName\r\n      );\r\n      this.currentType = arrayType;\r\n      return module.unreachable();\r\n    }\r\n    var arrayTypeRef = arrayType.toRef();\r\n\r\n    var stmts = new Array<ExpressionRef>();\r\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\r\n    stmts.push(\r\n      module.local_set(tempThis.index,\r\n        this.makeCallDirect(program.newArrayInstance, [\r\n          module.i32(length),\r\n          program.options.isWasm64\r\n            ? module.i64(elementType.alignLog2)\r\n            : module.i32(elementType.alignLog2),\r\n          module.i32(arrayInstance.id),\r\n          program.options.isWasm64\r\n            ? module.i64(0)\r\n            : module.i32(0)\r\n        ], expression),\r\n        arrayType.isManaged\r\n      )\r\n    );\r\n    // tempData = tempThis.dataStart\r\n    var dataStartMember = assert(arrayInstance.lookupInSelf(\"dataStart\"));\r\n    assert(dataStartMember.kind == ElementKind.FIELD);\r\n    stmts.push(\r\n      module.local_set(tempDataStart.index,\r\n        module.load(arrayType.byteSize, false,\r\n          module.local_get(tempThis.index, arrayTypeRef),\r\n          arrayTypeRef,\r\n          (<Field>dataStartMember).memoryOffset\r\n        ),\r\n        true // ArrayBuffer\r\n      )\r\n    );\r\n    for (let i = 0; i < length; ++i) {\r\n      // this[i] = value\r\n      stmts.push(\r\n        module.call(indexedSet.internalName, [\r\n          module.local_get(tempThis.index, arrayTypeRef),\r\n          module.i32(i),\r\n          values[i]\r\n        ], TypeRef.None)\r\n      );\r\n    }\r\n    // -> tempThis\r\n    stmts.push(\r\n      module.local_get(tempThis.index, arrayTypeRef)\r\n    );\r\n    flow.freeTempLocal(tempThis);\r\n    flow.freeTempLocal(tempDataStart);\r\n    if (length) this.compileFunction(indexedSet);\r\n    this.currentType = arrayType;\r\n    return module.flatten(stmts, arrayTypeRef);\r\n  }\r\n\r\n  /** Compiles a special `fixed` array literal. */\r\n  private compileStaticArrayLiteral(\r\n    expression: ArrayLiteralExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var program = this.program;\r\n\r\n    // make sure this method is only called with a valid contextualType\r\n    var arrayInstance = assert(contextualType.getClass());\r\n    var arrayType = arrayInstance.type;\r\n    var typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\r\n    var elementType = typeArguments[0];\r\n\r\n    // block those here so compiling expressions doesn't conflict\r\n    var tempThis = flow.getTempLocal(this.options.usizeType);\r\n\r\n    // compile value expressions and check if all are compile-time constants\r\n    var expressions = expression.elementExpressions;\r\n    var length = expressions.length;\r\n    var values = new Array<ExpressionRef>(length);\r\n    var isStatic = !elementType.isExternalReference;\r\n    for (let i = 0; i < length; ++i) {\r\n      let elementExpression = expressions[i];\r\n      if (elementExpression.kind != NodeKind.OMITTED) {\r\n        let expr = this.compileExpression(elementExpression, elementType, Constraints.CONV_IMPLICIT);\r\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\r\n        if (precomp) {\r\n          expr = precomp;\r\n        } else {\r\n          isStatic = false;\r\n        }\r\n        values[i] = expr;\r\n      } else {\r\n        values[i] = this.makeZero(elementType, elementExpression);\r\n      }\r\n    }\r\n\r\n    var isWasm64 = this.options.isWasm64;\r\n    var bufferSize = values.length << elementType.alignLog2;\r\n\r\n    // if the array is static, make a static arraybuffer segment\r\n    if (isStatic) {\r\n      flow.freeTempLocal(tempThis);\r\n\r\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\r\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.totalOverhead));\r\n\r\n      // return the static buffer directly if assigned to a global\r\n      if (constraints & Constraints.PREFER_STATIC) {\r\n        let expr = this.options.isWasm64\r\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\r\n          : module.i32(i64_low(bufferAddress));\r\n        this.currentType = arrayType;\r\n        return expr;\r\n\r\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\r\n      } else {\r\n        // __newBuffer(bufferSize, id, buffer)\r\n        let expr = this.makeCallDirect(program.newBufferInstance, [\r\n          isWasm64\r\n            ? module.i64(bufferSize)\r\n            : module.i32(bufferSize),\r\n          module.i32(arrayInstance.id),\r\n          isWasm64\r\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\r\n            : module.i32(i64_low(bufferAddress))\r\n        ], expression);\r\n        this.currentType = arrayType;\r\n        return expr;\r\n      }\r\n    }\r\n\r\n    // otherwise compile an explicit instantiation with indexed sets\r\n    var indexedSet = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\r\n    if (!indexedSet) {\r\n      flow.freeTempLocal(tempThis);\r\n      this.error(\r\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\r\n        expression.range, arrayInstance.internalName\r\n      );\r\n      this.currentType = arrayType;\r\n      return module.unreachable();\r\n    }\r\n    var arrayTypeRef = arrayType.toRef();\r\n\r\n    var stmts = new Array<ExpressionRef>();\r\n    // tempThis = __newBuffer(bufferSize, classId)\r\n    stmts.push(\r\n      module.local_set(tempThis.index,\r\n        this.makeCallDirect(program.newBufferInstance, [\r\n          isWasm64\r\n            ? module.i64(bufferSize)\r\n            : module.i32(bufferSize),\r\n          module.i32(arrayInstance.id)\r\n        ], expression),\r\n        arrayType.isManaged\r\n      )\r\n    );\r\n    for (let i = 0; i < length; ++i) {\r\n      // array[i] = value\r\n      stmts.push(\r\n        module.call(indexedSet.internalName, [\r\n          module.local_get(tempThis.index, arrayTypeRef),\r\n          module.i32(i),\r\n          values[i]\r\n        ], TypeRef.None)\r\n      );\r\n    }\r\n    // -> tempThis\r\n    stmts.push(\r\n      module.local_get(tempThis.index, arrayTypeRef)\r\n    );\r\n    flow.freeTempLocal(tempThis);\r\n    if (length) this.compileFunction(indexedSet);\r\n    this.currentType = arrayType;\r\n    return module.flatten(stmts, arrayTypeRef);\r\n  }\r\n\r\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\r\n    var module = this.module;\r\n\r\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\r\n    var classReference = contextualType.getClass();\r\n    if (!classReference) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        expression.range, \"<object>\", contextualType.toString()\r\n      );\r\n      return module.unreachable();\r\n    }\r\n    var classType = classReference.type;\r\n    this.currentType = classType.nonNullableType;\r\n    if (classReference.is(CommonFlags.ABSTRACT)) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\r\n        expression.range\r\n      );\r\n      return module.unreachable();\r\n    }\r\n\r\n    // Check that the class is compatible with object literals\r\n    var ctorPrototype = classReference.prototype.constructorPrototype;\r\n    if (ctorPrototype) {\r\n      this.errorRelated(\r\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\r\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\r\n      );\r\n      return module.unreachable();\r\n    }\r\n\r\n    var isManaged = classType.isManaged;\r\n    if (!isManaged) {\r\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.UNMANAGED, classReference.decoratorNodes));\r\n    }\r\n\r\n    // check and compile field values\r\n    var names = expression.names;\r\n    var numNames = names.length;\r\n    var values = expression.values;\r\n    var members = classReference.members;\r\n    var hasErrors = false;\r\n    var exprs = new Array<ExpressionRef>();\r\n    var flow = this.currentFlow;\r\n    var tempLocal = flow.getTempLocal(classType);\r\n    var classTypeRef = classType.toRef();\r\n    assert(numNames == values.length);\r\n\r\n    // Assume all class fields will be omitted, and add them to our omitted list\r\n    var omittedFields = new Set<Field>();\r\n    if (members) {\r\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\r\n        let memberKey = _keys[i];\r\n        let member = assert(members.get(memberKey));\r\n        if (member !== null && member.kind == ElementKind.FIELD) {\r\n          omittedFields.add(<Field>member); // incl. private/protected\r\n        }\r\n      }\r\n    }\r\n\r\n    // Iterate through the members defined in our expression\r\n    for (let i = 0; i < numNames; ++i) {\r\n      let memberName = names[i].text;\r\n      let member: DeclaredElement;\r\n      if (!members || !members.has(memberName) || (member = assert(members.get(memberName))).kind != ElementKind.FIELD) {\r\n        this.error(\r\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n          names[i].range, memberName, classType.toString()\r\n        );\r\n        hasErrors = true;\r\n        continue;\r\n      }\r\n      if (member.is(CommonFlags.PRIVATE)) {\r\n        this.error(\r\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\r\n          names[i].range, memberName, classType.toString()\r\n        );\r\n        hasErrors = true;\r\n        continue;\r\n      }\r\n      if (member.is(CommonFlags.PROTECTED)) {\r\n        this.error(\r\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\r\n          names[i].range, memberName, classType.toString()\r\n        );\r\n        hasErrors = true;\r\n        continue;\r\n      }\r\n      let fieldInstance = <Field>member;\r\n      let fieldType = fieldInstance.type;\r\n\r\n      let expr = this.compileExpression(values[i], fieldType, Constraints.CONV_IMPLICIT);\r\n      exprs.push(\r\n        module.call(fieldInstance.internalSetterName, [\r\n          module.local_get(tempLocal.index, classTypeRef),\r\n          expr\r\n        ], TypeRef.None)\r\n      );\r\n      this.compileFieldSetter(fieldInstance);\r\n\r\n      // This member is no longer omitted, so delete from our omitted fields\r\n      omittedFields.delete(fieldInstance);\r\n    }\r\n    this.currentType = classType.nonNullableType;\r\n    if (hasErrors) return module.unreachable();\r\n\r\n    // Check remaining omitted fields\r\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\r\n      let fieldInstance = _values[j];\r\n      let fieldType = fieldInstance.type;\r\n\r\n      if (fieldInstance.initializerNode) {\r\n        continue; // set by generated ctor\r\n      }\r\n\r\n      if (fieldType.isReference) {\r\n        if (!fieldType.isNullableReference) {\r\n          this.error(\r\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\r\n            expression.range, fieldInstance.name, \"<object>\", classType.toString()\r\n          );\r\n          hasErrors = true;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      switch (fieldType.kind) {\r\n        // Number Types (and Number alias types)\r\n        case TypeKind.I8:\r\n        case TypeKind.I16:\r\n        case TypeKind.I32:\r\n        case TypeKind.I64:\r\n        case TypeKind.ISIZE:\r\n        case TypeKind.U8:\r\n        case TypeKind.U16:\r\n        case TypeKind.U32:\r\n        case TypeKind.U64:\r\n        case TypeKind.USIZE:\r\n        case TypeKind.BOOL:\r\n        case TypeKind.F32:\r\n        case TypeKind.F64: {\r\n          exprs.push(\r\n            module.call(fieldInstance.internalSetterName, [\r\n              module.local_get(tempLocal.index, classTypeRef),\r\n              this.makeZero(fieldType, expression)\r\n            ], TypeRef.None)\r\n          );\r\n          this.compileFieldSetter(fieldInstance);\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // Otherwise error\r\n      this.error(\r\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\r\n        expression.range, fieldInstance.name, \"<object>\", classType.toString()\r\n      );\r\n      hasErrors = true;\r\n    }\r\n    if (hasErrors) return module.unreachable();\r\n\r\n    // generate the default constructor\r\n    var ctor = this.ensureConstructor(classReference, expression);\r\n    // note that this is not checking field initialization within the ctor, but\r\n    // instead checks conditions above with provided fields taken into account.\r\n\r\n    // allocate a new instance first and assign 'this' to the temp. local\r\n    exprs.unshift(\r\n      module.local_set(tempLocal.index,\r\n        this.compileInstantiate(ctor, [], Constraints.NONE, expression),\r\n        classType.isManaged\r\n      )\r\n    );\r\n\r\n    // once all field values have been set, return 'this'\r\n    exprs.push(\r\n      module.local_get(tempLocal.index, classTypeRef)\r\n    );\r\n\r\n    if (!isManaged) flow.freeTempLocal(tempLocal);\r\n    this.currentType = classType.nonNullableType;\r\n    return module.flatten(exprs, classTypeRef);\r\n  }\r\n\r\n  private compileNewExpression(\r\n    expression: NewExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n\r\n    // obtain the class being instantiated\r\n    var target = this.resolver.resolveTypeName(expression.typeName, flow.actualFunction);\r\n    if (!target) return module.unreachable();\r\n    if (target.kind != ElementKind.CLASS_PROTOTYPE) {\r\n      this.error(\r\n        DiagnosticCode.This_expression_is_not_constructable,\r\n        expression.typeName.range\r\n      );\r\n      return this.module.unreachable();\r\n    }\r\n    if (target.is(CommonFlags.ABSTRACT)) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\r\n        expression.typeName.range\r\n      );\r\n      return this.module.unreachable();\r\n    }\r\n    var classPrototype = <ClassPrototype>target;\r\n    var classInstance: Class | null = null;\r\n    var typeArguments = expression.typeArguments;\r\n    var classReference: Class | null;\r\n    if (\r\n      !typeArguments &&\r\n      (classReference = contextualType.classReference) !== null &&\r\n      classReference.prototype == classPrototype &&\r\n      classReference.is(CommonFlags.GENERIC)\r\n    ) {\r\n      // e.g. `arr: Array<T> = new Array()`\r\n      classInstance = this.resolver.resolveClass(\r\n        classPrototype,\r\n        classReference.typeArguments,\r\n        uniqueMap<string,Type>(flow.contextualTypeArguments)\r\n      );\r\n    } else {\r\n      classInstance = this.resolver.resolveClassInclTypeArguments(\r\n        classPrototype,\r\n        typeArguments,\r\n        flow.actualFunction.parent, // relative to caller\r\n        uniqueMap<string,Type>(flow.contextualTypeArguments),\r\n        expression\r\n      );\r\n    }\r\n    if (!classInstance) return module.unreachable();\r\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\r\n    var ctor = this.ensureConstructor(classInstance, expression);\r\n    if (!ctor.hasDecorator(DecoratorFlags.INLINE)) {\r\n      // Inlined ctors haven't been compiled yet and are checked upon inline\r\n      // compilation of their body instead.\r\n      this.checkFieldInitialization(classInstance, expression);\r\n    }\r\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\r\n  }\r\n\r\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\r\n  ensureConstructor(\r\n    /** Class wanting a constructor. */\r\n    classInstance: Class,\r\n    /** Report node. */\r\n    reportNode: Node\r\n  ): Function {\r\n    var instance = classInstance.constructorInstance;\r\n    if (instance) {\r\n      // shortcut if already compiled\r\n      if (instance.is(CommonFlags.COMPILED)) return instance;\r\n      // do not attempt to compile if inlined anyway\r\n      if (!instance.hasDecorator(DecoratorFlags.INLINE)) this.compileFunction(instance);\r\n    } else {\r\n      // clone base constructor if a derived class. note that we cannot just\r\n      // call the base ctor since the derived class may have additional fields.\r\n      let baseClass = classInstance.base;\r\n      let contextualTypeArguments = uniqueMap(classInstance.contextualTypeArguments);\r\n      if (baseClass) {\r\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\r\n        this.checkFieldInitialization(baseClass, reportNode);\r\n        instance = new Function(\r\n          CommonNames.constructor,\r\n          new FunctionPrototype(\r\n            CommonNames.constructor,\r\n            classInstance,\r\n            // declaration is important, i.e. to access optional parameter initializers\r\n            (<FunctionDeclaration>baseCtor.declaration).clone()\r\n          ),\r\n          null,\r\n          baseCtor.signature,\r\n          contextualTypeArguments\r\n        );\r\n\r\n      // otherwise make a default constructor\r\n      } else {\r\n        instance = new Function(\r\n          CommonNames.constructor,\r\n          new FunctionPrototype(\r\n            CommonNames.constructor,\r\n            classInstance, // bound\r\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\r\n              CommonFlags.INSTANCE | CommonFlags.CONSTRUCTOR\r\n            )\r\n          ),\r\n          null,\r\n          new Signature(this.program, null, classInstance.type, classInstance.type),\r\n          contextualTypeArguments\r\n        );\r\n      }\r\n\r\n      instance.set(CommonFlags.COMPILED);\r\n      instance.prototype.setResolvedInstance(\"\", instance);\r\n      if (classInstance.is(CommonFlags.MODULE_EXPORT)) {\r\n        instance.set(CommonFlags.MODULE_EXPORT);\r\n      }\r\n      classInstance.constructorInstance = instance;\r\n      let members = classInstance.members;\r\n      if (!members) classInstance.members = members = new Map();\r\n      members.set(\"constructor\", instance.prototype);\r\n\r\n      let previousFlow = this.currentFlow;\r\n      let flow = instance.flow;\r\n      this.currentFlow = flow;\r\n\r\n      // generate body\r\n      let signature = instance.signature;\r\n      let module = this.module;\r\n      let sizeTypeRef = this.options.sizeTypeRef;\r\n      let stmts = new Array<ExpressionRef>();\r\n\r\n      // {\r\n      //   this = <COND_ALLOC>\r\n      //   IF_DERIVED: this = super(this, ...args)\r\n      //   this.a = X\r\n      //   this.b = Y\r\n      //   return this\r\n      // }\r\n      stmts.push(\r\n        this.makeConditionalAllocation(classInstance, 0)\r\n      );\r\n      if (baseClass) {\r\n        let parameterTypes = signature.parameterTypes;\r\n        let numParameters = parameterTypes.length;\r\n        let operands = new Array<ExpressionRef>(1 + numParameters);\r\n        operands[0] = module.local_get(0, sizeTypeRef);\r\n        for (let i = 1; i <= numParameters; ++i) {\r\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toRef());\r\n        }\r\n        stmts.push(\r\n          module.local_set(0,\r\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false),\r\n            baseClass.type.isManaged\r\n          )\r\n        );\r\n      }\r\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\r\n      stmts.push(\r\n        module.local_get(0, sizeTypeRef)\r\n      );\r\n      flow.freeScopedLocals();\r\n      this.currentFlow = previousFlow;\r\n\r\n      // make the function\r\n      let locals = instance.localsByIndex;\r\n      let varTypes = new Array<TypeRef>(); // of temp. vars added while compiling initializers\r\n      let numOperands = 1 + signature.parameterTypes.length;\r\n      let numLocals = locals.length;\r\n      if (numLocals > numOperands) {\r\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toRef());\r\n      }\r\n      let funcRef = module.addFunction(\r\n        instance.internalName,\r\n        signature.paramRefs,\r\n        signature.resultRefs,\r\n        varTypes,\r\n        module.flatten(stmts, sizeTypeRef)\r\n      );\r\n      instance.finalize(module, funcRef);\r\n    }\r\n\r\n    return instance;\r\n  }\r\n\r\n  /** Checks that all class fields have been initialized. */\r\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\r\n    if (classInstance.didCheckFieldInitialization) return;\r\n    classInstance.didCheckFieldInitialization = true;\r\n    var ctor = assert(classInstance.constructorInstance);\r\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\r\n  }\r\n\r\n  /** Checks that all class fields have been initialized in the specified flow. */\r\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\r\n    var members = classInstance.members;\r\n    if (members) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let element = _values[i];\r\n        if (element.kind == ElementKind.FIELD && element.parent == classInstance) {\r\n          let field = <Field>element;\r\n          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.INITIALIZED)) {\r\n            if (!field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\r\n              if (relatedNode) {\r\n                this.errorRelated(\r\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\r\n                  field.declaration.name.range,\r\n                  relatedNode.range,\r\n                  field.internalName\r\n                );\r\n              } else {\r\n                this.error(\r\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\r\n                  field.declaration.name.range,\r\n                  field.internalName\r\n                );\r\n              }\r\n            }\r\n          } else if (field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\r\n            if (field.type.isReference) {\r\n              this.warning( // involves a runtime check\r\n                DiagnosticCode.Property_0_is_always_assigned_before_being_used,\r\n                field.identifierNode.range,\r\n                field.internalName\r\n              );\r\n            } else {\r\n              this.pedantic( // is a nop anyway\r\n                DiagnosticCode.Unnecessary_definite_assignment,\r\n                field.identifierNode.range\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  compileInstantiate(\r\n    /** Constructor to call. */\r\n    ctorInstance: Function,\r\n    /** Constructor arguments. */\r\n    argumentExpressions: Expression[],\r\n    /** Contextual flags. */\r\n    constraints: Constraints,\r\n    /** Node to report on. */\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    assert(ctorInstance.is(CommonFlags.CONSTRUCTOR));\r\n    var parent = ctorInstance.parent;\r\n    assert(parent.kind == ElementKind.CLASS);\r\n    var classInstance = <Class>parent;\r\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\r\n    var expr = this.compileCallDirect(\r\n      ctorInstance,\r\n      argumentExpressions,\r\n      reportNode,\r\n      this.makeZero(this.options.usizeType, reportNode),\r\n      constraints\r\n    );\r\n    if (getExpressionType(expr) != TypeRef.None) { // possibly WILL_DROP\r\n      this.currentType = classInstance.type; // important because a super ctor could be called\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  private compilePropertyAccessExpression(\r\n    expression: PropertyAccessExpression,\r\n    ctxType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n\r\n    this.maybeCompileEnclosingSource(expression);\r\n\r\n    var resolver = this.resolver;\r\n    var target = resolver.lookupExpression(expression, flow, ctxType); // reports\r\n    if (!target) return module.unreachable();\r\n    var thisExpression = resolver.currentThisExpression;\r\n    if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\r\n\r\n    switch (target.kind) {\r\n      case ElementKind.GLOBAL: { // static field\r\n        let global = <Global>target;\r\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\r\n        let globalType = global.type;\r\n        assert(globalType != Type.void);\r\n        if (this.pendingElements.has(global)) {\r\n          this.error(\r\n            DiagnosticCode.Variable_0_used_before_its_declaration,\r\n            expression.range,\r\n            global.internalName\r\n          );\r\n          this.currentType = globalType;\r\n          return module.unreachable();\r\n        }\r\n        if (global.is(CommonFlags.INLINED)) {\r\n          return this.compileInlineConstant(global, ctxType, constraints);\r\n        }\r\n        this.currentType = globalType;\r\n        return module.global_get(global.internalName, globalType.toRef());\r\n      }\r\n      case ElementKind.ENUMVALUE: { // enum value\r\n        let enumValue = <EnumValue>target;\r\n        let parent = assert(enumValue.parent);\r\n        assert(parent.kind == ElementKind.ENUM);\r\n        let parentEnum = <Enum>parent;\r\n        if (!this.compileEnum(parentEnum)) {\r\n          this.currentType = Type.i32;\r\n          return this.module.unreachable();\r\n        }\r\n        this.currentType = Type.i32;\r\n        if (enumValue.is(CommonFlags.INLINED)) {\r\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\r\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\r\n        }\r\n        assert(enumValue.type == Type.i32);\r\n        return module.global_get(enumValue.internalName, TypeRef.I32);\r\n      }\r\n      case ElementKind.FIELD: {\r\n        let fieldInstance = <Field>target;\r\n        let fieldType = fieldInstance.type;\r\n        assert(fieldInstance.memoryOffset >= 0);\r\n        let fieldParent = fieldInstance.parent;\r\n        assert(fieldParent.kind == ElementKind.CLASS);\r\n        thisExpression = assert(thisExpression);\r\n        let thisExpr = this.compileExpression(\r\n          thisExpression,\r\n          (<Class>fieldParent).type,\r\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n        );\r\n        let thisType = this.currentType;\r\n        if (\r\n          flow.actualFunction.is(CommonFlags.CONSTRUCTOR) &&\r\n          thisExpression.kind == NodeKind.THIS &&\r\n          !flow.isThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED) &&\r\n          !fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED)\r\n        ) {\r\n          this.errorRelated(\r\n            DiagnosticCode.Property_0_is_used_before_being_assigned,\r\n            expression.range,\r\n            fieldInstance.identifierNode.range,\r\n            fieldInstance.internalName\r\n          );\r\n        }\r\n        if (thisType.isNullableReference) {\r\n          if (!flow.isNonnull(thisExpr, thisType)) {\r\n            this.error(\r\n              DiagnosticCode.Object_is_possibly_null,\r\n              thisExpression.range\r\n            );\r\n          }\r\n        }\r\n        if (!fieldInstance.is(CommonFlags.COMPILED)) {\r\n          fieldInstance.set(CommonFlags.COMPILED);\r\n          let typeNode = fieldInstance.typeNode;\r\n          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);\r\n        }\r\n        this.currentType = fieldType;\r\n        let ret = module.load(\r\n          fieldType.byteSize,\r\n          fieldType.isSignedIntegerValue,\r\n          thisExpr,\r\n          fieldType.toRef(),\r\n          fieldInstance.memoryOffset\r\n        );\r\n        if (fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED) && fieldType.isReference && !fieldType.isNullableReference) {\r\n          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);\r\n        }\r\n        return ret;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyPrototype = <PropertyPrototype>target;\r\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\r\n        if (!propertyInstance) return module.unreachable();\r\n        target = propertyInstance;\r\n        // fall-through\r\n      }\r\n      case ElementKind.PROPERTY: {\r\n        let propertyInstance = <Property>target;\r\n        let getterInstance = propertyInstance.getterInstance;\r\n        if (!getterInstance) return module.unreachable(); // failed earlier\r\n        let thisArg: ExpressionRef = 0;\r\n        if (getterInstance.is(CommonFlags.INSTANCE)) {\r\n          thisArg = this.compileExpression(\r\n            assert(thisExpression),\r\n            assert(getterInstance.signature.thisType),\r\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\r\n          );\r\n        }\r\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\r\n      }\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        let functionPrototype = <FunctionPrototype>target;\r\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\r\n        if (!functionInstance) return module.unreachable();\r\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\r\n        this.currentType = functionInstance.type;\r\n        let offset = this.ensureRuntimeFunction(functionInstance);\r\n        return this.options.isWasm64\r\n          ? module.i64(i64_low(offset), i64_high(offset))\r\n          : module.i32(i64_low(offset));\r\n      }\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime,\r\n      expression.range\r\n    );\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  private compileTernaryExpression(\r\n    expression: TernaryExpression,\r\n    ctxType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var ifThen = expression.ifThen;\r\n    var ifElse = expression.ifElse;\r\n\r\n    var condExpr = this.makeIsTrueish(\r\n      this.compileExpression(expression.condition, Type.bool),\r\n      this.currentType,\r\n      expression.condition\r\n    );\r\n    // Try to eliminate unnecesssary branches if the condition is constant\r\n    // FIXME: skips common denominator, inconsistently picking branch type\r\n    var condKind = this.evaluateCondition(condExpr);\r\n    if (condKind == ConditionKind.TRUE) {\r\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));\r\n    }\r\n    if (condKind == ConditionKind.FALSE) {\r\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));\r\n    }\r\n\r\n    var outerFlow = this.currentFlow;\r\n    var ifThenFlow = outerFlow.fork();\r\n    ifThenFlow.inheritNonnullIfTrue(condExpr);\r\n    this.currentFlow = ifThenFlow;\r\n    var ifThenExpr = this.compileExpression(ifThen, ctxType);\r\n    var ifThenType = this.currentType;\r\n\r\n    var ifElseFlow = outerFlow.fork();\r\n    ifElseFlow.inheritNonnullIfFalse(condExpr);\r\n    this.currentFlow = ifElseFlow;\r\n    var ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType);\r\n    var ifElseType = this.currentType;\r\n\r\n    var commonType = Type.commonDenominator(ifThenType, ifElseType, false);\r\n    if (!commonType) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        ifElse.range, ifElseType.toString(), ifThenType.toString()\r\n      );\r\n      this.currentType = ctxType;\r\n      return module.unreachable();\r\n    }\r\n    ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\r\n    ifThenType = commonType;\r\n    ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\r\n    ifElseType = commonType;\r\n    this.currentType = commonType;\r\n\r\n    ifThenFlow.freeScopedLocals();\r\n    ifElseFlow.freeScopedLocals();\r\n\r\n    this.currentFlow = outerFlow;\r\n    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);\r\n\r\n    return module.if(condExpr, ifThenExpr, ifElseExpr);\r\n  }\r\n\r\n  private compileUnaryPostfixExpression(\r\n    expression: UnaryPostfixExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n\r\n    // make a getter for the expression (also obtains the type)\r\n    var getValue = this.compileExpression( // reports\r\n      expression.operand,\r\n      contextualType.exceptVoid,\r\n      Constraints.NONE\r\n    );\r\n\r\n    // shortcut if compiling the getter already failed\r\n    if (getExpressionId(getValue) == ExpressionId.Unreachable) return getValue;\r\n\r\n    // if the value isn't dropped, a temp. local is required to remember the original value,\r\n    // except if a static overload is found, which reverses the use of a temp. (see below)\r\n    var tempLocal: Local | null = null;\r\n    if (contextualType != Type.void) {\r\n      tempLocal = flow.getTempLocal(this.currentType);\r\n      getValue = module.local_tee(\r\n        tempLocal.index,\r\n        getValue,\r\n        this.currentType.isManaged\r\n      );\r\n    }\r\n\r\n    var expr: ExpressionRef;\r\n\r\n    switch (expression.operator) {\r\n      case Token.PLUS_PLUS: {\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_INC);\r\n          if (overload) {\r\n            let isInstance = overload.is(CommonFlags.INSTANCE);\r\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\r\n              getValue = getLocalSetValue(getValue);\r\n              flow.freeTempLocal(tempLocal);\r\n              tempLocal = null;\r\n            }\r\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\r\n            if (isInstance) break;\r\n            return expr; // here\r\n          }\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"++\", this.currentType.toString()\r\n          );\r\n          if (tempLocal) flow.freeTempLocal(tempLocal);\r\n          return module.unreachable();\r\n        }\r\n\r\n        switch (this.currentType.kind) {\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL: {\r\n            expr = module.binary(\r\n              BinaryOp.AddI32,\r\n              getValue,\r\n              module.i32(1)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.USIZE:\r\n          case TypeKind.ISIZE: {\r\n            let options = this.options;\r\n            expr = module.binary(\r\n              options.isWasm64\r\n                ? BinaryOp.AddI64\r\n                : BinaryOp.AddI32,\r\n              getValue,\r\n              this.makeOne(this.currentType)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.I64:\r\n          case TypeKind.U64: {\r\n            expr = module.binary(\r\n              BinaryOp.AddI64,\r\n              getValue,\r\n              module.i64(1)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.F32: {\r\n            expr = module.binary(\r\n              BinaryOp.AddF32,\r\n              getValue,\r\n              module.f32(1)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.F64: {\r\n            expr = module.binary(\r\n              BinaryOp.AddF64,\r\n              getValue,\r\n              module.f64(1)\r\n            );\r\n            break;\r\n          }\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"++\", this.currentType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case Token.MINUS_MINUS: {\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_DEC);\r\n          if (overload) {\r\n            let isInstance = overload.is(CommonFlags.INSTANCE);\r\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\r\n              getValue = getLocalSetValue(getValue);\r\n              flow.freeTempLocal(tempLocal);\r\n              tempLocal = null;\r\n            }\r\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\r\n            if (overload.is(CommonFlags.INSTANCE)) break;\r\n            return expr; // here\r\n          }\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"--\", this.currentType.toString()\r\n          );\r\n          if (tempLocal) flow.freeTempLocal(tempLocal);\r\n          return module.unreachable();\r\n        }\r\n\r\n        switch (this.currentType.kind) {\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL: {\r\n            expr = module.binary(\r\n              BinaryOp.SubI32,\r\n              getValue,\r\n              module.i32(1)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.USIZE:\r\n          case TypeKind.ISIZE: {\r\n            let options = this.options;\r\n            expr = module.binary(\r\n              options.isWasm64\r\n                ? BinaryOp.SubI64\r\n                : BinaryOp.SubI32,\r\n              getValue,\r\n              this.makeOne(this.currentType)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.I64:\r\n          case TypeKind.U64: {\r\n            expr = module.binary(\r\n              BinaryOp.SubI64,\r\n              getValue,\r\n              module.i64(1)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.F32: {\r\n            expr = module.binary(\r\n              BinaryOp.SubF32,\r\n              getValue,\r\n              module.f32(1)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.F64: {\r\n            expr = module.binary(\r\n              BinaryOp.SubF64,\r\n              getValue,\r\n              module.f64(1)\r\n            );\r\n            break;\r\n          }\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"--\", this.currentType.toString()\r\n            );\r\n            return module.unreachable();\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        assert(false);\r\n        return module.unreachable();\r\n      }\r\n    }\r\n\r\n    var resolver = this.resolver;\r\n    var target = resolver.lookupExpression(expression.operand, flow); // reports\r\n    if (!target) {\r\n      if (tempLocal) flow.freeTempLocal(tempLocal);\r\n      return module.unreachable();\r\n    }\r\n\r\n    // simplify if dropped anyway\r\n    if (!tempLocal) {\r\n      return this.makeAssignment(\r\n        target,\r\n        expr,\r\n        this.currentType,\r\n        expression.operand,\r\n        resolver.currentThisExpression,\r\n        resolver.currentElementExpression,\r\n        false\r\n      );\r\n    }\r\n\r\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\r\n    var setValue = this.makeAssignment(\r\n      target,\r\n      expr, // includes a tee of getValue to tempLocal\r\n      this.currentType,\r\n      expression.operand,\r\n      resolver.currentThisExpression,\r\n      resolver.currentElementExpression,\r\n      false\r\n    );\r\n\r\n    this.currentType = tempLocal.type;\r\n    flow.freeTempLocal(tempLocal);\r\n    var typeRef = tempLocal.type.toRef();\r\n\r\n    return module.block(null, [\r\n      setValue,\r\n      module.local_get(tempLocal.index, typeRef)\r\n    ], typeRef); // result of 'x++' / 'x--' might overflow\r\n  }\r\n\r\n  private compileUnaryPrefixExpression(\r\n    expression: UnaryPrefixExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var compound = false;\r\n    var expr: ExpressionRef;\r\n\r\n    switch (expression.operator) {\r\n      case Token.PLUS: {\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType.exceptVoid,\r\n          Constraints.NONE\r\n        );\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.PLUS);\r\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"+\", this.currentType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        // nop\r\n        break;\r\n      }\r\n      case Token.MINUS: {\r\n        let operand = expression.operand;\r\n        if (operand.isNumericLiteral) {\r\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\r\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.NONE, true);\r\n          // compileExpression normally does this:\r\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\r\n          break;\r\n        }\r\n\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType.exceptVoid,\r\n          Constraints.NONE\r\n        );\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.MINUS);\r\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"-\", this.currentType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        switch (this.currentType.kind) {\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL: {\r\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\r\n            break;\r\n          }\r\n          case TypeKind.USIZE:\r\n          case TypeKind.ISIZE: {\r\n            expr = module.binary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.SubI64\r\n                : BinaryOp.SubI32,\r\n              this.makeZero(this.currentType, expression.operand),\r\n              expr\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.I64:\r\n          case TypeKind.U64: {\r\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\r\n            break;\r\n          }\r\n          case TypeKind.F32: {\r\n            expr = module.unary(UnaryOp.NegF32, expr);\r\n            break;\r\n          }\r\n          case TypeKind.F64: {\r\n            expr = module.unary(UnaryOp.NegF64, expr);\r\n            break;\r\n          }\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"-\", this.currentType.toString()\r\n            );\r\n            expr = module.unreachable();\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case Token.PLUS_PLUS: {\r\n        compound = true;\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType.exceptVoid,\r\n          Constraints.NONE\r\n        );\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_INC);\r\n          if (overload) {\r\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\r\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\r\n            return expr; // skip re-assign\r\n          }\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"++\", this.currentType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        switch (this.currentType.kind) {\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL: {\r\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\r\n            break;\r\n          }\r\n          case TypeKind.USIZE:\r\n          case TypeKind.ISIZE: {\r\n            expr = module.binary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.AddI64\r\n                : BinaryOp.AddI32,\r\n              expr,\r\n              this.makeOne(this.currentType)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.I64:\r\n          case TypeKind.U64: {\r\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\r\n            break;\r\n          }\r\n          case TypeKind.F32: {\r\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\r\n            break;\r\n          }\r\n          case TypeKind.F64: {\r\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\r\n            break;\r\n          }\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"++\", this.currentType.toString()\r\n            );\r\n            expr = module.unreachable();\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case Token.MINUS_MINUS: {\r\n        compound = true;\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType.exceptVoid,\r\n          Constraints.NONE\r\n        );\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_DEC);\r\n          if (overload) {\r\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\r\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\r\n            return expr; // skip re-assign\r\n          }\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"--\", this.currentType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        switch (this.currentType.kind) {\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL: {\r\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\r\n            break;\r\n          }\r\n          case TypeKind.USIZE:\r\n          case TypeKind.ISIZE: {\r\n            expr = module.binary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.SubI64\r\n                : BinaryOp.SubI32,\r\n              expr,\r\n              this.makeOne(this.currentType)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.I64:\r\n          case TypeKind.U64: {\r\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\r\n            break;\r\n          }\r\n          case TypeKind.F32: {\r\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\r\n            break;\r\n          }\r\n          case TypeKind.F64: {\r\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\r\n            break;\r\n          }\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"--\", this.currentType.toString()\r\n            );\r\n            expr = module.unreachable();\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case Token.EXCLAMATION: {\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType.exceptVoid,\r\n          Constraints.NONE\r\n        );\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\r\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\r\n          // fall back to compare by value\r\n        }\r\n\r\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\r\n        this.currentType = Type.bool;\r\n        break;\r\n      }\r\n      case Token.TILDE: {\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.isFloatValue\r\n              ? Type.i64\r\n              : contextualType,\r\n          Constraints.NONE\r\n        );\r\n\r\n        // check operator overload\r\n        let classReference = this.currentType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\r\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\r\n        }\r\n        if (!this.currentType.isValue) {\r\n          this.error(\r\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n            expression.range, \"~\", this.currentType.toString()\r\n          );\r\n          return module.unreachable();\r\n        }\r\n\r\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\r\n\r\n        switch (this.currentType.kind) {\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL: {\r\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\r\n            break;\r\n          }\r\n          case TypeKind.USIZE:\r\n          case TypeKind.ISIZE: {\r\n            expr = module.binary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.XorI64\r\n                : BinaryOp.XorI32,\r\n              expr,\r\n              this.makeNegOne(this.currentType)\r\n            );\r\n            break;\r\n          }\r\n          case TypeKind.I64:\r\n          case TypeKind.U64: {\r\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\r\n            break;\r\n          }\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              expression.range, \"~\", this.currentType.toString()\r\n            );\r\n            expr = module.unreachable();\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case Token.TYPEOF: {\r\n        return this.compileTypeof(expression, contextualType, constraints);\r\n      }\r\n      case Token.DOT_DOT_DOT: {\r\n        this.error(\r\n          DiagnosticCode.Not_implemented_0,\r\n          expression.range, \"Spread operator\"\r\n        );\r\n        return module.unreachable();\r\n      }\r\n      default: {\r\n        assert(false);\r\n        return module.unreachable();\r\n      }\r\n    }\r\n    if (!compound) return expr;\r\n    var resolver = this.resolver;\r\n    var target = resolver.lookupExpression(expression.operand, this.currentFlow);\r\n    if (!target) return module.unreachable();\r\n    return this.makeAssignment(\r\n      target,\r\n      expr,\r\n      this.currentType,\r\n      expression.operand,\r\n      resolver.currentThisExpression,\r\n      resolver.currentElementExpression,\r\n      contextualType != Type.void\r\n    );\r\n  }\r\n\r\n  private compileTypeof(\r\n    expression: UnaryPrefixExpression,\r\n    contextualType: Type,\r\n    constraints: Constraints\r\n  ): ExpressionRef {\r\n    var operand = expression.operand;\r\n    var expr: ExpressionRef = 0;\r\n    var stringInstance = this.program.stringInstance;\r\n    var typeString: string;\r\n    if (operand.kind == NodeKind.NULL) {\r\n      typeString = \"object\"; // special since `null` without type context is usize\r\n    } else {\r\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.SWALLOW);\r\n      if (!element) {\r\n        switch (operand.kind) {\r\n          case NodeKind.IDENTIFIER: break; // ignore error: typeof doesntExist -> undefined\r\n          case NodeKind.PROPERTYACCESS:\r\n          case NodeKind.ELEMENTACCESS: {\r\n            operand = operand.kind == NodeKind.PROPERTYACCESS\r\n              ? (<PropertyAccessExpression>operand).expression\r\n              : (<ElementAccessExpression>operand).expression;\r\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.REPORT);\r\n            if (!targetType) { // access on non-object\r\n              this.currentType = stringInstance.type;\r\n              return this.module.unreachable();\r\n            }\r\n            // fall-through\r\n          }\r\n          default: {\r\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\r\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\r\n          }\r\n        }\r\n        typeString = \"undefined\";\r\n      } else {\r\n        switch (element.kind) {\r\n          case ElementKind.CLASS_PROTOTYPE:\r\n          case ElementKind.NAMESPACE:\r\n          case ElementKind.ENUM: {\r\n            typeString = \"object\";\r\n            break;\r\n          }\r\n          case ElementKind.FUNCTION_PROTOTYPE: {\r\n            typeString = \"function\";\r\n            break;\r\n          }\r\n          default: {\r\n            expr = this.compileExpression(operand, Type.auto);\r\n            let type = this.currentType;\r\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\r\n            if (type.isReference) {\r\n              let signatureReference = type.getSignature();\r\n              if (signatureReference) {\r\n                typeString = \"function\";\r\n              } else {\r\n                let classReference = type.getClass();\r\n                if (classReference) {\r\n                  if (classReference.prototype === stringInstance.prototype) {\r\n                    typeString = \"string\";\r\n                  } else {\r\n                    typeString = \"object\";\r\n                  }\r\n                } else {\r\n                  typeString = \"externref\"; // TODO?\r\n                }\r\n              }\r\n            } else if (type == Type.bool) {\r\n              typeString = \"boolean\";\r\n            } else if (type.isNumericValue) {\r\n              typeString = \"number\";\r\n            } else {\r\n              typeString = \"undefined\"; // failed to compile?\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.currentType = stringInstance.type;\r\n    return expr\r\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.sizeTypeRef)\r\n      : this.ensureStaticString(typeString);\r\n  }\r\n\r\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\r\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    switch (type.kind) {\r\n      case TypeKind.I8: {\r\n        if (flow.canOverflow(expr, type)) {\r\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\r\n            ? module.unary(UnaryOp.Extend8I32, expr)\r\n            : module.binary(BinaryOp.ShrI32,\r\n                module.binary(BinaryOp.ShlI32,\r\n                  expr,\r\n                  module.i32(24)\r\n                ),\r\n                module.i32(24)\r\n              );\r\n        }\r\n        break;\r\n      }\r\n      case TypeKind.I16: {\r\n        if (flow.canOverflow(expr, type)) {\r\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\r\n            ? module.unary(UnaryOp.Extend16I32, expr)\r\n            : module.binary(BinaryOp.ShrI32,\r\n                module.binary(BinaryOp.ShlI32,\r\n                  expr,\r\n                  module.i32(16)\r\n                ),\r\n                module.i32(16)\r\n              );\r\n        }\r\n        break;\r\n      }\r\n      case TypeKind.U8: {\r\n        if (flow.canOverflow(expr, type)) {\r\n          expr = module.binary(BinaryOp.AndI32,\r\n            expr,\r\n            module.i32(0xff)\r\n          );\r\n        }\r\n        break;\r\n      }\r\n      case TypeKind.U16: {\r\n        if (flow.canOverflow(expr, type)) {\r\n          expr = module.binary(BinaryOp.AndI32,\r\n            expr,\r\n            module.i32(0xffff)\r\n          );\r\n        }\r\n        break;\r\n      }\r\n      case TypeKind.BOOL: {\r\n        if (flow.canOverflow(expr, type)) {\r\n          // bool is special in that it compares to 0 instead of masking with 0x1\r\n          expr = module.binary(BinaryOp.NeI32,\r\n            expr,\r\n            module.i32(0)\r\n          );\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\r\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\r\n    var parentFunction = this.currentFlow.parentFunction;\r\n    var source = range.source;\r\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\r\n    range.debugInfoRef = expr;\r\n    parentFunction.debugLocations.push(range);\r\n  }\r\n\r\n  /** Checks whether a particular feature is enabled. */\r\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\r\n    if (!this.options.hasFeature(feature)) {\r\n      this.error(\r\n        DiagnosticCode.Feature_0_is_not_enabled,\r\n        reportNode.range, featureToString(feature)\r\n      );\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Checks whether a particular type is supported. */\r\n  checkTypeSupported(type: Type, reportNode: Node): bool {\r\n    switch (type.kind) {\r\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.SIMD, reportNode);\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode);\r\n      case TypeKind.ANYREF:\r\n      case TypeKind.EQREF:\r\n      case TypeKind.I31REF:\r\n      case TypeKind.DATAREF: {\r\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\r\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\r\n      }\r\n    }\r\n    let classReference = type.getClass();\r\n    if (classReference) {\r\n      do {\r\n        let typeArguments = classReference.typeArguments;\r\n        if (typeArguments) {\r\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\r\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        classReference = classReference.base;\r\n      } while(classReference);\r\n    } else {\r\n      let signatureReference = type.getSignature();\r\n      if (signatureReference) {\r\n        let thisType = signatureReference.thisType;\r\n        if (thisType) {\r\n          if (!this.checkTypeSupported(thisType, reportNode)) {\r\n            return false;\r\n          }\r\n        }\r\n        let parameterTypes = signatureReference.parameterTypes;\r\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\r\n            return false;\r\n          }\r\n        }\r\n        let returnType = signatureReference.returnType;\r\n        if (!this.checkTypeSupported(returnType, reportNode)) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Checks whether a particular function signature is supported. */\r\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\r\n    var supported = true;\r\n    var explicitThisType = reportNode.explicitThisType;\r\n    if (explicitThisType) {\r\n      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\r\n        supported = false;\r\n      }\r\n    }\r\n    var parameterTypes = signature.parameterTypes;\r\n    var parameterNodes = reportNode.parameters;\r\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n      let parameterReportNode: Node;\r\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\r\n      else parameterReportNode = reportNode;\r\n      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\r\n        supported = false;\r\n      }\r\n    }\r\n    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {\r\n      supported = false;\r\n    }\r\n    return supported;\r\n  }\r\n\r\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\r\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\r\n    assert(getExpressionType(expr) == TypeRef.I32);\r\n    var module = this.module;\r\n    var evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\r\n    if (evaled) {\r\n      return getConstValueI32(evaled)\r\n        ? ConditionKind.TRUE\r\n        : ConditionKind.FALSE;\r\n    }\r\n    return ConditionKind.UNKNOWN;\r\n  }\r\n\r\n  // === Specialized code generation ==============================================================\r\n\r\n  /** Makes a constant zero of the specified type. */\r\n  makeZero(type: Type, reportNode: Node): ExpressionRef {\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      default: assert(false);\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: return module.i32(0);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(0);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.i64(0);\r\n      case TypeKind.F32: return module.f32(0);\r\n      case TypeKind.F64: return module.f64(0);\r\n      case TypeKind.V128: return module.v128(v128_zero);\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n      case TypeKind.ANYREF:\r\n      case TypeKind.EQREF:\r\n      case TypeKind.DATAREF: return module.ref_null(type.toRef());\r\n      case TypeKind.I31REF: return module.i31_new(module.i32(0));\r\n    }\r\n  }\r\n\r\n  /** Makes a constant one of the specified type. */\r\n  makeOne(type: Type): ExpressionRef {\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      default: assert(false);\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: return module.i32(1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.i64(1);\r\n      case TypeKind.F32: return module.f32(1);\r\n      case TypeKind.F64: return module.f64(1);\r\n      case TypeKind.I31REF: return module.i31_new(module.i32(1));\r\n    }\r\n  }\r\n\r\n  /** Makes a constant negative one of the specified type. */\r\n  makeNegOne(type: Type): ExpressionRef {\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      default: assert(false);\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32: return module.i32(-1);\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(-1);\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return module.i64(-1, -1);\r\n      case TypeKind.F32: return module.f32(-1);\r\n      case TypeKind.F64: return module.f64(-1);\r\n    }\r\n  }\r\n\r\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\r\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\r\n    var module = this.module;\r\n    switch (type.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16: {\r\n        expr = this.ensureSmallIntegerWrap(expr, type);\r\n        // fall-through\r\n      }\r\n      case TypeKind.BOOL: // not a mask, just != 0\r\n      case TypeKind.I32:\r\n      case TypeKind.U32: {\r\n        return expr;\r\n      }\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: {\r\n        return module.binary(BinaryOp.NeI64, expr, module.i64(0));\r\n      }\r\n      case TypeKind.USIZE:\r\n      case TypeKind.ISIZE: {\r\n        return type.size == 64\r\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\r\n          : expr;\r\n      }\r\n      case TypeKind.F32: {\r\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\r\n        // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\r\n        //\r\n        // and finally:\r\n        // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\r\n        return module.binary(BinaryOp.LeU32,\r\n          module.binary(BinaryOp.SubI32,\r\n            module.binary(BinaryOp.ShlI32,\r\n              module.unary(UnaryOp.ReinterpretF32ToI32, expr),\r\n              module.i32(1)\r\n            ),\r\n            module.i32(2) // 1 << 1\r\n          ),\r\n          module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\r\n        );\r\n      }\r\n      case TypeKind.F64: {\r\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\r\n        // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\r\n        //\r\n        // and finally:\r\n        // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\r\n        return module.binary(BinaryOp.LeU64,\r\n          module.binary(BinaryOp.SubI64,\r\n            module.binary(BinaryOp.ShlI64,\r\n              module.unary(UnaryOp.ReinterpretF64ToI64, expr),\r\n              module.i64(1)\r\n            ),\r\n            module.i64(2) // 1 << 1\r\n          ),\r\n          module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\r\n        );\r\n      }\r\n      case TypeKind.FUNCREF:\r\n      case TypeKind.EXTERNREF:\r\n      case TypeKind.ANYREF:\r\n      case TypeKind.EQREF:\r\n      case TypeKind.DATAREF:\r\n      case TypeKind.I31REF: {\r\n        // Needs to be true (i.e. not zero) when the ref is _not_ null,\r\n        // which means `ref.is_null` returns false (i.e. zero).\r\n        return module.unary(UnaryOp.EqzI32, module.ref_is(RefIsOp.RefIsNull, expr));\r\n\r\n      }\r\n      default: {\r\n        assert(false);\r\n        return module.i32(0);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Makes a string conversion of the given expression. */\r\n  makeToString(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\r\n    var stringType = this.program.stringInstance.type;\r\n    if (type == stringType) {\r\n      return expr;\r\n    }\r\n    var classType = type.getClassOrWrapper(this.program);\r\n    if (classType) {\r\n      let toStringInstance = classType.getMethod(\"toString\");\r\n      if (toStringInstance) {\r\n        let toStringSignature = toStringInstance.signature;\r\n        if (!this.checkCallSignature( // reports\r\n          toStringSignature,\r\n          0,\r\n          true,\r\n          reportNode\r\n        )) {\r\n          this.currentType = stringType;\r\n          return this.module.unreachable();\r\n        }\r\n        if (!type.isStrictlyAssignableTo(assert(toStringSignature.thisType))) {\r\n          this.errorRelated(\r\n            DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\r\n            reportNode.range, toStringInstance.identifierAndSignatureRange\r\n          );\r\n          this.currentType = stringType;\r\n          return this.module.unreachable();\r\n        }\r\n        let toStringReturnType = toStringSignature.returnType;\r\n        if (!toStringReturnType.isStrictlyAssignableTo(stringType)) {\r\n          this.errorRelated(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            reportNode.range, toStringInstance.identifierAndSignatureRange, toStringReturnType.toString(), stringType.toString()\r\n          );\r\n          this.currentType = stringType;\r\n          return this.module.unreachable();\r\n        }\r\n        return this.makeCallDirect(toStringInstance, [ expr ], reportNode);\r\n      }\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n      reportNode.range, type.toString(), stringType.toString()\r\n    );\r\n    this.currentType = stringType;\r\n    return this.module.unreachable();\r\n  }\r\n\r\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\r\n  makeAllocation(\r\n    classInstance: Class\r\n  ): ExpressionRef {\r\n    var program = this.program;\r\n    assert(classInstance.program == program);\r\n    var module = this.module;\r\n    var options = this.options;\r\n    this.currentType = classInstance.type;\r\n    if (classInstance.hasDecorator(DecoratorFlags.UNMANAGED)) {\r\n      let allocInstance = program.allocInstance;\r\n      this.compileFunction(allocInstance);\r\n      return module.call(allocInstance.internalName, [\r\n        options.isWasm64\r\n          ? module.i64(classInstance.nextMemoryOffset)\r\n          : module.i32(classInstance.nextMemoryOffset)\r\n      ], options.sizeTypeRef);\r\n    } else {\r\n      let newInstance = program.newInstance;\r\n      this.compileFunction(newInstance);\r\n      return module.call(newInstance.internalName, [\r\n        options.isWasm64\r\n          ? module.i64(classInstance.nextMemoryOffset)\r\n          : module.i32(classInstance.nextMemoryOffset),\r\n        module.i32(classInstance.id)\r\n      ], options.sizeTypeRef);\r\n    }\r\n  }\r\n\r\n  /** Makes a conditional allocation where `this` might not have been initialized yet. */\r\n  makeConditionalAllocation(\r\n    classInstance: Class,\r\n    thisIndex: i32\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var classType = classInstance.type;\r\n    var classTypeRef = classType.toRef();\r\n    assert(classTypeRef == this.options.sizeTypeRef);\r\n    return module.if(\r\n      module.unary(classTypeRef == TypeRef.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\r\n        module.local_get(thisIndex, classTypeRef)\r\n      ),\r\n      module.local_set(thisIndex,\r\n        this.makeAllocation(classInstance),\r\n        classInstance.type.isManaged\r\n      )\r\n    );\r\n  }\r\n\r\n  /** Makes the initializers for a class's fields within the constructor. */\r\n  makeFieldInitializationInConstructor(\r\n    /** Class being initialized. */\r\n    classInstance: Class,\r\n    /** Statements to append to also being returned. Created if omitted. */\r\n    stmts: ExpressionRef[] = []\r\n  ): ExpressionRef[] {\r\n    var members = classInstance.members;\r\n    if (!members) return stmts;\r\n\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var isInline = flow.isInline;\r\n    var thisLocalIndex = isInline ? flow.lookupLocal(CommonNames.this_)!.index : 0;\r\n    var sizeTypeRef = this.options.sizeTypeRef;\r\n    var nonParameterFields: Field[] | null = null;\r\n\r\n    // TODO: for (let member of members.values()) {\r\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n      let member = unchecked(_values[i]);\r\n      if (\r\n        member.kind != ElementKind.FIELD || // not a field\r\n        member.parent != classInstance      // inherited field\r\n      ) continue;\r\n      let field = <Field>member;\r\n      assert(!field.isAny(CommonFlags.CONST));\r\n      let fieldPrototype = field.prototype;\r\n      let parameterIndex = fieldPrototype.parameterIndex;\r\n\r\n      // Defer non-parameter fields until parameter fields are initialized\r\n      if (parameterIndex < 0) {\r\n        if (!nonParameterFields) nonParameterFields = new Array();\r\n        nonParameterFields.push(field);\r\n        continue;\r\n      }\r\n\r\n      // Initialize constructor parameter field\r\n      let fieldType = field.type;\r\n      let fieldTypeRef = fieldType.toRef();\r\n      assert(!fieldPrototype.initializerNode);\r\n      this.compileFieldSetter(field);\r\n      stmts.push(\r\n        module.call(field.internalSetterName, [\r\n          module.local_get(thisLocalIndex, sizeTypeRef),\r\n          module.local_get(\r\n            isInline\r\n              ? flow.lookupLocal(field.name)!.index\r\n              : 1 + parameterIndex, // `this` is local 0\r\n            fieldTypeRef\r\n          )\r\n        ], TypeRef.None)\r\n      );\r\n    }\r\n\r\n    // Initialize deferred non-parameter fields\r\n    if (nonParameterFields) {\r\n      for (let i = 0, k = nonParameterFields.length; i < k; ++i) {\r\n        let field = unchecked(nonParameterFields[i]);\r\n        let fieldType = field.type;\r\n        let fieldPrototype = field.prototype;\r\n        let initializerNode = fieldPrototype.initializerNode;\r\n        assert(fieldPrototype.parameterIndex < 0);\r\n        this.compileFieldSetter(field);\r\n        stmts.push(\r\n          module.call(field.internalSetterName, [\r\n            module.local_get(thisLocalIndex, sizeTypeRef),\r\n            initializerNode // use initializer if present, otherwise initialize with zero\r\n              ? this.compileExpression(initializerNode, fieldType, Constraints.CONV_IMPLICIT)\r\n              : this.makeZero(fieldType, fieldPrototype.declaration)\r\n          ], TypeRef.None)\r\n        );\r\n      }\r\n    }\r\n\r\n    this.currentType = Type.void;\r\n    return stmts;\r\n  }\r\n\r\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\r\n  makeAbort(\r\n    /** Message argument of type string, if any. */\r\n    message: Expression | null,\r\n    /** Code location to report when aborting. */\r\n    codeLocation: Node\r\n  ): ExpressionRef {\r\n    var program = this.program;\r\n    var abortInstance = program.abortInstance;\r\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\r\n\r\n    var stringInstance = program.stringInstance;\r\n    var messageArg: ExpressionRef;\r\n    if (message !== null) {\r\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.CONV_IMPLICIT);\r\n    } else {\r\n      messageArg = this.makeZero(stringInstance.type, codeLocation);\r\n    }\r\n\r\n    return this.makeStaticAbort(messageArg, codeLocation);\r\n  }\r\n\r\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\r\n  makeStaticAbort(\r\n    /** Message argument of type string. May be zero. */\r\n    messageExpr: ExpressionRef,\r\n    /** Code location to report when aborting. */\r\n    codeLocation: Node\r\n  ): ExpressionRef {\r\n    var program = this.program;\r\n    var module = this.module;\r\n    var abortInstance = program.abortInstance;\r\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\r\n\r\n    var filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\r\n    var range = codeLocation.range;\r\n    var source = range.source;\r\n    return module.block(null, [\r\n      module.call(\r\n        abortInstance.internalName, [\r\n          messageExpr,\r\n          filenameExpr,\r\n          module.i32(source.lineAt(range.start)),\r\n          module.i32(source.columnAt())\r\n        ],\r\n        TypeRef.None\r\n      ),\r\n      module.unreachable()\r\n    ]);\r\n  }\r\n\r\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\r\n  makeRuntimeNonNullCheck(\r\n    /** Expression being checked. */\r\n    expr: ExpressionRef,\r\n    /** Type of the expression. */\r\n    type: Type,\r\n    /** Report node. */\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var temp = flow.getTempLocal(type);\r\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\r\n    flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\r\n    expr = module.if(\r\n      module.local_tee(temp.index, expr, type.isManaged),\r\n      module.local_get(temp.index, type.toRef()),\r\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected null\"), reportNode) // TODO: throw\r\n    );\r\n    flow.freeTempLocal(temp);\r\n    this.currentType = type.nonNullableType;\r\n    return expr;\r\n  }\r\n\r\n  /** Makes a runtime upcast check, e.g. on `<Child>parent`. */\r\n  makeRuntimeUpcastCheck(\r\n    /** Expression being upcast. */\r\n    expr: ExpressionRef,\r\n    /** Type of the expression. */\r\n    type: Type,\r\n    /** Type casting to. */\r\n    toType: Type,\r\n    /** Report node. */\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\r\n    var module = this.module;\r\n    var flow = this.currentFlow;\r\n    var temp = flow.getTempLocal(type);\r\n    var instanceofInstance = this.program.instanceofInstance;\r\n    assert(this.compileFunction(instanceofInstance));\r\n    expr = module.if(\r\n      module.call(instanceofInstance.internalName, [\r\n        module.local_tee(temp.index, expr, type.isManaged),\r\n        module.i32(toType.classReference!.id)\r\n      ], TypeRef.I32),\r\n      module.local_get(temp.index, type.toRef()),\r\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\r\n    );\r\n    flow.freeTempLocal(temp);\r\n    this.currentType = toType;\r\n    return expr;\r\n  }\r\n}\r\n\r\n// helpers\r\n\r\nfunction mangleImportName(\r\n  element: Element,\r\n  declaration: DeclarationStatement\r\n): void {\r\n  // by default, use the file name as the module name\r\n  mangleImportName_moduleName = declaration.range.source.simplePath;\r\n  // and the internal name of the element within that file as the element name\r\n  mangleImportName_elementName = mangleInternalName(\r\n    element.name, element.parent, element.is(CommonFlags.INSTANCE), true\r\n  );\r\n  if (!element.hasDecorator(DecoratorFlags.EXTERNAL)) return;\r\n\r\n  var program = element.program;\r\n  var decorator = assert(findDecorator(DecoratorKind.EXTERNAL, declaration.decorators));\r\n  var args = decorator.args;\r\n  if (args !== null && args.length > 0) {\r\n    let arg = args[0];\r\n    // if one argument is given, override just the element name\r\n    // if two arguments are given, override both module and element name\r\n    if (arg.isLiteralKind(LiteralKind.STRING)) {\r\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\r\n      if (args.length >= 2) {\r\n        arg = args[1];\r\n        if (arg.isLiteralKind(LiteralKind.STRING)) {\r\n          mangleImportName_moduleName = mangleImportName_elementName;\r\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\r\n          if (args.length > 2) {\r\n            program.error(\r\n              DiagnosticCode.Expected_0_arguments_but_got_1,\r\n              decorator.range, \"2\", args.length.toString()\r\n            );\r\n          }\r\n        } else {\r\n          program.error(\r\n            DiagnosticCode.String_literal_expected,\r\n            arg.range\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      program.error(\r\n        DiagnosticCode.String_literal_expected,\r\n        arg.range\r\n      );\r\n    }\r\n  } else {\r\n    program.error(\r\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\r\n      decorator.range, \"1\", \"0\"\r\n    );\r\n  }\r\n}\r\n\r\nvar mangleImportName_moduleName: string;\r\nvar mangleImportName_elementName: string;\r\n","/**\r\n * @fileoverview Builders for various definitions describing a module.\r\n *\r\n * - TSDBuilder: Creates a TypeScript definition file (.d.ts)\r\n * - IDLBuilder: Creates a WebIDL interface definition (.webidl)\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  CommonFlags\r\n} from \"./common\";\r\n\r\nimport {\r\n  Program,\r\n  Element,\r\n  ElementKind,\r\n  Global,\r\n  Enum,\r\n  EnumValue,\r\n  Field,\r\n  Function,\r\n  FunctionPrototype,\r\n  Class,\r\n  ClassPrototype,\r\n  Namespace,\r\n  ConstantValueKind,\r\n  Interface,\r\n  Property,\r\n  PropertyPrototype,\r\n  File\r\n} from \"./program\";\r\n\r\nimport {\r\n  Type,\r\n  TypeKind\r\n} from \"./types\";\r\n\r\nimport {\r\n  SourceKind\r\n} from \"./ast\";\r\n\r\nimport {\r\n  indent\r\n} from \"./util\";\r\n\r\n/** Walker base class. */\r\nexport abstract class ExportsWalker {\r\n\r\n  /** Program reference. */\r\n  program: Program;\r\n  /** Whether to include private members */\r\n  includePrivate: bool;\r\n  /** Already seen elements. */\r\n  seen: Map<Element,string> = new Map();\r\n\r\n  /** Constructs a new Element walker. */\r\n  constructor(program: Program, includePrivate: bool = false) {\r\n    this.program = program;\r\n    this.includePrivate = includePrivate;\r\n  }\r\n\r\n  /** Walks all elements and calls the respective handlers. */\r\n  walk(): void {\r\n    // TODO: for (let file of this.program.filesByName.values()) {\r\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\r\n      let file = unchecked(_values[i]);\r\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.visitFile(file);\r\n    }\r\n  }\r\n\r\n  /** Visits all exported elements of a file. */\r\n  visitFile(file: File): void {\r\n    var exports = file.exports;\r\n    if (exports) {\r\n      // TODO: for (let [memberName, member] of exports) {\r\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\r\n        let memberName = unchecked(_keys[i]);\r\n        let member = assert(exports.get(memberName));\r\n        this.visitElement(memberName, member);\r\n      }\r\n    }\r\n    var exportsStar = file.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        let exportStar = unchecked(exportsStar[i]);\r\n        this.visitFile(exportStar);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Visits an element.*/\r\n  visitElement(name: string, element: Element): void {\r\n    if (element.is(CommonFlags.PRIVATE) && !this.includePrivate) return;\r\n    var seen = this.seen;\r\n    if (!element.is(CommonFlags.INSTANCE) && seen.has(element)) {\r\n      this.visitAlias(name, element, assert(seen.get(element)));\r\n      return;\r\n    }\r\n    seen.set(element, name);\r\n    switch (element.kind) {\r\n      case ElementKind.GLOBAL: {\r\n        if (element.is(CommonFlags.COMPILED)) this.visitGlobal(name, <Global>element);\r\n        break;\r\n      }\r\n      case ElementKind.ENUM: {\r\n        if (element.is(CommonFlags.COMPILED)) this.visitEnum(name, <Enum>element);\r\n        break;\r\n      }\r\n      case ElementKind.ENUMVALUE: break; // handled by visitEnum\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\r\n        break;\r\n      }\r\n      case ElementKind.CLASS_PROTOTYPE: {\r\n        this.visitClassInstances(name, <ClassPrototype>element);\r\n        break;\r\n      }\r\n      case ElementKind.FIELD: {\r\n        let fieldInstance = <Field>element;\r\n        if (fieldInstance.is(CommonFlags.COMPILED)) this.visitField(name, fieldInstance);\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyInstance = (<PropertyPrototype>element).instance;\r\n        if (!propertyInstance) break;\r\n        element = propertyInstance;\r\n        // fall-through\r\n      }\r\n      case ElementKind.PROPERTY: {\r\n        let propertyInstance = <Property>element;\r\n        let getterInstance = propertyInstance.getterInstance;\r\n        if (getterInstance) this.visitFunction(name, getterInstance);\r\n        let setterInstance = propertyInstance.setterInstance;\r\n        if (setterInstance) this.visitFunction(name, setterInstance);\r\n        break;\r\n      }\r\n      case ElementKind.NAMESPACE: {\r\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\r\n        break;\r\n      }\r\n      case ElementKind.TYPEDEFINITION: break;\r\n      default: assert(false);\r\n    }\r\n  }\r\n\r\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\r\n    var instances = element.instances;\r\n    if (instances) {\r\n      // TODO: for (let instance of instances.values()) {\r\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\r\n        let instance = unchecked(_values[i]);\r\n        if (instance.is(CommonFlags.COMPILED)) this.visitFunction(name, instance);\r\n      }\r\n    }\r\n  }\r\n\r\n  private visitClassInstances(name: string, element: ClassPrototype): void {\r\n    var instances = element.instances;\r\n    if (instances) {\r\n      // TODO: for (let instance of instances.values()) {\r\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\r\n        let instance = unchecked(_values[i]);\r\n        if (instance.is(CommonFlags.COMPILED)) this.visitClass(name, instance);\r\n      }\r\n    }\r\n  }\r\n\r\n  abstract visitGlobal(name: string, element: Global): void;\r\n  abstract visitEnum(name: string, element: Enum): void;\r\n  abstract visitFunction(name: string, element: Function): void;\r\n  abstract visitClass(name: string, element: Class): void;\r\n  abstract visitInterface(name: string, element: Interface): void;\r\n  abstract visitField(name: string, element: Field): void;\r\n  abstract visitNamespace(name: string, element: Element): void;\r\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\r\n}\r\n\r\n/** A WebIDL definitions builder. */\r\nexport class IDLBuilder extends ExportsWalker {\r\n\r\n  /** Builds WebIDL definitions for the specified program. */\r\n  static build(program: Program): string {\r\n    return new IDLBuilder(program).build();\r\n  }\r\n\r\n  private sb: string[] = [];\r\n  private indentLevel: i32 = 0;\r\n\r\n  /** Constructs a new WebIDL builder. */\r\n  constructor(program: Program, includePrivate: bool = false) {\r\n    super(program, includePrivate);\r\n  }\r\n\r\n  visitGlobal(name: string, element: Global): void {\r\n    var sb = this.sb;\r\n    var isConst = element.is(CommonFlags.INLINED);\r\n    indent(sb, this.indentLevel);\r\n    if (isConst) sb.push(\"const \");\r\n    sb.push(this.typeToString(element.type));\r\n    sb.push(\" \");\r\n    sb.push(name);\r\n    if (isConst) {\r\n      switch (element.constantValueKind) {\r\n        case ConstantValueKind.INTEGER: {\r\n          sb.push(\" = \");\r\n          sb.push(i64_to_string(element.constantIntegerValue));\r\n          break;\r\n        }\r\n        case ConstantValueKind.FLOAT: {\r\n          sb.push(\" = \");\r\n          sb.push(element.constantFloatValue.toString());\r\n          break;\r\n        }\r\n        default: assert(false);\r\n      }\r\n    }\r\n    sb.push(\";\\n\");\r\n  }\r\n\r\n  visitEnum(name: string, element: Enum): void {\r\n    var sb = this.sb;\r\n    indent(sb, this.indentLevel++);\r\n    sb.push(\"interface \");\r\n    sb.push(name);\r\n    sb.push(\" {\\n\");\r\n    var members = element.members;\r\n    if (members) {\r\n      // TODO: for (let [memberName, member] of members) {\r\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\r\n        let memberName = unchecked(_keys[i]);\r\n        let member = assert(members.get(memberName));\r\n        if (member.kind == ElementKind.ENUMVALUE) {\r\n          let enumValue = <EnumValue>member;\r\n          let isConst = enumValue.is(CommonFlags.INLINED);\r\n          indent(sb, this.indentLevel);\r\n          if (isConst) sb.push(\"const \");\r\n          else sb.push(\"readonly \");\r\n          sb.push(\"unsigned long \");\r\n          sb.push(memberName);\r\n          if (isConst) {\r\n            sb.push(\" = \");\r\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\r\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\r\n          }\r\n          sb.push(\";\\n\");\r\n        }\r\n      }\r\n      // TODO: for (let member of members.values()) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        if (member.kind != ElementKind.ENUMVALUE) this.visitElement(member.name, member);\r\n      }\r\n    }\r\n    indent(sb, --this.indentLevel);\r\n    sb.push(\"}\\n\");\r\n  }\r\n\r\n  visitFunction(name: string, element: Function): void {\r\n    var sb = this.sb;\r\n    var signature = element.signature;\r\n    indent(sb, this.indentLevel);\r\n    sb.push(this.typeToString(signature.returnType));\r\n    sb.push(\" \");\r\n    sb.push(name);\r\n    sb.push(\"(\");\r\n    var parameters = signature.parameterTypes;\r\n    var numParameters = parameters.length;\r\n    // var requiredParameters = signature.requiredParameters;\r\n    for (let i = 0; i < numParameters; ++i) {\r\n      if (i) sb.push(\", \");\r\n      // if (i >= requiredParameters) sb.push(\"optional \");\r\n      sb.push(this.typeToString(parameters[i]));\r\n      sb.push(\" \");\r\n      sb.push(element.getParameterName(i));\r\n    }\r\n    sb.push(\");\\n\");\r\n    var members = element.members;\r\n    if (members !== null && members.size > 0) {\r\n      indent(sb, this.indentLevel);\r\n      sb.push(\"interface \");\r\n      sb.push(element.name);\r\n      sb.push(\" {\\n\");\r\n      // TODO: for (let member of members.values()) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        this.visitElement(member.name, member);\r\n      }\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\\n\");\r\n    }\r\n  }\r\n\r\n  visitClass(name: string, element: Class): void {\r\n    var sb = this.sb;\r\n    indent(sb, this.indentLevel++);\r\n    sb.push(\"interface \");\r\n    sb.push(name);\r\n    sb.push(\" {\\n\");\r\n    // TODO\r\n    indent(sb, --this.indentLevel);\r\n    sb.push(\"}\\n\");\r\n  }\r\n\r\n  visitInterface(name: string, element: Interface): void {\r\n    this.visitClass(name, element);\r\n  }\r\n\r\n  visitField(name: string, element: Field): void {\r\n    // TODO\r\n  }\r\n\r\n  visitNamespace(name: string, element: Namespace): void {\r\n    var sb = this.sb;\r\n    indent(sb, this.indentLevel++);\r\n    sb.push(\"interface \");\r\n    sb.push(name);\r\n    sb.push(\" {\\n\");\r\n    var members = element.members;\r\n    if (members) {\r\n      // TODO: for (let member of members.values()) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        this.visitElement(member.name, member);\r\n      }\r\n    }\r\n    indent(sb, --this.indentLevel);\r\n    sb.push(\"}\\n\");\r\n  }\r\n\r\n  visitAlias(name: string, element: Element, originalName: string): void {\r\n    // TODO\r\n  }\r\n\r\n  typeToString(type: Type): string {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return \"byte\";\r\n      case TypeKind.I16: return \"short\";\r\n      case TypeKind.I32: return \"long\";\r\n      case TypeKind.I64: return \"long long\";\r\n      case TypeKind.ISIZE: return this.program.options.isWasm64 ? \"long long\" : \"long\";\r\n      case TypeKind.U8: return \"octet\";\r\n      case TypeKind.U16: return \"unsigned short\";\r\n      case TypeKind.U32: return \"unsigned long\";\r\n        // ^ TODO: function types\r\n      case TypeKind.U64: return \"unsigned long long\";\r\n      case TypeKind.USIZE: return this.program.options.isWasm64 ? \"unsigned long long\" : \"unsigned long\";\r\n        // ^ TODO: class types\r\n      case TypeKind.BOOL: return \"boolean\";\r\n      case TypeKind.F32: return \"unrestricted float\";\r\n      case TypeKind.F64: return \"unrestricted double\";\r\n      case TypeKind.VOID: return \"void\";\r\n      default: {\r\n        assert(false);\r\n        return \"\";\r\n      }\r\n    }\r\n  }\r\n\r\n  build(): string {\r\n    var sb = this.sb;\r\n    sb.push(\"interface ASModule {\\n\");\r\n    ++this.indentLevel;\r\n    this.walk();\r\n    --this.indentLevel;\r\n    sb.push(\"}\\n\");\r\n    return sb.join(\"\");\r\n  }\r\n}\r\n\r\n/** A TypeScript definitions builder. */\r\nexport class TSDBuilder extends ExportsWalker {\r\n\r\n  /** Builds TypeScript definitions for the specified program. */\r\n  static build(program: Program): string {\r\n    return new TSDBuilder(program).build();\r\n  }\r\n\r\n  private sb: string[] = [];\r\n  private indentLevel: i32 = 0;\r\n\r\n  /** Constructs a new WebIDL builder. */\r\n  constructor(program: Program, includePrivate: bool = false) {\r\n    super(program, includePrivate);\r\n  }\r\n\r\n  visitGlobal(name: string, element: Global): void {\r\n    var sb = this.sb;\r\n    var isConst = element.is(CommonFlags.INLINED);\r\n    indent(sb, this.indentLevel);\r\n    if (element.is(CommonFlags.STATIC)) {\r\n      if (isConst) sb.push(\"static readonly \");\r\n      else sb.push(\"static \");\r\n    } else {\r\n      if (isConst) sb.push(\"export const \");\r\n      else sb.push(\"export var \");\r\n    }\r\n    sb.push(name);\r\n    sb.push(\": \");\r\n    sb.push(this.typeToString(element.type));\r\n    sb.push(\";\\n\");\r\n    this.visitNamespace(name, element);\r\n  }\r\n\r\n  visitEnum(name: string, element: Enum): void {\r\n    var sb = this.sb;\r\n    indent(sb, this.indentLevel++);\r\n    sb.push(\"export \");\r\n    if (element.is(CommonFlags.CONST)) sb.push(\"const \");\r\n    sb.push(\"enum \");\r\n    sb.push(name);\r\n    sb.push(\" {\\n\");\r\n    var members = element.members;\r\n    var remainingMembers = 0;\r\n    if (members) {\r\n      remainingMembers = members.size;\r\n      // TODO: for (let [memberName, member] of members) {\r\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\r\n        let memberName = unchecked(_keys[i]);\r\n        let member = assert(members.get(memberName));\r\n        if (member.kind == ElementKind.ENUMVALUE) {\r\n          let enumValue = <EnumValue>member;\r\n          indent(sb, this.indentLevel);\r\n          sb.push(memberName);\r\n          if (member.is(CommonFlags.INLINED)) {\r\n            sb.push(\" = \");\r\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\r\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\r\n          }\r\n          sb.push(\",\\n\");\r\n          --remainingMembers;\r\n        }\r\n      }\r\n    }\r\n    indent(sb, --this.indentLevel);\r\n    sb.push(\"}\\n\");\r\n    if (remainingMembers) this.visitNamespace(name, element);\r\n  }\r\n\r\n  visitFunction(name: string, element: Function): void {\r\n    if (element.isAny(CommonFlags.PRIVATE)) return;\r\n    var sb = this.sb;\r\n    var signature = element.signature;\r\n    indent(sb, this.indentLevel);\r\n    if (!element.isAny(CommonFlags.STATIC | CommonFlags.INSTANCE)) {\r\n      sb.push(\"export function \");\r\n    } else {\r\n      if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\r\n      if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\r\n      if (element.is(CommonFlags.GET)) sb.push(\"get \");\r\n      else if (element.is(CommonFlags.SET)) sb.push(\"set \");\r\n    }\r\n    sb.push(name);\r\n    sb.push(\"(\");\r\n    var parameters = signature.parameterTypes;\r\n    var numParameters = parameters.length;\r\n    var requiredParameters = signature.requiredParameters;\r\n    for (let i = 0; i < numParameters; ++i) {\r\n      if (i) sb.push(\", \");\r\n      sb.push(element.getParameterName(i));\r\n      if (i >= requiredParameters) sb.push(\"?\");\r\n      sb.push(\": \");\r\n      sb.push(this.typeToString(parameters[i]));\r\n    }\r\n    if (element.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)) {\r\n      sb.push(\")\");\r\n    } else {\r\n      sb.push(\"): \");\r\n      sb.push(this.typeToString(signature.returnType));\r\n    }\r\n    sb.push(\";\\n\");\r\n    this.visitNamespace(name, element);\r\n  }\r\n\r\n  visitClass(name: string, element: Class): void {\r\n    var sb = this.sb;\r\n    var isInterface = element.kind == ElementKind.INTERFACE;\r\n    indent(sb, this.indentLevel++);\r\n    if (isInterface) {\r\n      sb.push(\"export interface \");\r\n    } else {\r\n      sb.push(\"export \");\r\n      if (element.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\r\n      sb.push(\"class \");\r\n    }\r\n    sb.push(name);\r\n    var base = element.base;\r\n    if (base !== null && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {\r\n      sb.push(\" extends \");\r\n      let extendsNode = assert(element.prototype.extendsNode);\r\n      sb.push(extendsNode.name.identifier.text); // TODO: fqn?\r\n    }\r\n    sb.push(\" {\\n\");\r\n    if (!isInterface) {\r\n      indent(sb, this.indentLevel);\r\n      sb.push(\"static wrap(ptr: usize): \");\r\n      sb.push(name);\r\n      sb.push(\";\\n\");\r\n      indent(sb, this.indentLevel);\r\n      sb.push(\"valueOf(): usize;\\n\");\r\n    }\r\n    var staticMembers = element.prototype.members;\r\n    if (staticMembers) {\r\n      // TODO: for (let member of staticMembers.values()) {\r\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        this.visitElement(member.name, member);\r\n      }\r\n    }\r\n    var instanceMembers = element.members;\r\n    if (instanceMembers) {\r\n      // TODO: for (let member of instanceMembers.values()) {\r\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        if (member.parent == element) { // own member\r\n          this.visitElement(member.name, member);\r\n        }\r\n      }\r\n    }\r\n    indent(sb, --this.indentLevel);\r\n    sb.push(\"}\\n\");\r\n  }\r\n\r\n  visitInterface(name: string, element: Interface): void {\r\n    this.visitClass(name, element);\r\n  }\r\n\r\n  visitField(name: string, element: Field): void {\r\n    if (element.is(CommonFlags.PRIVATE)) return;\r\n    var sb = this.sb;\r\n    indent(sb, this.indentLevel);\r\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\r\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\r\n    if (element.is(CommonFlags.READONLY)) sb.push(\"readonly \");\r\n    sb.push(name);\r\n    sb.push(\": \");\r\n    sb.push(this.typeToString(element.type));\r\n    sb.push(\";\\n\");\r\n  }\r\n\r\n  visitNamespace(name: string, element: Element): void {\r\n    var members = element.members;\r\n    if (members !== null && members.size > 0) {\r\n      let sb = this.sb;\r\n      indent(sb, this.indentLevel++);\r\n      sb.push(\"export namespace \");\r\n      sb.push(name);\r\n      sb.push(\" {\\n\");\r\n      // TODO: for (let member of members.values()) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        this.visitElement(member.name, member);\r\n      }\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\\n\");\r\n    }\r\n  }\r\n\r\n  visitAlias(name: string, element: Element, originalName: string): void {\r\n    var sb = this.sb;\r\n    indent(sb, this.indentLevel);\r\n    sb.push(\"export const \");\r\n    sb.push(name);\r\n    sb.push(\": typeof \");\r\n    sb.push(originalName);\r\n    sb.push(\";\\n\");\r\n  }\r\n\r\n  typeToString(type: Type): string {\r\n    switch (type.kind) {\r\n      case TypeKind.I8: return \"i8\";\r\n      case TypeKind.I16: return \"i16\";\r\n      case TypeKind.I32: return \"i32\";\r\n      case TypeKind.I64: return \"i64\";\r\n      case TypeKind.ISIZE: return \"isize\";\r\n      case TypeKind.U8: return \"u8\";\r\n      case TypeKind.U16: return \"u16\";\r\n      case TypeKind.U32: return \"u32\";\r\n        // ^ TODO: function types\r\n      case TypeKind.U64: return \"u64\";\r\n      case TypeKind.USIZE: return \"usize\";\r\n        // ^ TODO: class types\r\n      case TypeKind.BOOL: return \"bool\";\r\n      case TypeKind.F32: return \"f32\";\r\n      case TypeKind.F64: return \"f64\";\r\n      case TypeKind.V128: return \"v128\";\r\n      case TypeKind.VOID: return \"void\";\r\n      case TypeKind.FUNCREF: return \"funcref\";\r\n      case TypeKind.EXTERNREF: return \"externref\";\r\n      case TypeKind.ANYREF: return \"anyref\";\r\n      case TypeKind.EQREF: return \"eqref\";\r\n      case TypeKind.I31REF: return \"i31ref\";\r\n      case TypeKind.DATAREF: return \"dataref\";\r\n      default: {\r\n        assert(false);\r\n        return \"any\";\r\n      }\r\n    }\r\n  }\r\n\r\n  build(): string {\r\n    var sb = this.sb;\r\n    var options = this.program.options;\r\n    sb.push(\"type i8 = number;\\n\");\r\n    sb.push(\"type i16 = number;\\n\");\r\n    sb.push(\"type i32 = number;\\n\");\r\n    sb.push(\"type i64 = bigint;\\n\");\r\n    if (options.isWasm64) {\r\n      sb.push(\"type isize = bigint;\\n\");\r\n    } else {\r\n      sb.push(\"type isize = number;\\n\");\r\n    }\r\n    sb.push(\"type u8 = number;\\n\");\r\n    sb.push(\"type u16 = number;\\n\");\r\n    sb.push(\"type u32 = number;\\n\");\r\n    sb.push(\"type u64 = bigint;\\n\");\r\n    if (options.isWasm64) {\r\n      sb.push(\"type usize = bigint;\\n\");\r\n    } else {\r\n      sb.push(\"type usize = number;\\n\");\r\n    }\r\n    sb.push(\"type f32 = number;\\n\");\r\n    sb.push(\"type f64 = number;\\n\");\r\n    sb.push(\"type bool = boolean | number;\\n\");\r\n    this.walk();\r\n    if (options.exportMemory) {\r\n      sb.push(\"export const memory: WebAssembly.Memory;\\n\");\r\n    }\r\n    if (options.exportTable) {\r\n      sb.push(\"export const table: WebAssembly.Table;\\n\");\r\n    }\r\n    if (options.explicitStart) {\r\n      sb.push(\"export function _start(): void;\\n\");\r\n    }\r\n    if (options.exportRuntime) {\r\n      sb.push(\"export function __new(size: usize, id: u32): usize;\\n\");\r\n      sb.push(\"export function __pin(ptr: usize): usize;\\n\");\r\n      sb.push(\"export function __unpin(ptr: usize): void;\\n\");\r\n      sb.push(\"export function __collect(): void;\\n\");\r\n      sb.push(\"export const __rtti_base: usize;\\n\");\r\n    }\r\n    sb.push(\"export const __setArgumentsLength: ((n: i32) => void) | undefined;\\n\");\r\n    return this.sb.join(\"\");\r\n  }\r\n}\r\n\r\n// helpers\r\n\r\n/** Tests if a namespace-like element has at least one compiled member. */\r\nfunction hasCompiledMember(element: Element): bool {\r\n  var members = element.members;\r\n  if (members) {\r\n    // TODO: for (let member of members.values()) {\r\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n      let member = unchecked(_values[i]);\r\n      switch (member.kind) {\r\n        case ElementKind.FUNCTION_PROTOTYPE: {\r\n          let instances = (<FunctionPrototype>member).instances;\r\n          if (instances) {\r\n            // TODO: for (let instance of instances.values()) {\r\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\r\n              let instance = unchecked(_values[j]);\r\n              if (instance.is(CommonFlags.COMPILED)) return true;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case ElementKind.CLASS_PROTOTYPE: {\r\n          let instances = (<ClassPrototype>member).instances;\r\n          if (instances) {\r\n            // TODO: for (let instance of instances.values()) {\r\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\r\n              let instance = unchecked(_values[j]);\r\n              if (instance.is(CommonFlags.COMPILED)) return true;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        default: {\r\n          if (member.is(CommonFlags.COMPILED) || hasCompiledMember(member)) return true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","/**\r\n * @fileoverview Generated from diagnosticsMessages.json. Do not edit.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** Enum of available diagnostic codes. */\r\nexport enum DiagnosticCode {\r\n  Not_implemented_0 = 100,\r\n  Operation_is_unsafe = 101,\r\n  User_defined_0 = 102,\r\n  Feature_0_is_not_enabled = 103,\r\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\r\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\r\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\r\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\r\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\r\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\r\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\r\n  Type_0_cannot_be_changed_to_type_1 = 202,\r\n  Operation_0_cannot_be_applied_to_type_1 = 203,\r\n  Type_0_cannot_be_nullable = 204,\r\n  Cannot_export_a_mutable_global = 205,\r\n  Mutable_value_cannot_be_inlined = 206,\r\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\r\n  Unmanaged_classes_cannot_implement_interfaces = 208,\r\n  Invalid_regular_expression_flags = 209,\r\n  Expression_is_never_null = 210,\r\n  Class_0_is_final_and_cannot_be_extended = 211,\r\n  Decorator_0_is_not_valid_here = 212,\r\n  Duplicate_decorator = 213,\r\n  Type_0_is_illegal_in_this_context = 214,\r\n  Optional_parameter_must_have_an_initializer = 215,\r\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\r\n  Function_0_cannot_be_inlined_into_itself = 217,\r\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\r\n  Optional_properties_are_not_supported = 219,\r\n  Expression_must_be_a_compile_time_constant = 220,\r\n  Type_0_is_not_a_function_index_or_function_reference = 221,\r\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\r\n  _0_must_be_a_power_of_two = 223,\r\n  _0_is_not_a_valid_operator = 224,\r\n  Expression_cannot_be_represented_by_a_type = 225,\r\n  Expression_resolves_to_unusual_type_0 = 226,\r\n  Array_literal_expected = 227,\r\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\r\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\r\n  _0_keyword_cannot_be_used_here = 230,\r\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\r\n  Property_0_is_always_assigned_before_being_used = 233,\r\n  Expression_refers_to_a_static_element_that_does_not_compile_to_a_value_at_runtime = 234,\r\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\r\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\r\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\r\n  Indexed_access_may_involve_bounds_checking = 904,\r\n  Explicitly_returning_constructor_drops_this_allocation = 905,\r\n  Unnecessary_definite_assignment = 906,\r\n  Exported_generic_function_or_class_has_no_concrete_instances = 907,\r\n  Unterminated_string_literal = 1002,\r\n  Identifier_expected = 1003,\r\n  _0_expected = 1005,\r\n  A_file_cannot_have_a_reference_to_itself = 1006,\r\n  Trailing_comma_not_allowed = 1009,\r\n  Unexpected_token = 1012,\r\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\r\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\r\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\r\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\r\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\r\n  _0_modifier_cannot_be_used_here = 1042,\r\n  A_rest_parameter_cannot_be_optional = 1047,\r\n  A_rest_parameter_cannot_have_an_initializer = 1048,\r\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\r\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\r\n  A_get_accessor_cannot_have_parameters = 1054,\r\n  Enum_member_must_have_initializer = 1061,\r\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\r\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\r\n  An_accessor_cannot_have_type_parameters = 1094,\r\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\r\n  Type_parameter_list_cannot_be_empty = 1098,\r\n  Type_argument_list_cannot_be_empty = 1099,\r\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\r\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\r\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\r\n  Expression_expected = 1109,\r\n  Type_expected = 1110,\r\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\r\n  Duplicate_label_0 = 1114,\r\n  An_export_assignment_cannot_have_modifiers = 1120,\r\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\r\n  Digit_expected = 1124,\r\n  Hexadecimal_digit_expected = 1125,\r\n  Unexpected_end_of_text = 1126,\r\n  Invalid_character = 1127,\r\n  _case_or_default_expected = 1130,\r\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\r\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\r\n  Type_argument_expected = 1140,\r\n  String_literal_expected = 1141,\r\n  Line_break_not_permitted_here = 1142,\r\n  Declaration_expected = 1146,\r\n  _const_declarations_must_be_initialized = 1155,\r\n  Unterminated_regular_expression_literal = 1161,\r\n  Interface_declaration_cannot_have_implements_clause = 1176,\r\n  Binary_digit_expected = 1177,\r\n  Octal_digit_expected = 1178,\r\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\r\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\r\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\r\n  Unterminated_Unicode_escape_sequence = 1199,\r\n  Decorators_are_not_valid_here = 1206,\r\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\r\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\r\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\r\n  A_class_may_only_extend_another_class = 1311,\r\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\r\n  An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = 1351,\r\n  Duplicate_identifier_0 = 2300,\r\n  Cannot_find_name_0 = 2304,\r\n  Module_0_has_no_exported_member_1 = 2305,\r\n  An_interface_can_only_extend_an_interface = 2312,\r\n  Generic_type_0_requires_1_type_argument_s = 2314,\r\n  Type_0_is_not_generic = 2315,\r\n  Type_0_is_not_assignable_to_type_1 = 2322,\r\n  Index_signature_is_missing_in_type_0 = 2329,\r\n  _this_cannot_be_referenced_in_current_location = 2332,\r\n  _this_cannot_be_referenced_in_constructor_arguments = 2333,\r\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\r\n  _super_cannot_be_referenced_in_constructor_arguments = 2336,\r\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\r\n  Property_0_does_not_exist_on_type_1 = 2339,\r\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\r\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\r\n  This_expression_is_not_constructable = 2351,\r\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\r\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\r\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\r\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\r\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\r\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\r\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\r\n  _get_and_set_accessor_must_have_the_same_type = 2380,\r\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\r\n  Constructor_implementation_is_missing = 2390,\r\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\r\n  Multiple_constructor_implementations_are_not_allowed = 2392,\r\n  Duplicate_function_implementation = 2393,\r\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\r\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\r\n  A_class_can_only_implement_an_interface = 2422,\r\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\r\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\r\n  Variable_0_used_before_its_declaration = 2448,\r\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\r\n  Type_0_has_no_property_1 = 2460,\r\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\r\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\r\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\r\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\r\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\r\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\r\n  Object_is_possibly_null = 2531,\r\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\r\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\r\n  Index_signature_in_type_0_only_permits_reading = 2542,\r\n  Expected_0_arguments_but_got_1 = 2554,\r\n  Expected_at_least_0_arguments_but_got_1 = 2555,\r\n  Expected_0_type_arguments_but_got_1 = 2558,\r\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\r\n  Property_0_is_used_before_being_assigned = 2565,\r\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\r\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\r\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\r\n  The_this_types_of_each_signature_are_incompatible = 2685,\r\n  Namespace_0_has_no_exported_member_1 = 2694,\r\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\r\n  Duplicate_property_0 = 2718,\r\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\r\n  Type_0_has_no_call_signatures = 2757,\r\n  File_0_not_found = 6054,\r\n  Numeric_separators_are_not_allowed_here = 6188,\r\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\r\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\r\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\r\n}\r\n\r\n/** Translates a diagnostic code to its respective string. */\r\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\r\n  switch (code) {\r\n    case 100: return \"Not implemented: {0}\";\r\n    case 101: return \"Operation is unsafe.\";\r\n    case 102: return \"User-defined: {0}\";\r\n    case 103: return \"Feature '{0}' is not enabled.\";\r\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\r\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\r\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\r\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\r\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\r\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\r\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\r\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\r\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\r\n    case 204: return \"Type '{0}' cannot be nullable.\";\r\n    case 205: return \"Cannot export a mutable global.\";\r\n    case 206: return \"Mutable value cannot be inlined.\";\r\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\r\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\r\n    case 209: return \"Invalid regular expression flags.\";\r\n    case 210: return \"Expression is never 'null'.\";\r\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\r\n    case 212: return \"Decorator '{0}' is not valid here.\";\r\n    case 213: return \"Duplicate decorator.\";\r\n    case 214: return \"Type '{0}' is illegal in this context.\";\r\n    case 215: return \"Optional parameter must have an initializer.\";\r\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\r\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\r\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\r\n    case 219: return \"Optional properties are not supported.\";\r\n    case 220: return \"Expression must be a compile-time constant.\";\r\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\r\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\r\n    case 223: return \"'{0}' must be a power of two.\";\r\n    case 224: return \"'{0}' is not a valid operator.\";\r\n    case 225: return \"Expression cannot be represented by a type.\";\r\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\r\n    case 227: return \"Array literal expected.\";\r\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\r\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\r\n    case 230: return \"'{0}' keyword cannot be used here.\";\r\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\r\n    case 233: return \"Property '{0}' is always assigned before being used.\";\r\n    case 234: return \"Expression refers to a static element that does not compile to a value at runtime.\";\r\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\r\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\r\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\r\n    case 904: return \"Indexed access may involve bounds checking.\";\r\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\r\n    case 906: return \"Unnecessary definite assignment.\";\r\n    case 907: return \"Exported generic function or class has no concrete instances.\";\r\n    case 1002: return \"Unterminated string literal.\";\r\n    case 1003: return \"Identifier expected.\";\r\n    case 1005: return \"'{0}' expected.\";\r\n    case 1006: return \"A file cannot have a reference to itself.\";\r\n    case 1009: return \"Trailing comma not allowed.\";\r\n    case 1012: return \"Unexpected token.\";\r\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\r\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\r\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\r\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\r\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\r\n    case 1042: return \"'{0}' modifier cannot be used here.\";\r\n    case 1047: return \"A rest parameter cannot be optional.\";\r\n    case 1048: return \"A rest parameter cannot have an initializer.\";\r\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\r\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\r\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\r\n    case 1061: return \"Enum member must have initializer.\";\r\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\r\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\r\n    case 1094: return \"An accessor cannot have type parameters.\";\r\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\r\n    case 1098: return \"Type parameter list cannot be empty.\";\r\n    case 1099: return \"Type argument list cannot be empty.\";\r\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\r\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\r\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\r\n    case 1109: return \"Expression expected.\";\r\n    case 1110: return \"Type expected.\";\r\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\r\n    case 1114: return \"Duplicate label '{0}'.\";\r\n    case 1120: return \"An export assignment cannot have modifiers.\";\r\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\r\n    case 1124: return \"Digit expected.\";\r\n    case 1125: return \"Hexadecimal digit expected.\";\r\n    case 1126: return \"Unexpected end of text.\";\r\n    case 1127: return \"Invalid character.\";\r\n    case 1130: return \"'case' or 'default' expected.\";\r\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\r\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\r\n    case 1140: return \"Type argument expected.\";\r\n    case 1141: return \"String literal expected.\";\r\n    case 1142: return \"Line break not permitted here.\";\r\n    case 1146: return \"Declaration expected.\";\r\n    case 1155: return \"'const' declarations must be initialized.\";\r\n    case 1161: return \"Unterminated regular expression literal.\";\r\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\r\n    case 1177: return \"Binary digit expected.\";\r\n    case 1178: return \"Octal digit expected.\";\r\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\r\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\r\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\r\n    case 1199: return \"Unterminated Unicode escape sequence.\";\r\n    case 1206: return \"Decorators are not valid here.\";\r\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\r\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\r\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\r\n    case 1311: return \"A class may only extend another class.\";\r\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\r\n    case 1351: return \"An identifier or keyword cannot immediately follow a numeric literal.\";\r\n    case 2300: return \"Duplicate identifier '{0}'.\";\r\n    case 2304: return \"Cannot find name '{0}'.\";\r\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\r\n    case 2312: return \"An interface can only extend an interface.\";\r\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\r\n    case 2315: return \"Type '{0}' is not generic.\";\r\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\r\n    case 2329: return \"Index signature is missing in type '{0}'.\";\r\n    case 2332: return \"'this' cannot be referenced in current location.\";\r\n    case 2333: return \"'this' cannot be referenced in constructor arguments.\";\r\n    case 2335: return \"'super' can only be referenced in a derived class.\";\r\n    case 2336: return \"'super' cannot be referenced in constructor arguments.\";\r\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\r\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\r\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\r\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\r\n    case 2351: return \"This expression is not constructable.\";\r\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\r\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\r\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\r\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\r\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\r\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\r\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\r\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\r\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\r\n    case 2390: return \"Constructor implementation is missing.\";\r\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\r\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\r\n    case 2393: return \"Duplicate function implementation.\";\r\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\r\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\r\n    case 2422: return \"A class can only implement an interface.\";\r\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\r\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\r\n    case 2448: return \"Variable '{0}' used before its declaration.\";\r\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\r\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\r\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\r\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\r\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\r\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\r\n    case 2511: return \"Cannot create an instance of an abstract class.\";\r\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\r\n    case 2531: return \"Object is possibly 'null'.\";\r\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\r\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\r\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\r\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\r\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\r\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\r\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\r\n    case 2565: return \"Property '{0}' is used before being assigned.\";\r\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\r\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\r\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\r\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\r\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\r\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\r\n    case 2718: return \"Duplicate property '{0}'.\";\r\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\r\n    case 2757: return \"Type '{0}' has no call signatures.\";\r\n    case 6054: return \"File '{0}' not found.\";\r\n    case 6188: return \"Numeric separators are not allowed here.\";\r\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\r\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\r\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\r\n    default: return \"\";\r\n  }\r\n}\r\n","/**\r\n * @fileoverview Shared diagnostic handling.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Range\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  Source\r\n} from \"./ast\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  diagnosticCodeToString\r\n} from \"./diagnosticMessages.generated\";\r\n\r\nimport {\r\n  isLineBreak,\r\n  COLOR_CYAN,\r\n  COLOR_YELLOW,\r\n  COLOR_RED,\r\n  COLOR_MAGENTA,\r\n  COLOR_RESET,\r\n  isColorsEnabled,\r\n  setColorsEnabled\r\n} from \"./util\";\r\n\r\nexport {\r\n  DiagnosticCode,\r\n  diagnosticCodeToString\r\n} from \"./diagnosticMessages.generated\";\r\n\r\n/** Indicates the category of a {@link DiagnosticMessage}. */\r\nexport enum DiagnosticCategory {\r\n  /** Overly pedantic message. */\r\n  PEDANTIC,\r\n  /** Informatory message. */\r\n  INFO,\r\n  /** Warning message. */\r\n  WARNING,\r\n  /** Error message. */\r\n  ERROR\r\n}\r\n\r\n/** Returns the string representation of the specified diagnostic category. */\r\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\r\n  switch (category) {\r\n    case DiagnosticCategory.PEDANTIC: return \"PEDANTIC\";\r\n    case DiagnosticCategory.INFO: return \"INFO\";\r\n    case DiagnosticCategory.WARNING: return \"WARNING\";\r\n    case DiagnosticCategory.ERROR: return \"ERROR\";\r\n    default: {\r\n      assert(false);\r\n      return \"\";\r\n    }\r\n  }\r\n}\r\n\r\n/** Returns the ANSI escape sequence for the specified category. */\r\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\r\n  switch (category) {\r\n    case DiagnosticCategory.PEDANTIC: return COLOR_MAGENTA;\r\n    case DiagnosticCategory.INFO: return COLOR_CYAN;\r\n    case DiagnosticCategory.WARNING: return COLOR_YELLOW;\r\n    case DiagnosticCategory.ERROR: return COLOR_RED;\r\n    default: {\r\n      assert(false);\r\n      return \"\";\r\n    }\r\n  }\r\n}\r\n\r\n/** Represents a diagnostic message. */\r\nexport class DiagnosticMessage {\r\n\r\n  /** Message code. */\r\n  code: i32;\r\n  /** Message category. */\r\n  category: DiagnosticCategory;\r\n  /** Message text. */\r\n  message: string;\r\n  /** Respective source range, if any. */\r\n  range: Range | null = null;\r\n  /** Related range, if any. */\r\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\r\n\r\n  /** Constructs a new diagnostic message. */\r\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\r\n    this.code = code;\r\n    this.category = category;\r\n    this.message = message;\r\n  }\r\n\r\n  /** Creates a new diagnostic message of the specified category. */\r\n  static create(\r\n    code: DiagnosticCode,\r\n    category: DiagnosticCategory,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): DiagnosticMessage {\r\n    var message = diagnosticCodeToString(code);\r\n    if (arg0 !== null) message = message.replace(\"{0}\", arg0);\r\n    if (arg1 !== null) message = message.replace(\"{1}\", arg1);\r\n    if (arg2 !== null) message = message.replace(\"{2}\", arg2);\r\n    return new DiagnosticMessage(code, category, message);\r\n  }\r\n\r\n  /** Tests if this message equals the specified. */\r\n  equals(other: DiagnosticMessage): bool {\r\n    if (this.code != other.code) return false;\r\n    var thisRange = this.range;\r\n    var otherRange = other.range;\r\n    if (thisRange) {\r\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\r\n    } else if (otherRange) {\r\n      return false;\r\n    }\r\n    var thisRelatedRange = this.relatedRange;\r\n    var otherRelatedRange = other.relatedRange;\r\n    if (thisRelatedRange) {\r\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\r\n    } else if (otherRange) {\r\n      return false;\r\n    }\r\n    return this.message == other.message;\r\n  }\r\n\r\n  /** Adds a source range to this message. */\r\n  withRange(range: Range): this {\r\n    this.range = range;\r\n    return this;\r\n  }\r\n\r\n  /** Adds a related source range to this message. */\r\n  withRelatedRange(range: Range): this {\r\n    this.relatedRange = range;\r\n    return this;\r\n  }\r\n\r\n  /** Converts this message to a string. */\r\n  toString(): string {\r\n    var range = this.range;\r\n    if (range) {\r\n      let source = range.source;\r\n      return (\r\n        diagnosticCategoryToString(this.category) +\r\n        \" \" +\r\n        this.code.toString() +\r\n        \": \\\"\" +\r\n        this.message +\r\n        \"\\\" in \" +\r\n        source.normalizedPath +\r\n        \"(\" +\r\n        source.lineAt(range.start).toString() +\r\n        \",\" +\r\n        source.columnAt().toString() +\r\n        \"+\" +\r\n        (range.end - range.start).toString() +\r\n        \")\"\r\n      );\r\n    }\r\n    return (\r\n      diagnosticCategoryToString(this.category) +\r\n      \" \" +\r\n      this.code.toString() +\r\n      \": \" +\r\n      this.message\r\n    );\r\n  }\r\n}\r\n\r\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\r\nexport function formatDiagnosticMessage(\r\n  message: DiagnosticMessage,\r\n  useColors: bool = false,\r\n  showContext: bool = false\r\n): string {\r\n  var wasColorsEnabled = setColorsEnabled(useColors);\r\n\r\n  // general information\r\n  var sb: string[] = [];\r\n  if (isColorsEnabled()) sb.push(diagnosticCategoryToColor(message.category));\r\n  sb.push(diagnosticCategoryToString(message.category));\r\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\r\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\r\n  sb.push(message.code.toString());\r\n  sb.push(\": \");\r\n  sb.push(message.message);\r\n\r\n  // include range information if available\r\n  var range = message.range;\r\n  if (range) {\r\n    let source = range.source;\r\n\r\n    // include context information if requested\r\n    if (showContext) {\r\n      sb.push(\"\\n\");\r\n      sb.push(formatDiagnosticContext(range));\r\n    }\r\n    sb.push(\"\\n\");\r\n    sb.push(\" in \");\r\n    sb.push(source.normalizedPath);\r\n    sb.push(\"(\");\r\n    sb.push(source.lineAt(range.start).toString());\r\n    sb.push(\",\");\r\n    sb.push(source.columnAt().toString());\r\n    sb.push(\")\");\r\n\r\n    let relatedRange = message.relatedRange;\r\n    if (relatedRange) {\r\n      let relatedSource = relatedRange.source;\r\n      if (showContext) {\r\n        sb.push(\"\\n\");\r\n        sb.push(formatDiagnosticContext(relatedRange));\r\n      }\r\n      sb.push(\"\\n\");\r\n      sb.push(\" in \");\r\n      sb.push(relatedSource.normalizedPath);\r\n      sb.push(\"(\");\r\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\r\n      sb.push(\",\");\r\n      sb.push(relatedSource.columnAt().toString());\r\n      sb.push(\")\");\r\n    }\r\n  }\r\n  setColorsEnabled(wasColorsEnabled);\r\n  return sb.join(\"\");\r\n}\r\n\r\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\r\nfunction formatDiagnosticContext(range: Range): string {\r\n  var text = range.source.text;\r\n  var len = text.length;\r\n  var start = range.start;\r\n  var end = range.end;\r\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\r\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\r\n  var sb: string[] = [\r\n    \"\\n \",\r\n    text.substring(start, end),\r\n    \"\\n \"\r\n  ];\r\n  while (start < range.start) {\r\n    sb.push(\" \");\r\n    start++;\r\n  }\r\n  if (isColorsEnabled()) sb.push(COLOR_RED);\r\n  if (range.start == range.end) {\r\n    sb.push(\"^\");\r\n  } else {\r\n    while (start++ < range.end) {\r\n      if (isLineBreak(text.charCodeAt(start))) {\r\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\r\n        break;\r\n      }\r\n      sb.push(\"~\");\r\n    }\r\n  }\r\n  if (isColorsEnabled()) sb.push(COLOR_RESET);\r\n  return sb.join(\"\");\r\n}\r\n\r\n/** Base class of all diagnostic emitters. */\r\nexport abstract class DiagnosticEmitter {\r\n\r\n  /** Diagnostic messages emitted so far. */\r\n  diagnostics: DiagnosticMessage[];\r\n  /** Diagnostic messages already seen, by range. */\r\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\r\n\r\n  /** Initializes this diagnostic emitter. */\r\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\r\n    if (!diagnostics) diagnostics = [];\r\n    this.diagnostics = diagnostics;\r\n  }\r\n\r\n  /** Emits a diagnostic message of the specified category. */\r\n  emitDiagnostic(\r\n    code: DiagnosticCode,\r\n    category: DiagnosticCategory,\r\n    range: Range | null,\r\n    relatedRange: Range | null,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\r\n    if (range) message = message.withRange(range);\r\n    if (relatedRange) message.relatedRange = relatedRange;\r\n    // It is possible that the same diagnostic is emitted twice, for example\r\n    // when compiling generics with different types or when recompiling a loop\r\n    // because our initial assumptions didn't hold. It is even possible to get\r\n    // multiple instances of the same range during parsing. Deduplicate these.\r\n    if (range) {\r\n      let seen = this.seen;\r\n      if (seen.has(range.source)) {\r\n        let seenInSource = assert(seen.get(range.source));\r\n        if (seenInSource.has(range.start)) {\r\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\r\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\r\n            if (seenMessagesAtPos[i].equals(message)) return;\r\n          }\r\n          seenMessagesAtPos.push(message);\r\n        } else {\r\n          seenInSource.set(range.start, [ message ]);\r\n        }\r\n      } else {\r\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\r\n        seenInSource.set(range.start, [ message ]);\r\n        seen.set(range.source, seenInSource);\r\n      }\r\n    }\r\n    this.diagnostics.push(message);\r\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\r\n    // console.log(<string>new Error(\"stack\").stack);\r\n  }\r\n\r\n  /** Emits an overly pedantic diagnostic message. */\r\n  pedantic(\r\n    code: DiagnosticCode,\r\n    range: Range | null,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, null, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits an overly pedantic diagnostic message with a related range. */\r\n  pedanticRelated(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    relatedRange: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, relatedRange, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits an informatory diagnostic message. */\r\n  info(\r\n    code: DiagnosticCode,\r\n    range: Range | null,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits an informatory diagnostic message with a related range. */\r\n  infoRelated(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    relatedRange: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits a warning diagnostic message. */\r\n  warning(\r\n    code: DiagnosticCode,\r\n    range: Range | null,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits a warning diagnostic message with a related range. */\r\n  warningRelated(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    relatedRange: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits an error diagnostic message. */\r\n  error(\r\n    code: DiagnosticCode,\r\n    range: Range | null,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);\r\n  }\r\n\r\n  /** Emits an error diagnostic message with a related range. */\r\n  errorRelated(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    relatedRange: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);\r\n  }\r\n}\r\n","/**\r\n * @fileoverview Abstract Syntax Tree extras.\r\n *\r\n * Provides serialization of the AssemblyScript AST back to it source form.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Node,\r\n  NodeKind,\r\n  Source,\r\n  ArrowKind,\r\n\r\n  TypeNode,\r\n  NamedTypeNode,\r\n  FunctionTypeNode,\r\n  TypeName,\r\n  TypeParameterNode,\r\n\r\n  Expression,\r\n  IdentifierExpression,\r\n  LiteralExpression,\r\n  LiteralKind,\r\n  FloatLiteralExpression,\r\n  IntegerLiteralExpression,\r\n  StringLiteralExpression,\r\n  TemplateLiteralExpression,\r\n  RegexpLiteralExpression,\r\n  ArrayLiteralExpression,\r\n  AssertionExpression,\r\n  AssertionKind,\r\n  BinaryExpression,\r\n  CallExpression,\r\n  CommaExpression,\r\n  ElementAccessExpression,\r\n  FunctionExpression,\r\n  NewExpression,\r\n  ParenthesizedExpression,\r\n  PropertyAccessExpression,\r\n  TernaryExpression,\r\n  UnaryPostfixExpression,\r\n  UnaryExpression,\r\n  UnaryPrefixExpression,\r\n  ClassExpression,\r\n  ObjectLiteralExpression,\r\n\r\n  BlockStatement,\r\n  BreakStatement,\r\n  ContinueStatement,\r\n  DoStatement,\r\n  EmptyStatement,\r\n  ExportImportStatement,\r\n  ExportStatement,\r\n  ExportDefaultStatement,\r\n  ExpressionStatement,\r\n  ForStatement,\r\n  ForOfStatement,\r\n  IfStatement,\r\n  ImportStatement,\r\n  InstanceOfExpression,\r\n  ReturnStatement,\r\n  SwitchStatement,\r\n  ThrowStatement,\r\n  TryStatement,\r\n  VariableStatement,\r\n  WhileStatement,\r\n\r\n  DeclarationStatement,\r\n  ClassDeclaration,\r\n  EnumDeclaration,\r\n  EnumValueDeclaration,\r\n  FieldDeclaration,\r\n  FunctionDeclaration,\r\n  ImportDeclaration,\r\n  InterfaceDeclaration,\r\n  MethodDeclaration,\r\n  NamespaceDeclaration,\r\n  TypeDeclaration,\r\n  VariableDeclaration,\r\n\r\n  DecoratorNode,\r\n  ParameterNode,\r\n  ParameterKind,\r\n  ExportMember,\r\n  SwitchCase,\r\n  IndexSignatureNode,\r\n\r\n  isTypeOmitted\r\n} from \"../ast\";\r\n\r\nimport {\r\n  operatorTokenToString\r\n} from \"../tokenizer\";\r\n\r\nimport {\r\n  CharCode,\r\n  indent\r\n} from \"../util\";\r\n\r\nimport {\r\n  CommonFlags\r\n} from \"../common\";\r\n\r\n/** An AST builder. */\r\nexport class ASTBuilder {\r\n\r\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\r\n  static build(node: Node): string {\r\n    var builder = new ASTBuilder();\r\n    builder.visitNode(node);\r\n    return builder.finish();\r\n  }\r\n\r\n  private sb: string[] = [];\r\n  private indentLevel: i32 = 0;\r\n\r\n  visitNode(node: Node): void {\r\n    switch (node.kind) {\r\n      case NodeKind.SOURCE: {\r\n        this.visitSource(<Source>node);\r\n        break;\r\n      }\r\n\r\n      // types\r\n\r\n      case NodeKind.NAMEDTYPE: {\r\n        this.visitNamedTypeNode(<NamedTypeNode>node);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTIONTYPE: {\r\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\r\n        break;\r\n      }\r\n      case NodeKind.TYPEPARAMETER: {\r\n        this.visitTypeParameter(<TypeParameterNode>node);\r\n        break;\r\n      }\r\n\r\n      // expressions\r\n\r\n      case NodeKind.FALSE:\r\n      case NodeKind.NULL:\r\n      case NodeKind.SUPER:\r\n      case NodeKind.THIS:\r\n      case NodeKind.TRUE:\r\n      case NodeKind.CONSTRUCTOR:\r\n      case NodeKind.IDENTIFIER: {\r\n        this.visitIdentifierExpression(<IdentifierExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.ASSERTION: {\r\n        this.visitAssertionExpression(<AssertionExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.BINARY: {\r\n        this.visitBinaryExpression(<BinaryExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.CALL: {\r\n        this.visitCallExpression(<CallExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.CLASS: {\r\n        this.visitClassExpression(<ClassExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.COMMA: {\r\n        this.visitCommaExpression(<CommaExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.ELEMENTACCESS: {\r\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTION: {\r\n        this.visitFunctionExpression(<FunctionExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.INSTANCEOF: {\r\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.LITERAL: {\r\n        this.visitLiteralExpression(<LiteralExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.NEW: {\r\n        this.visitNewExpression(<NewExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.PARENTHESIZED: {\r\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.PROPERTYACCESS: {\r\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.TERNARY: {\r\n        this.visitTernaryExpression(<TernaryExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.UNARYPOSTFIX: {\r\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.UNARYPREFIX: {\r\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\r\n        break;\r\n      }\r\n\r\n      // statements\r\n\r\n      case NodeKind.BLOCK: {\r\n        this.visitBlockStatement(<BlockStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.BREAK: {\r\n        this.visitBreakStatement(<BreakStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.CONTINUE: {\r\n        this.visitContinueStatement(<ContinueStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.DO: {\r\n        this.visitDoStatement(<DoStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.EMPTY: {\r\n        this.visitEmptyStatement(<EmptyStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.EXPORT: {\r\n        this.visitExportStatement(<ExportStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.EXPORTDEFAULT: {\r\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.EXPORTIMPORT: {\r\n        this.visitExportImportStatement(<ExportImportStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.EXPRESSION: {\r\n        this.visitExpressionStatement(<ExpressionStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.FOR: {\r\n        this.visitForStatement(<ForStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.FOROF: {\r\n        this.visitForOfStatement(<ForOfStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.IF: {\r\n        this.visitIfStatement(<IfStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.IMPORT: {\r\n        this.visitImportStatement(<ImportStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.RETURN: {\r\n        this.visitReturnStatement(<ReturnStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.SWITCH: {\r\n        this.visitSwitchStatement(<SwitchStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.THROW: {\r\n        this.visitThrowStatement(<ThrowStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.TRY: {\r\n        this.visitTryStatement(<TryStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.VARIABLE: {\r\n        this.visitVariableStatement(<VariableStatement>node);\r\n        break;\r\n      }\r\n      case NodeKind.WHILE: {\r\n        this.visitWhileStatement(<WhileStatement>node);\r\n        break;\r\n      }\r\n\r\n      // declaration statements\r\n\r\n      case NodeKind.CLASSDECLARATION: {\r\n        this.visitClassDeclaration(<ClassDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.ENUMDECLARATION: {\r\n        this.visitEnumDeclaration(<EnumDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.ENUMVALUEDECLARATION: {\r\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.FIELDDECLARATION: {\r\n        this.visitFieldDeclaration(<FieldDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTIONDECLARATION: {\r\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.IMPORTDECLARATION: {\r\n        this.visitImportDeclaration(<ImportDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.INTERFACEDECLARATION: {\r\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.METHODDECLARATION: {\r\n        this.visitMethodDeclaration(<MethodDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.NAMESPACEDECLARATION: {\r\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.TYPEDECLARATION: {\r\n        this.visitTypeDeclaration(<TypeDeclaration>node);\r\n        break;\r\n      }\r\n      case NodeKind.VARIABLEDECLARATION: {\r\n        this.visitVariableDeclaration(<VariableDeclaration>node);\r\n        break;\r\n      }\r\n\r\n      // other\r\n\r\n      case NodeKind.DECORATOR: {\r\n        this.serializeDecorator(<DecoratorNode>node);\r\n        break;\r\n      }\r\n      case NodeKind.EXPORTMEMBER: {\r\n        this.visitExportMember(<ExportMember>node);\r\n        break;\r\n      }\r\n      case NodeKind.PARAMETER: {\r\n        this.serializeParameter(<ParameterNode>node);\r\n        break;\r\n      }\r\n      case NodeKind.SWITCHCASE: {\r\n        this.visitSwitchCase(<SwitchCase>node);\r\n        break;\r\n      }\r\n      case NodeKind.INDEXSIGNATURE: {\r\n        this.visitIndexSignature(<IndexSignatureNode>node);\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n  }\r\n\r\n  visitSource(source: Source): void {\r\n    var statements = source.statements;\r\n    for (let i = 0, k = statements.length; i < k; ++i) {\r\n      this.visitNodeAndTerminate(statements[i]);\r\n    }\r\n  }\r\n\r\n  // types\r\n\r\n  visitTypeNode(node: TypeNode): void {\r\n    switch (node.kind) {\r\n      case NodeKind.NAMEDTYPE: {\r\n        this.visitNamedTypeNode(<NamedTypeNode>node);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTIONTYPE: {\r\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n  }\r\n\r\n  visitTypeName(node: TypeName): void {\r\n    this.visitIdentifierExpression(node.identifier);\r\n    var sb = this.sb;\r\n    var current = node.next;\r\n    while (current) {\r\n      sb.push(\".\");\r\n      this.visitIdentifierExpression(current.identifier);\r\n      current = current.next;\r\n    }\r\n  }\r\n\r\n  visitNamedTypeNode(node: NamedTypeNode): void {\r\n    this.visitTypeName(node.name);\r\n    var typeArguments = node.typeArguments;\r\n    if (typeArguments) {\r\n      let numTypeArguments = typeArguments.length;\r\n      let sb = this.sb;\r\n      if (numTypeArguments) {\r\n        sb.push(\"<\");\r\n        this.visitTypeNode(typeArguments[0]);\r\n        for (let i = 1; i < numTypeArguments; ++i) {\r\n          sb.push(\", \");\r\n          this.visitTypeNode(typeArguments[i]);\r\n        }\r\n        sb.push(\">\");\r\n      }\r\n      if (node.isNullable) sb.push(\" | null\");\r\n    }\r\n  }\r\n\r\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\r\n    var isNullable = node.isNullable;\r\n    var sb = this.sb;\r\n    sb.push(isNullable ? \"((\" : \"(\");\r\n    var explicitThisType = node.explicitThisType;\r\n    if (explicitThisType) {\r\n      sb.push(\"this: \");\r\n      this.visitTypeNode(explicitThisType);\r\n    }\r\n    var parameters = node.parameters;\r\n    var numParameters = parameters.length;\r\n    if (numParameters) {\r\n      if (explicitThisType) sb.push(\", \");\r\n      this.serializeParameter(parameters[0]);\r\n      for (let i = 1; i < numParameters; ++i) {\r\n        sb.push(\", \");\r\n        this.serializeParameter(parameters[i]);\r\n      }\r\n    }\r\n    var returnType = node.returnType;\r\n    if (returnType) {\r\n      sb.push(\") => \");\r\n      this.visitTypeNode(returnType);\r\n    } else {\r\n      sb.push(\") => void\");\r\n    }\r\n    if (isNullable) sb.push(\") | null\");\r\n  }\r\n\r\n  visitTypeParameter(node: TypeParameterNode): void {\r\n    this.visitIdentifierExpression(node.name);\r\n    var extendsType = node.extendsType;\r\n    if (extendsType) {\r\n      this.sb.push(\" extends \");\r\n      this.visitTypeNode(extendsType);\r\n    }\r\n    var defaultType = node.defaultType;\r\n    if (defaultType) {\r\n      this.sb.push(\"=\");\r\n      this.visitTypeNode(defaultType);\r\n    }\r\n  }\r\n\r\n  // expressions\r\n\r\n  visitIdentifierExpression(node: IdentifierExpression): void {\r\n    if (node.isQuoted) this.visitStringLiteral(node.text);\r\n    else this.sb.push(node.text);\r\n  }\r\n\r\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\r\n    var sb = this.sb;\r\n    sb.push(\"[\");\r\n    var elements = node.elementExpressions;\r\n    var numElements = elements.length;\r\n    if (numElements) {\r\n      let element = elements[0];\r\n      if (element) this.visitNode(element);\r\n      for (let i = 1; i < numElements; ++i) {\r\n        element = elements[i];\r\n        sb.push(\", \");\r\n        if (element) this.visitNode(element);\r\n      }\r\n    }\r\n    sb.push(\"]\");\r\n  }\r\n\r\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\r\n    var sb = this.sb;\r\n    var names = node.names;\r\n    var values = node.values;\r\n    var numElements = names.length;\r\n    assert(numElements == values.length);\r\n    if (numElements) {\r\n      sb.push(\"{\\n\");\r\n      indent(sb, ++this.indentLevel);\r\n      this.visitNode(names[0]);\r\n      sb.push(\": \");\r\n      this.visitNode(values[0]);\r\n      for (let i = 1; i < numElements; ++i) {\r\n        sb.push(\",\\n\");\r\n        indent(sb, this.indentLevel);\r\n        let name = names[i];\r\n        let value = values[i];\r\n        if (name === value) {\r\n          this.visitNode(name);\r\n        } else {\r\n          this.visitNode(name);\r\n          sb.push(\": \");\r\n          this.visitNode(value);\r\n        }\r\n      }\r\n      sb.push(\"\\n\");\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\");\r\n    } else {\r\n      sb.push(\"{}\");\r\n    }\r\n  }\r\n\r\n  visitAssertionExpression(node: AssertionExpression): void {\r\n    var sb = this.sb;\r\n    switch (node.assertionKind) {\r\n      case AssertionKind.PREFIX: {\r\n        sb.push(\"<\");\r\n        this.visitTypeNode(assert(node.toType));\r\n        sb.push(\">\");\r\n        this.visitNode(node.expression);\r\n        break;\r\n      }\r\n      case AssertionKind.AS: {\r\n        this.visitNode(node.expression);\r\n        sb.push(\" as \");\r\n        this.visitTypeNode(assert(node.toType));\r\n        break;\r\n      }\r\n      case AssertionKind.NONNULL: {\r\n        this.visitNode(node.expression);\r\n        sb.push(\"!\");\r\n        break;\r\n      }\r\n      case AssertionKind.CONST: {\r\n        this.visitNode(node.expression);\r\n        sb.push(\" as const\");\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n  }\r\n\r\n  visitBinaryExpression(node: BinaryExpression): void {\r\n    var sb = this.sb;\r\n    this.visitNode(node.left);\r\n    sb.push(\" \");\r\n    sb.push(operatorTokenToString(node.operator));\r\n    sb.push(\" \");\r\n    this.visitNode(node.right);\r\n  }\r\n\r\n  visitCallExpression(node: CallExpression): void {\r\n    this.visitNode(node.expression);\r\n    this.visitArguments(node.typeArguments, node.args);\r\n  }\r\n\r\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\r\n    var sb = this.sb;\r\n    if (typeArguments) {\r\n      let numTypeArguments = typeArguments.length;\r\n      if (numTypeArguments) {\r\n        sb.push(\"<\");\r\n        this.visitTypeNode(typeArguments[0]);\r\n        for (let i = 1; i < numTypeArguments; ++i) {\r\n          sb.push(\", \");\r\n          this.visitTypeNode(typeArguments[i]);\r\n        }\r\n        sb.push(\">(\");\r\n      }\r\n    } else {\r\n      sb.push(\"(\");\r\n    }\r\n    var numArgs = args.length;\r\n    if (numArgs) {\r\n      this.visitNode(args[0]);\r\n      for (let i = 1; i < numArgs; ++i) {\r\n        sb.push(\", \");\r\n        this.visitNode(args[i]);\r\n      }\r\n    }\r\n    sb.push(\")\");\r\n  }\r\n\r\n  visitClassExpression(node: ClassExpression): void {\r\n    var declaration = node.declaration;\r\n    this.visitClassDeclaration(declaration);\r\n  }\r\n\r\n  visitCommaExpression(node: CommaExpression): void {\r\n    var expressions = node.expressions;\r\n    var numExpressions = assert(expressions.length);\r\n    this.visitNode(expressions[0]);\r\n    var sb = this.sb;\r\n    for (let i = 1; i < numExpressions; ++i) {\r\n      sb.push(\",\");\r\n      this.visitNode(expressions[i]);\r\n    }\r\n  }\r\n\r\n  visitElementAccessExpression(node: ElementAccessExpression): void {\r\n    var sb = this.sb;\r\n    this.visitNode(node.expression);\r\n    sb.push(\"[\");\r\n    this.visitNode(node.elementExpression);\r\n    sb.push(\"]\");\r\n  }\r\n\r\n  visitFunctionExpression(node: FunctionExpression): void {\r\n    var declaration = node.declaration;\r\n    if (!declaration.arrowKind) {\r\n      if (declaration.name.text.length) {\r\n        this.sb.push(\"function \");\r\n      } else {\r\n        this.sb.push(\"function\");\r\n      }\r\n    } else {\r\n      assert(declaration.name.text.length == 0);\r\n    }\r\n    this.visitFunctionCommon(declaration);\r\n  }\r\n\r\n  visitLiteralExpression(node: LiteralExpression): void {\r\n    switch (node.literalKind) {\r\n      case LiteralKind.FLOAT: {\r\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\r\n        break;\r\n      }\r\n      case LiteralKind.INTEGER: {\r\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\r\n        break;\r\n      }\r\n      case LiteralKind.STRING: {\r\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\r\n        break;\r\n      }\r\n      case LiteralKind.TEMPLATE: {\r\n        this.visitTemplateLiteralExpression(<TemplateLiteralExpression>node);\r\n        break;\r\n      }\r\n      case LiteralKind.REGEXP: {\r\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\r\n        break;\r\n      }\r\n      case LiteralKind.ARRAY: {\r\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\r\n        break;\r\n      }\r\n      case LiteralKind.OBJECT: {\r\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\r\n        break;\r\n      }\r\n      default: {\r\n        assert(false);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\r\n    this.sb.push(node.value.toString());\r\n  }\r\n\r\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\r\n    this.visitNode(node.expression);\r\n    this.sb.push(\" instanceof \");\r\n    this.visitTypeNode(node.isType);\r\n  }\r\n\r\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\r\n    this.sb.push(i64_to_string(node.value));\r\n  }\r\n\r\n  visitStringLiteral(str: string): void {\r\n    var sb = this.sb;\r\n    sb.push(\"\\\"\");\r\n    this.visitRawString(str, CharCode.DOUBLEQUOTE);\r\n    sb.push(\"\\\"\");\r\n  }\r\n\r\n  private visitRawString(str: string, quote: CharCode): void {\r\n    var sb = this.sb;\r\n    var off = 0;\r\n    var i = 0;\r\n    for (let k = str.length; i < k;) {\r\n      switch (str.charCodeAt(i)) {\r\n        case CharCode.NULL: {\r\n          if (i > off) sb.push(str.substring(off, off = i + 1));\r\n          sb.push(\"\\\\0\");\r\n          off = ++i;\r\n          break;\r\n        }\r\n        case CharCode.BACKSPACE: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          off = ++i;\r\n          sb.push(\"\\\\b\");\r\n          break;\r\n        }\r\n        case CharCode.TAB: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          off = ++i;\r\n          sb.push(\"\\\\t\");\r\n          break;\r\n        }\r\n        case CharCode.LINEFEED: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          off = ++i;\r\n          sb.push(\"\\\\n\");\r\n          break;\r\n        }\r\n        case CharCode.VERTICALTAB: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          off = ++i;\r\n          sb.push(\"\\\\v\");\r\n          break;\r\n        }\r\n        case CharCode.FORMFEED: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          off = ++i;\r\n          sb.push(\"\\\\f\");\r\n          break;\r\n        }\r\n        case CharCode.CARRIAGERETURN: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          sb.push(\"\\\\r\");\r\n          off = ++i;\r\n          break;\r\n        }\r\n        case CharCode.DOUBLEQUOTE: {\r\n          if (quote == CharCode.DOUBLEQUOTE) {\r\n            if (i > off) sb.push(str.substring(off, i));\r\n            sb.push(\"\\\\\\\"\");\r\n            off = ++i;\r\n          } else {\r\n            ++i;\r\n          }\r\n          break;\r\n        }\r\n        case CharCode.SINGLEQUOTE: {\r\n          if (quote == CharCode.SINGLEQUOTE) {\r\n            if (i > off) sb.push(str.substring(off, i));\r\n            sb.push(\"\\\\'\");\r\n            off = ++i;\r\n          } else {\r\n            ++i;\r\n          }\r\n          break;\r\n        }\r\n        case CharCode.BACKSLASH: {\r\n          if (i > off) sb.push(str.substring(off, i));\r\n          sb.push(\"\\\\\\\\\");\r\n          off = ++i;\r\n          break;\r\n        }\r\n        case CharCode.BACKTICK: {\r\n          if (quote == CharCode.BACKTICK) {\r\n            if (i > off) sb.push(str.substring(off, i));\r\n            sb.push(\"\\\\`\");\r\n            off = ++i;\r\n          } else {\r\n            ++i;\r\n          }\r\n          break;\r\n        }\r\n        default: {\r\n          ++i;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (i > off) sb.push(str.substring(off, i));\r\n  }\r\n\r\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\r\n    this.visitStringLiteral(node.value);\r\n  }\r\n\r\n  visitTemplateLiteralExpression(node: TemplateLiteralExpression): void {\r\n    var sb = this.sb;\r\n    var tag = node.tag;\r\n    var parts = node.parts;\r\n    var expressions = node.expressions;\r\n    if (tag) this.visitNode(tag);\r\n    sb.push(\"`\");\r\n    this.visitRawString(parts[0], CharCode.BACKTICK);\r\n    assert(parts.length == expressions.length + 1);\r\n    for (let i = 0, k = expressions.length; i < k; ++i) {\r\n      sb.push(\"${\");\r\n      this.visitNode(expressions[i]);\r\n      sb.push(\"}\");\r\n      this.visitRawString(parts[i + 1], CharCode.BACKTICK);\r\n    }\r\n    sb.push(\"`\");\r\n  }\r\n\r\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\r\n    var sb = this.sb;\r\n    sb.push(\"/\");\r\n    sb.push(node.pattern);\r\n    sb.push(\"/\");\r\n    sb.push(node.patternFlags);\r\n  }\r\n\r\n  visitNewExpression(node: NewExpression): void {\r\n    this.sb.push(\"new \");\r\n    this.visitTypeName(node.typeName);\r\n    this.visitArguments(node.typeArguments, node.args);\r\n  }\r\n\r\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\r\n    var sb = this.sb;\r\n    sb.push(\"(\");\r\n    this.visitNode(node.expression);\r\n    sb.push(\")\");\r\n  }\r\n\r\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\r\n    this.visitNode(node.expression);\r\n    this.sb.push(\".\");\r\n    this.visitIdentifierExpression(node.property);\r\n  }\r\n\r\n  visitTernaryExpression(node: TernaryExpression): void {\r\n    var sb = this.sb;\r\n    this.visitNode(node.condition);\r\n    sb.push(\" ? \");\r\n    this.visitNode(node.ifThen);\r\n    sb.push(\" : \");\r\n    this.visitNode(node.ifElse);\r\n  }\r\n\r\n  visitUnaryExpression(node: UnaryExpression): void {\r\n    switch (node.kind) {\r\n      case NodeKind.UNARYPOSTFIX: {\r\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\r\n        break;\r\n      }\r\n      case NodeKind.UNARYPREFIX: {\r\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n  }\r\n\r\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\r\n    this.visitNode(node.operand);\r\n    this.sb.push(operatorTokenToString(node.operator));\r\n  }\r\n\r\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\r\n    this.sb.push(operatorTokenToString(node.operator));\r\n    this.visitNode(node.operand);\r\n  }\r\n\r\n  // statements\r\n\r\n  visitNodeAndTerminate(node: Node): void {\r\n    this.visitNode(node);\r\n    var sb = this.sb;\r\n    if (\r\n      !sb.length ||                     // leading EmptyStatement\r\n      node.kind == NodeKind.VARIABLE || // potentially assigns a FunctionExpression\r\n      node.kind == NodeKind.EXPRESSION  // potentially assigns a FunctionExpression\r\n    ) {\r\n      sb.push(\";\\n\");\r\n    } else {\r\n      let last = sb[sb.length - 1];\r\n      let lastCharPos = last.length - 1;\r\n      if (lastCharPos >= 0 && (\r\n        last.charCodeAt(lastCharPos) == CharCode.CLOSEBRACE ||\r\n        last.charCodeAt(lastCharPos) == CharCode.SEMICOLON)\r\n      ) {\r\n        sb.push(\"\\n\");\r\n      } else {\r\n        sb.push(\";\\n\");\r\n      }\r\n    }\r\n  }\r\n\r\n  visitBlockStatement(node: BlockStatement): void {\r\n    var sb = this.sb;\r\n    var statements = node.statements;\r\n    var numStatements = statements.length;\r\n    if (numStatements) {\r\n      sb.push(\"{\\n\");\r\n      let indentLevel = ++this.indentLevel;\r\n      for (let i = 0; i < numStatements; ++i) {\r\n        indent(sb, indentLevel);\r\n        this.visitNodeAndTerminate(statements[i]);\r\n      }\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\");\r\n    } else {\r\n      sb.push(\"{}\");\r\n    }\r\n  }\r\n\r\n  visitBreakStatement(node: BreakStatement): void {\r\n    var label = node.label;\r\n    if (label) {\r\n      this.sb.push(\"break \");\r\n      this.visitIdentifierExpression(label);\r\n    } else {\r\n      this.sb.push(\"break\");\r\n    }\r\n  }\r\n\r\n  visitContinueStatement(node: ContinueStatement): void {\r\n    var label = node.label;\r\n    if (label) {\r\n      this.sb.push(\"continue \");\r\n      this.visitIdentifierExpression(label);\r\n    } else {\r\n      this.sb.push(\"continue\");\r\n    }\r\n  }\r\n\r\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    var sb = this.sb;\r\n    if (isDefault) {\r\n      sb.push(\"export default \");\r\n    } else {\r\n      this.serializeExternalModifiers(node);\r\n    }\r\n    if (node.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\r\n    if (node.name.text.length) {\r\n      sb.push(\"class \");\r\n      this.visitIdentifierExpression(node.name);\r\n    } else {\r\n      sb.push(\"class\");\r\n    }\r\n    var typeParameters = node.typeParameters;\r\n    if (typeParameters != null && typeParameters.length > 0) {\r\n      sb.push(\"<\");\r\n      this.visitTypeParameter(typeParameters[0]);\r\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\r\n        sb.push(\", \");\r\n        this.visitTypeParameter(typeParameters[i]);\r\n      }\r\n      sb.push(\">\");\r\n    }\r\n    var extendsType = node.extendsType;\r\n    if (extendsType) {\r\n      sb.push(\" extends \");\r\n      this.visitTypeNode(extendsType);\r\n    }\r\n    var implementsTypes = node.implementsTypes;\r\n    if (implementsTypes) {\r\n      let numImplementsTypes = implementsTypes.length;\r\n      if (numImplementsTypes) {\r\n        sb.push(\" implements \");\r\n        this.visitTypeNode(implementsTypes[0]);\r\n        for (let i = 1; i < numImplementsTypes; ++i) {\r\n          sb.push(\", \");\r\n          this.visitTypeNode(implementsTypes[i]);\r\n        }\r\n      }\r\n    }\r\n    var indexSignature = node.indexSignature;\r\n    var members = node.members;\r\n    var numMembers = members.length;\r\n    if (indexSignature !== null || numMembers) {\r\n      sb.push(\" {\\n\");\r\n      let indentLevel = ++this.indentLevel;\r\n      if (indexSignature) {\r\n        indent(sb, indentLevel);\r\n        this.visitNodeAndTerminate(indexSignature);\r\n      }\r\n      for (let i = 0, k = members.length; i < k; ++i) {\r\n        let member = members[i];\r\n        if (member.kind != NodeKind.FIELDDECLARATION || (<FieldDeclaration>member).parameterIndex < 0) {\r\n          indent(sb, indentLevel);\r\n          this.visitNodeAndTerminate(member);\r\n        }\r\n      }\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\");\r\n    } else {\r\n      sb.push(\" {}\");\r\n    }\r\n  }\r\n\r\n  visitDoStatement(node: DoStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"do \");\r\n    this.visitNode(node.statement);\r\n    if (node.statement.kind == NodeKind.BLOCK) {\r\n      sb.push(\" while (\");\r\n    } else {\r\n      sb.push(\";\\n\");\r\n      indent(sb, this.indentLevel);\r\n      sb.push(\"while (\");\r\n    }\r\n    this.visitNode(node.condition);\r\n    sb.push(\")\");\r\n  }\r\n\r\n  visitEmptyStatement(node: EmptyStatement): void {\r\n    /* nop */\r\n  }\r\n\r\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\r\n    var sb = this.sb;\r\n    if (isDefault) {\r\n      sb.push(\"export default \");\r\n    } else {\r\n      this.serializeExternalModifiers(node);\r\n    }\r\n    if (node.is(CommonFlags.CONST)) sb.push(\"const \");\r\n    sb.push(\"enum \");\r\n    this.visitIdentifierExpression(node.name);\r\n    var values = node.values;\r\n    var numValues = values.length;\r\n    if (numValues) {\r\n      sb.push(\" {\\n\");\r\n      let indentLevel = ++this.indentLevel;\r\n      indent(sb, indentLevel);\r\n      this.visitEnumValueDeclaration(node.values[0]);\r\n      for (let i = 1; i < numValues; ++i) {\r\n        sb.push(\",\\n\");\r\n        indent(sb, indentLevel);\r\n        this.visitEnumValueDeclaration(node.values[i]);\r\n      }\r\n      sb.push(\"\\n\");\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\");\r\n    } else {\r\n      sb.push(\" {}\");\r\n    }\r\n  }\r\n\r\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\r\n    this.visitIdentifierExpression(node.name);\r\n    var initializer = node.initializer;\r\n    if (initializer) {\r\n      this.sb.push(\" = \");\r\n      this.visitNode(initializer);\r\n    }\r\n  }\r\n\r\n  visitExportImportStatement(node: ExportImportStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"export import \");\r\n    this.visitIdentifierExpression(node.externalName);\r\n    sb.push(\" = \");\r\n    this.visitIdentifierExpression(node.name);\r\n  }\r\n\r\n  visitExportMember(node: ExportMember): void {\r\n    this.visitIdentifierExpression(node.localName);\r\n    if (node.exportedName.text != node.localName.text) {\r\n      this.sb.push(\" as \");\r\n      this.visitIdentifierExpression(node.exportedName);\r\n    }\r\n  }\r\n\r\n  visitExportStatement(node: ExportStatement): void {\r\n    var sb = this.sb;\r\n    if (node.isDeclare) {\r\n      sb.push(\"declare \");\r\n    }\r\n    var members = node.members;\r\n    if (members != null && members.length > 0) {\r\n      let numMembers = members.length;\r\n      sb.push(\"export {\\n\");\r\n      let indentLevel = ++this.indentLevel;\r\n      indent(sb, indentLevel);\r\n      this.visitExportMember(members[0]);\r\n      for (let i = 1; i < numMembers; ++i) {\r\n        sb.push(\",\\n\");\r\n        indent(sb, indentLevel);\r\n        this.visitExportMember(members[i]);\r\n      }\r\n      --this.indentLevel;\r\n      sb.push(\"\\n}\");\r\n    } else {\r\n      sb.push(\"export {}\");\r\n    }\r\n    var path = node.path;\r\n    if (path) {\r\n      sb.push(\" from \");\r\n      this.visitStringLiteralExpression(path);\r\n    }\r\n    sb.push(\";\");\r\n  }\r\n\r\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\r\n    var declaration = node.declaration;\r\n    switch (declaration.kind) {\r\n      case NodeKind.ENUMDECLARATION: {\r\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTIONDECLARATION: {\r\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\r\n        break;\r\n      }\r\n      case NodeKind.CLASSDECLARATION: {\r\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\r\n        break;\r\n      }\r\n      case NodeKind.INTERFACEDECLARATION: {\r\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\r\n        break;\r\n      }\r\n      case NodeKind.NAMESPACEDECLARATION: {\r\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n  }\r\n\r\n  visitExpressionStatement(node: ExpressionStatement): void {\r\n    this.visitNode(node.expression);\r\n  }\r\n\r\n  visitFieldDeclaration(node: FieldDeclaration): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    this.serializeAccessModifiers(node);\r\n    this.visitIdentifierExpression(node.name);\r\n    var sb = this.sb;\r\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\r\n      sb.push(\"!\");\r\n    }\r\n    var type = node.type;\r\n    if (type) {\r\n      sb.push(\": \");\r\n      this.visitTypeNode(type);\r\n    }\r\n    var initializer = node.initializer;\r\n    if (initializer) {\r\n      sb.push(\" = \");\r\n      this.visitNode(initializer);\r\n    }\r\n  }\r\n\r\n  visitForStatement(node: ForStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"for (\");\r\n    var initializer = node.initializer;\r\n    if (initializer) {\r\n      this.visitNode(initializer);\r\n    }\r\n    var condition = node.condition;\r\n    if (condition) {\r\n      sb.push(\"; \");\r\n      this.visitNode(condition);\r\n    } else {\r\n      sb.push(\";\");\r\n    }\r\n    var incrementor = node.incrementor;\r\n    if (incrementor) {\r\n      sb.push(\"; \");\r\n      this.visitNode(incrementor);\r\n    } else {\r\n      sb.push(\";\");\r\n    }\r\n    sb.push(\") \");\r\n    this.visitNode(node.statement);\r\n  }\r\n\r\n  visitForOfStatement(node: ForOfStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"for (\");\r\n    this.visitNode(node.variable);\r\n    sb.push(\" of \");\r\n    this.visitNode(node.iterable);\r\n    sb.push(\") \");\r\n    this.visitNode(node.statement);\r\n  }\r\n\r\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\r\n    var sb = this.sb;\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    if (isDefault) {\r\n      sb.push(\"export default \");\r\n    } else {\r\n      this.serializeExternalModifiers(node);\r\n      this.serializeAccessModifiers(node);\r\n    }\r\n    if (node.name.text.length) {\r\n      sb.push(\"function \");\r\n    } else {\r\n      sb.push(\"function\");\r\n    }\r\n    this.visitFunctionCommon(node);\r\n  }\r\n\r\n  visitFunctionCommon(node: FunctionDeclaration): void {\r\n    var sb = this.sb;\r\n    this.visitIdentifierExpression(node.name);\r\n    var signature = node.signature;\r\n    var typeParameters = node.typeParameters;\r\n    if (typeParameters) {\r\n      let numTypeParameters = typeParameters.length;\r\n      if (numTypeParameters) {\r\n        sb.push(\"<\");\r\n        this.visitTypeParameter(typeParameters[0]);\r\n        for (let i = 1; i < numTypeParameters; ++i) {\r\n          sb.push(\", \");\r\n          this.visitTypeParameter(typeParameters[i]);\r\n        }\r\n        sb.push(\">\");\r\n      }\r\n    }\r\n    if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\r\n      let parameters = signature.parameters;\r\n      assert(parameters.length == 1);\r\n      assert(!signature.explicitThisType);\r\n      this.serializeParameter(parameters[0]);\r\n    } else {\r\n      sb.push(\"(\");\r\n      let parameters = signature.parameters;\r\n      let numParameters = parameters.length;\r\n      let explicitThisType = signature.explicitThisType;\r\n      if (explicitThisType) {\r\n        sb.push(\"this: \");\r\n        this.visitTypeNode(explicitThisType);\r\n      }\r\n      if (numParameters) {\r\n        if (explicitThisType) sb.push(\", \");\r\n        this.serializeParameter(parameters[0]);\r\n        for (let i = 1; i < numParameters; ++i) {\r\n          sb.push(\", \");\r\n          this.serializeParameter(parameters[i]);\r\n        }\r\n      }\r\n    }\r\n    var body = node.body;\r\n    var returnType = signature.returnType;\r\n    if (node.arrowKind) {\r\n      if (body) {\r\n        if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\r\n          assert(isTypeOmitted(returnType));\r\n        } else {\r\n          if (isTypeOmitted(returnType)) {\r\n            sb.push(\")\");\r\n          } else {\r\n            sb.push(\"): \");\r\n            this.visitTypeNode(returnType);\r\n          }\r\n        }\r\n        sb.push(\" => \");\r\n        this.visitNode(body);\r\n      } else {\r\n        assert(!isTypeOmitted(returnType));\r\n        sb.push(\" => \");\r\n        this.visitTypeNode(returnType);\r\n      }\r\n    } else {\r\n      if (\r\n        !isTypeOmitted(returnType) &&\r\n        !node.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)\r\n      ) {\r\n        sb.push(\"): \");\r\n        this.visitTypeNode(returnType);\r\n      } else {\r\n        sb.push(\")\");\r\n      }\r\n      if (body) {\r\n        sb.push(\" \");\r\n        this.visitNode(body);\r\n      }\r\n    }\r\n  }\r\n\r\n  visitIfStatement(node: IfStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"if (\");\r\n    this.visitNode(node.condition);\r\n    sb.push(\") \");\r\n    var ifTrue = node.ifTrue;\r\n    this.visitNode(ifTrue);\r\n    if (ifTrue.kind != NodeKind.BLOCK) {\r\n      sb.push(\";\\n\");\r\n    }\r\n    var ifFalse = node.ifFalse;\r\n    if (ifFalse) {\r\n      if (ifTrue.kind == NodeKind.BLOCK) {\r\n        sb.push(\" else \");\r\n      } else {\r\n        sb.push(\"else \");\r\n      }\r\n      this.visitNode(ifFalse);\r\n    }\r\n  }\r\n\r\n  visitImportDeclaration(node: ImportDeclaration): void {\r\n    var externalName = node.foreignName;\r\n    var name = node.name;\r\n    this.visitIdentifierExpression(externalName);\r\n    if (externalName.text != name.text) {\r\n      this.sb.push(\" as \");\r\n      this.visitIdentifierExpression(name);\r\n    }\r\n  }\r\n\r\n  visitImportStatement(node: ImportStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"import \");\r\n    var declarations = node.declarations;\r\n    var namespaceName = node.namespaceName;\r\n    if (declarations) {\r\n      let numDeclarations = declarations.length;\r\n      if (numDeclarations) {\r\n        sb.push(\"{\\n\");\r\n        let indentLevel = ++this.indentLevel;\r\n        indent(sb, indentLevel);\r\n        this.visitImportDeclaration(declarations[0]);\r\n        for (let i = 1; i < numDeclarations; ++i) {\r\n          sb.push(\",\\n\");\r\n          indent(sb, indentLevel);\r\n          this.visitImportDeclaration(declarations[i]);\r\n        }\r\n        --this.indentLevel;\r\n        sb.push(\"\\n} from \");\r\n      } else {\r\n        sb.push(\"{} from \");\r\n      }\r\n    } else if (namespaceName) {\r\n      sb.push(\"* as \");\r\n      this.visitIdentifierExpression(namespaceName);\r\n      sb.push(\" from \");\r\n    }\r\n    this.visitStringLiteralExpression(node.path);\r\n  }\r\n\r\n  visitIndexSignature(node: IndexSignatureNode): void {\r\n    var sb = this.sb;\r\n    sb.push(\"[key: \");\r\n    this.visitTypeNode(node.keyType);\r\n    sb.push(\"]: \");\r\n    this.visitTypeNode(node.valueType);\r\n  }\r\n\r\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    var sb = this.sb;\r\n    if (isDefault) {\r\n      sb.push(\"export default \");\r\n    } else {\r\n      this.serializeExternalModifiers(node);\r\n    }\r\n    sb.push(\"interface \");\r\n    this.visitIdentifierExpression(node.name);\r\n    var typeParameters = node.typeParameters;\r\n    if (typeParameters != null && typeParameters.length > 0) {\r\n      sb.push(\"<\");\r\n      this.visitTypeParameter(typeParameters[0]);\r\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\r\n        sb.push(\", \");\r\n        this.visitTypeParameter(typeParameters[i]);\r\n      }\r\n      sb.push(\">\");\r\n    }\r\n    var extendsType = node.extendsType;\r\n    if (extendsType) {\r\n      sb.push(\" extends \");\r\n      this.visitTypeNode(extendsType);\r\n    }\r\n    // must not have implementsTypes\r\n    sb.push(\" {\\n\");\r\n    var indentLevel = ++this.indentLevel;\r\n    var members = node.members;\r\n    for (let i = 0, k = members.length; i < k; ++i) {\r\n      indent(sb, indentLevel);\r\n      this.visitNodeAndTerminate(members[i]);\r\n    }\r\n    --this.indentLevel;\r\n    sb.push(\"}\");\r\n  }\r\n\r\n  visitMethodDeclaration(node: MethodDeclaration): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    this.serializeAccessModifiers(node);\r\n    if (node.is(CommonFlags.GET)) {\r\n      this.sb.push(\"get \");\r\n    } else if (node.is(CommonFlags.SET)) {\r\n      this.sb.push(\"set \");\r\n    }\r\n    this.visitFunctionCommon(node);\r\n  }\r\n\r\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    var sb = this.sb;\r\n    if (isDefault) {\r\n      sb.push(\"export default \");\r\n    } else {\r\n      this.serializeExternalModifiers(node);\r\n    }\r\n    sb.push(\"namespace \");\r\n    this.visitIdentifierExpression(node.name);\r\n    var members = node.members;\r\n    var numMembers = members.length;\r\n    if (numMembers) {\r\n      sb.push(\" {\\n\");\r\n      let indentLevel = ++this.indentLevel;\r\n      for (let i = 0, k = members.length; i < k; ++i) {\r\n        indent(sb, indentLevel);\r\n        this.visitNodeAndTerminate(members[i]);\r\n      }\r\n      indent(sb, --this.indentLevel);\r\n      sb.push(\"}\");\r\n    } else {\r\n      sb.push(\" {}\");\r\n    }\r\n  }\r\n\r\n  visitReturnStatement(node: ReturnStatement): void {\r\n    var value = node.value;\r\n    if (value) {\r\n      this.sb.push(\"return \");\r\n      this.visitNode(value);\r\n    } else {\r\n      this.sb.push(\"return\");\r\n    }\r\n  }\r\n\r\n  visitSwitchCase(node: SwitchCase): void {\r\n    var sb = this.sb;\r\n    var label = node.label;\r\n    if (label) {\r\n      sb.push(\"case \");\r\n      this.visitNode(label);\r\n      sb.push(\":\\n\");\r\n    } else {\r\n      sb.push(\"default:\\n\");\r\n    }\r\n    var statements = node.statements;\r\n    var numStatements = statements.length;\r\n    if (numStatements) {\r\n      let indentLevel = ++this.indentLevel;\r\n      indent(sb, indentLevel);\r\n      this.visitNodeAndTerminate(statements[0]);\r\n      for (let i = 1; i < numStatements; ++i) {\r\n        indent(sb, indentLevel);\r\n        this.visitNodeAndTerminate(statements[i]);\r\n      }\r\n      --this.indentLevel;\r\n    }\r\n  }\r\n\r\n  visitSwitchStatement(node: SwitchStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"switch (\");\r\n    this.visitNode(node.condition);\r\n    sb.push(\") {\\n\");\r\n    var indentLevel = ++this.indentLevel;\r\n    var cases = node.cases;\r\n    for (let i = 0, k = cases.length; i < k; ++i) {\r\n      indent(sb, indentLevel);\r\n      this.visitSwitchCase(cases[i]);\r\n      sb.push(\"\\n\");\r\n    }\r\n    --this.indentLevel;\r\n    sb.push(\"}\");\r\n  }\r\n\r\n  visitThrowStatement(node: ThrowStatement): void {\r\n    this.sb.push(\"throw \");\r\n    this.visitNode(node.value);\r\n  }\r\n\r\n  visitTryStatement(node: TryStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"try {\\n\");\r\n    var indentLevel = ++this.indentLevel;\r\n    var statements = node.statements;\r\n    for (let i = 0, k = statements.length; i < k; ++i) {\r\n      indent(sb, indentLevel);\r\n      this.visitNodeAndTerminate(statements[i]);\r\n    }\r\n    var catchVariable = node.catchVariable;\r\n    if (catchVariable) {\r\n      indent(sb, indentLevel - 1);\r\n      sb.push(\"} catch (\");\r\n      this.visitIdentifierExpression(catchVariable);\r\n      sb.push(\") {\\n\");\r\n      let catchStatements = node.catchStatements;\r\n      if (catchStatements) {\r\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\r\n          indent(sb, indentLevel);\r\n          this.visitNodeAndTerminate(catchStatements[i]);\r\n        }\r\n      }\r\n    }\r\n    var finallyStatements = node.finallyStatements;\r\n    if (finallyStatements) {\r\n      indent(sb, indentLevel - 1);\r\n      sb.push(\"} finally {\\n\");\r\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\r\n        indent(sb, indentLevel);\r\n        this.visitNodeAndTerminate(finallyStatements[i]);\r\n      }\r\n    }\r\n    indent(sb, indentLevel - 1);\r\n    sb.push(\"}\");\r\n  }\r\n\r\n  visitTypeDeclaration(node: TypeDeclaration): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    var sb = this.sb;\r\n    this.serializeExternalModifiers(node);\r\n    sb.push(\"type \");\r\n    this.visitIdentifierExpression(node.name);\r\n    var typeParameters = node.typeParameters;\r\n    if (typeParameters) {\r\n      let numTypeParameters = typeParameters.length;\r\n      if (numTypeParameters) {\r\n        sb.push(\"<\");\r\n        for (let i = 0; i < numTypeParameters; ++i) {\r\n          this.visitTypeParameter(typeParameters[i]);\r\n        }\r\n        sb.push(\">\");\r\n      }\r\n    }\r\n    sb.push(\" = \");\r\n    this.visitTypeNode(node.type);\r\n  }\r\n\r\n  visitVariableDeclaration(node: VariableDeclaration): void {\r\n    this.visitIdentifierExpression(node.name);\r\n    var type = node.type;\r\n    var sb = this.sb;\r\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\r\n      sb.push(\"!\");\r\n    }\r\n    if (type) {\r\n      sb.push(\": \");\r\n      this.visitTypeNode(type);\r\n    }\r\n    var initializer = node.initializer;\r\n    if (initializer) {\r\n      sb.push(\" = \");\r\n      this.visitNode(initializer);\r\n    }\r\n  }\r\n\r\n  visitVariableStatement(node: VariableStatement): void {\r\n    var decorators = node.decorators;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.serializeDecorator(decorators[i]);\r\n      }\r\n    }\r\n    var sb = this.sb;\r\n    var declarations = node.declarations;\r\n    var numDeclarations = assert(declarations.length);\r\n    var firstDeclaration = declarations[0];\r\n    this.serializeExternalModifiers(firstDeclaration);\r\n    sb.push(firstDeclaration.is(CommonFlags.CONST) ? \"const \" : firstDeclaration.is(CommonFlags.LET) ? \"let \" : \"var \");\r\n    this.visitVariableDeclaration(node.declarations[0]);\r\n    for (let i = 1; i < numDeclarations; ++i) {\r\n      sb.push(\", \");\r\n      this.visitVariableDeclaration(node.declarations[i]);\r\n    }\r\n  }\r\n\r\n  visitWhileStatement(node: WhileStatement): void {\r\n    var sb = this.sb;\r\n    sb.push(\"while (\");\r\n    this.visitNode(node.condition);\r\n    var statement = node.statement;\r\n    if (statement.kind == NodeKind.EMPTY) {\r\n      sb.push(\")\");\r\n    } else {\r\n      sb.push(\") \");\r\n      this.visitNode(node.statement);\r\n    }\r\n  }\r\n\r\n  // other\r\n\r\n  serializeDecorator(node: DecoratorNode): void {\r\n    var sb = this.sb;\r\n    sb.push(\"@\");\r\n    this.visitNode(node.name);\r\n    var args = node.args;\r\n    if (args) {\r\n      sb.push(\"(\");\r\n      let numArgs = args.length;\r\n      if (numArgs) {\r\n        this.visitNode(args[0]);\r\n        for (let i = 1; i < numArgs; ++i) {\r\n          sb.push(\", \");\r\n          this.visitNode(args[i]);\r\n        }\r\n      }\r\n      sb.push(\")\\n\");\r\n    } else {\r\n      sb.push(\"\\n\");\r\n    }\r\n    indent(sb, this.indentLevel);\r\n  }\r\n\r\n  serializeParameter(node: ParameterNode): void {\r\n    var sb = this.sb;\r\n    var kind = node.parameterKind;\r\n    var implicitFieldDeclaration = node.implicitFieldDeclaration;\r\n    if (implicitFieldDeclaration) {\r\n      this.serializeAccessModifiers(implicitFieldDeclaration);\r\n    }\r\n    if (kind == ParameterKind.REST) {\r\n      sb.push(\"...\");\r\n    }\r\n    this.visitIdentifierExpression(node.name);\r\n    var type = node.type;\r\n    var initializer = node.initializer;\r\n    if (type) {\r\n      if (kind == ParameterKind.OPTIONAL && !initializer) sb.push(\"?\");\r\n      if (!isTypeOmitted(type)) {\r\n        sb.push(\": \");\r\n        this.visitTypeNode(type);\r\n      }\r\n    }\r\n    if (initializer) {\r\n      sb.push(\" = \");\r\n      this.visitNode(initializer);\r\n    }\r\n  }\r\n\r\n  serializeExternalModifiers(node: DeclarationStatement): void {\r\n    var sb = this.sb;\r\n    if (node.is(CommonFlags.EXPORT)) {\r\n      sb.push(\"export \");\r\n    } else if (node.is(CommonFlags.IMPORT)) {\r\n      sb.push(\"import \");\r\n    } else if (node.is(CommonFlags.DECLARE)) {\r\n      sb.push(\"declare \");\r\n    }\r\n  }\r\n\r\n  serializeAccessModifiers(node: DeclarationStatement): void {\r\n    var sb = this.sb;\r\n    if (node.is(CommonFlags.PUBLIC)) {\r\n      sb.push(\"public \");\r\n    } else if (node.is(CommonFlags.PRIVATE)) {\r\n      sb.push(\"private \");\r\n    } else if (node.is(CommonFlags.PROTECTED)) {\r\n      sb.push(\"protected \");\r\n    }\r\n    if (node.is(CommonFlags.STATIC)) {\r\n      sb.push(\"static \");\r\n    } else if (node.is(CommonFlags.ABSTRACT)) {\r\n      sb.push(\"abstract \");\r\n    }\r\n    if (node.is(CommonFlags.READONLY)) {\r\n      sb.push(\"readonly \");\r\n    }\r\n  }\r\n\r\n  finish(): string {\r\n    var ret = this.sb.join(\"\");\r\n    this.sb = [];\r\n    return ret;\r\n  }\r\n}\r\n","/**\r\n * @fileoverview A concurrent code flow analyzer.\r\n *\r\n * Flows keep track of compilation state and can be queried for various\r\n * conditions, like whether the current branch always terminates, whether\r\n * a local is known to be non-null or whether an expression has possibly\r\n * overflown its value range.\r\n *\r\n * To accomplish this, compilation of each function begins with a clean\r\n * flow populated with initial local states etc. While compilation\r\n * progresses, statements and expressions update flow state while control\r\n * constructs fork, potentially add scoped locals and later merge these\r\n * forked branches as necessary.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Type,\r\n  TypeFlags,\r\n  TypeKind\r\n} from \"./types\";\r\n\r\nimport {\r\n  Local,\r\n  Function,\r\n  Element,\r\n  ElementKind,\r\n  Global,\r\n  Field,\r\n  Class\r\n} from \"./program\";\r\n\r\nimport {\r\n  TypeRef,\r\n  ExpressionId,\r\n  ExpressionRef,\r\n  BinaryOp,\r\n  UnaryOp,\r\n\r\n  getExpressionId,\r\n  getLocalGetIndex,\r\n  isLocalTee,\r\n  getLocalSetValue,\r\n  getGlobalGetName,\r\n  getBinaryOp,\r\n  getBinaryLeft,\r\n  getConstValueI32,\r\n  getBinaryRight,\r\n  getUnaryOp,\r\n  getExpressionType,\r\n  getConstValueI64Low,\r\n  getConstValueF32,\r\n  getConstValueF64,\r\n  getLoadBytes,\r\n  isLoadSigned,\r\n  getBlockName,\r\n  getBlockChildCount,\r\n  getBlockChildAt,\r\n  getIfTrue,\r\n  getIfFalse,\r\n  getSelectThen,\r\n  getSelectElse,\r\n  getCallTarget,\r\n  getLocalSetIndex,\r\n  getIfCondition,\r\n  getConstValueI64High,\r\n  getUnaryValue\r\n} from \"./module\";\r\n\r\nimport {\r\n  CommonFlags\r\n} from \"./common\";\r\n\r\nimport {\r\n  DiagnosticCode\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Node\r\n} from \"./ast\";\r\n\r\nimport {\r\n  uniqueMap\r\n} from \"./util\";\r\n\r\n/** Control flow flags indicating specific conditions. */\r\nexport const enum FlowFlags {\r\n  /** No specific conditions. */\r\n  NONE = 0,\r\n\r\n  // categorical\r\n\r\n  /** This flow always returns. */\r\n  RETURNS = 1 << 0,\r\n  /** This flow always returns a wrapped value. */\r\n  RETURNS_WRAPPED = 1 << 1,\r\n  /** This flow always returns a non-null value. */\r\n  RETURNS_NONNULL = 1 << 2,\r\n  /** This flow always throws. */\r\n  THROWS = 1 << 3,\r\n  /** This flow always breaks. */\r\n  BREAKS = 1 << 4,\r\n  /** This flow always continues. */\r\n  CONTINUES = 1 << 5,\r\n  /** This flow always accesses `this`. Constructors only. */\r\n  ACCESSES_THIS = 1 << 6,\r\n  /** This flow always calls `super`. Constructors only. */\r\n  CALLS_SUPER = 1 << 7,\r\n  /** This flow always terminates (returns, throws or continues). */\r\n  TERMINATES = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\r\n\r\n  // conditional\r\n\r\n  /** This flow conditionally returns in a child flow. */\r\n  CONDITIONALLY_RETURNS = 1 << 9,\r\n  /** This flow conditionally throws in a child flow. */\r\n  CONDITIONALLY_THROWS = 1 << 10,\r\n  /** This flow conditionally breaks in a child flow. */\r\n  CONDITIONALLY_BREAKS = 1 << 11,\r\n  /** This flow conditionally continues in a child flow. */\r\n  CONDITIONALLY_CONTINUES = 1 << 12,\r\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\r\n  CONDITIONALLY_ACCESSES_THIS = 1 << 13,\r\n  /** This flow may return a non-this value. Constructors only. */\r\n  MAY_RETURN_NONTHIS = 1 << 14,\r\n\r\n  // other\r\n\r\n  /** This is a flow with explicitly disabled bounds checking. */\r\n  UNCHECKED_CONTEXT = 1 << 15,\r\n  /** This is a flow compiling a constructor parameter. */\r\n  CTORPARAM_CONTEXT = 1 << 16,\r\n\r\n  // masks\r\n\r\n  /** Any categorical flag. */\r\n  ANY_CATEGORICAL = FlowFlags.RETURNS\r\n                  | FlowFlags.RETURNS_WRAPPED\r\n                  | FlowFlags.RETURNS_NONNULL\r\n                  | FlowFlags.THROWS\r\n                  | FlowFlags.BREAKS\r\n                  | FlowFlags.CONTINUES\r\n                  | FlowFlags.ACCESSES_THIS\r\n                  | FlowFlags.CALLS_SUPER\r\n                  | FlowFlags.TERMINATES,\r\n\r\n  /** Any conditional flag. */\r\n  ANY_CONDITIONAL = FlowFlags.CONDITIONALLY_RETURNS\r\n                  | FlowFlags.CONDITIONALLY_THROWS\r\n                  | FlowFlags.CONDITIONALLY_BREAKS\r\n                  | FlowFlags.CONDITIONALLY_CONTINUES\r\n                  | FlowFlags.CONDITIONALLY_ACCESSES_THIS\r\n}\r\n\r\n/** Flags indicating the current state of a local. */\r\nexport enum LocalFlags {\r\n  /** No specific conditions. */\r\n  NONE = 0,\r\n\r\n  /** Local is constant. */\r\n  CONSTANT = 1 << 0,\r\n  /** Local is properly wrapped. Relevant for small integers. */\r\n  WRAPPED = 1 << 1,\r\n  /** Local is non-null. */\r\n  NONNULL = 1 << 2,\r\n  /** Local is initialized. */\r\n  INITIALIZED = 1 << 3\r\n}\r\n\r\n/** Flags indicating the current state of a field. */\r\nexport enum FieldFlags {\r\n  NONE = 0,\r\n  INITIALIZED = 1 << 0\r\n}\r\n\r\n/** Condition kinds. */\r\nexport const enum ConditionKind {\r\n  /** Outcome of the condition is unknown */\r\n  UNKNOWN,\r\n  /** Condition is always true. */\r\n  TRUE,\r\n  /** Condition is always false. */\r\n  FALSE\r\n}\r\n\r\n/** A control flow evaluator. */\r\nexport class Flow {\r\n\r\n  /** Creates the parent flow of the specified function. */\r\n  static createParent(parentFunction: Function): Flow {\r\n    var flow = new Flow(parentFunction);\r\n    if (parentFunction.is(CommonFlags.CONSTRUCTOR)) {\r\n      flow.initThisFieldFlags();\r\n    }\r\n    return flow;\r\n  }\r\n\r\n  /** Creates an inline flow within `parentFunction`. */\r\n  static createInline(parentFunction: Function, inlineFunction: Function): Flow {\r\n    var flow = new Flow(parentFunction);\r\n    flow.inlineFunction = inlineFunction;\r\n    flow.inlineReturnLabel = inlineFunction.internalName + \"|inlined.\" + (inlineFunction.nextInlineId++).toString();\r\n    if (inlineFunction.is(CommonFlags.CONSTRUCTOR)) {\r\n      flow.initThisFieldFlags();\r\n    }\r\n    return flow;\r\n  }\r\n\r\n  private constructor(\r\n    /** Function this flow belongs to. */\r\n    public parentFunction: Function\r\n  ) {\r\n    /* nop */\r\n  }\r\n\r\n  /** Parent flow. */\r\n  parent: Flow | null = null;\r\n  /** Outer flow. Only relevant for first-class functions. */\r\n  outer: Flow | null = null;\r\n  /** Flow flags indicating specific conditions. */\r\n  flags: FlowFlags = FlowFlags.NONE;\r\n  /** The label we break to when encountering a continue statement. */\r\n  continueLabel: string | null = null;\r\n  /** The label we break to when encountering a break statement. */\r\n  breakLabel: string | null = null;\r\n  /** Scoped local variables. */\r\n  scopedLocals: Map<string,Local> | null = null;\r\n  /** Local flags. */\r\n  localFlags: LocalFlags[] = [];\r\n  /** Field flags on `this`. Constructors only. */\r\n  thisFieldFlags: Map<Field,FieldFlags> | null = null;\r\n  /** Function being inlined, when inlining. */\r\n  inlineFunction: Function | null = null;\r\n  /** The label we break to when encountering a return statement, when inlining. */\r\n  inlineReturnLabel: string | null = null;\r\n\r\n  /** Tests if this is an inline flow. */\r\n  get isInline(): bool {\r\n    return this.inlineFunction !== null;\r\n  }\r\n\r\n  /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */\r\n  get actualFunction(): Function {\r\n    var inlineFunction = this.inlineFunction;\r\n    if (inlineFunction) return inlineFunction;\r\n    return this.parentFunction;\r\n  }\r\n\r\n  /** Gets the current return type. */\r\n  get returnType(): Type {\r\n    return this.actualFunction.signature.returnType;\r\n  }\r\n\r\n  /** Gets the current contextual type arguments. */\r\n  get contextualTypeArguments(): Map<string,Type> | null {\r\n    return this.actualFunction.contextualTypeArguments;\r\n  }\r\n\r\n  /** Tests if this flow has the specified flag or flags. */\r\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\r\n  /** Tests if this flow has one of the specified flags. */\r\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\r\n  /** Sets the specified flag or flags. */\r\n  set(flag: FlowFlags): void { this.flags |= flag; }\r\n  /** Unsets the specified flag or flags. */\r\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\r\n\r\n  /** Forks this flow to a child flow. */\r\n  fork(resetBreakContext: bool = false): Flow {\r\n    var branch = new Flow(this.parentFunction);\r\n    branch.parent = this;\r\n    branch.outer = this.outer;\r\n    if (resetBreakContext) {\r\n      branch.flags = this.flags & ~(\r\n        FlowFlags.BREAKS |\r\n        FlowFlags.CONDITIONALLY_BREAKS |\r\n        FlowFlags.CONTINUES |\r\n        FlowFlags.CONDITIONALLY_CONTINUES\r\n      );\r\n    } else {\r\n      branch.flags = this.flags;\r\n      branch.continueLabel = this.continueLabel;\r\n      branch.breakLabel = this.breakLabel;\r\n    }\r\n    branch.localFlags = this.localFlags.slice();\r\n    if (this.actualFunction.is(CommonFlags.CONSTRUCTOR)) {\r\n      let thisFieldFlags = assert(this.thisFieldFlags);\r\n      branch.thisFieldFlags = uniqueMap<Field,FieldFlags>(thisFieldFlags);\r\n    } else {\r\n      assert(!this.thisFieldFlags);\r\n    }\r\n    branch.inlineFunction = this.inlineFunction;\r\n    branch.inlineReturnLabel = this.inlineReturnLabel;\r\n    return branch;\r\n  }\r\n\r\n  /** Gets a free temporary local of the specified type. */\r\n  getTempLocal(type: Type, except: Set<i32> | null = null): Local {\r\n    var parentFunction = this.parentFunction;\r\n    var temps: Local[] | null;\r\n    switch (<u32>type.toRef()) {\r\n      case <u32>TypeRef.I32: { temps = parentFunction.tempI32s; break; }\r\n      case <u32>TypeRef.I64: { temps = parentFunction.tempI64s; break; }\r\n      case <u32>TypeRef.F32: { temps = parentFunction.tempF32s; break; }\r\n      case <u32>TypeRef.F64: { temps = parentFunction.tempF64s; break; }\r\n      case <u32>TypeRef.V128: { temps = parentFunction.tempV128s; break; }\r\n      case <u32>TypeRef.Funcref: { temps = parentFunction.tempFuncrefs; break; }\r\n      case <u32>TypeRef.Externref: { temps = parentFunction.tempExternrefs; break; }\r\n      case <u32>TypeRef.Anyref: { temps = parentFunction.tempAnyrefs; break; }\r\n      case <u32>TypeRef.Eqref: { temps = parentFunction.tempEqrefs; break; }\r\n      case <u32>TypeRef.I31ref: { temps = parentFunction.tempI31refs; break; }\r\n      case <u32>TypeRef.Dataref: { temps = parentFunction.tempDatarefs; break; }\r\n      default: throw new Error(\"concrete type expected\");\r\n    }\r\n    var local: Local;\r\n    if (except) {\r\n      if (temps !== null && temps.length > 0) {\r\n        for (let i = 0, k = temps.length; i < k; ++i) {\r\n          if (!except.has(temps[i].index)) {\r\n            local = temps[i];\r\n            let k = temps.length - 1;\r\n            while (i < k) unchecked(temps[i] = temps[i++ + 1]);\r\n            temps.length = k;\r\n            local.type = type;\r\n            local.flags = CommonFlags.NONE;\r\n            this.unsetLocalFlag(local.index, ~0);\r\n            return local;\r\n          }\r\n        }\r\n      }\r\n      local = parentFunction.addLocal(type);\r\n    } else {\r\n      if (temps !== null && temps.length > 0) {\r\n        local = assert(temps.pop());\r\n        local.type = type;\r\n        local.flags = CommonFlags.NONE;\r\n      } else {\r\n        local = parentFunction.addLocal(type);\r\n      }\r\n    }\r\n    this.unsetLocalFlag(local.index, ~0);\r\n    return local;\r\n  }\r\n\r\n  /** Frees the temporary local for reuse. */\r\n  freeTempLocal(local: Local): void {\r\n    if (local.is(CommonFlags.INLINED)) return;\r\n    assert(local.index >= 0);\r\n    var parentFunction = this.parentFunction;\r\n    var temps: Local[];\r\n    assert(local.type != null); // internal error\r\n    local.resetTemporaryName();\r\n    switch (<u32>local.type.toRef()) {\r\n      case <u32>TypeRef.I32: {\r\n        let tempI32s = parentFunction.tempI32s;\r\n        if (tempI32s) temps = tempI32s;\r\n        else parentFunction.tempI32s = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.I64: {\r\n        let tempI64s = parentFunction.tempI64s;\r\n        if (tempI64s) temps = tempI64s;\r\n        else parentFunction.tempI64s = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.F32: {\r\n        let tempF32s = parentFunction.tempF32s;\r\n        if (tempF32s) temps = tempF32s;\r\n        else parentFunction.tempF32s = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.F64: {\r\n        let tempF64s = parentFunction.tempF64s;\r\n        if (tempF64s) temps = tempF64s;\r\n        else parentFunction.tempF64s = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.V128: {\r\n        let tempV128s = parentFunction.tempV128s;\r\n        if (tempV128s) temps = tempV128s;\r\n        else parentFunction.tempV128s = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.Funcref: {\r\n        let tempFuncrefs = parentFunction.tempFuncrefs;\r\n        if (tempFuncrefs) temps = tempFuncrefs;\r\n        else parentFunction.tempFuncrefs = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.Externref: {\r\n        let tempExternrefs = parentFunction.tempExternrefs;\r\n        if (tempExternrefs) temps = tempExternrefs;\r\n        else parentFunction.tempExternrefs = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.Anyref: {\r\n        let tempAnyrefs = parentFunction.tempAnyrefs;\r\n        if (tempAnyrefs) temps = tempAnyrefs;\r\n        else parentFunction.tempAnyrefs = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.Eqref: {\r\n        let tempEqrefs = parentFunction.tempEqrefs;\r\n        if (tempEqrefs) temps = tempEqrefs;\r\n        else parentFunction.tempEqrefs = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.I31ref: {\r\n        let tempI31refs = parentFunction.tempI31refs;\r\n        if (tempI31refs) temps = tempI31refs;\r\n        else parentFunction.tempI31refs = temps = [];\r\n        break;\r\n      }\r\n      case <u32>TypeRef.Dataref: {\r\n        let tempDatarefs = parentFunction.tempDatarefs;\r\n        if (tempDatarefs) temps = tempDatarefs;\r\n        else parentFunction.tempDatarefs = temps = [];\r\n        break;\r\n      }\r\n      default: throw new Error(\"concrete type expected\");\r\n    }\r\n    assert(local.index >= 0);\r\n    temps.push(local);\r\n  }\r\n\r\n  /** Gets the scoped local of the specified name. */\r\n  getScopedLocal(name: string): Local | null {\r\n    var scopedLocals = this.scopedLocals;\r\n    if (scopedLocals !== null && scopedLocals.has(name)) return assert(scopedLocals.get(name));\r\n    return null;\r\n  }\r\n\r\n  /** Adds a new scoped local of the specified name. */\r\n  addScopedLocal(name: string, type: Type, except: Set<i32> | null = null): Local {\r\n    var scopedLocal = this.getTempLocal(type, except);\r\n    scopedLocal.setTemporaryName(name);\r\n    var scopedLocals = this.scopedLocals;\r\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\r\n    else assert(!scopedLocals.has(name));\r\n    scopedLocal.set(CommonFlags.SCOPED);\r\n    scopedLocals.set(name, scopedLocal);\r\n    return scopedLocal;\r\n  }\r\n\r\n  /** Adds a new scoped dummy local of the specified name. */\r\n  addScopedDummyLocal(name: string, type: Type): Local {\r\n    var scopedDummy = new Local(name, -1, type, this.parentFunction);\r\n    var scopedLocals = this.scopedLocals;\r\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\r\n    else assert(!scopedLocals.has(name));\r\n    scopedDummy.set(CommonFlags.SCOPED);\r\n    scopedLocals.set(name, scopedDummy);\r\n    return scopedDummy;\r\n  }\r\n\r\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\r\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\r\n    var scopedLocals = this.scopedLocals;\r\n    if (!scopedLocals) {\r\n      this.scopedLocals = scopedLocals = new Map();\r\n    } else if (scopedLocals.has(name)) {\r\n      let existingLocal = assert(scopedLocals.get(name));\r\n      if (reportNode) {\r\n        if (!existingLocal.declaration.range.source.isNative) {\r\n          this.parentFunction.program.errorRelated(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            reportNode.range,\r\n            existingLocal.declaration.name.range,\r\n            name\r\n          );\r\n        } else {\r\n          this.parentFunction.program.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            reportNode.range, name\r\n          );\r\n        }\r\n      }\r\n      return existingLocal;\r\n    }\r\n    assert(index < this.parentFunction.localsByIndex.length);\r\n    var scopedAlias = new Local(name, index, type, this.parentFunction);\r\n    // not flagged as SCOPED as it must not be free'd when the flow is finalized\r\n    scopedLocals.set(name, scopedAlias);\r\n    return scopedAlias;\r\n  }\r\n\r\n  /** Tests if this flow has any scoped locals that must be free'd. */\r\n  get hasScopedLocals(): bool {\r\n    var scopedLocals = this.scopedLocals;\r\n    if (scopedLocals) {\r\n      // TODO: for (let local of scopedLocals.values()) {\r\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\r\n        let local = unchecked(_values[i]);\r\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Frees a single scoped local by its name. */\r\n  freeScopedDummyLocal(name: string): void {\r\n    var scopedLocals = assert(this.scopedLocals);\r\n    assert(scopedLocals.has(name));\r\n    let local = assert(scopedLocals.get(name));\r\n    assert(local.index == -1);\r\n    scopedLocals.delete(name);\r\n  }\r\n\r\n  /** Frees this flow's scoped variables and returns its parent flow. */\r\n  freeScopedLocals(): void {\r\n    var scopedLocals = this.scopedLocals;\r\n    if (scopedLocals) {\r\n      // TODO: for (let local of scopedLocals.values()) {\r\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\r\n        let local = unchecked(_values[i]);\r\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\r\n          this.freeTempLocal(local);\r\n        }\r\n      }\r\n      this.scopedLocals = null;\r\n    }\r\n  }\r\n\r\n  /** Looks up the local of the specified name in the current scope. */\r\n  lookupLocal(name: string): Local | null {\r\n    var current: Flow | null = this;\r\n    do {\r\n      let scope = current.scopedLocals;\r\n      if (scope !== null && scope.has(name)) return assert(scope.get(name));\r\n      current = current.parent;\r\n    } while (current);\r\n    var localsByName = this.parentFunction.localsByName;\r\n    if (localsByName.has(name)) return assert(localsByName.get(name));\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the element with the specified name relative to the scope of this flow. */\r\n  lookup(name: string): Element | null {\r\n    var element = this.lookupLocal(name);\r\n    if (element) return element;\r\n    return this.actualFunction.lookup(name);\r\n  }\r\n\r\n  /** Tests if the local at the specified index has the specified flag or flags. */\r\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\r\n    if (index < 0) return defaultIfInlined;\r\n    var localFlags = this.localFlags;\r\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\r\n  }\r\n\r\n  /** Tests if the local at the specified index has any of the specified flags. */\r\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\r\n    if (index < 0) return defaultIfInlined;\r\n    var localFlags = this.localFlags;\r\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\r\n  }\r\n\r\n  /** Sets the specified flag or flags on the local at the specified index. */\r\n  setLocalFlag(index: i32, flag: LocalFlags): void {\r\n    if (index < 0) return;\r\n    var localFlags = this.localFlags;\r\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\r\n    localFlags[index] = flags | flag;\r\n  }\r\n\r\n  /** Unsets the specified flag or flags on the local at the specified index. */\r\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\r\n    if (index < 0) return;\r\n    var localFlags = this.localFlags;\r\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\r\n    localFlags[index] = flags & ~flag;\r\n  }\r\n\r\n  /** Initializes `this` field flags. */\r\n  initThisFieldFlags(): void {\r\n    var actualFunction = this.actualFunction;\r\n    assert(actualFunction.is(CommonFlags.CONSTRUCTOR));\r\n    var actualParent = actualFunction.parent;\r\n    assert(actualParent.kind == ElementKind.CLASS);\r\n    var actualClass = <Class>actualParent;\r\n    this.thisFieldFlags = new Map();\r\n    var members = actualClass.members;\r\n    if (members) {\r\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = _values[i];\r\n        if (member.kind == ElementKind.FIELD) {\r\n          let field = <Field>member;\r\n          if (\r\n            // guaranteed by super\r\n            field.parent != actualClass ||\r\n            // has field initializer\r\n            field.initializerNode !== null ||\r\n            // is initialized as a ctor parameter\r\n            field.prototype.parameterIndex != -1 ||\r\n            // is safe to initialize with zero\r\n            field.type.isAny(TypeFlags.VALUE | TypeFlags.NULLABLE)\r\n          ) {\r\n            this.setThisFieldFlag(field, FieldFlags.INITIALIZED);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Tests if the specified `this` field has the specified flag or flags. */\r\n  isThisFieldFlag(field: Field, flag: FieldFlags): bool {\r\n    var fieldFlags = this.thisFieldFlags;\r\n    if (fieldFlags != null && fieldFlags.has(field)) {\r\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Sets the specified flag or flags on the given `this` field. */\r\n  setThisFieldFlag(field: Field, flag: FieldFlags): void {\r\n    var fieldFlags = this.thisFieldFlags;\r\n    if (fieldFlags) {\r\n      assert(this.actualFunction.is(CommonFlags.CONSTRUCTOR));\r\n      if (fieldFlags.has(field)) {\r\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\r\n        fieldFlags.set(field, flags | flag);\r\n      } else {\r\n        fieldFlags.set(field, flag);\r\n      }\r\n    } else {\r\n      assert(!this.actualFunction.is(CommonFlags.CONSTRUCTOR));\r\n    }\r\n  }\r\n\r\n  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */\r\n  pushBreakLabel(): string {\r\n    var parentFunction = this.parentFunction;\r\n    var id = parentFunction.nextBreakId++;\r\n    var stack = parentFunction.breakStack;\r\n    if (!stack) parentFunction.breakStack = [ id ];\r\n    else stack.push(id);\r\n    var label = id.toString();\r\n    parentFunction.breakLabel = label;\r\n    return label;\r\n  }\r\n\r\n  /** Pops the most recent break label from the stack. */\r\n  popBreakLabel(): void {\r\n    var parentFunction = this.parentFunction;\r\n    var stack = assert(parentFunction.breakStack);\r\n    var length = assert(stack.length);\r\n    stack.pop();\r\n    if (length > 1) {\r\n      parentFunction.breakLabel = stack[length - 2].toString();\r\n    } else {\r\n      parentFunction.breakLabel = null;\r\n      parentFunction.breakStack = null;\r\n    }\r\n  }\r\n\r\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\r\n  inherit(other: Flow): void {\r\n    assert(other.parentFunction == this.parentFunction);\r\n    assert(other.parent == this); // currently the case, but might change\r\n    var otherFlags = other.flags;\r\n\r\n    // respective inner flags are irrelevant if contexts differ\r\n    if (this.breakLabel != other.breakLabel) {\r\n      if (otherFlags & (FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\r\n        otherFlags &= ~FlowFlags.TERMINATES;\r\n      }\r\n      otherFlags &= ~(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS);\r\n    }\r\n    if (this.continueLabel != other.continueLabel) {\r\n      otherFlags &= ~(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\r\n    }\r\n\r\n    this.flags = this.flags | otherFlags; // what happens before is still true\r\n    this.localFlags = other.localFlags;\r\n    this.thisFieldFlags = other.thisFieldFlags;\r\n  }\r\n\r\n  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */\r\n  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.UNKNOWN): void {\r\n    assert(other.parentFunction == this.parentFunction);\r\n    switch (conditionKind) {\r\n      case ConditionKind.TRUE: this.inherit(other); // always executes\r\n      case ConditionKind.FALSE: return;             // never executes\r\n    }\r\n\r\n    // Note that flags in `this` flow have already happened. For instance,\r\n    // a return cannot be undone no matter what'd happen in subsequent branches,\r\n    // but an allocation, which doesn't terminate, can become conditional. Not\r\n    // all flags have a corresponding conditional flag that's tracked.\r\n\r\n    var thisFlags = this.flags;\r\n    var otherFlags = other.flags;\r\n    var newFlags = FlowFlags.NONE;\r\n\r\n    if (thisFlags & FlowFlags.RETURNS) { // nothing can change that\r\n      newFlags |= FlowFlags.RETURNS;\r\n    } else if (otherFlags & FlowFlags.RETURNS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\r\n    } else {\r\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_RETURNS;\r\n    }\r\n\r\n    // must be the case in both\r\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_WRAPPED;\r\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_NONNULL;\r\n\r\n    if (thisFlags & FlowFlags.THROWS) { // nothing can change that\r\n      newFlags |= FlowFlags.THROWS;\r\n    } else if (otherFlags & FlowFlags.THROWS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\r\n    } else {\r\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_THROWS;\r\n    }\r\n\r\n    if (thisFlags & FlowFlags.BREAKS) { // nothing can change that\r\n      newFlags |= FlowFlags.BREAKS;\r\n    } else if (other.breakLabel == this.breakLabel) {\r\n      if (otherFlags & FlowFlags.BREAKS) {\r\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\r\n      } else {\r\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_BREAKS;\r\n      }\r\n    } else {\r\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_BREAKS;\r\n    }\r\n\r\n    if (thisFlags & FlowFlags.CONTINUES) { // nothing can change that\r\n      newFlags |= FlowFlags.CONTINUES;\r\n    } else if (other.continueLabel === this.continueLabel) {\r\n      if (otherFlags & FlowFlags.CONTINUES) {\r\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\r\n      } else {\r\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\r\n      }\r\n    } else {\r\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_CONTINUES;\r\n    }\r\n\r\n    if (thisFlags & FlowFlags.ACCESSES_THIS) { // can become conditional\r\n      if (otherFlags & FlowFlags.ACCESSES_THIS) {\r\n        newFlags |= FlowFlags.ACCESSES_THIS;\r\n      } else {\r\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\r\n      }\r\n    } else if (otherFlags & FlowFlags.ACCESSES_THIS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\r\n    }\r\n\r\n    // may be the case in any\r\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MAY_RETURN_NONTHIS;\r\n\r\n    // must be the case in both\r\n    newFlags |= thisFlags & otherFlags & FlowFlags.CALLS_SUPER;\r\n\r\n    if (thisFlags & FlowFlags.TERMINATES) { // nothing can change that\r\n      newFlags |= FlowFlags.TERMINATES;\r\n    }\r\n\r\n    this.flags = newFlags | (thisFlags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));\r\n\r\n    // local flags\r\n    var thisLocalFlags = this.localFlags;\r\n    var numThisLocalFlags = thisLocalFlags.length;\r\n    var otherLocalFlags = other.localFlags;\r\n    var numOtherLocalFlags = otherLocalFlags.length;\r\n    var maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\r\n    for (let i = 0; i < maxLocalFlags; ++i) {\r\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\r\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\r\n      thisLocalFlags[i] = thisFlags & otherFlags & (\r\n        LocalFlags.CONSTANT  |\r\n        LocalFlags.WRAPPED   |\r\n        LocalFlags.NONNULL   |\r\n        LocalFlags.INITIALIZED\r\n      );\r\n    }\r\n\r\n    // field flags do not matter here since there's only INITIALIZED, which can\r\n    // only be set if it has been observed prior to entering the branch.\r\n  }\r\n\r\n  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */\r\n  inheritMutual(left: Flow, right: Flow): void {\r\n    assert(left.parentFunction == right.parentFunction);\r\n    assert(left.parentFunction == this.parentFunction);\r\n    // This differs from the previous method in that no flags are guaranteed\r\n    // to happen unless it is the case in both flows.\r\n\r\n    var leftFlags = left.flags;\r\n    var rightFlags = right.flags;\r\n    var newFlags = FlowFlags.NONE;\r\n\r\n    if (leftFlags & FlowFlags.RETURNS) {\r\n      if (rightFlags & FlowFlags.RETURNS) {\r\n        newFlags |= FlowFlags.RETURNS;\r\n      } else {\r\n        newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\r\n      }\r\n    } else if (rightFlags & FlowFlags.RETURNS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\r\n    } else {\r\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_RETURNS;\r\n    }\r\n\r\n    if ((leftFlags & FlowFlags.RETURNS_WRAPPED) && (rightFlags & FlowFlags.RETURNS_WRAPPED)) {\r\n      newFlags |= FlowFlags.RETURNS_WRAPPED;\r\n    }\r\n\r\n    if ((leftFlags & FlowFlags.RETURNS_NONNULL) && (rightFlags & FlowFlags.RETURNS_NONNULL)) {\r\n      newFlags |= FlowFlags.RETURNS_NONNULL;\r\n    }\r\n\r\n    if (leftFlags & FlowFlags.THROWS) {\r\n      if (rightFlags & FlowFlags.THROWS) {\r\n        newFlags |= FlowFlags.THROWS;\r\n      } else {\r\n        newFlags |= FlowFlags.CONDITIONALLY_THROWS;\r\n      }\r\n    } else if (rightFlags & FlowFlags.THROWS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\r\n    } else {\r\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_THROWS;\r\n    }\r\n\r\n    if (leftFlags & FlowFlags.BREAKS) {\r\n      if (rightFlags & FlowFlags.BREAKS) {\r\n        newFlags |= FlowFlags.BREAKS;\r\n      } else {\r\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\r\n      }\r\n    } else if (rightFlags & FlowFlags.BREAKS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\r\n    } else {\r\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_BREAKS;\r\n    }\r\n\r\n    if (leftFlags & FlowFlags.CONTINUES) {\r\n      if (rightFlags & FlowFlags.CONTINUES) {\r\n        newFlags |= FlowFlags.CONTINUES;\r\n      } else {\r\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\r\n      }\r\n    } else if (rightFlags & FlowFlags.CONTINUES) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\r\n    } else {\r\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\r\n    }\r\n\r\n    if (leftFlags & FlowFlags.ACCESSES_THIS) {\r\n      if (rightFlags & FlowFlags.ACCESSES_THIS) {\r\n        newFlags |= FlowFlags.ACCESSES_THIS;\r\n      } else {\r\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\r\n      }\r\n    } else if (rightFlags & FlowFlags.ACCESSES_THIS) {\r\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\r\n    } else {\r\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_ACCESSES_THIS;\r\n    }\r\n\r\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MAY_RETURN_NONTHIS;\r\n\r\n    if ((leftFlags & FlowFlags.CALLS_SUPER) && (rightFlags & FlowFlags.CALLS_SUPER)) {\r\n      newFlags |= FlowFlags.CALLS_SUPER;\r\n    }\r\n\r\n    if ((leftFlags & FlowFlags.TERMINATES) && (rightFlags & FlowFlags.TERMINATES)) {\r\n      newFlags |= FlowFlags.TERMINATES;\r\n    }\r\n\r\n    this.flags = newFlags | (this.flags & (FlowFlags.UNCHECKED_CONTEXT | FlowFlags.CTORPARAM_CONTEXT));\r\n\r\n    // local flags\r\n    var thisLocalFlags = this.localFlags;\r\n    if (leftFlags & FlowFlags.TERMINATES) {\r\n      if (!(rightFlags & FlowFlags.TERMINATES)) {\r\n        let rightLocalFlags = right.localFlags;\r\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\r\n          thisLocalFlags[i] = rightLocalFlags[i];\r\n        }\r\n      }\r\n    } else if (rightFlags & FlowFlags.TERMINATES) {\r\n      let leftLocalFlags = left.localFlags;\r\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\r\n        thisLocalFlags[i] = leftLocalFlags[i];\r\n      }\r\n    } else {\r\n      let leftLocalFlags = left.localFlags;\r\n      let numLeftLocalFlags = leftLocalFlags.length;\r\n      let rightLocalFlags = right.localFlags;\r\n      let numRightLocalFlags = rightLocalFlags.length;\r\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\r\n      for (let i = 0; i < maxLocalFlags; ++i) {\r\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\r\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\r\n        thisLocalFlags[i] = leftFlags & rightFlags & (\r\n          LocalFlags.CONSTANT  |\r\n          LocalFlags.WRAPPED   |\r\n          LocalFlags.NONNULL   |\r\n          LocalFlags.INITIALIZED\r\n        );\r\n      }\r\n    }\r\n\r\n    // field flags (currently only INITIALIZED, so can simplify)\r\n    var leftFieldFlags = left.thisFieldFlags;\r\n    if (leftFieldFlags) {\r\n      let newFieldFlags = new Map<Field,FieldFlags>();\r\n      let rightFieldFlags = assert(right.thisFieldFlags);\r\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\r\n        let key = _keys[i];\r\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\r\n        if (\r\n          (leftFlags & FieldFlags.INITIALIZED) != 0 && rightFieldFlags.has(key) && \r\n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.INITIALIZED)\r\n        ) {\r\n          newFieldFlags.set(key, FieldFlags.INITIALIZED);\r\n        }\r\n      }\r\n      this.thisFieldFlags = newFieldFlags;\r\n    } else {\r\n      assert(!right.thisFieldFlags);\r\n    }\r\n  }\r\n\r\n  /** Tests if the specified flows have differing local states. */\r\n  static hasIncompatibleLocalStates(before: Flow, after: Flow): bool {\r\n    var numThisLocalFlags = before.localFlags.length;\r\n    var numOtherLocalFlags = after.localFlags.length;\r\n    var parentFunction = before.parentFunction;\r\n    assert(parentFunction === after.parentFunction);\r\n    var localsByIndex = parentFunction.localsByIndex;\r\n    assert(localsByIndex === after.parentFunction.localsByIndex);\r\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\r\n      let local = localsByIndex[i];\r\n      let type = local.type;\r\n      if (type.isShortIntegerValue) {\r\n        if (before.isLocalFlag(i, LocalFlags.WRAPPED) && !after.isLocalFlag(i, LocalFlags.WRAPPED)) {\r\n          return true;\r\n        }\r\n      }\r\n      if (type.isNullableReference) {\r\n        if (before.isLocalFlag(i, LocalFlags.NONNULL) && !after.isLocalFlag(i, LocalFlags.NONNULL)) {\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Unifies local flags between this and the other flow. */\r\n  unifyLocalFlags(other: Flow): void {\r\n    var numThisLocalFlags = this.localFlags.length;\r\n    var numOtherLocalFlags = other.localFlags.length;\r\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\r\n      if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {\r\n        this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped\r\n      }\r\n      if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {\r\n        this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\r\n  isNonnull(expr: ExpressionRef, type: Type): bool {\r\n    if (!type.isNullableReference) return true;\r\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\r\n    // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else\r\n    // has already been handled by the nullable type check above.\r\n    switch (getExpressionId(expr)) {\r\n      case ExpressionId.LocalSet: {\r\n        if (!isLocalTee(expr)) break;\r\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\r\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\r\n      }\r\n      case ExpressionId.LocalGet: {\r\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\r\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\r\n  inheritNonnullIfTrue(\r\n    /** Expression being true. */\r\n    expr: ExpressionRef,\r\n    /** If specified, only set the flag if also nonnull in this flow. */\r\n    iff: Flow | null = null\r\n  ): void {\r\n    // A: `expr` is true-ish -> Q: how did that happen?\r\n\r\n    // The iff argument is useful in situations like\r\n    //\r\n    //  if (!ref) {\r\n    //    ref = new Ref();\r\n    //  }\r\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\r\n    //\r\n\r\n    switch (getExpressionId(expr)) {\r\n      case ExpressionId.LocalSet: {\r\n        if (!isLocalTee(expr)) break;\r\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\r\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\r\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\r\n        }\r\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\r\n        break;\r\n      }\r\n      case ExpressionId.LocalGet: {\r\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\r\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\r\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\r\n        }\r\n        break;\r\n      }\r\n      case ExpressionId.If: {\r\n        let ifFalse = getIfFalse(expr);\r\n        if (!ifFalse) break;\r\n        if (getExpressionId(ifFalse) == ExpressionId.Const) {\r\n          // Logical AND: (if (condition ifTrue 0))\r\n          // the only way this had become true is if condition and ifTrue are true\r\n          if (\r\n            (getExpressionType(ifFalse) == TypeRef.I32 && getConstValueI32(ifFalse) == 0) ||\r\n            (getExpressionType(ifFalse) == TypeRef.I64 && getConstValueI64Low(ifFalse) == 0 && getConstValueI64High(ifFalse) == 0)\r\n          ) {\r\n            this.inheritNonnullIfTrue(getIfCondition(expr), iff);\r\n            this.inheritNonnullIfTrue(getIfTrue(expr), iff);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ExpressionId.Unary: {\r\n        switch (getUnaryOp(expr)) {\r\n          case UnaryOp.EqzI32:\r\n          case UnaryOp.EqzI64: {\r\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ExpressionId.Binary: {\r\n        switch (getBinaryOp(expr)) {\r\n          case BinaryOp.EqI32: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\r\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\r\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n          case BinaryOp.EqI64: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\r\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 && getConstValueI64High(right) != 0)) {\r\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n          case BinaryOp.NeI32: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\r\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\r\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n          case BinaryOp.NeI64: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\r\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\r\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\r\n  inheritNonnullIfFalse(\r\n    /** Expression being false. */\r\n    expr: ExpressionRef,\r\n    /** If specified, only set the flag if also nonnull in this flow. */\r\n    iff: Flow | null = null\r\n  ): void {\r\n    // A: `expr` is false-ish -> Q: how did that happen?\r\n    switch (getExpressionId(expr)) {\r\n      case ExpressionId.Unary: {\r\n        switch (getUnaryOp(expr)) {\r\n          case UnaryOp.EqzI32:\r\n          case UnaryOp.EqzI64: {\r\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ExpressionId.If: {\r\n        let ifTrue = getIfTrue(expr);\r\n        if (getExpressionId(ifTrue) == ExpressionId.Const) {\r\n          let ifFalse = getIfFalse(expr);\r\n          if (!ifFalse) break;\r\n          // Logical OR: (if (condition 1 ifFalse))\r\n          // the only way this had become false is if condition and ifFalse are false\r\n          let exprType = getExpressionType(ifTrue);\r\n          if (\r\n            (exprType == TypeRef.I32 && getConstValueI32(ifTrue) != 0) ||\r\n            (exprType == TypeRef.I64 && (getConstValueI64Low(ifTrue) != 0 || getConstValueI64High(ifTrue) != 0))\r\n          ) {\r\n            this.inheritNonnullIfFalse(getIfCondition(expr), iff);\r\n            this.inheritNonnullIfFalse(getIfFalse(expr), iff);\r\n          }\r\n\r\n        }\r\n        break;\r\n      }\r\n      case ExpressionId.Binary: {\r\n        switch (getBinaryOp(expr)) {\r\n          // remember: we want to know how the _entire_ expression became FALSE (!)\r\n          case BinaryOp.EqI32: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\r\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\r\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n          case BinaryOp.EqI64: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\r\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\r\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n          case BinaryOp.NeI32: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\r\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true\r\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\r\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true\r\n            }\r\n            break;\r\n          }\r\n          case BinaryOp.NeI64: {\r\n            let left = getBinaryLeft(expr);\r\n            let right = getBinaryRight(expr);\r\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\r\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true for this to become false\r\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 || getConstValueI64High(right) != 0)) {\r\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true for this to become false\r\n            }\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\r\n   * expression might already have overflown and returns `false` only if the operation neglects\r\n   * any possible combination of garbage bits being present.\r\n   */\r\n  canOverflow(expr: ExpressionRef, type: Type): bool {\r\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\r\n    // opportunities here, obviously.\r\n    assert(type != Type.void);\r\n\r\n    // types other than i8, u8, i16, u16 and bool do not overflow\r\n    if (!type.isShortIntegerValue) return false;\r\n\r\n    var operand: ExpressionRef;\r\n    switch (getExpressionId(expr)) {\r\n\r\n      // overflows if the local isn't wrapped or the conversion does\r\n      case ExpressionId.LocalGet: {\r\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\r\n        return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)\r\n            || canConversionOverflow(local.type, type);\r\n      }\r\n\r\n      // overflows if the value does\r\n      case ExpressionId.LocalSet: { // tee\r\n        assert(isLocalTee(expr));\r\n        return this.canOverflow(getLocalSetValue(expr), type);\r\n      }\r\n\r\n      // overflows if the conversion does (globals are wrapped on set)\r\n      case ExpressionId.GlobalGet: {\r\n        // TODO: this is inefficient because it has to read a string\r\n        let global = assert(this.parentFunction.program.elementsByName.get(assert(getGlobalGetName(expr))));\r\n        assert(global.kind == ElementKind.GLOBAL);\r\n        return canConversionOverflow((<Global>global).type, type);\r\n      }\r\n\r\n      case ExpressionId.Binary: {\r\n        switch (getBinaryOp(expr)) {\r\n\r\n          // comparisons do not overflow (result is 0 or 1)\r\n          case BinaryOp.EqI32:\r\n          case BinaryOp.EqI64:\r\n          case BinaryOp.EqF32:\r\n          case BinaryOp.EqF64:\r\n          case BinaryOp.NeI32:\r\n          case BinaryOp.NeI64:\r\n          case BinaryOp.NeF32:\r\n          case BinaryOp.NeF64:\r\n          case BinaryOp.LtI32:\r\n          case BinaryOp.LtU32:\r\n          case BinaryOp.LtI64:\r\n          case BinaryOp.LtU64:\r\n          case BinaryOp.LtF32:\r\n          case BinaryOp.LtF64:\r\n          case BinaryOp.LeI32:\r\n          case BinaryOp.LeU32:\r\n          case BinaryOp.LeI64:\r\n          case BinaryOp.LeU64:\r\n          case BinaryOp.LeF32:\r\n          case BinaryOp.LeF64:\r\n          case BinaryOp.GtI32:\r\n          case BinaryOp.GtU32:\r\n          case BinaryOp.GtI64:\r\n          case BinaryOp.GtU64:\r\n          case BinaryOp.GtF32:\r\n          case BinaryOp.GtF64:\r\n          case BinaryOp.GeI32:\r\n          case BinaryOp.GeU32:\r\n          case BinaryOp.GeI64:\r\n          case BinaryOp.GeU64:\r\n          case BinaryOp.GeF32:\r\n          case BinaryOp.GeF64: return false;\r\n\r\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\r\n          case BinaryOp.MulI32: {\r\n            return !(\r\n              (\r\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\r\n                (\r\n                  getConstValueI32(operand) == 0 ||\r\n                  (\r\n                    getConstValueI32(operand) == 1 &&\r\n                    !this.canOverflow(getBinaryRight(expr), type)\r\n                  )\r\n                )\r\n              ) || (\r\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\r\n                (\r\n                  getConstValueI32(operand) == 0 ||\r\n                  (\r\n                    getConstValueI32(operand) == 1 &&\r\n                    !this.canOverflow(getBinaryLeft(expr), type)\r\n                  )\r\n                )\r\n              )\r\n            );\r\n          }\r\n\r\n          // result won't overflow if one side is a constant less than this type's mask or one side\r\n          // is wrapped\r\n          case BinaryOp.AndI32: {\r\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\r\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\r\n            return !(\r\n              (\r\n                (\r\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\r\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\r\n                ) || !this.canOverflow(operand, type)\r\n              ) || (\r\n                (\r\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\r\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\r\n                ) || !this.canOverflow(operand, type)\r\n              )\r\n            );\r\n          }\r\n\r\n          // overflows if the shift doesn't clear potential garbage bits\r\n          case BinaryOp.ShlI32: {\r\n            let shift = 32 - type.size;\r\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\r\n                || getConstValueI32(operand) < shift;\r\n          }\r\n\r\n          // overflows if the value does and the shift doesn't clear potential garbage bits\r\n          case BinaryOp.ShrI32: {\r\n            let shift = 32 - type.size;\r\n            return this.canOverflow(getBinaryLeft(expr), type) && (\r\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\r\n              getConstValueI32(operand) < shift\r\n            );\r\n          }\r\n\r\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\r\n          // wrapped, it can't overflow.\r\n          case BinaryOp.ShrU32: {\r\n            let shift = 32 - type.size;\r\n            return type.isSignedIntegerValue\r\n              ? !(\r\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\r\n                  getConstValueI32(operand) > shift // must clear MSB\r\n                )\r\n              : this.canOverflow(getBinaryLeft(expr), type) &&\r\n                !(\r\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\r\n                  getConstValueI32(operand) >= shift // can leave MSB\r\n                );\r\n          }\r\n\r\n          // overflows if any side does\r\n          case BinaryOp.DivU32:\r\n          case BinaryOp.RemI32:\r\n          case BinaryOp.RemU32: {\r\n            return this.canOverflow(getBinaryLeft(expr), type)\r\n                || this.canOverflow(getBinaryRight(expr), type);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n\r\n      case ExpressionId.Unary: {\r\n        switch (getUnaryOp(expr)) {\r\n\r\n          // comparisons do not overflow (result is 0 or 1)\r\n          case UnaryOp.EqzI32:\r\n          case UnaryOp.EqzI64: return false;\r\n\r\n          // overflow if the maximum result (32) cannot be represented in the target type\r\n          case UnaryOp.ClzI32:\r\n          case UnaryOp.CtzI32:\r\n          case UnaryOp.PopcntI32: return type.size < 7;\r\n\r\n          // sign extensions overflow if result can have high garbage bits in the target type\r\n          case UnaryOp.Extend8I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 8);\r\n          case UnaryOp.Extend8I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 8);\r\n          case UnaryOp.Extend16I32: return type.size < (type.isUnsignedIntegerValue ? 32 : 16);\r\n          case UnaryOp.Extend16I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 16);\r\n          case UnaryOp.Extend32I64: return type.size < (type.isUnsignedIntegerValue ? 64 : 32);\r\n        }\r\n        break;\r\n      }\r\n\r\n      // overflows if the value cannot be represented in the target type\r\n      case ExpressionId.Const: {\r\n        let value: i32 = 0;\r\n        switch (<u32>getExpressionType(expr)) {\r\n          case <u32>TypeRef.I32: { value = getConstValueI32(expr); break; }\r\n          case <u32>TypeRef.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\r\n          case <u32>TypeRef.F32: { value = i32(getConstValueF32(expr)); break; }\r\n          case <u32>TypeRef.F64: { value = i32(getConstValueF64(expr)); break; }\r\n          default: assert(false);\r\n        }\r\n        switch (type.kind) {\r\n          case TypeKind.I8: return value < <i32>i8.MIN_VALUE || value > <i32>i8.MAX_VALUE;\r\n          case TypeKind.I16: return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\r\n          case TypeKind.U8: return value < 0 || value > <i32>u8.MAX_VALUE;\r\n          case TypeKind.U16: return value < 0 || value > <i32>u16.MAX_VALUE;\r\n          case TypeKind.BOOL: return (value & ~1) != 0;\r\n        }\r\n        break;\r\n      }\r\n\r\n      // overflows if the conversion does\r\n      case ExpressionId.Load: {\r\n        let fromType: Type;\r\n        let signed = isLoadSigned(expr);\r\n        switch (getLoadBytes(expr)) {\r\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\r\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\r\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\r\n        }\r\n        return canConversionOverflow(fromType, type);\r\n      }\r\n\r\n      // overflows if the result does, which is either\r\n      // - the last expression of the block, by contract, if the block doesn't have a label\r\n      // - the last expression or the value of an inner br if the block has a label (TODO)\r\n      case ExpressionId.Block: {\r\n        if (!getBlockName(expr)) {\r\n          let size = assert(getBlockChildCount(expr));\r\n          let last = getBlockChildAt(expr, size - 1);\r\n          return this.canOverflow(last, type);\r\n        }\r\n        break;\r\n      }\r\n\r\n      // overflows if either side does\r\n      case ExpressionId.If: {\r\n        return this.canOverflow(getIfTrue(expr), type)\r\n            || this.canOverflow(assert(getIfFalse(expr)), type);\r\n      }\r\n\r\n      // overflows if either side does\r\n      case ExpressionId.Select: {\r\n        return this.canOverflow(getSelectThen(expr), type)\r\n            || this.canOverflow(getSelectElse(expr), type);\r\n      }\r\n\r\n      // overflows if the call does not return a wrapped value or the conversion does\r\n      case ExpressionId.Call: {\r\n        let program = this.parentFunction.program;\r\n        let instancesByName = program.instancesByName;\r\n        let instanceName = assert(getCallTarget(expr));\r\n        if (instancesByName.has(instanceName)) {\r\n          let instance = assert(instancesByName.get(instanceName));\r\n          assert(instance.kind == ElementKind.FUNCTION);\r\n          let functionInstance = <Function>instance;\r\n          let returnType = functionInstance.signature.returnType;\r\n          return !functionInstance.flow.is(FlowFlags.RETURNS_WRAPPED)\r\n              || canConversionOverflow(returnType, type);\r\n        }\r\n        return false; // assume no overflow for builtins\r\n      }\r\n\r\n      // doesn't technically overflow\r\n      case ExpressionId.Unreachable: return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  toString(): string {\r\n    var levels = 0;\r\n    var parent = this.parent;\r\n    while (parent) {\r\n      parent = parent.parent;\r\n      ++levels;\r\n    }\r\n    var sb = new Array<string>();\r\n    if (this.is(FlowFlags.RETURNS)) sb.push(\"RETURNS\");\r\n    if (this.is(FlowFlags.RETURNS_WRAPPED)) sb.push(\"RETURNS_WRAPPED\");\r\n    if (this.is(FlowFlags.RETURNS_NONNULL)) sb.push(\"RETURNS_NONNULL\");\r\n    if (this.is(FlowFlags.THROWS)) sb.push(\"THROWS\");\r\n    if (this.is(FlowFlags.BREAKS)) sb.push(\"BREAKS\");\r\n    if (this.is(FlowFlags.CONTINUES)) sb.push(\"CONTINUES\");\r\n    if (this.is(FlowFlags.ACCESSES_THIS)) sb.push(\"ACCESSES_THIS\");\r\n    if (this.is(FlowFlags.CALLS_SUPER)) sb.push(\"CALLS_SUPER\");\r\n    if (this.is(FlowFlags.TERMINATES)) sb.push(\"TERMINATES\");\r\n    if (this.is(FlowFlags.CONDITIONALLY_RETURNS)) sb.push(\"CONDITIONALLY_RETURNS\");\r\n    if (this.is(FlowFlags.CONDITIONALLY_THROWS)) sb.push(\"CONDITIONALLY_THROWS\");\r\n    if (this.is(FlowFlags.CONDITIONALLY_BREAKS)) sb.push(\"CONDITIONALLY_BREAKS\");\r\n    if (this.is(FlowFlags.CONDITIONALLY_CONTINUES)) sb.push(\"CONDITIONALLY_CONTINUES\");\r\n    if (this.is(FlowFlags.CONDITIONALLY_ACCESSES_THIS)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\r\n    if (this.is(FlowFlags.MAY_RETURN_NONTHIS)) sb.push(\"MAY_RETURN_NONTHIS\");\r\n    return \"Flow(\" + this.actualFunction.toString() + \")[\" + levels.toString() + \"] \" + sb.join(\" \");\r\n  }\r\n}\r\n\r\n/** Tests if a conversion from one type to another can technically overflow. */\r\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\r\n  return toType.isShortIntegerValue && (\r\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\r\n    fromType.size > toType.size ||                                 // larger int to small int\r\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\r\n  );\r\n}\r\n\r\nexport { findUsedLocals } from \"./passes/findusedlocals\";\r\n","/**\r\n * @fileoverview JavaScript glue code.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport \"../../../std/portable/index\";\r\nimport \"../binaryen\";\r\nimport \"./float\";\r\nimport \"./i64\";\r\nimport \"./collections\";\r\n","/**\r\n * @license\r\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * SPDX-License-Identifier: Apache-2.0\r\n */\r\n\r\n/**\r\n * @fileoverview The C-like and re-exported public compiler interface.\r\n *\r\n * The intended way to consume the compiler sources is to import this\r\n * file, which again exports all relevant functions, classes and constants\r\n * as a flat namespace.\r\n *\r\n * Note though that the compiler sources are written in \"portable\r\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\r\n * to WebAssembly with asc, and as such require additional glue code\r\n * depending on the target.\r\n *\r\n * When compiling to JavaScript `glue/js/index.js` must be included.\r\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\r\n */\r\n\r\nimport { Target, Feature } from \"./common\";\r\nimport { Compiler, Options } from \"./compiler\";\r\nimport { IDLBuilder, TSDBuilder } from \"./definitions\";\r\nimport { DiagnosticMessage, DiagnosticCategory, formatDiagnosticMessage } from \"./diagnostics\";\r\nimport { Module } from \"./module\";\r\nimport { Program } from \"./program\";\r\n\r\n// Options\r\n\r\n/** Creates a new set of compiler options. */\r\nexport function newOptions(): Options {\r\n  return new Options();\r\n}\r\n\r\n/** Sets the `target` option. */\r\nexport function setTarget(options: Options, target: Target): void {\r\n  options.target = target;\r\n}\r\n\r\n/** Sets the `noAssert` option. */\r\nexport function setNoAssert(options: Options, noAssert: bool): void {\r\n  options.noAssert = noAssert;\r\n}\r\n\r\n/** Sets the `exportMemory` option. */\r\nexport function setExportMemory(options: Options, exportMemory: bool): void {\r\n  options.exportMemory = exportMemory;\r\n}\r\n\r\n/** Sets the `importMemory` option. */\r\nexport function setImportMemory(options: Options, importMemory: bool): void {\r\n  options.importMemory = importMemory;\r\n}\r\n\r\n/** Sets the `initialMemory` option. */\r\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\r\n  options.initialMemory = initialMemory;\r\n}\r\n\r\n/** Sets the `maximumMemory` option. */\r\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\r\n  options.maximumMemory = maximumMemory;\r\n}\r\n\r\n/** Sets the `sharedMemory` option. */\r\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\r\n  options.sharedMemory = sharedMemory;\r\n}\r\n\r\n/** Sets the `importTable` option. */\r\nexport function setImportTable(options: Options, importTable: bool): void {\r\n  options.importTable = importTable;\r\n}\r\n\r\n/** Sets the `exportTable` option. */\r\nexport function setExportTable(options: Options, exportTable: bool): void {\r\n  options.exportTable = exportTable;\r\n}\r\n\r\n/** Sets the `sourceMap` option. */\r\nexport function setSourceMap(options: Options, sourceMap: bool): void {\r\n  options.sourceMap = sourceMap;\r\n}\r\n\r\n/** Sets the `memoryBase` option. */\r\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\r\n  options.memoryBase = memoryBase;\r\n}\r\n\r\n/** Sets the `tableBase` option. */\r\nexport function setTableBase(options: Options, tableBase: u32): void {\r\n  options.tableBase = tableBase;\r\n}\r\n\r\n/** Sets a 'globalAliases' value. */\r\nexport function setGlobalAlias(options: Options, alias: string, name: string): void {\r\n  var globalAliases = options.globalAliases;\r\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\r\n  globalAliases.set(alias, name);\r\n}\r\n\r\n/** Sets the `explicitStart` option. */\r\nexport function setExplicitStart(options: Options, explicitStart: bool): void {\r\n  options.explicitStart = explicitStart;\r\n}\r\n\r\n/** Sets the `noUnsafe` option. */\r\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\r\n  options.noUnsafe = noUnsafe;\r\n}\r\n\r\n/** Sets the `lowMemoryLimit` option. */\r\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\r\n  options.lowMemoryLimit = lowMemoryLimit;\r\n}\r\n\r\n/** Sets the `exportRuntime` option. */\r\nexport function setExportRuntime(options: Options, exportRuntime: bool): void {\r\n  options.exportRuntime = exportRuntime;\r\n}\r\n\r\n/** Default stack size. */\r\nexport const DEFAULT_STACK_SIZE = 16384;\r\n\r\n/** Sets the `stackSize` option. */\r\nexport function setStackSize(options: Options, stackSize: i32): void {\r\n  options.stackSize = stackSize;\r\n}\r\n\r\n/** Sets the bundle semantic version. */\r\nexport function setBundleVersion(\r\n  options: Options,\r\n  bundleMajorVersion: i32,\r\n  bundleMinorVersion: i32,\r\n  bundlePatchVersion: i32,\r\n): void {\r\n  options.bundleMajorVersion = bundleMajorVersion;\r\n  options.bundleMinorVersion = bundleMinorVersion;\r\n  options.bundlePatchVersion = bundlePatchVersion;\r\n}\r\n\r\n/** Sign extension operations. */\r\nexport const FEATURE_SIGN_EXTENSION = Feature.SIGN_EXTENSION;\r\n/** Mutable global imports and exports. */\r\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MUTABLE_GLOBALS;\r\n/** Non-trapping float to int conversion operations. */\r\nexport const FEATURE_NONTRAPPING_F2I = Feature.NONTRAPPING_F2I;\r\n/** Bulk memory operations. */\r\nexport const FEATURE_BULK_MEMORY = Feature.BULK_MEMORY;\r\n/** SIMD types and operations. */\r\nexport const FEATURE_SIMD = Feature.SIMD;\r\n/** Threading and atomic operations. */\r\nexport const FEATURE_THREADS = Feature.THREADS;\r\n/** Exception handling operations. */\r\nexport const FEATURE_EXCEPTION_HANDLING = Feature.EXCEPTION_HANDLING;\r\n/** Tail call operations. */\r\nexport const FEATURE_TAIL_CALLS = Feature.TAIL_CALLS;\r\n/** Reference types. */\r\nexport const FEATURE_REFERENCE_TYPES = Feature.REFERENCE_TYPES;\r\n/** Multi value types. */\r\nexport const FEATURE_MULTI_VALUE = Feature.MULTI_VALUE;\r\n/** Garbage collection. */\r\nexport const FEATURE_GC = Feature.GC;\r\n/** Memory64. */\r\nexport const FEATURE_MEMORY64 = Feature.MEMORY64;\r\n\r\n/** Enables a specific feature. */\r\nexport function enableFeature(options: Options, feature: Feature): void {\r\n  options.features |= feature;\r\n}\r\n\r\n/** Disables a specific feature. */\r\nexport function disableFeature(options: Options, feature: Feature): void {\r\n  options.features &= ~feature;\r\n}\r\n\r\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\r\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\r\n  options.optimizeLevelHint = optimizeLevel;\r\n  options.shrinkLevelHint = shrinkLevel;\r\n}\r\n\r\n/** Sets the `pedantic` option. */\r\nexport function setPedantic(options: Options, pedantic: bool): void {\r\n  options.pedantic = pedantic;\r\n}\r\n\r\n// Program\r\n\r\n/** Creates a new Program. */\r\nexport function newProgram(options: Options): Program {\r\n  return new Program(options);\r\n}\r\n\r\n/** Obtains the next diagnostic message. Returns `null` once complete. */\r\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\r\n  return program.diagnosticsOffset < program.diagnostics.length\r\n    ? program.diagnostics[program.diagnosticsOffset++]\r\n    : null;\r\n}\r\n\r\n/** Obtains the source of the given file. */\r\nexport function getSource(program: Program, internalPath: string): string | null {\r\n  return program.getSource(internalPath);\r\n}\r\n\r\n/** Formats a diagnostic message to a string. */\r\nexport { formatDiagnosticMessage as formatDiagnostic };\r\n\r\n/** Tests whether a diagnostic is informatory. */\r\nexport function isInfo(message: DiagnosticMessage): bool {\r\n  return message.category == DiagnosticCategory.INFO;\r\n}\r\n\r\n/** Tests whether a diagnostic is a warning. */\r\nexport function isWarning(message: DiagnosticMessage): bool {\r\n  return message.category == DiagnosticCategory.WARNING;\r\n}\r\n\r\n/** Tests whether a diagnostic is an error. */\r\nexport function isError(message: DiagnosticMessage): bool {\r\n  return message.category == DiagnosticCategory.ERROR;\r\n}\r\n\r\n// Parser\r\n\r\n/** Parses a source file. If `parser` has been omitted a new one is created. */\r\nexport function parse(\r\n  /** Program reference. */\r\n  program: Program,\r\n  /** Source text of the file, or `null` to indicate not found. */\r\n  text: string | null,\r\n  /** Normalized path of the file. */\r\n  path: string,\r\n  /** Whether this is an entry file. */\r\n  isEntry: bool = false\r\n): void {\r\n  program.parser.parseFile(text, path, isEntry);\r\n}\r\n\r\n/** Obtains the next required file's path. Returns `null` once complete. */\r\nexport function nextFile(program: Program): string | null {\r\n  return program.parser.nextFile();\r\n}\r\n\r\n/** Obtains the path of the dependee of a given imported file. */\r\nexport function getDependee(program: Program, file: string): string | null {\r\n  return program.parser.getDependee(file);\r\n}\r\n\r\n// Compiler\r\n\r\n/** Initializes the program pre-emptively for transform hooks. */\r\nexport function initializeProgram(program: Program): void {\r\n  program.initialize();\r\n}\r\n\r\n/** Compiles the parsed sources to a module. */\r\nexport function compile(program: Program): Module {\r\n  program.parser.finish();\r\n  return new Compiler(program).compile();\r\n}\r\n\r\n/** Builds WebIDL definitions for the specified program. */\r\nexport function buildIDL(program: Program): string {\r\n  return IDLBuilder.build(program);\r\n}\r\n\r\n/** Builds TypeScript definitions for the specified program. */\r\nexport function buildTSD(program: Program): string {\r\n  return TSDBuilder.build(program);\r\n}\r\n\r\n// Full API\r\nexport * from \"./ast\";\r\nexport * from \"./common\";\r\nexport * from \"./compiler\";\r\nexport * from \"./definitions\";\r\nexport * from \"./diagnostics\";\r\nexport * from \"./flow\";\r\nexport * from \"./module\";\r\nexport * from \"./parser\";\r\nexport * from \"./program\";\r\nexport * from \"./resolver\";\r\nexport * from \"./tokenizer\";\r\nexport * from \"./types\";\r\nexport * from \"./extra/ast\";\r\nimport * as util from \"./util/index\";\r\nexport { util };\r\n","/**\r\n * @fileoverview A thin wrapper around Binaryen's C-API.\r\n *\r\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\r\n * though it currently imports binaryen.js, none of the JS APIs it\r\n * provides are used.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport { BuiltinNames } from \"./builtins\";\r\nimport { Target } from \"./common\";\r\nimport * as binaryen from \"./glue/binaryen\";\r\n\r\n/** A Binaryen-compatible index. */\r\nexport type Index = binaryen.Index;\r\n/** Reference to a Binaryen-compatible string. */\r\nexport type StringRef = binaryen.StringRef;\r\n/** Reference to a Binaryen module. */\r\nexport type ModuleRef = binaryen.ModuleRef;\r\n/** Reference to a Binaryen function. */\r\nexport type FunctionRef = binaryen.FunctionRef;\r\n/** Reference to a Binaryen expression. */\r\nexport type ExpressionRef = binaryen.ExpressionRef;\r\n/** Reference to a Binaryen global. */\r\nexport type GlobalRef = binaryen.GlobalRef;\r\n/** Reference to a Binaryen tag. */\r\nexport type TagRef = binaryen.TagRef;\r\n/** Reference to a Binaryen import. */\r\nexport type ImportRef = binaryen.ImportRef;\r\n/** Reference to a Binaryen export. */\r\nexport type ExportRef = binaryen.ExportRef;\r\n/** Reference to a Binaryen relooper. */\r\nexport type RelooperRef = binaryen.RelooperRef;\r\n/** Reference to a Binaryen relooper block. */\r\nexport type RelooperBlockRef = binaryen.RelooperBlockRef;\r\n\r\n// The following constants must be updated by running scripts/update-constants.\r\n// This is necessary because the functions are not yet callable with Binaryen\r\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\r\n// that this essentially fixes the compiler to specific versions of Binaryen\r\n// sometimes, because these constants can differ between Binaryen versions.\r\n\r\n/** Reference to a Binaryen type. */\r\nexport type TypeRef = binaryen.TypeRef;\r\nexport namespace TypeRef {\r\n  export const None: TypeRef = 0 /* _BinaryenTypeNone */;\r\n  export const Unreachable: TypeRef = 1 /* _BinaryenTypeUnreachable */;\r\n  export const I32: TypeRef = 2 /* _BinaryenTypeInt32 */;\r\n  export const I64: TypeRef = 3 /* _BinaryenTypeInt64 */;\r\n  export const F32: TypeRef = 4 /* _BinaryenTypeFloat32 */;\r\n  export const F64: TypeRef = 5 /* _BinaryenTypeFloat64 */;\r\n  export const V128: TypeRef = 6 /* _BinaryenTypeVec128 */;\r\n  export const Funcref: TypeRef = 7 /* _BinaryenTypeFuncref */;\r\n  export const Externref: TypeRef = 8 /* _BinaryenTypeExternref */;\r\n  export const Anyref: TypeRef = 9 /* _BinaryenTypeAnyref */;\r\n  export const Eqref: TypeRef = 10 /* _BinaryenTypeEqref */;\r\n  export const I31ref: TypeRef = 11 /* _BinaryenTypeI31ref */;\r\n  export const Dataref: TypeRef = 12 /* _BinaryenTypeDataref */;\r\n  export const Auto: TypeRef = -1 /* _BinaryenTypeAuto */;\r\n}\r\n\r\n/** Binaryen feature constants. */\r\nexport enum FeatureFlags {\r\n  MVP = 0 /* _BinaryenFeatureMVP */,\r\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\r\n  MutableGloabls = 2 /* _BinaryenFeatureMutableGlobals */,\r\n  NontrappingFPToInt = 4 /* _BinaryenFeatureNontrappingFPToInt */,\r\n  SIMD128 = 8 /* _BinaryenFeatureSIMD128 */,\r\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\r\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\r\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\r\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\r\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\r\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\r\n  GC = 1024 /* _BinaryenFeatureGC */,\r\n  Memory64 = 2048 /* _BinaryenFeatureMemory64 */,\r\n  TypedFunctionReferences  = 4096 /* _BinaryenTypedFunctionReferences */,\r\n  All = 8191 /* _BinaryenFeatureAll */\r\n}\r\n\r\n/** Binaryen expression id constants. */\r\nexport enum ExpressionId {\r\n  Invalid = 0 /* _BinaryenInvalidId */,\r\n  Block = 1 /* _BinaryenBlockId */,\r\n  If = 2 /* _BinaryenIfId */,\r\n  Loop = 3 /* _BinaryenLoopId */,\r\n  Break = 4 /* _BinaryenBreakId */,\r\n  Switch = 5 /* _BinaryenSwitchId */,\r\n  Call = 6 /* _BinaryenCallId */,\r\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\r\n  LocalGet = 8 /* _BinaryenLocalGetId */,\r\n  LocalSet = 9 /* _BinaryenLocalSetId */,\r\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\r\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\r\n  Load = 12 /* _BinaryenLoadId */,\r\n  Store = 13 /* _BinaryenStoreId */,\r\n  Const = 14 /* _BinaryenConstId */,\r\n  Unary = 15 /* _BinaryenUnaryId */,\r\n  Binary = 16 /* _BinaryenBinaryId */,\r\n  Select = 17 /* _BinaryenSelectId */,\r\n  Drop = 18 /* _BinaryenDropId */,\r\n  Return = 19 /* _BinaryenReturnId */,\r\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\r\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\r\n  Nop = 22 /* _BinaryenNopId */,\r\n  Unreachable = 23 /* _BinaryenUnreachableId */,\r\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\r\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\r\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\r\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\r\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\r\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\r\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\r\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\r\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\r\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\r\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\r\n  SIMDLoadStoreLane = 35 /* _BinaryenSIMDLoadStoreLaneId */,\r\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\r\n  DataDrop = 37 /* _BinaryenDataDropId */,\r\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\r\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\r\n  Pop = 40 /* _BinaryenPopId */,\r\n  RefNull = 41 /* _BinaryenRefNullId */,\r\n  RefIs = 42 /* _BinaryenRefIsId */,\r\n  RefFunc = 43 /* _BinaryenRefFuncId */,\r\n  RefEq = 44 /* _BinaryenRefEqId */,\r\n  Try = 45 /* _BinaryenTryId */,\r\n  Throw = 46 /* _BinaryenThrowId */,\r\n  Rethrow = 47 /* _BinaryenRethrowId */,\r\n  TupleMake = 48 /* _BinaryenTupleMakeId */,\r\n  TupleExtract = 49 /* _BinaryenTupleExtractId */,\r\n  I31New = 50 /* _BinaryenI31NewId */,\r\n  I31Get = 51 /* _BinaryenI31GetId */,\r\n  CallRef = 52 /* _BinaryenCallRefId */,\r\n  RefTest = 53 /* _BinaryenRefTestId */,\r\n  RefCast = 54 /* _BinaryenRefCastId */,\r\n  BrOn = 55 /* _BinaryenBrOnId */,\r\n  RttCanon = 56 /* _BinaryenRttCanonId */,\r\n  RttSub = 57 /* _BinaryenRttSubId */,\r\n  StructNew = 58 /* _BinaryenStructNewId */,\r\n  StructGet = 59 /* _BinaryenStructGetId */,\r\n  StructSet = 60 /* _BinaryenStructSetId */,\r\n  ArrayNew = 61 /* _BinaryenArrayNewId */,\r\n  ArrayGet = 62 /* _BinaryenArrayGetId */,\r\n  ArraySet = 63 /* _BinaryenArraySetId */,\r\n  ArrayLen = 64 /* _BinaryenArrayLenId */,\r\n  RefAs = 65 /* _BinaryenRefAsId */\r\n}\r\n\r\n/** Binaryen external kind constants. */\r\nexport enum ExternalKind {\r\n  Function = 0 /* _BinaryenExternalFunction */,\r\n  Table = 1 /* _BinaryenExternalTable */,\r\n  Memory = 2 /* _BinaryenExternalMemory */,\r\n  Global = 3 /* _BinaryenExternalGlobal */,\r\n  Tag = 4 /* _BinaryenExternalTag */\r\n}\r\n\r\n/** Binaryen unary operation constants. */\r\nexport enum UnaryOp {\r\n  /** i32.clz */\r\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\r\n  /** i64.clz */\r\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\r\n  /** i32.ctz */\r\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\r\n  /** i64.ctz */\r\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\r\n  /** i32.popcnt */\r\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\r\n  /** i64.popcnt */\r\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\r\n  /** f32.neg */\r\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\r\n  /** f64.neg */\r\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\r\n  /** f32.abs */\r\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\r\n  /** f64.abs */\r\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\r\n  /** f32.ceil */\r\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\r\n  /** f64.ceil */\r\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\r\n  /** f32.floor */\r\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\r\n  /** f64.floor */\r\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\r\n  /** f32.trunc */\r\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\r\n  /** f64.trunc */\r\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\r\n  /** f32.nearest */\r\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\r\n  /** f64.nearest */\r\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\r\n  /** f32.sqrt */\r\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\r\n  /** f64.sqrt */\r\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\r\n  /** i32.eqz */\r\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\r\n  /** i64.eqz */\r\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\r\n  /** i64.extend_i32_s */\r\n  ExtendI32ToI64 = 22 /* _BinaryenExtendSInt32 */,\r\n  /** i64.extend_i32_u */\r\n  ExtendU32ToU64 = 23 /* _BinaryenExtendUInt32 */,\r\n  /** i32.wrap_i64 */\r\n  WrapI64ToI32 = 24 /* _BinaryenWrapInt64 */,\r\n  /** i32.trunc_f32_s */\r\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\r\n  /** i64.trunc_f32_s */\r\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\r\n  /** i32.trunc_f32_u */\r\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\r\n  /** i64.trunc_f32_u */\r\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\r\n  /** i32.trunc_f64_s */\r\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\r\n  /** i64.trunc_f64_s */\r\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\r\n  /** i32.trunc_f64_u */\r\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\r\n  /** i64.trunc_f64_u */\r\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\r\n  /** i32.reinterpret_f32 */\r\n  ReinterpretF32ToI32 = 33 /* _BinaryenReinterpretFloat32 */,\r\n  /** i64.reinterpret_f64 */\r\n  ReinterpretF64ToI64 = 34 /* _BinaryenReinterpretFloat64 */,\r\n  /** f32.convert_i32_s */\r\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\r\n  /** f64.convert_i32_s */\r\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\r\n  /** f32.convert_i32_u */\r\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\r\n  /** f64.convert_i32_u */\r\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\r\n  /** f32.convert_i64_s */\r\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\r\n  /** f64.convert_i64_s */\r\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\r\n  /** f32.convert_i64_u */\r\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\r\n  /** f64.convert_i64_u */\r\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\r\n  /** f64.promote.f32 */\r\n  PromoteF32ToF64 = 43 /* _BinaryenPromoteFloat32 */,\r\n  /** f32.demote_f64 */\r\n  DemoteF64ToF32 = 44 /* _BinaryenDemoteFloat64 */,\r\n  /** f32.reinterpret_i32 */\r\n  ReinterpretI32ToF32 = 45 /* _BinaryenReinterpretInt32 */,\r\n  /** f64.reinterpret_i64 */\r\n  ReinterpretI64ToF64 = 46 /* _BinaryenReinterpretInt64 */,\r\n\r\n  // see: https://github.com/WebAssembly/sign-extension-ops\r\n\r\n  /** i32.extend8_s */\r\n  Extend8I32 = 47 /* _BinaryenExtendS8Int32 */,\r\n  /** i32.extend16_s */\r\n  Extend16I32 = 48 /* _BinaryenExtendS16Int32 */,\r\n  /** i64.extend8_s */\r\n  Extend8I64 = 49 /* _BinaryenExtendS8Int64 */,\r\n  /** i64.extend16_s */\r\n  Extend16I64 = 50 /* _BinaryenExtendS16Int64 */,\r\n  /** i64.extend32_s (i64 in, i64 out) */\r\n  Extend32I64 = 51 /* _BinaryenExtendS32Int64 */,\r\n\r\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\r\n\r\n  /** i32.trunc_sat_f32_s */\r\n  TruncSatF32ToI32 = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\r\n  /** i32.trunc_sat_f32_u */\r\n  TruncSatF32ToU32 = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\r\n  /** i32.trunc_sat_f64_s */\r\n  TruncSatF64ToI32 = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\r\n  /** i32.trunc_sat_f64_u */\r\n  TruncSatF64ToU32 = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\r\n  /** i64.trunc_sat_f32_s */\r\n  TruncSatF32ToI64 = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\r\n  /** i64.trunc_sat_f32_u */\r\n  TruncSatF32ToU64 = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\r\n  /** i64.trunc_sat_f64_s */\r\n  TruncSatF64ToI64 = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\r\n  /** i64.trunc_sat_f64_u */\r\n  TruncSatF64ToU64 = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\r\n\r\n  // see: https://github.com/WebAssembly/simd\r\n\r\n  /** i8x16.splat */\r\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\r\n  /** i16x8.splat */\r\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\r\n  /** i32x4.splat */\r\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\r\n  /** i64x2.splat */\r\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\r\n  /** f32x4.splat */\r\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\r\n  /** f64x2.splat */\r\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\r\n  /** v128.not */\r\n  NotV128 = 66 /* _BinaryenNotVec128 */,\r\n  /** v128.any_true */\r\n  AnyTrueV128 = 67 /* _BinaryenAnyTrueVec128 */,\r\n  /** i8x16.abs */\r\n  AbsI8x16 = 68 /* _BinaryenAbsVecI8x16 */,\r\n  /** i8x16.neg */\r\n  NegI8x16 = 69 /* _BinaryenNegVecI8x16 */,\r\n  /** i8x16.all_true */\r\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\r\n  /** i8x16.bitmask */\r\n  BitmaskI8x16 = 71 /* _BinaryenBitmaskVecI8x16 */,\r\n  /** i8x16.popcnt */\r\n  PopcntI8x16 = 72 /* _BinaryenPopcntVecI8x16 */,\r\n  /** i16x8.abs */\r\n  AbsI16x8 = 73 /* _BinaryenAbsVecI16x8 */,\r\n  /** i16x8.neg */\r\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\r\n  /** i16x8.all_true */\r\n  AllTrueI16x8 = 75 /* _BinaryenAllTrueVecI16x8 */,\r\n  /** i16x8.bitmask */\r\n  BitmaskI16x8 = 76 /* _BinaryenBitmaskVecI16x8 */,\r\n  /** i32x4.abs */\r\n  AbsI32x4 = 77 /* _BinaryenAbsVecI32x4 */,\r\n  /** i32x4.neg */\r\n  NegI32x4 = 78 /* _BinaryenNegVecI32x4 */,\r\n  /** i32x4.all_true */\r\n  AllTrueI32x4 = 79 /* _BinaryenAllTrueVecI32x4 */,\r\n  /** i32x4.bitmask */\r\n  BitmaskI32x4 = 80 /* _BinaryenBitmaskVecI32x4 */,\r\n  /** i64x2.abs */\r\n  AbsI64x2 = 81 /* _BinaryenAbsVecI64x2 */,\r\n  /** i64x2.neg */\r\n  NegI64x2 = 82 /* _BinaryenNegVecI64x2 */,\r\n  /** i64x2.all_true */\r\n  AllTrueI64x2 = 83 /* _BinaryenAllTrueVecI64x2 */,\r\n  /** i64x2.bitmask */\r\n  BitmaskI64x2 = 84 /* _BinaryenBitmaskVecI64x2 */,\r\n  /** f32x4.abs */\r\n  AbsF32x4 = 85 /* _BinaryenAbsVecF32x4 */,\r\n  /** f32x4.neg */\r\n  NegF32x4 = 86 /* _BinaryenNegVecF32x4 */,\r\n  /** f32x4.sqrt */\r\n  SqrtF32x4 = 87 /* _BinaryenSqrtVecF32x4 */,\r\n  /** f32x4.ceil */\r\n  CeilF32x4 = 88 /* _BinaryenCeilVecF32x4 */,\r\n  /** f32x4.floor */\r\n  FloorF32x4 = 89 /* _BinaryenFloorVecF32x4 */,\r\n  /** f32x4.trunc */\r\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\r\n  /** f32x4.nearest */\r\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\r\n  /** f64x2.abs */\r\n  AbsF64x2 = 92 /* _BinaryenAbsVecF64x2 */,\r\n  /** f64x2.neg */\r\n  NegF64x2 = 93 /* _BinaryenNegVecF64x2 */,\r\n  /** f64x2.sqrt */\r\n  SqrtF64x2 = 94 /* _BinaryenSqrtVecF64x2 */,\r\n  /** f64x2.ceil */\r\n  CeilF64x2 = 95 /* _BinaryenCeilVecF64x2 */,\r\n  /** f64x2.floor */\r\n  FloorF64x2 = 96 /* _BinaryenFloorVecF64x2 */,\r\n  /** f64x2.trunc */\r\n  TruncF64x2 = 97 /* _BinaryenTruncVecF64x2 */,\r\n  /** f64x2.nearest */\r\n  NearestF64x2 = 98 /* _BinaryenNearestVecF64x2 */,\r\n  /** i16x8.extadd_pairwise_i8x16_s */\r\n  ExtaddPairwiseI8x16ToI16x8 = 99 /* _BinaryenExtAddPairwiseSVecI8x16ToI16x8 */,\r\n  /** i16x8.extadd_pairwise.i8x16_u */\r\n  ExtaddPairwiseU8x16ToU16x8 = 100 /* _BinaryenExtAddPairwiseUVecI8x16ToI16x8 */,\r\n  /** i32x4.extadd_pairwise.i16x8_s */\r\n  ExtaddPairwiseI16x8ToI32x4 = 101 /* _BinaryenExtAddPairwiseSVecI16x8ToI32x4 */,\r\n  /** i32x4.extadd_pairwise.i64x8_u */\r\n  ExtaddPairwiseU16x8ToU32x4 = 102 /* _BinaryenExtAddPairwiseUVecI16x8ToI32x4 */,\r\n  /** i32x4.trunc_sat_f32x4_s */\r\n  TruncSatF32x4ToI32x4 = 103 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\r\n  /** i32x4.trunc_sat_f32x4_u */\r\n  TruncSatF32x4ToU32x4 = 104 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\r\n  /** f32x4.convert_i32x4_s */\r\n  ConvertI32x4ToF32x4 = 105 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\r\n  /** f32x4.convert_i32x4_u */\r\n  ConvertU32x4ToF32x4 = 106 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\r\n  /** i16x8.extend_low_i8x16_s */\r\n  ExtendLowI8x16ToI16x8 = 107 /* _BinaryenExtendLowSVecI8x16ToVecI16x8 */,\r\n  /** i16x8.extend_high_i8x16_s */\r\n  ExtendHighI8x16ToI16x8 = 108 /* _BinaryenExtendHighSVecI8x16ToVecI16x8 */,\r\n  /** i16x8.extend_low_i8x16_u */\r\n  ExtendLowU8x16ToU16x8 = 109 /* _BinaryenExtendLowUVecI8x16ToVecI16x8 */,\r\n  /** i16x8.extend_high_i8x16_u */\r\n  ExtendHighU8x16ToU16x8 = 110 /* _BinaryenExtendHighUVecI8x16ToVecI16x8 */,\r\n  /** i32x4.extend_low_i16x8_s */\r\n  ExtendLowI16x8ToI32x4 = 111 /* _BinaryenExtendLowSVecI16x8ToVecI32x4 */,\r\n  /** i32x4.extend_high_i16x8_s */\r\n  ExtendHighI16x8ToI32x4 = 112 /* _BinaryenExtendHighSVecI16x8ToVecI32x4 */,\r\n  /** i32x4.extend_low_i16x8_u */\r\n  ExtendLowU16x8ToU32x4 = 113 /* _BinaryenExtendLowUVecI16x8ToVecI32x4 */,\r\n  /** i32x4.extend_high_i16x8_u */\r\n  ExtendHighU16x8ToU32x4 = 114 /* _BinaryenExtendHighUVecI16x8ToVecI32x4 */,\r\n  /** i64x2.extend_low_i32x4_s */\r\n  ExtendLowI32x4ToI64x2 = 115 /* _BinaryenExtendLowSVecI32x4ToVecI64x2 */,\r\n  /** i64x2.extend_high_i32x4_s */\r\n  ExtendHighI32x4ToI64x2 = 116 /* _BinaryenExtendHighSVecI32x4ToVecI64x2 */,\r\n  /** i64x2.extend_low_i32x4_u */\r\n  ExtendLowU32x4ToU64x2 = 117 /* _BinaryenExtendLowUVecI32x4ToVecI64x2 */,\r\n  /** i64x2.extend_high_i32x4_u */\r\n  ExtendHighU32x4ToU64x2 = 118 /* _BinaryenExtendHighUVecI32x4ToVecI64x2 */,\r\n  /** f32x4.convert_i32x4_s */\r\n  ConvertLowI32x4ToF64x2 = 119 /* _BinaryenConvertLowSVecI32x4ToVecF64x2 */,\r\n  /** f32x4.convert_i32x4_u */\r\n  ConvertLowU32x4ToF64x2 = 120 /* _BinaryenConvertLowUVecI32x4ToVecF64x2 */,\r\n  /** i32x4.trunc_sat_f64x2_s_zero */\r\n  TruncSatF64x2ToI32x4Zero = 121 /* _BinaryenTruncSatZeroSVecF64x2ToVecI32x4 */,\r\n  /** i32x4.trunc_sat_f64x2_u_zero */\r\n  TruncSatF64x2ToU32x4Zero = 122 /* _BinaryenTruncSatZeroUVecF64x2ToVecI32x4 */,\r\n  /** f32x4.demote_f64x2_zero */\r\n  DemoteZeroF64x2ToF32x4 = 123 /* _BinaryenDemoteZeroVecF64x2ToVecF32x4 */,\r\n  /** f64x2.promote_low_f32x4 */\r\n  PromoteLowF32x4ToF64x2 = 124 /* _BinaryenPromoteLowVecF32x4ToVecF64x2 */,\r\n\r\n  _last = PromoteLowF32x4ToF64x2,\r\n\r\n  // Target dependent\r\n\r\n  /** i32.clz or i64.clz, depending on target word size */\r\n  ClzSize,\r\n  /** i32.ctz or i64.ctz, depending on target word size */\r\n  CtzSize,\r\n  /** i32.popcnt or i64.popcnt, depending on target word size */\r\n  PopcntSize,\r\n  /** i32.eqz or i64.eqz, depending on target word size */\r\n  EqzSize\r\n}\r\n\r\n/** Binaryen binary operation constants. */\r\nexport enum BinaryOp {\r\n  /** i32.add */\r\n  AddI32 = 0 /* _BinaryenAddInt32 */,\r\n  /** i32.sub */\r\n  SubI32 = 1 /* _BinaryenSubInt32 */,\r\n  /** i32.mul */\r\n  MulI32 = 2 /* _BinaryenMulInt32 */,\r\n  /** i32.div_s */\r\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\r\n  /** i32.div_u */\r\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\r\n  /** i32.rem_s */\r\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\r\n  /** i32.rem_u */\r\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\r\n  /** i32.and */\r\n  AndI32 = 7 /* _BinaryenAndInt32 */,\r\n  /** i32.or */\r\n  OrI32 = 8 /* _BinaryenOrInt32 */,\r\n  /** i32.xor */\r\n  XorI32 = 9 /* _BinaryenXorInt32 */,\r\n  /** i32.shl */\r\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\r\n  /** i32.shr_s */\r\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\r\n  /** i32.shr_u */\r\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\r\n  /** i32.rotl */\r\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\r\n  /** i32.rotr */\r\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\r\n  /** i32.eq */\r\n  EqI32 = 15 /* _BinaryenEqInt32 */,\r\n  /** i32.ne */\r\n  NeI32 = 16 /* _BinaryenNeInt32 */,\r\n  /** i32.lt_s */\r\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\r\n  /** i32.lt_u */\r\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\r\n  /** i32.le_s */\r\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\r\n  /** i32.le_u */\r\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\r\n  /** i32.gt_s */\r\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\r\n  /** i32.gt_u */\r\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\r\n  /** i32.ge_s */\r\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\r\n  /** i32.ge_u */\r\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\r\n  /** i64.add */\r\n  AddI64 = 25 /* _BinaryenAddInt64 */,\r\n  /** i64.sub */\r\n  SubI64 = 26 /* _BinaryenSubInt64 */,\r\n  /** i64.mul */\r\n  MulI64 = 27 /* _BinaryenMulInt64 */,\r\n  /** i64.div_s */\r\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\r\n  /** i64.div_u */\r\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\r\n  /** i64.rem_s */\r\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\r\n  /** i64.rem_u */\r\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\r\n  /** i64.and */\r\n  AndI64 = 32 /* _BinaryenAndInt64 */,\r\n  /** i64.or */\r\n  OrI64 = 33 /* _BinaryenOrInt64 */,\r\n  /** i64.xor */\r\n  XorI64 = 34 /* _BinaryenXorInt64 */,\r\n  /** i64.shl */\r\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\r\n  /** i64.shr_s */\r\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\r\n  /** i64.shr_u */\r\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\r\n  /** i64.rotl */\r\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\r\n  /** i64.rotr */\r\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\r\n  /** i64.eq */\r\n  EqI64 = 40 /* _BinaryenEqInt64 */,\r\n  /** i64.ne */\r\n  NeI64 = 41 /* _BinaryenNeInt64 */,\r\n  /** i64.lt_s */\r\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\r\n  /** i64.lt_u */\r\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\r\n  /** i64.le_s */\r\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\r\n  /** i64.le_u */\r\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\r\n  /** i64.gt_s */\r\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\r\n  /** i64.gt_u */\r\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\r\n  /** i64.ge_s */\r\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\r\n  /** i64.ge_u */\r\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\r\n  /** f32.add */\r\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\r\n  /** f32.sub */\r\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\r\n  /** f32.mul */\r\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\r\n  /** f32.div */\r\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\r\n  /** f32.copysign */\r\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\r\n  /** f32.min */\r\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\r\n  /** f32.max */\r\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\r\n  /** f32.eq */\r\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\r\n  /** f32.ne */\r\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\r\n  /** f32.lt */\r\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\r\n  /** f32.le */\r\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\r\n  /** f32.gt */\r\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\r\n  /** f32.ge */\r\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\r\n  /** f64.add */\r\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\r\n  /** f64.sub */\r\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\r\n  /** f64.mul */\r\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\r\n  /** f64.div */\r\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\r\n  /** f64.copysign */\r\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\r\n  /** f64.min */\r\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\r\n  /** f64.max */\r\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\r\n  /** f64.eq */\r\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\r\n  /** f64.ne */\r\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\r\n  /** f64.lt */\r\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\r\n  /** f64.le */\r\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\r\n  /** f64.gt */\r\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\r\n  /** f64.ge */\r\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\r\n\r\n  // see: https://github.com/WebAssembly/simd\r\n\r\n  /** i8x16.eq */\r\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\r\n  /** i8x16.he */\r\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\r\n  /** i8x16.lt_s */\r\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\r\n  /** i8x16.lt_u */\r\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\r\n  /** i8x16.gt_s */\r\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\r\n  /** i8x16.gt_u */\r\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\r\n  /** i8x16.le_s */\r\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\r\n  /** i8x16.le_u */\r\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\r\n  /** i8x16.ge_s */\r\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\r\n  /** i8x16.ge_u */\r\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\r\n  /** i16x8.eq */\r\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\r\n  /** i16x8.ne */\r\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\r\n  /** i16x8.lt_s */\r\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\r\n  /** i16x8.lt_u */\r\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\r\n  /** i16x8.gt_s */\r\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\r\n  /** i16x8.gt_u */\r\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\r\n  /** i16x8.le_s */\r\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\r\n  /** i16x8.le_u */\r\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\r\n  /** i16x8.ge_s */\r\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\r\n  /** i16x8.ge_u */\r\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\r\n  /** i32x4.eq */\r\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\r\n  /** i32x4.ne */\r\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\r\n  /** i32x4.lt_s */\r\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\r\n  /** i32x4.lt_u */\r\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\r\n  /** i32x4.gt_s */\r\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\r\n  /** i32x4.gt_u */\r\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\r\n  /** i32x4.le_s */\r\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\r\n  /** i32x4.le_u */\r\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\r\n  /** i32x4.ge_s */\r\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\r\n  /** i32x4.ge_u */\r\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\r\n  /** i64x2.eq */\r\n  EqI64x2 = 106 /* _BinaryenEqVecI64x2 */,\r\n  /** i64x2.ne */\r\n  NeI64x2 = 107 /* _BinaryenNeVecI64x2 */,\r\n  /** i64x2.lt_s */\r\n  LtI64x2 = 108 /* _BinaryenLtSVecI64x2 */,\r\n  /** i64x2.gt_s */\r\n  GtI64x2 = 109 /* _BinaryenGtSVecI64x2 */,\r\n  /** i64x2.le_s */\r\n  LeI64x2 = 110 /* _BinaryenLeSVecI64x2 */,\r\n  /** i64x2.ge_s */\r\n  GeI64x2 = 111 /* _BinaryenGeSVecI64x2 */,\r\n  /** f32x4.eq */\r\n  EqF32x4 = 112 /* _BinaryenEqVecF32x4 */,\r\n  /** f32x4.ne */\r\n  NeF32x4 = 113 /* _BinaryenNeVecF32x4 */,\r\n  /** f32x4.lt */\r\n  LtF32x4 = 114 /* _BinaryenLtVecF32x4 */,\r\n  /** f32x4.gt */\r\n  GtF32x4 = 115 /* _BinaryenGtVecF32x4 */,\r\n  /** f32x4.le */\r\n  LeF32x4 = 116 /* _BinaryenLeVecF32x4 */,\r\n  /** f32x4.ge */\r\n  GeF32x4 = 117 /* _BinaryenGeVecF32x4 */,\r\n  /** f64x2.eq */\r\n  EqF64x2 = 118 /* _BinaryenEqVecF64x2 */,\r\n  /** f64x2.ne */\r\n  NeF64x2 = 119 /* _BinaryenNeVecF64x2 */,\r\n  /** f64x2.lt */\r\n  LtF64x2 = 120 /* _BinaryenLtVecF64x2 */,\r\n  /** f64x2.gt */\r\n  GtF64x2 = 121 /* _BinaryenGtVecF64x2 */,\r\n  /** f64x2.le */\r\n  LeF64x2 = 122 /* _BinaryenLeVecF64x2 */,\r\n  /** f64x2.ge */\r\n  GeF64x2 = 123 /* _BinaryenGeVecF64x2 */,\r\n  /** v128.and */\r\n  AndV128 = 124 /* _BinaryenAndVec128 */,\r\n  /** v128.or */\r\n  OrV128 = 125 /* _BinaryenOrVec128 */,\r\n  /** v128.xor */\r\n  XorV128 = 126 /* _BinaryenXorVec128 */,\r\n  /** v128.andnot */\r\n  AndnotV128 = 127 /* _BinaryenAndNotVec128 */,\r\n  /** i8x16.add */\r\n  AddI8x16 = 128 /* _BinaryenAddVecI8x16 */,\r\n  /** i8x16.add_sat_s */\r\n  AddSatI8x16 = 129 /* _BinaryenAddSatSVecI8x16 */,\r\n  /** i8x16.add_sat_u */\r\n  AddSatU8x16 = 130 /* _BinaryenAddSatUVecI8x16 */,\r\n  /** i8x16.sub */\r\n  SubI8x16 = 131 /* _BinaryenSubVecI8x16 */,\r\n  /** i8x16.sub_sat_s */\r\n  SubSatI8x16 = 132 /* _BinaryenSubSatSVecI8x16 */,\r\n  /** i8x16.sub_sat_u */\r\n  SubSatU8x16 = 133 /* _BinaryenSubSatUVecI8x16 */,\r\n  /** i8x16.min_s */\r\n  MinI8x16 = 134 /* _BinaryenMinSVecI8x16 */,\r\n  /** i8x16.min_u */\r\n  MinU8x16 = 135 /* _BinaryenMinUVecI8x16 */,\r\n  /** i8x16.max_s */\r\n  MaxI8x16 = 136 /* _BinaryenMaxSVecI8x16 */,\r\n  /** i8x16.max_u */\r\n  MaxU8x16 = 137 /* _BinaryenMaxUVecI8x16 */,\r\n  /** i8x16.avgr_u */\r\n  AvgrU8x16 = 138 /* _BinaryenAvgrUVecI8x16 */,\r\n  /** i16x8.add */\r\n  AddI16x8 = 139 /* _BinaryenAddVecI16x8 */,\r\n  /** i16x8.add_sat_s */\r\n  AddSatI16x8 = 140 /* _BinaryenAddSatSVecI16x8 */,\r\n  /** i16x8.add_sat_u */\r\n  AddSatU16x8 = 141 /* _BinaryenAddSatUVecI16x8 */,\r\n  /** i16x8.sub */\r\n  SubI16x8 = 142 /* _BinaryenSubVecI16x8 */,\r\n  /** i16x8.sub_sat_s */\r\n  SubSatI16x8 = 143 /* _BinaryenSubSatSVecI16x8 */,\r\n  /** i16x8.sub_sat_u */\r\n  SubSatU16x8 = 144 /* _BinaryenSubSatUVecI16x8 */,\r\n  /** i16x8.mul */\r\n  MulI16x8 = 145 /* _BinaryenMulVecI16x8 */,\r\n  /** i16x8.min_s */\r\n  MinI16x8 = 146 /* _BinaryenMinSVecI16x8 */,\r\n  /** i16x8.min_u */\r\n  MinU16x8 = 147 /* _BinaryenMinUVecI16x8 */,\r\n  /** i16x8.max_s */\r\n  MaxI16x8 = 148 /* _BinaryenMaxSVecI16x8 */,\r\n  /** i16x8.max_u */\r\n  MaxU16x8 = 149 /* _BinaryenMaxUVecI16x8 */,\r\n  /** i16x8.avgr_u */\r\n  AvgrU16x8 = 150 /* _BinaryenAvgrUVecI16x8 */,\r\n  /** i16x8.q15mulr_sat_s */\r\n  Q15mulrSatI16x8 = 151 /* _BinaryenQ15MulrSatSVecI16x8 */,\r\n  /** i16x8.extmul_low_i8x16_s */\r\n  ExtmulLowI16x8 = 152 /* _BinaryenExtMulLowSVecI16x8 */,\r\n  /** i16x8.extmul_high_i8x16_s */\r\n  ExtmulHighI16x8 = 153 /* _BinaryenExtMulHighSVecI16x8 */,\r\n  /** i16x8.extmul_low_i8x16_u */\r\n  ExtmulLowU16x8 = 154 /* _BinaryenExtMulLowUVecI16x8 */,\r\n  /** i16x8.extmul_high_i8x16_u */\r\n  ExtmulHighU16x8 = 155 /* _BinaryenExtMulHighUVecI16x8 */,\r\n  /** i32x4.add */\r\n  AddI32x4 = 156 /* _BinaryenAddVecI32x4 */,\r\n  /** i32x4.sub */\r\n  SubI32x4 = 157 /* _BinaryenSubVecI32x4 */,\r\n  /** i32x4.mul */\r\n  MulI32x4 = 158 /* _BinaryenMulVecI32x4 */,\r\n  /** i32x4.min_s */\r\n  MinI32x4 = 159 /* _BinaryenMinSVecI32x4 */,\r\n  /** i32x4.min_u */\r\n  MinU32x4 = 160 /* _BinaryenMinUVecI32x4 */,\r\n  /** i32x4.max_s */\r\n  MaxI32x4 = 161 /* _BinaryenMaxSVecI32x4 */,\r\n  /** i32x4.max_u */\r\n  MaxU32x4 = 162 /* _BinaryenMaxUVecI32x4 */,\r\n  /** i32x4.dot_i16x8_s */\r\n  DotI16x8 = 163 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\r\n  /** i32x4.extmul_low_i16x8_s */\r\n  ExtmulLowI32x4 = 164 /* _BinaryenExtMulLowSVecI32x4 */,\r\n  /** i32x4.extmul_high_i16x8_s */\r\n  ExtmulHighI32x4 = 165 /* _BinaryenExtMulHighSVecI32x4 */,\r\n  /** i32x4.extmul_low_i16x8_u */\r\n  ExtmulLowU32x4 = 166 /* _BinaryenExtMulLowUVecI32x4 */,\r\n  /** i32x4.extmul_high_i16x8_u */\r\n  ExtmulHighU32x4 = 167 /* _BinaryenExtMulHighUVecI32x4 */,\r\n  /** i64x2.add */\r\n  AddI64x2 = 168 /* _BinaryenAddVecI64x2 */,\r\n  /** i64x2.sub */\r\n  SubI64x2 = 169 /* _BinaryenSubVecI64x2 */,\r\n  /** i64x2.mul */\r\n  MulI64x2 = 170 /* _BinaryenMulVecI64x2 */,\r\n  /** i64x2.extmul_low_i32x4_s */\r\n  ExtmulLowI64x2 = 171 /* _BinaryenExtMulLowSVecI64x2 */,\r\n  /** i64x2.extmul_high_i32x4_s */\r\n  ExtmulHighI64x2 = 172 /* _BinaryenExtMulHighSVecI64x2 */,\r\n  /** i64x2.extmul_low_i32x4_u */\r\n  ExtmulLowU64x2 = 173 /* _BinaryenExtMulLowUVecI64x2 */,\r\n  /** i64x2.extmul_high_i32x4_u */\r\n  ExtmulHighU64x2 = 174 /* _BinaryenExtMulHighUVecI64x2 */,\r\n  /** f32x4.add */\r\n  AddF32x4 = 175 /* _BinaryenAddVecF32x4 */,\r\n  /** f32x4.sub */\r\n  SubF32x4 = 176 /* _BinaryenSubVecF32x4 */,\r\n  /** f32x4.mul */\r\n  MulF32x4 = 177 /* _BinaryenMulVecF32x4 */,\r\n  /** f32x4.div */\r\n  DivF32x4 = 178 /* _BinaryenDivVecF32x4 */,\r\n  /** f32x4.min */\r\n  MinF32x4 = 179 /* _BinaryenMinVecF32x4 */,\r\n  /** f32x4.max */\r\n  MaxF32x4 = 180 /* _BinaryenMaxVecF32x4 */,\r\n  /** f32x4.pmin */\r\n  PminF32x4 = 181 /* _BinaryenPMinVecF32x4 */,\r\n  /** f32x4.pmax */\r\n  PmaxF32x4 = 182 /* _BinaryenPMaxVecF32x4 */,\r\n  /** f64x2.add */\r\n  AddF64x2 = 183 /* _BinaryenAddVecF64x2 */,\r\n  /** f64x2.sub */\r\n  SubF64x2 = 184 /* _BinaryenSubVecF64x2 */,\r\n  /** f64x2.mul */\r\n  MulF64x2 = 185 /* _BinaryenMulVecF64x2 */,\r\n  /** f64x2.div */\r\n  DivF64x2 = 186 /* _BinaryenDivVecF64x2 */,\r\n  /** f64x2.min */\r\n  MinF64x2 = 187 /* _BinaryenMinVecF64x2 */,\r\n  /** f64x2.max */\r\n  MaxF64x2 = 188 /* _BinaryenMaxVecF64x2 */,\r\n  /** f64x2.pmin */\r\n  PminF64x2 = 189 /* _BinaryenPMinVecF64x2 */,\r\n  /** f64x2.pmax */\r\n  PmaxF64x2 = 190 /* _BinaryenPMaxVecF64x2 */,\r\n  /** i8x16.narrow_i16x8_s */\r\n  NarrowI16x8ToI8x16 = 191 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\r\n  /** i8x16.narrow_i16x8_u */\r\n  NarrowU16x8ToU8x16 = 192 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\r\n  /** i16x8.narrow_i32x4_s */\r\n  NarrowI32x4ToI16x8 = 193 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\r\n  /** i16x8.narrow_i32x4_u */\r\n  NarrowU32x4ToU16x8 = 194 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\r\n  /** i8x16.swizzle */\r\n  SwizzleI8x16 = 195 /* _BinaryenSwizzleVec8x16 */,\r\n\r\n  _last = SwizzleI8x16,\r\n\r\n  // Target dependent\r\n\r\n  /** i32.add or i64.add, depending on target word size */\r\n  AddSize,\r\n  /** i32.sub or i64.sub, depending on target word size */\r\n  SubSize,\r\n  /** i32.mul or i64.mul, depending on target word size */\r\n  MulSize,\r\n  /** i32.div_s or i64.div_s, depending on target word size */\r\n  DivISize,\r\n  /** i32.div_u or i64.div_u, depending on target word size */\r\n  DivUSize,\r\n  /** i32.rem_s or i64.rem_s, depending on target word size */\r\n  RemISize,\r\n  /** i32.rem_u or i64.rem_u, depending on target word size */\r\n  RemUSize,\r\n  /** i32.and or i64.and, depending on target word size */\r\n  AndSize,\r\n  /** i32.or or i64.or, depending on target word size */\r\n  OrSize,\r\n  /** i32.xor or i64.xor, depending on target word size */\r\n  XorSize,\r\n  /** i32.shl or i64.shl, depending on target word size */\r\n  ShlSize,\r\n  /** i32.shr_s or i64.shr_s, depending on target word size */\r\n  ShrISize,\r\n  /** i32.shr_u or i64.shr_u, depending on target word size */\r\n  ShrUSize,\r\n  /** i32.rotl or i64.rotl, depending on target word size */\r\n  RotlSize,\r\n  /** i32.rotr or i64.rotr, depending on target word size */\r\n  RotrSize,\r\n  /** i32.eq or i64.eq, depending on target word size */\r\n  EqSize,\r\n  /** i32.ne or i64.ne, depending on target word size */\r\n  NeSize,\r\n  /** i32.lt_s or i64.lt_s, depending on target word size */\r\n  LtISize,\r\n  /** i32.lt_u or i64.lt_u, depending on target word size */\r\n  LtUSize,\r\n  /** i32.le_s or i64.le_s, depending on target word size */\r\n  LeISize,\r\n  /** i32.le_u or i64.le_u, depending on target word size */\r\n  LeUSize,\r\n  /** i32.gt_s or i64.gt_s, depending on target word size */\r\n  GtISize,\r\n  /** i32.gt_u or i64.gt_u, depending on target word size */\r\n  GtUSize,\r\n  /** i32.ge_s or i64.ge_s, depending on target word size */\r\n  GeISize,\r\n  /** i32.ge_u or i64.ge_u, depending on target word size */\r\n  GeUSize\r\n}\r\n\r\n/** Binaryen atomic read-modify-write operation constants. */\r\nexport enum AtomicRMWOp {\r\n  /** i32.atomic.rmw.add, i32.atomic.rmw8.add_u, i32.atomic.rmw16.add_u, i64.atomic.rmw.add, i64.atomic.rmw8.add_u, i64.atomic.rmw16.add_u, i64.atomic.rmw32.add_u */\r\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\r\n  /** i32.atomic.rmw.sub, i32.atomic.rmw8.sub_u, i32.atomic.rmw16.sub_u, i64.atomic.rmw.sub, i64.atomic.rmw8.sub_u, i64.atomic.rmw16.sub_u, i64.atomic.rmw32.sub_u */\r\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\r\n  /** i32.atomic.rmw.and, i32.atomic.rmw8.and_u, i32.atomic.rmw16.and_u, i64.atomic.rmw.and, i64.atomic.rmw8.and_u, i64.atomic.rmw16.and_u, i64.atomic.rmw32.and_u */\r\n  And = 2 /* _BinaryenAtomicRMWAnd */,\r\n  /** i32.atomic.rmw.or, i32.atomic.rmw8.or_u, i32.atomic.rmw16.or_u, i64.atomic.rmw.or, i64.atomic.rmw8.or_u, i64.atomic.rmw16.or_u, i64.atomic.rmw32.or_u */\r\n  Or = 3 /* _BinaryenAtomicRMWOr */,\r\n  /** i32.atomic.rmw.xor, i32.atomic.rmw8.xor_u, i32.atomic.rmw16.xor_u, i64.atomic.rmw.xor, i64.atomic.rmw8.xor_u, i64.atomic.rmw16.xor_u, i64.atomic.rmw32.xor_u */\r\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\r\n  /** i32.atomic.rmw.xchg, i32.atomic.rmw8.xchg_u, i32.atomic.rmw16.xchg_u, i64.atomic.rmw.xchg, i64.atomic.rmw8.xchg_u, i64.atomic.rmw16.xchg_u, i64.atomic.rmw32.xchg_u */\r\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\r\n}\r\n\r\n/** Binaryen SIMD extract operation constants. */\r\nexport enum SIMDExtractOp {\r\n  /** i8x16.extract_lane_s */\r\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\r\n  /** i8x16.extract_lane_u */\r\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\r\n  /** i16x8.extract_lane_s */\r\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\r\n  /** i16x8.extract_lane_u */\r\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\r\n  /** i32x4.extract_lane_s */\r\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\r\n  /** i32x4.extract_lane_u */\r\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\r\n  /** i64x2.extract_lane_s */\r\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\r\n  /** i64x2.extract_lane_u */\r\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\r\n}\r\n\r\n/** Binaryen SIMD replace operation constants. */\r\nexport enum SIMDReplaceOp {\r\n  /** i8x16.replace_lane */\r\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\r\n  /** i16x8.replace_lane */\r\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\r\n  /** i32x4.replace_lane */\r\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\r\n  /** i64x2.replace_lane */\r\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\r\n  /** f32x4.replace_lane */\r\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\r\n  /** f64x2.replace_lane */\r\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\r\n}\r\n\r\n/** Binaryen SIMD shift operation constants. */\r\nexport enum SIMDShiftOp {\r\n  /** i8x16.shl */\r\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\r\n  /** i8x16.shr_s */\r\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\r\n  /** i8x16.shr_u */\r\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\r\n  /** i16x8.shl */\r\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\r\n  /** i16x8.shr_s */\r\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\r\n  /** i16x8.shr_u */\r\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\r\n  /** i16x8.shl */\r\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\r\n  /** i32x4.shr_s */\r\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\r\n  /** i32x4.shr_u */\r\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\r\n  /** i64x2.shl */\r\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\r\n  /** i64x2.shr_u */\r\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\r\n  /** i64x2.shr_u */\r\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\r\n}\r\n\r\n/** Binaryen SIMD load operation constants. */\r\nexport enum SIMDLoadOp {\r\n  /** v128.load8_splat */\r\n  Load8Splat = 0 /* _BinaryenLoad8SplatVec128 */,\r\n  /** v128.load16_splat */\r\n  Load16Splat = 1 /* _BinaryenLoad16SplatVec128 */,\r\n  /** v128.load32_splat */\r\n  Load32Splat = 2 /* _BinaryenLoad32SplatVec128 */,\r\n  /** v128.load64_splat */\r\n  Load64Splat = 3 /* _BinaryenLoad64SplatVec128 */,\r\n  /** v128.load8x8_s */\r\n  Load8x8S = 4 /* _BinaryenLoad8x8SVec128 */,\r\n  /** v128.load8x8_u */\r\n  Load8x8U = 5 /* _BinaryenLoad8x8UVec128 */,\r\n  /** v128.load16x4_s */\r\n  Load16x4S = 6 /* _BinaryenLoad16x4SVec128 */,\r\n  /** v128.load16x4_u */\r\n  Load16x4U = 7 /* _BinaryenLoad16x4UVec128 */,\r\n  /** v128.load32x2_s */\r\n  Load32x2S = 8 /* _BinaryenLoad32x2SVec128 */,\r\n  /** v128.load32x2_u */\r\n  Load32x2U = 9 /* _BinaryenLoad32x2UVec128 */,\r\n  /** v128.load32_zero */\r\n  Load32Zero = 10 /* _BinaryenLoad32ZeroVec128 */,\r\n  /** v128.load64_zero */\r\n  Load64Zero = 11 /* _BinaryenLoad64ZeroVec128 */,\r\n}\r\n\r\n/** Binaryen SIMD load/store lane operation constants. */\r\nexport enum SIMDLoadStoreLaneOp {\r\n  /** v128.load8_lane */\r\n  Load8Lane = 0 /* _BinaryenLoad8LaneVec128 */,\r\n  /** v128.load16_lane */\r\n  Load16Lane = 1 /* _BinaryenLoad16LaneVec128 */,\r\n  /** v128.load32_lane */\r\n  Load32Lane = 2 /* _BinaryenLoad32LaneVec128 */,\r\n  /** v128.load64_lane */\r\n  Load64Lane = 3 /* _BinaryenLoad64LaneVec128 */,\r\n  /** v128.store8_lane */\r\n  Store8Lane = 4 /* _BinaryenStore8LaneVec128 */,\r\n  /** v128.store16_lane */\r\n  Store16Lane = 5 /* _BinaryenStore16LaneVec128 */,\r\n  /** v128.store32_lane */\r\n  Store32Lane = 6 /* _BinaryenStore32LaneVec128 */,\r\n  /** v128.store64_lane */\r\n  Store64Lane = 7 /* _BinaryenStore64LaneVec128 */,\r\n}\r\n\r\n/** Binaryen SIMD ternary operation constants. */\r\nexport enum SIMDTernaryOp {\r\n  /** v128.bitselect */\r\n  Bitselect = 0 /* _BinaryenBitselectVec128 */\r\n}\r\n\r\n/** Binaryen RefIs operation constants. */\r\nexport enum RefIsOp {\r\n  /** ref.is_null */\r\n  RefIsNull = 0 /* _BinaryenRefIsNull */,\r\n  /** ref.is_func */\r\n  RefIsFunc = 1 /* _BinaryenRefIsFunc */,\r\n  /** ref.is_data */\r\n  RefIsData = 2 /* _BinaryenRefIsData */,\r\n  /** ref.is_i31 */\r\n  RefIsI31 = 3 /* _BinaryenRefIsI31 */\r\n}\r\n\r\n/** Binaryen RefAs operation constants. */\r\nexport enum RefAsOp {\r\n  /** ref.as_non_null */\r\n  RefAsNonNull = 0 /* _BinaryenRefAsNonNull */,\r\n  /** ref.as_func */\r\n  RefAsFunc = 1 /* _BinaryenRefAsFunc */,\r\n  /** ref.as_data */\r\n  RefAsData = 2 /* _BinaryenRefAsData */,\r\n  /** ref.as_i31 */\r\n  RefAsI31 = 3 /* _BinaryenRefAsI31 */\r\n}\r\n\r\n/** Binaryen BrOn operation constants. */\r\nexport enum BrOnOp {\r\n  /** br_on_null */\r\n  BrOnNull = 0 /* TODO_BinaryenBrOnNull */,\r\n  /** br_on_cast */\r\n  BrOnCast = 1 /* TODO_BinaryenBrOnCast */,\r\n  /** br_on_func */\r\n  BrOnFunc = 2 /* TODO_BinaryenBrOnFunc */,\r\n  /** br_on_data */\r\n  BrOnData = 3 /* TODO_BinaryenBrOnData */,\r\n  /** br_on_i31 */\r\n  BrOnI31 = 4 /* TODO_BinaryenBrOnI31 */\r\n}\r\n\r\n/** Binaryen expression runner flags. */\r\nexport enum ExpressionRunnerFlags {\r\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\r\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\r\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\r\n}\r\n\r\nexport class MemorySegment {\r\n  constructor(\r\n    /** Segment data. */\r\n    public buffer: Uint8Array,\r\n    /** Segment offset. */\r\n    public offset: i64\r\n  ) {}\r\n}\r\n\r\nexport class Module {\r\n  constructor(\r\n    /** Binaryen module reference. */\r\n    public ref: ModuleRef,\r\n    /** Whether a shadow stack is used. */\r\n    public useShadowStack: bool,\r\n    /** Architecture-dependent size type. */\r\n    public sizeType: TypeRef\r\n  ) {\r\n    assert(sizeType == TypeRef.I32 || sizeType == TypeRef.I64);\r\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\r\n  }\r\n\r\n  private lit: usize;\r\n\r\n  static create(useShadowStack: bool, sizeType: TypeRef): Module {\r\n    return new Module(binaryen._BinaryenModuleCreate(), useShadowStack, sizeType);\r\n  }\r\n\r\n  static createFrom(buffer: Uint8Array, useShadowStack: bool, sizeType: TypeRef): Module {\r\n    var cArr = allocU8Array(buffer);\r\n    var module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length), useShadowStack, sizeType);\r\n    binaryen._free(changetype<usize>(cArr));\r\n    return module;\r\n  }\r\n\r\n  // constants\r\n\r\n  i32(value: i32): ExpressionRef {\r\n    var out = this.lit;\r\n    binaryen._BinaryenLiteralInt32(out, value);\r\n    return binaryen._BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\r\n    var out = this.lit;\r\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\r\n    return binaryen._BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  // isize<T>(value: T): ExpressionRef {\r\n  //   if (i64_is(value)) {\r\n  //     if (this.sizeType == TypeRef.I64) {\r\n  //       return this.i64(i64_low(value), i64_high(value));\r\n  //     }\r\n  //     assert(i64_is_i32(value));\r\n  //     return this.i32(i64_low(value));\r\n  //   }\r\n  //   return this.sizeType == TypeRef.I64\r\n  //     ? this.i64(i32(value), i32(value) < 0 ? -1 : 0)\r\n  //     : this.i32(i32(value));\r\n  // }\r\n\r\n  usize<T>(value: T): ExpressionRef {\r\n    if (i64_is(value)) {\r\n      if (this.sizeType == TypeRef.I64) {\r\n        return this.i64(i64_low(value), i64_high(value));\r\n      }\r\n      assert(i64_is_u32(value));\r\n      return this.i32(i64_low(value));\r\n    }\r\n    return this.sizeType == TypeRef.I64\r\n      ? this.i64(i32(value))\r\n      : this.i32(i32(value));\r\n  }\r\n\r\n  f32(value: f32): ExpressionRef {\r\n    var out = this.lit;\r\n    binaryen._BinaryenLiteralFloat32(out, value);\r\n    return binaryen._BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  f64(value: f64): ExpressionRef {\r\n    var out = this.lit;\r\n    binaryen._BinaryenLiteralFloat64(out, value);\r\n    return binaryen._BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  v128(bytes: Uint8Array): ExpressionRef {\r\n    assert(bytes.length == 16);\r\n    var out = this.lit;\r\n    for (let i = 0; i < 16; ++i) {\r\n      binaryen.__i32_store8(out + i, bytes[i]);\r\n    }\r\n    binaryen._BinaryenLiteralVec128(out, out);\r\n    return binaryen._BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  ref_null(type: TypeRef): ExpressionRef {\r\n    return binaryen._BinaryenRefNull(this.ref, type);\r\n  }\r\n\r\n  ref_eq(left: ExpressionRef, right: ExpressionRef): ExpressionRef {\r\n    return binaryen._BinaryenRefEq(this.ref, left, right);\r\n  }\r\n\r\n  // expressions\r\n\r\n  unary(\r\n    op: UnaryOp,\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    if (op > UnaryOp._last) {\r\n      let isWam64 = this.sizeType == TypeRef.I64;\r\n      switch (op) {\r\n        case UnaryOp.ClzSize: return this.unary(isWam64 ? UnaryOp.ClzI64 : UnaryOp.ClzI32, value);\r\n        case UnaryOp.CtzSize: return this.unary(isWam64 ? UnaryOp.CtzI64 : UnaryOp.CtzI32, value);\r\n        case UnaryOp.PopcntSize: return this.unary(isWam64 ? UnaryOp.PopcntI64 : UnaryOp.PopcntI32, value);\r\n        case UnaryOp.EqzSize: return this.unary(isWam64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32, value);\r\n      }\r\n      assert(false);\r\n    }\r\n    return binaryen._BinaryenUnary(this.ref, op, value);\r\n  }\r\n\r\n  binary(\r\n    op: BinaryOp,\r\n    left: ExpressionRef,\r\n    right: ExpressionRef\r\n  ): ExpressionRef {\r\n    if (op > BinaryOp._last) {\r\n      let isWasm64 = this.sizeType == TypeRef.I64;\r\n      switch (op) {\r\n        case BinaryOp.AddSize: return this.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32, left, right);\r\n        case BinaryOp.SubSize: return this.binary(isWasm64 ? BinaryOp.SubI64 : BinaryOp.SubI32, left, right);\r\n        case BinaryOp.MulSize: return this.binary(isWasm64 ? BinaryOp.MulI64 : BinaryOp.MulI32, left, right);\r\n        case BinaryOp.DivISize: return this.binary(isWasm64 ? BinaryOp.DivI64 : BinaryOp.DivI32, left, right);\r\n        case BinaryOp.DivUSize: return this.binary(isWasm64 ? BinaryOp.DivU64 : BinaryOp.DivU32, left, right);\r\n        case BinaryOp.RemISize: return this.binary(isWasm64 ? BinaryOp.RemI64 : BinaryOp.RemI32, left, right);\r\n        case BinaryOp.RemUSize: return this.binary(isWasm64 ? BinaryOp.RemU64 : BinaryOp.RemU32, left, right);\r\n        case BinaryOp.AndSize: return this.binary(isWasm64 ? BinaryOp.AndI64 : BinaryOp.AndI32, left, right);\r\n        case BinaryOp.OrSize: return this.binary(isWasm64 ? BinaryOp.OrI64 : BinaryOp.OrI32, left, right);\r\n        case BinaryOp.XorSize: return this.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32, left, right);\r\n        case BinaryOp.ShlSize: return this.binary(isWasm64 ? BinaryOp.ShlI64 : BinaryOp.ShlI32, left, right);\r\n        case BinaryOp.ShrISize: return this.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32, left, right);\r\n        case BinaryOp.ShrUSize: return this.binary(isWasm64 ? BinaryOp.ShrU64 : BinaryOp.ShrU32, left, right);\r\n        case BinaryOp.RotlSize: return this.binary(isWasm64 ? BinaryOp.RotlI64 : BinaryOp.RotlI32, left, right);\r\n        case BinaryOp.RotrSize: return this.binary(isWasm64 ? BinaryOp.RotrI64 : BinaryOp.RotrI32, left, right);\r\n        case BinaryOp.EqSize: return this.binary(isWasm64 ? BinaryOp.EqI64 : BinaryOp.EqI32, left, right);\r\n        case BinaryOp.NeSize: return this.binary(isWasm64 ? BinaryOp.NeI64 : BinaryOp.NeI32, left, right);\r\n        case BinaryOp.LtISize: return this.binary(isWasm64 ? BinaryOp.LtI64 : BinaryOp.LtI32, left, right);\r\n        case BinaryOp.LtUSize: return this.binary(isWasm64 ? BinaryOp.LtU64 : BinaryOp.LtU32, left, right);\r\n        case BinaryOp.LeISize: return this.binary(isWasm64 ? BinaryOp.LeI64 : BinaryOp.LeI32, left, right);\r\n        case BinaryOp.LeUSize: return this.binary(isWasm64 ? BinaryOp.LeU64 : BinaryOp.LeU32, left, right);\r\n        case BinaryOp.GtISize: return this.binary(isWasm64 ? BinaryOp.GtI64 : BinaryOp.GtI32, left, right);\r\n        case BinaryOp.GtUSize: return this.binary(isWasm64 ? BinaryOp.GtU64 : BinaryOp.GtU32, left, right);\r\n        case BinaryOp.GeISize: return this.binary(isWasm64 ? BinaryOp.GeI64 : BinaryOp.GeI32, left, right);\r\n        case BinaryOp.GeUSize: return this.binary(isWasm64 ? BinaryOp.GeU64 : BinaryOp.GeU32, left, right);\r\n      }\r\n      assert(false);\r\n    }\r\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\r\n  }\r\n\r\n  memory_size(): ExpressionRef {\r\n    return binaryen._BinaryenMemorySize(this.ref);\r\n  }\r\n\r\n  memory_grow(delta: ExpressionRef): ExpressionRef {\r\n    return binaryen._BinaryenMemoryGrow(this.ref, delta);\r\n  }\r\n\r\n  local_get(\r\n    index: i32,\r\n    type: TypeRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\r\n  }\r\n\r\n  tostack(value: ExpressionRef): ExpressionRef {\r\n    if (this.useShadowStack) {\r\n      let type = binaryen._BinaryenExpressionGetType(value);\r\n      assert(type == TypeRef.I32 || type == TypeRef.Unreachable);\r\n      return this.call(BuiltinNames.tostack, [ value ], type);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  local_tee(\r\n    index: i32,\r\n    value: ExpressionRef,\r\n    isManaged: bool,\r\n    type: TypeRef = TypeRef.Auto,\r\n  ): ExpressionRef {\r\n    if (type == TypeRef.Auto) type = binaryen._BinaryenExpressionGetType(value);\r\n    if (isManaged && this.useShadowStack) {\r\n      value = this.tostack(value);\r\n    }\r\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\r\n  }\r\n\r\n  global_get(\r\n    name: string,\r\n    type: TypeRef\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\r\n  }\r\n\r\n  load(\r\n    bytes: Index,\r\n    signed: bool,\r\n    ptr: ExpressionRef,\r\n    type: TypeRef,\r\n    offset: Index = 0,\r\n    align: Index = bytes // naturally aligned by default\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr);\r\n  }\r\n\r\n  store(\r\n    bytes: Index,\r\n    ptr: ExpressionRef,\r\n    value: ExpressionRef,\r\n    type: TypeRef,\r\n    offset: Index = 0,\r\n    align: Index = bytes // naturally aligned by default\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);\r\n  }\r\n\r\n  atomic_load(\r\n    bytes: Index,\r\n    ptr: ExpressionRef,\r\n    type: TypeRef,\r\n    offset: Index = 0\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\r\n  }\r\n\r\n  atomic_store(\r\n    bytes: Index,\r\n    ptr: ExpressionRef,\r\n    value: ExpressionRef,\r\n    type: TypeRef,\r\n    offset: Index = 0\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\r\n  }\r\n\r\n  atomic_rmw(\r\n    op: AtomicRMWOp,\r\n    bytes: Index,\r\n    offset: Index,\r\n    ptr: ExpressionRef,\r\n    value: ExpressionRef,\r\n    type: TypeRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\r\n  }\r\n\r\n  atomic_cmpxchg(\r\n    bytes: Index,\r\n    offset: Index,\r\n    ptr: ExpressionRef,\r\n    expected: ExpressionRef,\r\n    replacement: ExpressionRef,\r\n    type: TypeRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\r\n  }\r\n\r\n  atomic_wait(\r\n    ptr: ExpressionRef,\r\n    expected: ExpressionRef,\r\n    timeout: ExpressionRef,\r\n    expectedType: TypeRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\r\n  }\r\n\r\n  atomic_notify(\r\n    ptr: ExpressionRef,\r\n    notifyCount: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount);\r\n  }\r\n\r\n  atomic_fence(): ExpressionRef {\r\n    return binaryen._BinaryenAtomicFence(this.ref);\r\n  }\r\n\r\n  // statements\r\n\r\n  local_set(\r\n    index: Index,\r\n    value: ExpressionRef,\r\n    isManaged: bool\r\n  ): ExpressionRef {\r\n    if (isManaged && this.useShadowStack) {\r\n      value = this.tostack(value);\r\n    }\r\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\r\n  }\r\n\r\n  global_set(\r\n    name: string,\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\r\n  }\r\n\r\n  block(\r\n    label: string | null,\r\n    children: ExpressionRef[],\r\n    type: TypeRef = TypeRef.None\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(label);\r\n    var cArr = allocPtrArray(children);\r\n    var ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\r\n  flatten(\r\n    stmts: ExpressionRef[],\r\n    type: TypeRef = TypeRef.None\r\n  ): ExpressionRef {\r\n    var length = stmts.length;\r\n    if (length == 0) return this.nop(); // usually filtered out again\r\n    if (length == 1) {\r\n      let single = stmts[0];\r\n      switch (getExpressionId(single)) {\r\n        case ExpressionId.Return:\r\n        case ExpressionId.Throw:\r\n        case ExpressionId.Unreachable: {\r\n          // type does no matter, terminates anyway\r\n          return single;\r\n        }\r\n      }\r\n      let singleType = getExpressionType(single);\r\n      assert(singleType == TypeRef.Unreachable || singleType == type);\r\n      return single;\r\n    }\r\n    return this.block(null, stmts, type);\r\n  }\r\n\r\n  br(\r\n    label: string | null,\r\n    condition: ExpressionRef = 0,\r\n    value: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(label);\r\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\r\n  }\r\n\r\n  drop(\r\n    expression: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenDrop(this.ref, expression);\r\n  }\r\n\r\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\r\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\r\n    // when encountering a local with an unknown value. This helper only drops\r\n    // the pre-evaluated condition if it has relevant side effects.\r\n    // see WebAssembly/binaryen#1237\r\n    if ((getSideEffects(condition) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\r\n      return this.block(null, [\r\n        this.drop(condition),\r\n        result\r\n      ], getExpressionType(result));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  loop(\r\n    label: string | null,\r\n    body: ExpressionRef\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(label);\r\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\r\n  }\r\n\r\n  if(\r\n    condition: ExpressionRef,\r\n    ifTrue: ExpressionRef,\r\n    ifFalse: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\r\n  }\r\n\r\n  nop(): ExpressionRef {\r\n    return binaryen._BinaryenNop(this.ref);\r\n  }\r\n\r\n  return(\r\n    expression: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenReturn(this.ref, expression);\r\n  }\r\n\r\n  select(\r\n    ifTrue: ExpressionRef,\r\n    ifFalse: ExpressionRef,\r\n    condition: ExpressionRef,\r\n    type: TypeRef = TypeRef.Auto\r\n  ): ExpressionRef {\r\n    if (type == TypeRef.Auto) {\r\n      type = binaryen._BinaryenExpressionGetType(ifTrue);\r\n      assert(type == binaryen._BinaryenExpressionGetType(ifFalse));\r\n    }\r\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\r\n  }\r\n\r\n  switch(\r\n    names: string[],\r\n    defaultName: string | null,\r\n    condition: ExpressionRef,\r\n    value: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    var numNames = names.length;\r\n    var strs = new Array<StringRef>(numNames);\r\n    for (let i = 0; i < numNames; ++i) {\r\n      strs[i] = this.allocStringCached(names[i]);\r\n    }\r\n    var cArr = allocPtrArray(strs);\r\n    var cStr = this.allocStringCached(defaultName);\r\n    var ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  call(\r\n    target: string,\r\n    operands: ExpressionRef[] | null,\r\n    returnType: TypeRef,\r\n    isReturn: bool = false\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(target);\r\n    var cArr = allocPtrArray(operands);\r\n    var ret = isReturn\r\n      ? binaryen._BinaryenReturnCall(\r\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\r\n        )\r\n      : binaryen._BinaryenCall(\r\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\r\n        );\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  return_call(\r\n    target: string,\r\n    operands: ExpressionRef[] | null,\r\n    returnType: TypeRef\r\n  ): ExpressionRef {\r\n    return this.call(target, operands, returnType, true);\r\n  }\r\n\r\n  call_indirect(\r\n    index: ExpressionRef,\r\n    operands: ExpressionRef[] | null,\r\n    params: TypeRef,\r\n    results: TypeRef,\r\n    isReturn: bool = false\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(\"0\"); // TODO: multiple tables\r\n    var cArr = allocPtrArray(operands);\r\n    var ret = isReturn\r\n      ? binaryen._BinaryenReturnCallIndirect(\r\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\r\n        )\r\n      : binaryen._BinaryenCallIndirect(\r\n          this.ref, cStr, index, cArr, operands ? operands.length : 0, params, results\r\n        );\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  return_call_indirect(\r\n    tableName: string,\r\n    index: ExpressionRef,\r\n    operands: ExpressionRef[] | null,\r\n    params: TypeRef,\r\n    results: TypeRef\r\n  ): ExpressionRef {\r\n    return this.call_indirect(index, operands, params, results, true);\r\n  }\r\n\r\n  unreachable(): ExpressionRef {\r\n    return binaryen._BinaryenUnreachable(this.ref);\r\n  }\r\n\r\n  // bulk memory\r\n\r\n  memory_copy(\r\n    dest: ExpressionRef,\r\n    source: ExpressionRef,\r\n    size: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size);\r\n  }\r\n\r\n  memory_fill(\r\n    dest: ExpressionRef,\r\n    value: ExpressionRef,\r\n    size: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size);\r\n  }\r\n\r\n  // exception handling\r\n\r\n  // try(\r\n  //   body: ExpressionRef,\r\n  //   catchTags: string[],\r\n  //   catchBodies: ExpressionRef[]\r\n  // ): ExpressionRef {\r\n  //   var numCatchTags = catchTags.length;\r\n  //   var strs = new Array<TagRef>(numCatchTags);\r\n  //   for (let i = 0; i < numCatchTags; ++i) {\r\n  //     strs[i] = this.allocStringCached(catchTags[i]);\r\n  //   }\r\n  //   var cArr1 = allocPtrArray(strs);\r\n  //   var cArr2 = allocPtrArray(catchBodies);\r\n  //   var ret = binaryen._BinaryenTry(this.ref, body, cArr1, numCatchTags, cArr2, catchBodies.length);\r\n  //   binaryen._free(cArr2);\r\n  //   binaryen._free(cArr1);\r\n  //   return ret;\r\n  // }\r\n\r\n  throw(\r\n    tagName: string,\r\n    operands: ExpressionRef[]\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(tagName);\r\n    var cArr = allocPtrArray(operands);\r\n    var ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  rethrow(\r\n    target: string\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(target);\r\n    return binaryen._BinaryenRethrow(this.ref, cStr);\r\n  }\r\n\r\n  // multi value (pseudo instructions)\r\n\r\n  pop(\r\n    type: TypeRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenPop(this.ref, type);\r\n  }\r\n\r\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\r\n    var cArr = allocPtrArray(operands);\r\n    var ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\r\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\r\n  }\r\n\r\n  // simd\r\n\r\n  simd_extract(\r\n    op: SIMDExtractOp,\r\n    vec: ExpressionRef,\r\n    idx: u8\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\r\n  }\r\n\r\n  simd_replace(\r\n    op: SIMDReplaceOp,\r\n    vec: ExpressionRef,\r\n    idx: u8,\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\r\n  }\r\n\r\n  simd_shuffle(\r\n    vec1: ExpressionRef,\r\n    vec2: ExpressionRef,\r\n    mask: Uint8Array\r\n  ): ExpressionRef {\r\n    assert(mask.length == 16);\r\n    var cArr = allocU8Array(mask);\r\n    var ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  simd_ternary(\r\n    op: SIMDTernaryOp,\r\n    a: ExpressionRef,\r\n    b: ExpressionRef,\r\n    c: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\r\n  }\r\n\r\n  simd_shift(\r\n    op: SIMDShiftOp,\r\n    vec: ExpressionRef,\r\n    shift: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\r\n  }\r\n\r\n  simd_load(\r\n    op: SIMDLoadOp,\r\n    ptr: ExpressionRef,\r\n    offset: u32,\r\n    align: u32\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr);\r\n  }\r\n\r\n  simd_loadstorelane(\r\n    op: SIMDLoadStoreLaneOp,\r\n    ptr: ExpressionRef,\r\n    offset: u32,\r\n    align: u32,\r\n    index: u8,\r\n    vec: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenSIMDLoadStoreLane(this.ref, op, offset, align, index, ptr, vec);\r\n  }\r\n\r\n  // reference types / gc\r\n\r\n  ref_is(\r\n    op: RefIsOp,\r\n    expr: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenRefIs(this.ref, op, expr);\r\n  }\r\n\r\n  ref_as(\r\n    op: RefAsOp,\r\n    expr: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenRefAs(this.ref, op, expr);\r\n  }\r\n\r\n  ref_func(\r\n    name: string,\r\n    type: TypeRef\r\n  ): ExpressionRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenRefFunc(this.ref, cStr, type);\r\n  }\r\n\r\n  i31_new(\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenI31New(this.ref, value);\r\n  }\r\n\r\n  i31_get(\r\n    expr: ExpressionRef,\r\n    signed: bool\r\n  ): ExpressionRef {\r\n    return binaryen._BinaryenI31Get(this.ref, expr, signed);\r\n  }\r\n\r\n  // globals\r\n\r\n  addGlobal(\r\n    name: string,\r\n    type: TypeRef,\r\n    mutable: bool,\r\n    initializer: ExpressionRef\r\n  ): GlobalRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\r\n  }\r\n\r\n  getGlobal(\r\n    name: string\r\n  ): GlobalRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\r\n  }\r\n\r\n  removeGlobal(\r\n    name: string\r\n  ): void {\r\n    var cStr = this.allocStringCached(name);\r\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\r\n  }\r\n\r\n  // tags\r\n\r\n  addTag(\r\n    name: string,\r\n    params: TypeRef,\r\n    results: TypeRef\r\n  ): TagRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenAddTag(this.ref, cStr, params, results);\r\n  }\r\n\r\n  getTag(\r\n    name: string\r\n  ): TagRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenGetTag(this.ref, cStr);\r\n  }\r\n\r\n  removeTag(\r\n    name: string\r\n  ): void {\r\n    var cStr = this.allocStringCached(name);\r\n    binaryen._BinaryenRemoveTag(this.ref, cStr);\r\n  }\r\n\r\n  // functions\r\n\r\n  addFunction(\r\n    name: string,\r\n    params: TypeRef,\r\n    results: TypeRef,\r\n    varTypes: TypeRef[] | null,\r\n    body: ExpressionRef\r\n  ): FunctionRef {\r\n    var cStr = this.allocStringCached(name);\r\n    var cArr = allocPtrArray(varTypes);\r\n    var ret = binaryen._BinaryenAddFunction(\r\n      this.ref,\r\n      cStr,\r\n      params,\r\n      results,\r\n      cArr,\r\n      varTypes ? varTypes.length : 0,\r\n      body\r\n    );\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  getFunction(\r\n    name: string\r\n  ): FunctionRef {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\r\n  }\r\n\r\n  removeFunction(name: string): void {\r\n    var cStr = this.allocStringCached(name);\r\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\r\n  }\r\n\r\n  hasFunction(name: string): bool {\r\n    var cStr = this.allocStringCached(name);\r\n    return binaryen._BinaryenGetFunction(this.ref, cStr) != 0;\r\n  }\r\n\r\n  private hasTemporaryFunction: bool = false;\r\n\r\n  addTemporaryFunction(\r\n    result: TypeRef,\r\n    paramTypes: TypeRef[] | null,\r\n    body: ExpressionRef\r\n  ): FunctionRef {\r\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\r\n    var tempName = this.allocStringCached(\"\");\r\n    var cArr = allocPtrArray(paramTypes);\r\n    var ret = binaryen._BinaryenAddFunction(this.ref,\r\n      tempName,\r\n      createType(paramTypes),\r\n      result,\r\n      0, 0,\r\n      body\r\n    );\r\n    binaryen._free(cArr);\r\n    return ret;\r\n  }\r\n\r\n  removeTemporaryFunction(): void {\r\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\r\n    var tempName = this.allocStringCached(\"\");\r\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\r\n  }\r\n\r\n  setStart(func: FunctionRef): void {\r\n    binaryen._BinaryenSetStart(this.ref, func);\r\n  }\r\n\r\n  // exports\r\n\r\n  addFunctionExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalName);\r\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\r\n  }\r\n\r\n  addTableExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalName);\r\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\r\n  }\r\n\r\n  addMemoryExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalName);\r\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\r\n  }\r\n\r\n  addGlobalExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalName);\r\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\r\n  }\r\n\r\n  addTagExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalName);\r\n    return binaryen._BinaryenAddTagExport(this.ref, cStr1, cStr2);\r\n  }\r\n\r\n  removeExport(externalName: string): void {\r\n    var cStr = this.allocStringCached(externalName);\r\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\r\n  }\r\n\r\n  hasExport(externalName: string): bool {\r\n    var cStr = this.allocStringCached(externalName);\r\n    return binaryen._BinaryenGetExport(this.ref, cStr) != 0;\r\n  }\r\n\r\n  // imports\r\n\r\n  addFunctionImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string,\r\n    params: TypeRef,\r\n    results: TypeRef\r\n  ): void {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalModuleName);\r\n    var cStr3 = this.allocStringCached(externalBaseName);\r\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\r\n  }\r\n\r\n  addTableImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string\r\n  ): void {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalModuleName);\r\n    var cStr3 = this.allocStringCached(externalBaseName);\r\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\r\n  }\r\n\r\n  addMemoryImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string,\r\n    shared: bool = false,\r\n  ): void {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalModuleName);\r\n    var cStr3 = this.allocStringCached(externalBaseName);\r\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\r\n  }\r\n\r\n  addGlobalImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string,\r\n    globalType: TypeRef,\r\n    mutable: bool = false\r\n  ): void {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalModuleName);\r\n    var cStr3 = this.allocStringCached(externalBaseName);\r\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\r\n  }\r\n\r\n  addTagImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string,\r\n    params: TypeRef,\r\n    results: TypeRef\r\n  ): void {\r\n    var cStr1 = this.allocStringCached(internalName);\r\n    var cStr2 = this.allocStringCached(externalModuleName);\r\n    var cStr3 = this.allocStringCached(externalBaseName);\r\n    binaryen._BinaryenAddTagImport(\r\n      this.ref, cStr1, cStr2, cStr3, params, results\r\n    );\r\n  }\r\n\r\n  // memory\r\n\r\n  /** Unlimited memory constant. */\r\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\r\n\r\n  setMemory(\r\n    initial: Index,\r\n    maximum: Index,\r\n    segments: MemorySegment[],\r\n    target: Target,\r\n    exportName: string | null = null,\r\n    shared: bool = false\r\n  ): void {\r\n    var cStr = this.allocStringCached(exportName);\r\n    var k = segments.length;\r\n    var segs = new Array<usize>(k);\r\n    var psvs = new Uint8Array(k);\r\n    var offs = new Array<ExpressionRef>(k);\r\n    var sizs = new Array<Index>(k);\r\n    for (let i = 0; i < k; ++i) {\r\n      let segment = segments[i];\r\n      let buffer = segment.buffer;\r\n      let offset = segment.offset;\r\n      segs[i] = allocU8Array(buffer);\r\n      psvs[i] = 0; // no passive segments currently\r\n      offs[i] = target == Target.WASM64\r\n        ? this.i64(i64_low(offset), i64_high(offset))\r\n        : this.i32(i64_low(offset));\r\n      sizs[i] = buffer.length;\r\n    }\r\n    var cArr1 = allocPtrArray(segs);\r\n    var cArr2 = allocU8Array(psvs);\r\n    var cArr3 = allocPtrArray(offs);\r\n    var cArr4 = allocU32Array(sizs);\r\n    binaryen._BinaryenSetMemory(\r\n      this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared\r\n    );\r\n    binaryen._free(cArr4);\r\n    binaryen._free(cArr3);\r\n    binaryen._free(cArr2);\r\n    binaryen._free(cArr1);\r\n    for (let i = k - 1; i >= 0; --i) {\r\n      binaryen._free(segs[i]);\r\n    }\r\n  }\r\n\r\n  // table\r\n\r\n  /** Unlimited table constant. */\r\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\r\n\r\n  addFunctionTable(\r\n    name: string,\r\n    initial: Index,\r\n    maximum: Index,\r\n    funcs: string[],\r\n    offset: ExpressionRef\r\n  ): void {\r\n    var cStr = this.allocStringCached(name);\r\n    var numNames = funcs.length;\r\n    var names = new Array<StringRef>(numNames);\r\n    for (let i = 0; i < numNames; ++i) {\r\n      names[i] = this.allocStringCached(funcs[i]);\r\n    }\r\n    var cArr = allocPtrArray(names);\r\n    var tableRef = binaryen._BinaryenGetTable(this.ref, cStr);\r\n    if (!tableRef) {\r\n      tableRef = binaryen._BinaryenAddTable(this.ref, cStr, initial, maximum);\r\n    } else {\r\n      binaryen._BinaryenTableSetInitial(tableRef, initial);\r\n      binaryen._BinaryenTableSetMax(tableRef, maximum);\r\n    }\r\n    binaryen._BinaryenAddActiveElementSegment(this.ref, cStr, cStr, cArr, numNames, offset);\r\n    binaryen._free(cArr);\r\n  }\r\n\r\n  /* setFunctionTable(\r\n    initial: Index,\r\n    maximum: Index,\r\n    funcs: string[],\r\n    offset: ExpressionRef\r\n  ): void {\r\n    var numNames = funcs.length;\r\n    var names = new Array<CString>(numNames);\r\n    for (let i = 0; i < numNames; ++i) {\r\n      names[i] = this.allocStringCached(funcs[i]);\r\n    }\r\n    var cArr = allocPtrArray(names);\r\n    binaryen._BinaryenSetFunctionTable(\r\n      this.ref, initial, maximum, cArr, numNames, offset\r\n    );\r\n    binaryen._free(cArr);\r\n  } */\r\n\r\n  // sections\r\n\r\n  addCustomSection(name: string, contents: Uint8Array): void {\r\n    var cStr = this.allocStringCached(name);\r\n    var cArr = allocU8Array(contents);\r\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\r\n    binaryen._free(cArr);\r\n  }\r\n\r\n  // meta (global)\r\n\r\n  getOptimizeLevel(): i32 {\r\n    return binaryen._BinaryenGetOptimizeLevel();\r\n  }\r\n\r\n  setOptimizeLevel(level: i32): void {\r\n    binaryen._BinaryenSetOptimizeLevel(level);\r\n  }\r\n\r\n  getShrinkLevel(): i32 {\r\n    return binaryen._BinaryenGetShrinkLevel();\r\n  }\r\n\r\n  setShrinkLevel(level: i32): void {\r\n    binaryen._BinaryenSetShrinkLevel(level);\r\n  }\r\n\r\n  getDebugInfo(): boolean {\r\n    return binaryen._BinaryenGetDebugInfo();\r\n  }\r\n\r\n  setDebugInfo(on: bool): void {\r\n    binaryen._BinaryenSetDebugInfo(on);\r\n  }\r\n\r\n  getLowMemoryUnused(): bool {\r\n    return binaryen._BinaryenGetLowMemoryUnused();\r\n  }\r\n\r\n  setLowMemoryUnused(on: bool): void {\r\n    binaryen._BinaryenSetLowMemoryUnused(on);\r\n  }\r\n\r\n  getFastMath(): bool {\r\n    return binaryen._BinaryenGetFastMath();\r\n  }\r\n\r\n  setFastMath(on: bool): void {\r\n    binaryen._BinaryenSetFastMath(on);\r\n  }\r\n\r\n  getPassArgument(key: string): string | null {\r\n    var cStr = this.allocStringCached(key);\r\n    var ptr = binaryen._BinaryenGetPassArgument(cStr);\r\n    return ptr ? readString(ptr) : null;\r\n  }\r\n\r\n  setPassArgument(key: string, value: string | null): void {\r\n    var cStr1 = this.allocStringCached(key);\r\n    var cStr2 = this.allocStringCached(value);\r\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\r\n  }\r\n\r\n  clearPassArguments(): void {\r\n    binaryen._BinaryenClearPassArguments();\r\n  }\r\n\r\n  getAlwaysInlineMaxSize(): Index {\r\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\r\n  }\r\n\r\n  setAlwaysInlineMaxSize(size: Index): void {\r\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\r\n  }\r\n\r\n  getFlexibleInlineMaxSize(): Index {\r\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\r\n  }\r\n\r\n  setFlexibleInlineMaxSize(size: Index): void {\r\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\r\n  }\r\n\r\n  getOneCallerInlineMaxSize(): Index {\r\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\r\n  }\r\n\r\n  setOneCallerInlineMaxSize(size: Index): void {\r\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\r\n  }\r\n\r\n  getAllowInliningFunctionsWithLoops(): bool {\r\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\r\n  }\r\n\r\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\r\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\r\n  }\r\n\r\n  // meta (module)\r\n\r\n  getFeatures(): FeatureFlags {\r\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\r\n  }\r\n\r\n  setFeatures(featureFlags: FeatureFlags): void {\r\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\r\n  }\r\n\r\n  runPass(pass: string, func: FunctionRef = 0): void {\r\n    var cStr = allocString(pass);\r\n    if (func) {\r\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cStr, 1);\r\n    } else {\r\n      binaryen._BinaryenModuleRunPasses(this.ref, cStr, 1);\r\n    }\r\n    binaryen._free(cStr);\r\n  }\r\n\r\n  runPasses(passes: string[], func: FunctionRef = 0): void {\r\n    var numNames = passes.length;\r\n    var cStrs = new Array<StringRef>(numNames);\r\n    for (let i = 0; i < numNames; ++i) {\r\n      cStrs[i] = allocString(passes[i]);\r\n    }\r\n    var cArr = allocPtrArray(cStrs);\r\n    if (func) {\r\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\r\n    } else {\r\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\r\n    }\r\n    binaryen._free(cArr);\r\n    for (let i = numNames - 1; i >= 0; --i) binaryen._free(cStrs[i]);\r\n  }\r\n\r\n  optimize(optimizeLevel: i32, shrinkLevel: i32, debugInfo: bool = false): void {\r\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\r\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\r\n\r\n    this.setOptimizeLevel(optimizeLevel);\r\n    this.setShrinkLevel(shrinkLevel);\r\n    this.setDebugInfo(debugInfo);\r\n    this.setFastMath(true);\r\n    this.clearPassArguments();\r\n\r\n    // Tweak inlining limits based on optimization levels\r\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\r\n      this.setAlwaysInlineMaxSize(12);\r\n      this.setFlexibleInlineMaxSize(70);\r\n      this.setOneCallerInlineMaxSize(200);\r\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\r\n    } else {\r\n      this.setAlwaysInlineMaxSize(\r\n        optimizeLevel <= 1 || shrinkLevel >= 2\r\n          ? 2\r\n          : 6\r\n      );\r\n      this.setFlexibleInlineMaxSize(65);\r\n      this.setOneCallerInlineMaxSize(80);\r\n      this.setAllowInliningFunctionsWithLoops(false);\r\n    }\r\n\r\n    // Pass order here differs substantially from Binaryen's defaults\r\n    // see: Binaryen/src/pass.cpp\r\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\r\n      let passes = new Array<string>();\r\n\r\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\r\n\r\n      passes.push(\"duplicate-function-elimination\");\r\n      passes.push(\"remove-unused-module-elements\"); // +\r\n\r\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\r\n\r\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\r\n        passes.push(\"simplify-locals-notee-nostructure\");\r\n        passes.push(\"rse\");\r\n        passes.push(\"vacuum\");\r\n        passes.push(\"ssa-nomerge\");\r\n        passes.push(\"simplify-globals-optimizing\");\r\n        passes.push(\"remove-unused-brs\");\r\n        passes.push(\"remove-unused-names\");\r\n        passes.push(\"merge-blocks\");\r\n        passes.push(\"precompute-propagate\");\r\n      }\r\n      if (optimizeLevel >= 3) {\r\n        passes.push(\"flatten\");\r\n        passes.push(\"vacuum\");\r\n        passes.push(\"simplify-locals-notee-nostructure\");\r\n        passes.push(\"merge-locals\");\r\n\r\n        passes.push(\"code-folding\");\r\n        passes.push(\"flatten\");\r\n        passes.push(\"vacuum\");\r\n        passes.push(\"local-cse\");\r\n        passes.push(\"reorder-locals\");\r\n      }\r\n      passes.push(\"optimize-instructions\");\r\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\r\n        passes.push(\"dce\");\r\n      }\r\n      passes.push(\"remove-unused-names\");\r\n      passes.push(\"remove-unused-brs\");\r\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\r\n        passes.push(\"inlining\");\r\n        passes.push(\"precompute-propagate\");\r\n      } else {\r\n        passes.push(\"precompute\");\r\n      }\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\r\n        passes.push(\"pick-load-signs\");\r\n        passes.push(\"simplify-globals-optimizing\");\r\n      }\r\n      if (optimizeLevel >= 3 && shrinkLevel <= 1) {\r\n        passes.push(\"licm\");\r\n      }\r\n      passes.push(\"simplify-locals-nostructure\");\r\n      passes.push(\"vacuum\");\r\n\r\n      passes.push(\"reorder-locals\");\r\n      passes.push(\"remove-unused-brs\");\r\n      passes.push(\"coalesce-locals\");\r\n      passes.push(\"simplify-locals\");\r\n      passes.push(\"vacuum\");\r\n\r\n      passes.push(\"reorder-locals\");\r\n      passes.push(\"coalesce-locals\");\r\n      passes.push(\"reorder-locals\");\r\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\r\n        passes.push(\"merge-locals\");\r\n      }\r\n      passes.push(\"vacuum\");\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\r\n        passes.push(\"simplify-globals-optimizing\");\r\n      }\r\n      passes.push(\"merge-blocks\");\r\n      passes.push(\"remove-unused-brs\");\r\n      passes.push(\"remove-unused-names\");\r\n      passes.push(\"merge-blocks\");\r\n      if (optimizeLevel >= 3) {\r\n        passes.push(\"optimize-instructions\");\r\n      }\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\r\n        passes.push(\"rse\");\r\n        passes.push(\"vacuum\");\r\n      }\r\n\r\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\r\n\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\r\n        passes.push(\"simplify-globals-optimizing\");\r\n        passes.push(\"dae-optimizing\");\r\n      }\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\r\n        passes.push(\"inlining-optimizing\");\r\n      }\r\n      if (this.getLowMemoryUnused()) {\r\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\r\n          passes.push(\"optimize-added-constants-propagate\");\r\n        } else {\r\n          passes.push(\"optimize-added-constants\");\r\n        }\r\n      }\r\n      passes.push(\"duplicate-import-elimination\");\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\r\n        passes.push(\"simplify-globals-optimizing\");\r\n      } else {\r\n        passes.push(\"simplify-globals\");\r\n        passes.push(\"vacuum\");\r\n      }\r\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\r\n        passes.push(\"code-folding\");\r\n      }\r\n      if (optimizeLevel > 1 && (this.getFeatures() & FeatureFlags.GC) != 0) {\r\n        passes.push(\"heap2local\");\r\n      }\r\n      // precompute works best after global optimizations\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\r\n        passes.push(\"precompute-propagate\");\r\n      } else {\r\n        passes.push(\"precompute\");\r\n      }\r\n      passes.push(\"directize\"); // replace indirect with direct calls\r\n      passes.push(\"dae-optimizing\"); // reduce arity\r\n      passes.push(\"inlining-optimizing\"); // and inline if possible\r\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\r\n        passes.push(\"rse\");\r\n        // move code on early return (after CFG cleanup)\r\n        passes.push(\"code-pushing\");\r\n        if (optimizeLevel >= 3) {\r\n          // very expensive, so O3 only\r\n          passes.push(\"simplify-globals\");\r\n          passes.push(\"vacuum\");\r\n\r\n          passes.push(\"precompute-propagate\");\r\n\r\n          // replace indirect with direct calls again and inline\r\n          passes.push(\"inlining-optimizing\");\r\n          passes.push(\"directize\");\r\n          passes.push(\"dae-optimizing\");\r\n\r\n          passes.push(\"merge-locals\");\r\n          passes.push(\"coalesce-locals\");\r\n          passes.push(\"simplify-locals\");\r\n          passes.push(\"vacuum\");\r\n\r\n          passes.push(\"inlining\");\r\n          passes.push(\"precompute-propagate\");\r\n          passes.push(\"vacuum\");\r\n\r\n          passes.push(\"coalesce-locals\");\r\n        }\r\n        passes.push(\"remove-unused-brs\");\r\n        passes.push(\"remove-unused-names\");\r\n        passes.push(\"vacuum\");\r\n\r\n        passes.push(\"optimize-instructions\");\r\n        passes.push(\"simplify-globals-optimizing\");\r\n      }\r\n      // clean up\r\n      passes.push(\"duplicate-function-elimination\");\r\n      passes.push(\"remove-unused-nonfunction-module-elements\");\r\n      passes.push(\"memory-packing\");\r\n      passes.push(\"remove-unused-module-elements\");\r\n\r\n      this.runPasses(passes);\r\n    }\r\n  }\r\n\r\n  validate(): bool {\r\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\r\n  }\r\n\r\n  interpret(): void {\r\n    binaryen._BinaryenModuleInterpret(this.ref);\r\n  }\r\n\r\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\r\n    var out = this.lit; // safe to reuse as long as..\r\n    assert(binaryen._BinaryenSizeofLiteral() >= 12);\r\n    var cStr = allocString(sourceMapUrl);\r\n    var binaryPtr: usize = 0;\r\n    var sourceMapPtr: usize = 0;\r\n    binaryen._BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\r\n    binaryPtr = assert(binaryen.__i32_load(out));\r\n    var binaryLen = binaryen.__i32_load(out + 4);\r\n    sourceMapPtr = binaryen.__i32_load(out + 8); // may be NULL\r\n    var binary = new BinaryModule(readBuffer(binaryPtr, binaryLen), readString(sourceMapPtr));\r\n    if (cStr) binaryen._free(cStr);\r\n    binaryen._free(binaryPtr);\r\n    if (sourceMapPtr) binaryen._free(sourceMapPtr);\r\n    return binary;\r\n  }\r\n\r\n  toText(watFormat: bool = true): string {\r\n    throw new Error(\"not implemented\"); // JS glue overrides this\r\n  }\r\n\r\n  toAsmjs(): string {\r\n    throw new Error(\"not implemented\"); // JS glue overrides this\r\n  }\r\n\r\n  private cachedStringsToPointers: Map<string,usize> = new Map();\r\n  private cachedPointersToStrings: Map<usize,string | null> = new Map();\r\n\r\n  allocStringCached(str: string | null): usize {\r\n    if (str === null) return 0;\r\n    var cached = this.cachedStringsToPointers;\r\n    if (cached.has(str)) return changetype<usize>(cached.get(str));\r\n    var ptr = allocString(str);\r\n    cached.set(str, ptr);\r\n    return ptr;\r\n  }\r\n\r\n  readStringCached(ptr: usize): string | null {\r\n    // Binaryen internalizes names, so using this method where it's safe can\r\n    // avoid quite a bit of unnecessary garbage.\r\n    if (ptr == 0) return null;\r\n    var cached = this.cachedPointersToStrings;\r\n    if (cached.has(ptr)) return changetype<string>(this.cachedPointersToStrings.get(ptr));\r\n    var str = readString(ptr);\r\n    cached.set(ptr, str);\r\n    return str;\r\n  }\r\n\r\n  dispose(): void {\r\n    assert(this.ref);\r\n    // TODO: for (let ptr of this.cachedStrings.values()) {\r\n    for (let _values = Map_values(this.cachedStringsToPointers), i = 0, k = _values.length; i < k; ++i) {\r\n      let ptr = unchecked(_values[i]);\r\n      binaryen._free(ptr);\r\n    }\r\n    this.cachedStringsToPointers.clear();\r\n    this.cachedPointersToStrings.clear();\r\n    binaryen._free(this.lit);\r\n    binaryen._BinaryenModuleDispose(this.ref);\r\n    this.ref = 0;\r\n  }\r\n\r\n  createRelooper(): Relooper {\r\n    return Relooper.create(this);\r\n  }\r\n\r\n  cloneExpression(\r\n    expr: ExpressionRef,\r\n    noSideEffects: bool = false,\r\n    maxDepth: i32 = i32.MAX_VALUE\r\n  ): ExpressionRef { // currently supports side effect free expressions only\r\n    if (maxDepth < 0) return 0;\r\n    maxDepth -= 1;\r\n\r\n    var nested1: ExpressionRef,\r\n        nested2: ExpressionRef;\r\n\r\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\r\n      case ExpressionId.Const: {\r\n        switch (<u32>binaryen._BinaryenExpressionGetType(expr)) {\r\n          case <u32>TypeRef.I32: {\r\n            return this.i32(binaryen._BinaryenConstGetValueI32(expr));\r\n          }\r\n          case <u32>TypeRef.I64: {\r\n            return this.i64(\r\n              binaryen._BinaryenConstGetValueI64Low(expr),\r\n              binaryen._BinaryenConstGetValueI64High(expr)\r\n            );\r\n          }\r\n          case <u32>TypeRef.F32: {\r\n            return this.f32(binaryen._BinaryenConstGetValueF32(expr));\r\n          }\r\n          case <u32>TypeRef.F64: {\r\n            return this.f64(binaryen._BinaryenConstGetValueF64(expr));\r\n          }\r\n          case <u32>TypeRef.V128: {\r\n            // TODO\r\n            return 0;\r\n          }\r\n          // Not possible to clone an externref as it is opaque\r\n          case <u32>TypeRef.Externref: {\r\n            return 0;\r\n          }\r\n          default: {\r\n            throw new Error(\"concrete type expected\");\r\n          }\r\n        }\r\n      }\r\n      case ExpressionId.LocalGet: {\r\n        return binaryen._BinaryenLocalGet(this.ref,\r\n          binaryen._BinaryenLocalGetGetIndex(expr),\r\n          binaryen._BinaryenExpressionGetType(expr)\r\n        );\r\n      }\r\n      case ExpressionId.GlobalGet: {\r\n        let globalName = binaryen._BinaryenGlobalGetGetName(expr);\r\n        if (!globalName) break;\r\n        return binaryen._BinaryenGlobalGet(\r\n          this.ref, globalName, binaryen._BinaryenExpressionGetType(expr)\r\n        );\r\n      }\r\n      case ExpressionId.Load: {\r\n        if (!(nested1 = this.cloneExpression(\r\n          binaryen._BinaryenLoadGetPtr(expr), noSideEffects, maxDepth)\r\n        )) {\r\n          break;\r\n        }\r\n        return (\r\n          binaryen._BinaryenLoadIsAtomic(expr)\r\n            ? binaryen._BinaryenAtomicLoad(this.ref,\r\n                binaryen._BinaryenLoadGetBytes(expr),\r\n                binaryen._BinaryenLoadGetOffset(expr),\r\n                binaryen._BinaryenExpressionGetType(expr),\r\n                nested1\r\n              )\r\n            : binaryen._BinaryenLoad(this.ref,\r\n                binaryen._BinaryenLoadGetBytes(expr),\r\n                binaryen._BinaryenLoadIsSigned(expr),\r\n                binaryen._BinaryenLoadGetOffset(expr),\r\n                binaryen._BinaryenLoadGetAlign(expr),\r\n                binaryen._BinaryenExpressionGetType(expr),\r\n                nested1\r\n              )\r\n        );\r\n      }\r\n      case ExpressionId.Unary: {\r\n        if (!(nested1 = this.cloneExpression(\r\n          binaryen._BinaryenUnaryGetValue(expr), noSideEffects, maxDepth)\r\n        )) {\r\n          break;\r\n        }\r\n        return binaryen._BinaryenUnary(\r\n          this.ref, binaryen._BinaryenUnaryGetOp(expr), nested1\r\n        );\r\n      }\r\n      case ExpressionId.Binary: {\r\n        if (!(nested1 = this.cloneExpression(\r\n          binaryen._BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth)\r\n        )) {\r\n          break;\r\n        }\r\n        if (!(nested2 = this.cloneExpression(\r\n          binaryen._BinaryenBinaryGetRight(expr), noSideEffects, maxDepth)\r\n        )) {\r\n          break;\r\n        }\r\n        return binaryen._BinaryenBinary(\r\n          this.ref, binaryen._BinaryenBinaryGetOp(expr), nested1, nested2\r\n        );\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  copyExpression(expr: ExpressionRef): ExpressionRef {\r\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\r\n  }\r\n\r\n  runExpression(\r\n    expr: ExpressionRef,\r\n    flags: ExpressionRunnerFlags,\r\n    maxDepth: i32 = 50,\r\n    maxLoopIterations: i32 = 1\r\n  ): ExpressionRef {\r\n    var runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\r\n    var precomp =  binaryen._ExpressionRunnerRunAndDispose(runner, expr);\r\n    if (precomp) {\r\n      assert(getExpressionId(precomp) == ExpressionId.Const);\r\n      assert(getExpressionType(precomp) == getExpressionType(expr));\r\n    }\r\n    return precomp;\r\n  }\r\n\r\n  // source map generation\r\n\r\n  addDebugInfoFile(name: string): Index {\r\n    var cStr = allocString(name);\r\n    var ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\r\n    binaryen._free(cStr);\r\n    return ret;\r\n  }\r\n\r\n  getDebugInfoFile(index: Index): string | null {\r\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\r\n  }\r\n\r\n  setDebugLocation(\r\n    func: FunctionRef,\r\n    expr: ExpressionRef,\r\n    fileIndex: Index,\r\n    lineNumber: Index,\r\n    columnNumber: Index\r\n  ): void {\r\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\r\n  }\r\n}\r\n\r\n// types\r\n\r\nexport function createType(types: TypeRef[] | null): TypeRef {\r\n  if (!types) return TypeRef.None;\r\n  switch (types.length) {\r\n    case 0: return TypeRef.None;\r\n    case 1: return types[0];\r\n  }\r\n  var cArr = allocPtrArray(types);\r\n  var ret = binaryen._BinaryenTypeCreate(cArr, types.length);\r\n  binaryen._free(cArr);\r\n  return ret;\r\n}\r\n\r\nexport function expandType(type: TypeRef): TypeRef[] {\r\n  var arity = binaryen._BinaryenTypeArity(type);\r\n  var cArr = binaryen._malloc(<usize>arity << 2);\r\n  binaryen._BinaryenTypeExpand(type, cArr);\r\n  var types = new Array<TypeRef>(arity);\r\n  for (let i: u32 = 0; i < arity; ++i) {\r\n    types[i] = binaryen.__i32_load(cArr + (<usize>i << 2));\r\n  }\r\n  binaryen._free(cArr);\r\n  return types;\r\n}\r\n\r\n// expressions\r\n\r\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\r\n  return binaryen._BinaryenExpressionGetId(expr);\r\n}\r\n\r\nexport function getExpressionType(expr: ExpressionRef): TypeRef {\r\n  return binaryen._BinaryenExpressionGetType(expr);\r\n}\r\n\r\nexport function getConstValueI32(expr: ExpressionRef): i32 {\r\n  return binaryen._BinaryenConstGetValueI32(expr);\r\n}\r\n\r\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\r\n  return binaryen._BinaryenConstGetValueI64Low(expr);\r\n}\r\n\r\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\r\n  return binaryen._BinaryenConstGetValueI64High(expr);\r\n}\r\n\r\nexport function getConstValueF32(expr: ExpressionRef): f32 {\r\n  return binaryen._BinaryenConstGetValueF32(expr);\r\n}\r\n\r\nexport function getConstValueF64(expr: ExpressionRef): f64 {\r\n  return binaryen._BinaryenConstGetValueF64(expr);\r\n}\r\n\r\nexport function isConstZero(expr: ExpressionRef): bool {\r\n  if (getExpressionId(expr) != ExpressionId.Const) return false;\r\n  var type = getExpressionType(expr);\r\n  if (type == TypeRef.I32) return getConstValueI32(expr) == 0;\r\n  if (type == TypeRef.I64) return getConstValueI64Low(expr) == 0 && getConstValueI64High(expr) == 0;\r\n  if (type == TypeRef.F32) return getConstValueF32(expr) == 0;\r\n  if (type == TypeRef.F64) return getConstValueF64(expr) == 0;\r\n  return false;\r\n}\r\n\r\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\r\n  return binaryen._BinaryenLocalGetGetIndex(expr);\r\n}\r\n\r\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\r\n  return binaryen._BinaryenLocalSetGetIndex(expr);\r\n}\r\n\r\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenLocalSetGetValue(expr);\r\n}\r\n\r\nexport function isLocalTee(expr: ExpressionRef): bool {\r\n  return binaryen._BinaryenLocalSetIsTee(expr);\r\n}\r\n\r\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\r\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\r\n}\r\n\r\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\r\n  return binaryen._BinaryenBinaryGetOp(expr);\r\n}\r\n\r\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenBinaryGetLeft(expr);\r\n}\r\n\r\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenBinaryGetRight(expr);\r\n}\r\n\r\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\r\n  return binaryen._BinaryenUnaryGetOp(expr);\r\n}\r\n\r\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenUnaryGetValue(expr);\r\n}\r\n\r\nexport function getLoadBytes(expr: ExpressionRef): u32 {\r\n  return binaryen._BinaryenLoadGetBytes(expr);\r\n}\r\n\r\nexport function getLoadOffset(expr: ExpressionRef): u32 {\r\n  return binaryen._BinaryenLoadGetOffset(expr);\r\n}\r\n\r\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenLoadGetPtr(expr);\r\n}\r\n\r\nexport function isLoadSigned(expr: ExpressionRef): bool {\r\n  return binaryen._BinaryenLoadIsSigned(expr);\r\n}\r\n\r\nexport function getStoreBytes(expr: ExpressionRef): u32 {\r\n  return binaryen._BinaryenStoreGetBytes(expr);\r\n}\r\n\r\nexport function getStoreOffset(expr: ExpressionRef): u32 {\r\n  return binaryen._BinaryenStoreGetOffset(expr);\r\n}\r\n\r\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenStoreGetPtr(expr);\r\n}\r\n\r\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenStoreGetValue(expr);\r\n}\r\n\r\nexport function getBlockName(expr: ExpressionRef): string | null {\r\n  return readString(binaryen._BinaryenBlockGetName(expr));\r\n}\r\n\r\nexport function getBlockChildCount(expr: ExpressionRef): Index {\r\n  return binaryen._BinaryenBlockGetNumChildren(expr);\r\n}\r\n\r\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\r\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\r\n}\r\n\r\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenIfGetCondition(expr);\r\n}\r\n\r\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenIfGetIfTrue(expr);\r\n}\r\n\r\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenIfGetIfFalse(expr);\r\n}\r\n\r\nexport function getLoopName(expr: ExpressionRef): string | null {\r\n  return readString(binaryen._BinaryenLoopGetName(expr));\r\n}\r\n\r\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenLoopGetBody(expr);\r\n}\r\n\r\nexport function getBreakName(expr: ExpressionRef): string | null {\r\n  return readString(binaryen._BinaryenBreakGetName(expr));\r\n}\r\n\r\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenBreakGetCondition(expr);\r\n}\r\n\r\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenSelectGetIfTrue(expr);\r\n}\r\n\r\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenSelectGetIfFalse(expr);\r\n}\r\n\r\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenSelectGetCondition(expr);\r\n}\r\n\r\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenDropGetValue(expr);\r\n}\r\n\r\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenReturnGetValue(expr);\r\n}\r\n\r\nexport function getCallTarget(expr: ExpressionRef): string | null {\r\n  return readString(binaryen._BinaryenCallGetTarget(expr));\r\n}\r\n\r\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\r\n  return binaryen._BinaryenCallGetNumOperands(expr);\r\n}\r\n\r\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\r\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\r\n}\r\n\r\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\r\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\r\n}\r\n\r\n// functions\r\n\r\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\r\n  return binaryen._BinaryenFunctionGetBody(func);\r\n}\r\n\r\nexport function getFunctionName(func: FunctionRef): string | null {\r\n  return readString(binaryen._BinaryenFunctionGetName(func));\r\n}\r\n\r\nexport function getFunctionParams(func: FunctionRef): TypeRef {\r\n  return binaryen._BinaryenFunctionGetParams(func);\r\n}\r\n\r\nexport function getFunctionResults(func: FunctionRef): TypeRef {\r\n  return binaryen._BinaryenFunctionGetResults(func);\r\n}\r\n\r\nexport function getFunctionVars(func: FunctionRef): TypeRef[] {\r\n  var count = binaryen._BinaryenFunctionGetNumVars(func);\r\n  var types = new Array<TypeRef>(count);\r\n  for (let i: Index = 0; i < count; ++i) {\r\n    types[i] = binaryen._BinaryenFunctionGetVar(func, i);\r\n  }\r\n  return types;\r\n}\r\n\r\n// globals\r\n\r\nexport function getGlobalName(global: GlobalRef): string | null {\r\n  return readString(binaryen._BinaryenGlobalGetName(global));\r\n}\r\n\r\nexport function getGlobalType(global: GlobalRef): TypeRef {\r\n  return binaryen._BinaryenGlobalGetType(global);\r\n}\r\n\r\nexport function isGlobalMutable(global: GlobalRef): bool {\r\n  return binaryen._BinaryenGlobalIsMutable(global);\r\n}\r\n\r\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\r\n  return binaryen._BinaryenGlobalGetInitExpr(global);\r\n}\r\n\r\n// tags\r\n\r\nexport function getTagName(tag: TagRef): string | null {\r\n  return readString(binaryen._BinaryenTagGetName(tag));\r\n}\r\n\r\nexport function getTagParams(tag: TagRef): TypeRef {\r\n  return binaryen._BinaryenTagGetParams(tag);\r\n}\r\n\r\nexport function getTagResults(tag: TagRef): TypeRef {\r\n  return binaryen._BinaryenTagGetResults(tag);\r\n}\r\n\r\nexport class Relooper {\r\n  constructor(\r\n    /** Module this relooper belongs to. */\r\n    public module: Module,\r\n    /** Binaryen relooper reference. */\r\n    public ref: RelooperRef\r\n  ) {}\r\n\r\n  static create(module: Module): Relooper {\r\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\r\n  }\r\n\r\n  addBlock(code: ExpressionRef): RelooperBlockRef {\r\n    return binaryen._RelooperAddBlock(this.ref, code);\r\n  }\r\n\r\n  addBranch(\r\n    from: RelooperBlockRef,\r\n    to: RelooperBlockRef,\r\n    condition: ExpressionRef = 0,\r\n    code: ExpressionRef = 0\r\n  ): void {\r\n    binaryen._RelooperAddBranch(from, to, condition, code);\r\n  }\r\n\r\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\r\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\r\n  }\r\n\r\n  addBranchForSwitch(\r\n    from: RelooperBlockRef,\r\n    to: RelooperBlockRef,\r\n    indexes: i32[],\r\n    code: ExpressionRef = 0\r\n  ): void {\r\n    var cArr = allocI32Array(indexes);\r\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\r\n    binaryen._free(cArr);\r\n  }\r\n\r\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\r\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\r\n  }\r\n}\r\n\r\n/** Builds a switch using a sequence of `br_if`s. */\r\nexport class SwitchBuilder {\r\n  // This is useful because Binaryen understands sequences of `br_if`s and\r\n  // knows how to make a `br_table` from such a sequence if switched over\r\n  // values are considered dense enough, respectively a size-efficient sequence\r\n  // of `if`s if not, depending on optimization levels.\r\n\r\n  private module: Module;\r\n  private condition: ExpressionRef;\r\n  private values: i32[] = new Array();\r\n  private indexes: i32[] = new Array();\r\n  private cases: ExpressionRef[][] = new Array();\r\n  private defaultIndex: i32 = -1;\r\n\r\n  /** Creates a new builder using the specified i32 condition. */\r\n  constructor(module: Module, condition: ExpressionRef) {\r\n    this.module = module;\r\n    this.condition = condition;\r\n  }\r\n\r\n  /** Links a case to the specified branch. */\r\n  addCase(value: i32, code: ExpressionRef[]): void {\r\n    var cases = this.cases;\r\n    var index = cases.indexOf(code);\r\n    if (index < 0) {\r\n      index = cases.length;\r\n      cases.push(code);\r\n    }\r\n    this.values.push(value);\r\n    this.indexes.push(index);\r\n  }\r\n\r\n  /** Links the default branch. */\r\n  addDefault(code: ExpressionRef[]): void {\r\n    assert(this.defaultIndex == -1);\r\n    var cases = this.cases;\r\n    this.defaultIndex = cases.length;\r\n    cases.push(code);\r\n  }\r\n\r\n  /** Renders the switch to a block. */\r\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\r\n    var module = this.module;\r\n    var cases = this.cases;\r\n    var numCases = cases.length;\r\n    if (!numCases) {\r\n      return module.drop(this.condition);\r\n    }\r\n    var values = this.values;\r\n    var numValues = values.length;\r\n    var indexes = this.indexes;\r\n    var entry = new Array<ExpressionRef>(1 + numValues + 1);\r\n    var labels = new Array<string>(numCases);\r\n    for (let i = 0; i < numCases; ++i) {\r\n      labels[i] = \"case\" + i.toString() + labelPostfix;\r\n    }\r\n    entry[0] = module.local_set(localIndex, this.condition, false); // u32\r\n    for (let i = 0; i < numValues; ++i) {\r\n      let index = indexes[i];\r\n      entry[1 + i] = module.br(labels[index],\r\n        module.binary(BinaryOp.EqI32,\r\n          module.local_get(localIndex, TypeRef.I32),\r\n          module.i32(values[i])\r\n        )\r\n      );\r\n    }\r\n    var defaultIndex = this.defaultIndex;\r\n    var defaultLabel = \"default\" + labelPostfix;\r\n    entry[1 + numValues] = module.br(\r\n      ~defaultIndex\r\n        ? labels[defaultIndex]\r\n        : defaultLabel\r\n    );\r\n    var current = module.block(labels[0], entry);\r\n    for (let i = 1; i < numCases; ++i) {\r\n      let block = cases[i - 1];\r\n      block.unshift(current);\r\n      current = module.block(labels[i], block);\r\n    }\r\n    var lastCase = cases[numCases - 1];\r\n    lastCase.unshift(current);\r\n    return module.block(\r\n      ~defaultIndex\r\n        ? null\r\n        : defaultLabel,\r\n      lastCase\r\n    );\r\n  }\r\n}\r\n\r\nexport enum SideEffects {\r\n  None = 0 /* _BinaryenSideEffectNone */,\r\n  Branches = 1 /* _BinaryenSideEffectBranches */,\r\n  Calls = 2 /* _BinaryenSideEffectCalls */,\r\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\r\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\r\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\r\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\r\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\r\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\r\n  ImplicitTrap = 256 /* _BinaryenSideEffectImplicitTrap */,\r\n  IsAtomic = 512 /* _BinaryenSideEffectIsAtomic */,\r\n  Throws = 1024 /* _BinaryenSideEffectThrows */,\r\n  DanglingPop = 2048 /* _BinaryenSideEffectDanglingPop */,\r\n  Any = 4095 /* _BinaryenSideEffectAny */\r\n}\r\n\r\nexport function getSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): SideEffects {\r\n  return binaryen._BinaryenExpressionGetSideEffects(expr, features);\r\n}\r\n\r\nexport function hasSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): bool {\r\n  return getSideEffects(expr, features) != SideEffects.None;\r\n}\r\n\r\n// helpers\r\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\r\n\r\nfunction allocU8Array(u8s: Uint8Array | null): usize {\r\n  if (!u8s) return 0;\r\n  var len = u8s.length;\r\n  var ptr = binaryen._malloc(len);\r\n  for (let i = 0; i < len; ++i) {\r\n    binaryen.__i32_store8(ptr + i, u8s[i]);\r\n  }\r\n  return ptr;\r\n}\r\n\r\nfunction allocI32Array(i32s: i32[] | null): usize {\r\n  if (!i32s) return 0;\r\n  var len = i32s.length;\r\n  var ptr = binaryen._malloc(len << 2);\r\n  var idx = ptr;\r\n  for (let i = 0; i < len; ++i) {\r\n    let val = i32s[i];\r\n    binaryen.__i32_store(idx, val);\r\n    idx += 4;\r\n  }\r\n  return ptr;\r\n}\r\n\r\nfunction allocU32Array(u32s: u32[] | null): usize {\r\n  if (!u32s) return 0;\r\n  var len = u32s.length;\r\n  var ptr = binaryen._malloc(len << 2);\r\n  var idx = ptr;\r\n  for (let i = 0; i < len; ++i) {\r\n    let val = u32s[i];\r\n    binaryen.__i32_store(idx, val);\r\n    idx += 4;\r\n  }\r\n  return ptr;\r\n}\r\n\r\nexport function allocPtrArray(ptrs: usize[] | null): usize {\r\n  if (!ptrs) return 0;\r\n  // TODO: WASM64\r\n  assert(ASC_TARGET != Target.WASM64);\r\n  var len = ptrs.length;\r\n  var ptr = binaryen._malloc(len << 2);\r\n  var idx = ptr;\r\n  for (let i = 0, k = len; i < k; ++i) {\r\n    let val = ptrs[i];\r\n    binaryen.__i32_store(idx, <i32>val);\r\n    idx += 4;\r\n  }\r\n  return ptr;\r\n}\r\n\r\nfunction stringLengthUTF8(str: string): usize {\r\n  var len = 0;\r\n  for (let i = 0, k = str.length; i < k; ++i) {\r\n    let u = str.charCodeAt(i);\r\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      len += 1;\r\n    } else if (u <= 0x7FF) {\r\n      len += 2;\r\n    } else if (u <= 0xFFFF) {\r\n      len += 3;\r\n    } else {\r\n      len += 4;\r\n    }\r\n  }\r\n  return len;\r\n}\r\n\r\nfunction allocString(str: string | null): usize {\r\n  if (str === null) return 0;\r\n  var ptr = binaryen._malloc(stringLengthUTF8(str) + 1) >>> 0;\r\n  // the following is based on Emscripten's stringToUTF8Array\r\n  var idx = ptr;\r\n  for (let i = 0, k = str.length; i < k; ++i) {\r\n    let u = str.charCodeAt(i);\r\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      binaryen.__i32_store8(idx++, u as u8);\r\n    } else if (u <= 0x7FF) {\r\n      binaryen.__i32_store8(idx++, (0xC0 |  (u >>> 6)       ) as u8);\r\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\r\n    } else if (u <= 0xFFFF) {\r\n      binaryen.__i32_store8(idx++, (0xE0 |  (u >>> 12)      ) as u8);\r\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\r\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\r\n    } else {\r\n      assert(u < 0x200000, \"Invalid Unicode code point during allocString\");\r\n      binaryen.__i32_store8(idx++, (0xF0 |  (u >>> 18)      ) as u8);\r\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>> 12) & 63)) as u8);\r\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\r\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\r\n    }\r\n  }\r\n  binaryen.__i32_store8(idx, 0);\r\n  return ptr;\r\n}\r\n\r\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\r\n  var ret = new Uint8Array(len);\r\n  for (let i = 0; i < len; ++i) {\r\n    ret[i] = binaryen.__i32_load8_u(ptr + <usize>i);\r\n  }\r\n  return ret;\r\n}\r\n\r\nexport function readString(ptr: usize): string | null {\r\n  if (!ptr) return null;\r\n  var arr = new Array<i32>();\r\n  // the following is based on Emscripten's UTF8ArrayToString\r\n  var cp: u32;\r\n  var u1: u32, u2: u32, u3: u32;\r\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\r\n    if (!(cp & 0x80)) {\r\n      arr.push(cp);\r\n      continue;\r\n    }\r\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\r\n    if ((cp & 0xE0) == 0xC0) {\r\n      arr.push(((cp & 31) << 6) | u1);\r\n      continue;\r\n    }\r\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\r\n    if ((cp & 0xF0) == 0xE0) {\r\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\r\n    } else {\r\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\r\n      if ((cp & 0xF8) == 0xF0) {\r\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\r\n      } else {\r\n        assert(false, \"Invalid UTF8 sequence during readString\");\r\n      }\r\n    }\r\n    if (cp < 0x10000) {\r\n      arr.push(cp);\r\n    } else {\r\n      let ch = cp - 0x10000;\r\n      arr.push(0xD800 | (ch >>> 10));\r\n      arr.push(0xDC00 | (ch & 0x3FF));\r\n    }\r\n  }\r\n  return String.fromCharCodes(arr);\r\n}\r\n\r\n/** Result structure of {@link Module#toBinary}. */\r\nexport class BinaryModule {\r\n  constructor(\r\n    /** WebAssembly binary. */\r\n    public output: Uint8Array,\r\n    /** Source map, if generated. */\r\n    public sourceMap: string | null\r\n  ) {}\r\n}\r\n\r\n/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */\r\nexport function needsExplicitUnreachable(expr: ExpressionRef): bool {\r\n  // not applicable if pushing a value to the stack\r\n  if (binaryen._BinaryenExpressionGetType(expr) != TypeRef.Unreachable) {\r\n    return false;\r\n  }\r\n\r\n  switch (binaryen._BinaryenExpressionGetId(expr)) {\r\n    case ExpressionId.Unreachable:\r\n    case ExpressionId.Return: return false;\r\n    case ExpressionId.Break: {\r\n      return binaryen._BinaryenBreakGetCondition(expr) != 0;\r\n    }\r\n    case ExpressionId.Block: {\r\n      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it\r\n        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable\r\n        return (\r\n          numChildren > 0 &&\r\n          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n","/**\r\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\r\n *\r\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\r\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  CommonFlags,\r\n  LIBRARY_PREFIX,\r\n  PATH_DELIMITER\r\n} from \"./common\";\r\n\r\nimport {\r\n  Tokenizer,\r\n  Token,\r\n  Range,\r\n  CommentHandler,\r\n  IdentifierHandling,\r\n  isIllegalVariableIdentifier\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticEmitter,\r\n  DiagnosticMessage\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  CharCode,\r\n  normalizePath\r\n} from \"./util\";\r\n\r\nimport {\r\n  Node,\r\n  NodeKind,\r\n  Source,\r\n  SourceKind,\r\n  TypeNode,\r\n  TypeName,\r\n  NamedTypeNode,\r\n  FunctionTypeNode,\r\n  ArrowKind,\r\n\r\n  Expression,\r\n  AssertionKind,\r\n  CallExpression,\r\n  ClassExpression,\r\n  FunctionExpression,\r\n  IdentifierExpression,\r\n  StringLiteralExpression,\r\n\r\n  Statement,\r\n  BlockStatement,\r\n  BreakStatement,\r\n  ClassDeclaration,\r\n  ContinueStatement,\r\n  DeclarationStatement,\r\n  DecoratorNode,\r\n  DoStatement,\r\n  EnumDeclaration,\r\n  EnumValueDeclaration,\r\n  ExportImportStatement,\r\n  ExportMember,\r\n  ExportStatement,\r\n  ExpressionStatement,\r\n  ForOfStatement,\r\n  FunctionDeclaration,\r\n  IfStatement,\r\n  ImportDeclaration,\r\n  ImportStatement,\r\n  IndexSignatureNode,\r\n  NamespaceDeclaration,\r\n  ParameterNode,\r\n  ParameterKind,\r\n  ReturnStatement,\r\n  SwitchCase,\r\n  SwitchStatement,\r\n  ThrowStatement,\r\n  TryStatement,\r\n  TypeDeclaration,\r\n  TypeParameterNode,\r\n  VariableStatement,\r\n  VariableDeclaration,\r\n  VoidStatement,\r\n  WhileStatement,\r\n\r\n  mangleInternalPath\r\n} from \"./ast\";\r\n\r\n/** Represents a dependee. */\r\nclass Dependee {\r\n  constructor(\r\n    public source: Source,\r\n    public reportNode: Node\r\n  ) {}\r\n}\r\n\r\n/** Parser interface. */\r\nexport class Parser extends DiagnosticEmitter {\r\n\r\n  /** Source file names to be requested next. */\r\n  backlog: string[] = new Array();\r\n  /** Source file names already seen, that is processed or backlogged. */\r\n  seenlog: Set<string> = new Set();\r\n  /** Source file names already completely processed. */\r\n  donelog: Set<string> = new Set();\r\n  /** Optional handler to intercept comments while tokenizing. */\r\n  onComment: CommentHandler | null = null;\r\n  /** Current file being parsed. */\r\n  currentSource: Source | null = null;\r\n  /** Map of dependees being depended upon by a source, by path. */\r\n  dependees: Map<string, Dependee> = new Map();\r\n  /** An array of parsed sources. */\r\n  sources: Source[];\r\n\r\n  /** Constructs a new parser. */\r\n  constructor(\r\n    diagnostics: DiagnosticMessage[] | null = null,\r\n    sources: Source[] | null = null\r\n  ) {\r\n    super(diagnostics);\r\n    this.sources = sources ? sources : new Array<Source>();\r\n  }\r\n\r\n  /** Parses a file and adds its definitions to the program. */\r\n  parseFile(\r\n    /** Source text of the file, or `null` to indicate not found. */\r\n    text: string | null,\r\n    /** Normalized path of the file. */\r\n    path: string,\r\n    /** Whether this is an entry file. */\r\n    isEntry: bool\r\n  ): void {\r\n    // the frontend gives us paths with file extensions\r\n    var normalizedPath = normalizePath(path);\r\n    var internalPath = mangleInternalPath(normalizedPath);\r\n\r\n    // check if already processed\r\n    if (this.donelog.has(internalPath)) return;\r\n    this.donelog.add(internalPath); // do not parse again\r\n    this.seenlog.add(internalPath); // do not request again\r\n\r\n    // check if this is an error\r\n    if (text === null) {\r\n      let dependees = this.dependees;\r\n      let dependee: Dependee | null = null;\r\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\r\n      this.error(\r\n        DiagnosticCode.File_0_not_found,\r\n        dependee\r\n          ? dependee.reportNode.range\r\n          : null,\r\n        path\r\n      );\r\n      return;\r\n    }\r\n\r\n    // create the source element\r\n    var source = new Source(\r\n      isEntry\r\n        ? SourceKind.USER_ENTRY\r\n        : path.startsWith(LIBRARY_PREFIX)\r\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\r\n            ? SourceKind.LIBRARY_ENTRY\r\n            : SourceKind.LIBRARY\r\n          : SourceKind.USER,\r\n      normalizedPath,\r\n      text\r\n    );\r\n\r\n    this.sources.push(source);\r\n    this.currentSource = source;\r\n\r\n    // tokenize and parse\r\n    var tn = new Tokenizer(source, this.diagnostics);\r\n    tn.onComment = this.onComment;\r\n    var statements = source.statements;\r\n    while (!tn.skip(Token.ENDOFFILE)) {\r\n      let statement = this.parseTopLevelStatement(tn, null);\r\n      if (statement) {\r\n        statements.push(statement);\r\n      } else {\r\n        this.skipStatement(tn);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Parses a top-level statement. */\r\n  parseTopLevelStatement(\r\n    tn: Tokenizer,\r\n    namespace: NamespaceDeclaration | null = null\r\n  ): Statement | null {\r\n    var flags = CommonFlags.NONE;\r\n    var startPos = -1;\r\n\r\n    // check decorators\r\n    var decorators: DecoratorNode[] | null = null;\r\n    while (tn.skip(Token.AT)) {\r\n      if (startPos < 0) startPos = tn.tokenPos;\r\n      let decorator = this.parseDecorator(tn);\r\n      if (!decorator) {\r\n        this.skipStatement(tn);\r\n        continue;\r\n      }\r\n      if (!decorators) decorators = [decorator];\r\n      else decorators.push(decorator);\r\n    }\r\n\r\n    // check modifiers\r\n    var exportStart = 0;\r\n    var exportEnd = 0;\r\n    var defaultStart = 0;\r\n    var defaultEnd = 0;\r\n    if (tn.skip(Token.EXPORT)) {\r\n      if (startPos < 0) startPos = tn.tokenPos;\r\n      flags |= CommonFlags.EXPORT;\r\n      exportStart = tn.tokenPos;\r\n      exportEnd = tn.pos;\r\n      if (tn.skip(Token.DEFAULT)) {\r\n        defaultStart = tn.tokenPos;\r\n        defaultEnd = tn.pos;\r\n      }\r\n    }\r\n\r\n    var declareStart = 0;\r\n    var declareEnd = 0;\r\n    var contextIsAmbient = namespace != null && namespace.is(CommonFlags.AMBIENT);\r\n    if (tn.skip(Token.DECLARE)) {\r\n      if (contextIsAmbient) {\r\n        this.error(\r\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\r\n          tn.range()\r\n        ); // recoverable\r\n      } else {\r\n        if (startPos < 0) startPos = tn.tokenPos;\r\n        declareStart = startPos;\r\n        declareEnd = tn.pos;\r\n        flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;\r\n      }\r\n    } else if (contextIsAmbient) {\r\n      flags |= CommonFlags.AMBIENT;\r\n    }\r\n\r\n    // parse the statement\r\n    var statement: Statement | null = null;\r\n\r\n    // handle declarations\r\n    var first = tn.peek();\r\n    if (startPos < 0) startPos = tn.nextTokenPos;\r\n    switch (first) {\r\n      case Token.CONST: {\r\n        tn.next();\r\n        flags |= CommonFlags.CONST;\r\n        if (tn.skip(Token.ENUM)) {\r\n          statement = this.parseEnum(tn, flags, decorators, startPos);\r\n        } else {\r\n          statement = this.parseVariable(tn, flags, decorators, startPos);\r\n        }\r\n        decorators = null;\r\n        break;\r\n      }\r\n      case Token.LET: flags |= CommonFlags.LET;\r\n      case Token.VAR: {\r\n        tn.next();\r\n        statement = this.parseVariable(tn, flags, decorators, startPos);\r\n        decorators = null;\r\n        break;\r\n      }\r\n      case Token.ENUM: {\r\n        tn.next();\r\n        statement = this.parseEnum(tn, flags, decorators, startPos);\r\n        decorators = null;\r\n        break;\r\n      }\r\n      case Token.FUNCTION: {\r\n        tn.next();\r\n        statement = this.parseFunction(tn, flags, decorators, startPos);\r\n        decorators = null;\r\n        break;\r\n      }\r\n      case Token.ABSTRACT: {\r\n        let state = tn.mark();\r\n        tn.next();\r\n        let abstractStart = tn.tokenPos;\r\n        let abstractEnd = tn.pos;\r\n        let next = tn.peek(true);\r\n        if (tn.nextTokenOnNewLine) {\r\n          tn.reset(state);\r\n          statement = this.parseStatement(tn, true);\r\n          break;\r\n        }\r\n        if (next != Token.CLASS) {\r\n          if (next == Token.INTERFACE) {\r\n            this.error(\r\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\r\n              tn.range(abstractStart, abstractEnd)\r\n            );\r\n          }\r\n          tn.reset(state);\r\n          statement = this.parseStatement(tn, true);\r\n          break;\r\n        } else {\r\n          tn.discard(state);\r\n        }\r\n        flags |= CommonFlags.ABSTRACT;\r\n        // fall through\r\n      }\r\n      case Token.CLASS:\r\n      case Token.INTERFACE: {\r\n        tn.next();\r\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\r\n        decorators = null;\r\n        break;\r\n      }\r\n      case Token.NAMESPACE: {\r\n        let state = tn.mark();\r\n        tn.next();\r\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\r\n          tn.discard(state);\r\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\r\n          decorators = null;\r\n        } else {\r\n          tn.reset(state);\r\n          statement = this.parseStatement(tn, true);\r\n        }\r\n        break;\r\n      }\r\n      case Token.IMPORT: {\r\n        tn.next();\r\n        flags |= CommonFlags.IMPORT;\r\n        if (flags & CommonFlags.EXPORT) {\r\n          statement = this.parseExportImport(tn, startPos);\r\n        } else {\r\n          statement = this.parseImport(tn);\r\n        }\r\n        break;\r\n      }\r\n      case Token.TYPE: { // also identifier\r\n        let state = tn.mark();\r\n        tn.next();\r\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\r\n          tn.discard(state);\r\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\r\n          decorators = null;\r\n        } else {\r\n          tn.reset(state);\r\n          statement = this.parseStatement(tn, true);\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n\r\n        // handle plain exports\r\n        if (flags & CommonFlags.EXPORT) {\r\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.PREFER)) {\r\n            if (declareEnd) {\r\n              this.error(\r\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\r\n                tn.range(declareStart, declareEnd)\r\n              );\r\n            }\r\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\r\n            defaultStart = defaultEnd = 0; // consume\r\n          } else {\r\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.DECLARE) != 0);\r\n          }\r\n\r\n        // handle non-declaration statements\r\n        } else {\r\n          if (exportEnd) {\r\n            this.error(\r\n              DiagnosticCode._0_modifier_cannot_be_used_here,\r\n              tn.range(exportStart, exportEnd), \"export\"\r\n            ); // recoverable\r\n          }\r\n          if (declareEnd) {\r\n            this.error(\r\n              DiagnosticCode._0_modifier_cannot_be_used_here,\r\n              tn.range(declareStart, declareEnd), \"declare\"\r\n            ); // recoverable\r\n          }\r\n          if (!namespace) {\r\n            statement = this.parseStatement(tn, true);\r\n          } // TODO: else?\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // check for decorators that weren't consumed\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        this.error(\r\n          DiagnosticCode.Decorators_are_not_valid_here,\r\n          decorators[i].range\r\n        );\r\n      }\r\n    }\r\n\r\n    // check if this an `export default` declaration\r\n    if (defaultEnd && statement !== null) {\r\n      switch (statement.kind) {\r\n        case NodeKind.ENUMDECLARATION:\r\n        case NodeKind.FUNCTIONDECLARATION:\r\n        case NodeKind.CLASSDECLARATION:\r\n        case NodeKind.INTERFACEDECLARATION:\r\n        case NodeKind.NAMESPACEDECLARATION: {\r\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\r\n        }\r\n        default: {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(defaultStart, defaultEnd), \"default\"\r\n          );\r\n        }\r\n      }\r\n    }\r\n    return statement;\r\n  }\r\n\r\n  /** Obtains the next file to parse. */\r\n  nextFile(): string | null {\r\n    var backlog = this.backlog;\r\n    return backlog.length ? assert(backlog.shift()) : null;\r\n  }\r\n\r\n  /** Obtains the path of the dependee of the given imported file. */\r\n  getDependee(dependent: string): string | null {\r\n    var dependees = this.dependees;\r\n    if (dependees.has(dependent)) {\r\n      let dependee = assert(dependees.get(dependent));\r\n      return dependee.source.internalPath;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Finishes parsing. */\r\n  finish(): void {\r\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\r\n    this.backlog = [];\r\n    this.seenlog.clear();\r\n    this.donelog.clear();\r\n    this.dependees.clear();\r\n  }\r\n\r\n  // types\r\n\r\n  /** Parses a type name. */\r\n  parseTypeName(\r\n    tn: Tokenizer\r\n  ): TypeName | null {\r\n\r\n    // at: Identifier ('.' Identifier)*\r\n\r\n    var first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\r\n    var current = first;\r\n    while (tn.skip(Token.DOT)) {\r\n      if (tn.skip(Token.IDENTIFIER)) {\r\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\r\n        current.next = next;\r\n        current = next;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Identifier_expected,\r\n          tn.range(tn.pos)\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n    return first;\r\n  }\r\n\r\n  /** Parses a type. */\r\n  parseType(\r\n    tn: Tokenizer,\r\n    acceptParenthesized: bool = true,\r\n    suppressErrors: bool = false\r\n  ): TypeNode | null {\r\n\r\n    // before: Type\r\n\r\n    // NOTE: this parses our limited subset\r\n    var token = tn.next();\r\n    var startPos = tn.tokenPos;\r\n\r\n    var type: TypeNode;\r\n\r\n    // '(' ...\r\n    if (token == Token.OPENPAREN) {\r\n\r\n      // '(' FunctionSignature ')' '|' 'null'?\r\n      let isNullableSignature = tn.skip(Token.OPENPAREN);\r\n      // FunctionSignature?\r\n      let signature = this.tryParseFunctionType(tn);\r\n      if (signature) {\r\n        if (isNullableSignature) {\r\n          if (!tn.skip(Token.CLOSEPAREN)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \")\"\r\n            );\r\n            return null;\r\n          }\r\n          if (!tn.skip(Token.BAR)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"|\"\r\n            );\r\n            return null;\r\n          }\r\n          if (!tn.skip(Token.NULL)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"null\"\r\n            );\r\n          }\r\n          signature.isNullable = true;\r\n        }\r\n        return signature;\r\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\r\n        this.error(\r\n          DiagnosticCode.Unexpected_token,\r\n          tn.range()\r\n        );\r\n        return null;\r\n      }\r\n\r\n      // Type (',' Type)* ')'\r\n      if (acceptParenthesized) {\r\n        let innerType = this.parseType(tn, false, suppressErrors);\r\n        if (!innerType) return null;\r\n        if (!tn.skip(Token.CLOSEPAREN)) {\r\n          if (!suppressErrors) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(tn.pos), \")\"\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        type = innerType;\r\n        type.range.start = startPos;\r\n        type.range.end = tn.pos;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Unexpected_token,\r\n          tn.range()\r\n        );\r\n        return null;\r\n      }\r\n\r\n    // 'void'\r\n    } else if (token == Token.VOID) {\r\n      type = Node.createNamedType(\r\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // 'this'\r\n    } else if (token == Token.THIS) {\r\n      type = Node.createNamedType(\r\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // 'true'\r\n    } else if (token == Token.TRUE || token == Token.FALSE) {\r\n      type = Node.createNamedType(\r\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // 'null'\r\n    } else if (token == Token.NULL) {\r\n      type = Node.createNamedType(\r\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // StringLiteral\r\n    } else if (token == Token.STRINGLITERAL) {\r\n      tn.readString();\r\n      type = Node.createNamedType(\r\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // Identifier\r\n    } else if (token == Token.IDENTIFIER) {\r\n      let name = this.parseTypeName(tn);\r\n      if (!name) return null;\r\n      let parameters: TypeNode[] | null = null;\r\n\r\n      // Name<T>\r\n      if (tn.skip(Token.LESSTHAN)) {\r\n        do {\r\n          let parameter = this.parseType(tn, true, suppressErrors);\r\n          if (!parameter) return null;\r\n          if (!parameters) parameters = [ parameter ];\r\n          else parameters.push(parameter);\r\n        } while (tn.skip(Token.COMMA));\r\n        if (!tn.skip(Token.GREATERTHAN)) {\r\n          if (!suppressErrors) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(tn.pos), \">\"\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      if (!parameters) parameters = [];\r\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\r\n    } else {\r\n      if (!suppressErrors) {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          tn.range()\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    // ... | null\r\n    while (tn.skip(Token.BAR)) {\r\n      if (tn.skip(Token.NULL)) {\r\n        type.isNullable = true;\r\n      } else {\r\n        let notNullStart = tn.pos;\r\n        let notNull = this.parseType(tn, false, true);\r\n        if (!suppressErrors) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n    // ... [][]\r\n    while (tn.skip(Token.OPENBRACKET)) {\r\n      let bracketStart = tn.tokenPos;\r\n      if (!tn.skip(Token.CLOSEBRACKET)) {\r\n        if (!suppressErrors) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"]\"\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      let bracketRange = tn.range(bracketStart, tn.pos);\r\n\r\n      // ...[] | null\r\n      let nullable = false;\r\n      if (tn.skip(Token.BAR)) {\r\n        if (tn.skip(Token.NULL)) {\r\n          nullable = true;\r\n        } else {\r\n          if (!suppressErrors) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"null\"\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      type = Node.createNamedType(\r\n        Node.createSimpleTypeName(\"Array\", bracketRange),\r\n        [ type ],\r\n        nullable,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n      if (nullable) break;\r\n    }\r\n\r\n    return type;\r\n  }\r\n\r\n  // Indicates whether tryParseSignature determined that it is handling a Signature\r\n  private tryParseSignatureIsSignature: bool = false;\r\n\r\n  /** Parses a function type, as used in type declarations. */\r\n  tryParseFunctionType(\r\n    tn: Tokenizer\r\n  ): FunctionTypeNode | null {\r\n\r\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\r\n\r\n    var state = tn.mark();\r\n    var startPos = tn.tokenPos;\r\n    var parameters: ParameterNode[] | null = null;\r\n    var thisType: NamedTypeNode | null = null;\r\n    var isSignature: bool = false;\r\n    var firstParamNameNoType: IdentifierExpression | null = null;\r\n    var firstParamKind: ParameterKind = ParameterKind.DEFAULT;\r\n\r\n    if (tn.skip(Token.CLOSEPAREN)) {\r\n      isSignature = true;\r\n      tn.discard(state);\r\n      parameters = [];\r\n\r\n    } else {\r\n      isSignature = false; // not yet known\r\n      do {\r\n        let paramStart = -1;\r\n        let kind = ParameterKind.DEFAULT;\r\n        if (tn.skip(Token.DOT_DOT_DOT)) {\r\n          paramStart = tn.tokenPos;\r\n          isSignature = true;\r\n          tn.discard(state);\r\n          kind = ParameterKind.REST;\r\n        }\r\n        if (tn.skip(Token.THIS)) {\r\n          if (paramStart < 0) paramStart = tn.tokenPos;\r\n          if (tn.skip(Token.COLON)) {\r\n            isSignature = true;\r\n            tn.discard(state);\r\n            let type = this.parseType(tn, false);\r\n            if (!type) return null;\r\n            if (type.kind != NodeKind.NAMEDTYPE) {\r\n              this.error(\r\n                DiagnosticCode.Identifier_expected,\r\n                type.range\r\n              );\r\n              this.tryParseSignatureIsSignature = true;\r\n              return null;\r\n            }\r\n            thisType = <NamedTypeNode>type;\r\n          } else {\r\n            tn.reset(state);\r\n            this.tryParseSignatureIsSignature = false;\r\n            return null;\r\n          }\r\n        } else if (tn.skipIdentifier()) {\r\n          if (paramStart < 0) paramStart = tn.tokenPos;\r\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\r\n          if (tn.skip(Token.QUESTION)) {\r\n            isSignature = true;\r\n            tn.discard(state);\r\n            if (kind == ParameterKind.REST) {\r\n              this.error(\r\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\r\n                tn.range()\r\n              ); // recoverable\r\n            } else {\r\n              kind = ParameterKind.OPTIONAL;\r\n            }\r\n          }\r\n          if (tn.skip(Token.COLON)) {\r\n            isSignature = true;\r\n            tn.discard(state);\r\n            let type = this.parseType(tn); // not suppressing errors because known\r\n            if (!type) {\r\n              this.tryParseSignatureIsSignature = isSignature;\r\n              return null;\r\n            }\r\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\r\n            if (!parameters) parameters = [ param ];\r\n            else parameters.push(param);\r\n          } else {\r\n            if (!isSignature) {\r\n              if (tn.peek() == Token.COMMA) {\r\n                isSignature = true;\r\n                tn.discard(state);\r\n              }\r\n            }\r\n            if (isSignature) {\r\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\r\n              if (!parameters) parameters = [ param ];\r\n              else parameters.push(param);\r\n              this.error(\r\n                DiagnosticCode.Type_expected,\r\n                param.type.range\r\n              ); // recoverable\r\n            } else if (!parameters) {\r\n              // on '(' Identifier ^',' we don't yet know whether this is a\r\n              // parenthesized or a function type, hence we have to delay the\r\n              // respective diagnostic until we know for sure.\r\n              firstParamNameNoType = name;\r\n              firstParamKind = kind;\r\n            }\r\n          }\r\n        } else {\r\n          if (isSignature) {\r\n            this.error(\r\n              DiagnosticCode.Identifier_expected,\r\n              tn.range()\r\n            );\r\n          } else {\r\n            tn.reset(state);\r\n          }\r\n          this.tryParseSignatureIsSignature = isSignature;\r\n          return null;\r\n        }\r\n      } while (tn.skip(Token.COMMA));\r\n      if (!tn.skip(Token.CLOSEPAREN)) {\r\n        if (isSignature) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n        } else {\r\n          tn.reset(state);\r\n        }\r\n        this.tryParseSignatureIsSignature = isSignature;\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var returnType: TypeNode | null;\r\n    if (tn.skip(Token.EQUALS_GREATERTHAN)) {\r\n      if (!isSignature) {\r\n        isSignature = true;\r\n        tn.discard(state);\r\n        if (firstParamNameNoType) { // now we know\r\n          let param = Node.createParameter(\r\n            firstParamKind,\r\n            firstParamNameNoType,\r\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\r\n            null,\r\n            firstParamNameNoType.range\r\n          );\r\n          if (!parameters) parameters = [ param ];\r\n          else parameters.push(param);\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            param.type.range\r\n          ); // recoverable\r\n        }\r\n      }\r\n      returnType = this.parseType(tn);\r\n      if (!returnType) {\r\n        this.tryParseSignatureIsSignature = isSignature;\r\n        return null;\r\n      }\r\n    } else {\r\n      if (isSignature) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"=>\"\r\n        );\r\n      } else {\r\n        tn.reset(state);\r\n      }\r\n      this.tryParseSignatureIsSignature = isSignature;\r\n      return null;\r\n    }\r\n    this.tryParseSignatureIsSignature = true;\r\n\r\n    if (!parameters) parameters = [];\r\n\r\n    return Node.createFunctionType(\r\n      parameters,\r\n      returnType,\r\n      thisType,\r\n      false,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n  }\r\n\r\n  // statements\r\n\r\n  parseDecorator(\r\n    tn: Tokenizer\r\n  ): DecoratorNode | null {\r\n\r\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skipIdentifier()) {\r\n      let name = tn.readIdentifier();\r\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\r\n      while (tn.skip(Token.DOT)) {\r\n        if (tn.skipIdentifier(IdentifierHandling.PREFER)) {\r\n          name = tn.readIdentifier();\r\n          expression = Node.createPropertyAccessExpression(\r\n            expression,\r\n            Node.createIdentifierExpression(name, tn.range()),\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      let args: Expression[] | null;\r\n      if (tn.skip(Token.OPENPAREN)) {\r\n        args = this.parseArguments(tn);\r\n        if (args) {\r\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\r\n        }\r\n      } else {\r\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseVariable(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n    startPos: i32,\r\n    isFor: bool = false\r\n  ): VariableStatement | null {\r\n\r\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\r\n\r\n    var declarations = new Array<VariableDeclaration>();\r\n    do {\r\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\r\n      if (!declaration) return null;\r\n      declarations.push(declaration);\r\n    } while (tn.skip(Token.COMMA));\r\n\r\n    var ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseVariableDeclaration(\r\n    tn: Tokenizer,\r\n    parentFlags: CommonFlags,\r\n    parentDecorators: DecoratorNode[] | null,\r\n    isFor: bool = false\r\n  ): VariableDeclaration | null {\r\n\r\n    // before: Identifier (':' Type)? ('=' Expression)?\r\n\r\n    if (!tn.skipIdentifier()) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    if (isIllegalVariableIdentifier(identifier.text)) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        identifier.range\r\n      );\r\n    }\r\n    var flags = parentFlags;\r\n    if (tn.skip(Token.EXCLAMATION)) {\r\n      flags |= CommonFlags.DEFINITELY_ASSIGNED;\r\n    }\r\n\r\n    var type: TypeNode | null = null;\r\n    if (tn.skip(Token.COLON)) {\r\n      type = this.parseType(tn, true);\r\n    }\r\n\r\n    var initializer: Expression | null = null;\r\n    if (tn.skip(Token.EQUALS)) {\r\n      if (flags & CommonFlags.AMBIENT) {\r\n        this.error(\r\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n      initializer = this.parseExpression(tn, Precedence.COMMA + 1);\r\n      if (!initializer) return null;\r\n    } else if (!isFor) {\r\n      if (flags & CommonFlags.CONST) {\r\n        if (!(flags & CommonFlags.AMBIENT)) {\r\n          this.error(\r\n            DiagnosticCode._const_declarations_must_be_initialized,\r\n            identifier.range\r\n          ); // recoverable\r\n        }\r\n      } else if (!type) { // neither type nor initializer\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          tn.range(tn.pos)\r\n        ); // recoverable\r\n      }\r\n    }\r\n    var range = Range.join(identifier.range, tn.range());\r\n    if (initializer !== null && (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0) {\r\n      this.error(\r\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\r\n        range\r\n      );\r\n    }\r\n    return Node.createVariableDeclaration(\r\n      identifier,\r\n      parentDecorators,\r\n      flags,\r\n      type,\r\n      initializer,\r\n      range\r\n    );\r\n  }\r\n\r\n  parseEnum(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n    startPos: i32\r\n  ): EnumDeclaration | null {\r\n\r\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\r\n\r\n    if (tn.next() != Token.IDENTIFIER) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    if (tn.next() != Token.OPENBRACE) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n      return null;\r\n    }\r\n    var members = new Array<EnumValueDeclaration>();\r\n    while (!tn.skip(Token.CLOSEBRACE)) {\r\n      let member = this.parseEnumValue(tn, CommonFlags.NONE);\r\n      if (!member) return null;\r\n      members.push(member);\r\n      if (!tn.skip(Token.COMMA)) {\r\n        if (tn.skip(Token.CLOSEBRACE)) {\r\n          break;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"}\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n    var ret = Node.createEnumDeclaration(\r\n      identifier,\r\n      decorators,\r\n      flags,\r\n      members,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseEnumValue(\r\n    tn: Tokenizer,\r\n    parentFlags: CommonFlags\r\n  ): EnumValueDeclaration | null {\r\n\r\n    // before: Identifier ('=' Expression)?\r\n\r\n    if (!tn.skipIdentifier()) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    var value: Expression | null = null;\r\n    if (tn.skip(Token.EQUALS)) {\r\n      value = this.parseExpression(tn, Precedence.COMMA + 1);\r\n      if (!value) return null;\r\n    }\r\n    return Node.createEnumValueDeclaration(\r\n      identifier,\r\n      parentFlags,\r\n      value,\r\n      Range.join(identifier.range, tn.range())\r\n    );\r\n  }\r\n\r\n  parseReturn(\r\n    tn: Tokenizer\r\n  ): ReturnStatement | null {\r\n\r\n    // at 'return': Expression | (';' | '}' | ...'\\n')\r\n\r\n    var startPos = tn.tokenPos;\r\n    var expr: Expression | null = null;\r\n    if (\r\n      tn.peek(true) != Token.SEMICOLON &&\r\n      tn.nextToken != Token.CLOSEBRACE &&\r\n      !tn.nextTokenOnNewLine\r\n    ) {\r\n      if (!(expr = this.parseExpression(tn))) return null;\r\n    }\r\n\r\n    var ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseTypeParameters(\r\n    tn: Tokenizer\r\n  ): TypeParameterNode[] | null {\r\n\r\n    // at '<': TypeParameter (',' TypeParameter)* '>'\r\n\r\n    var typeParameters = new Array<TypeParameterNode>();\r\n    var seenOptional = false;\r\n    var start = tn.tokenPos;\r\n    while (!tn.skip(Token.GREATERTHAN)) {\r\n      let typeParameter = this.parseTypeParameter(tn);\r\n      if (!typeParameter) return null;\r\n      if (typeParameter.defaultType !== null) {\r\n        seenOptional = true;\r\n      } else if (seenOptional) {\r\n        this.error(\r\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\r\n          typeParameter.range\r\n        );\r\n        typeParameter.defaultType = null;\r\n      }\r\n      typeParameters.push(typeParameter);\r\n      if (!tn.skip(Token.COMMA)) {\r\n        if (tn.skip(Token.GREATERTHAN)) {\r\n          break;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \">\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n    if (!typeParameters.length) {\r\n      this.error(\r\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\r\n        tn.range(start, tn.pos)\r\n      ); // recoverable\r\n    }\r\n    return typeParameters;\r\n  }\r\n\r\n  parseTypeParameter(\r\n    tn: Tokenizer\r\n  ): TypeParameterNode | null {\r\n\r\n    // before: Identifier ('extends' Type)? ('=' Type)?\r\n\r\n    if (tn.next() == Token.IDENTIFIER) {\r\n      let identifier = Node.createIdentifierExpression(\r\n        tn.readIdentifier(),\r\n        tn.range()\r\n      );\r\n      let extendsType: NamedTypeNode | null = null;\r\n      if (tn.skip(Token.EXTENDS)) {\r\n        let type = this.parseType(tn);\r\n        if (!type) return null;\r\n        if (type.kind != NodeKind.NAMEDTYPE) {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            type.range\r\n          );\r\n          return null;\r\n        }\r\n        extendsType = <NamedTypeNode>type;\r\n      }\r\n      let defaultType: NamedTypeNode | null = null;\r\n      if (tn.skip(Token.EQUALS)) {\r\n        let type = this.parseType(tn);\r\n        if (!type) return null;\r\n        if (type.kind != NodeKind.NAMEDTYPE) {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            type.range\r\n          );\r\n          return null;\r\n        }\r\n        defaultType = <NamedTypeNode>type;\r\n      }\r\n      return Node.createTypeParameter(\r\n        identifier,\r\n        extendsType,\r\n        defaultType,\r\n        Range.join(identifier.range, tn.range())\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private parseParametersThis: NamedTypeNode | null = null;\r\n\r\n  parseParameters(\r\n    tn: Tokenizer,\r\n    isConstructor: bool = false\r\n  ): ParameterNode[] | null {\r\n\r\n    // at '(': (Parameter (',' Parameter)*)? ')'\r\n\r\n    var parameters = new Array<ParameterNode>();\r\n    var seenRest: ParameterNode | null = null;\r\n    var seenOptional = false;\r\n    var reportedRest = false;\r\n    var thisType: TypeNode | null = null;\r\n\r\n    // check if there is a leading `this` parameter\r\n    this.parseParametersThis = null;\r\n    if (tn.skip(Token.THIS)) {\r\n      if (tn.skip(Token.COLON)) {\r\n        thisType = this.parseType(tn); // reports\r\n        if (!thisType) return null;\r\n        if (thisType.kind == NodeKind.NAMEDTYPE) {\r\n          this.parseParametersThis = <NamedTypeNode>thisType;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            thisType.range\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \":\"\r\n        );\r\n        return null;\r\n      }\r\n      if (!tn.skip(Token.COMMA)) {\r\n        if (tn.skip(Token.CLOSEPAREN)) {\r\n          return parameters;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    while (!tn.skip(Token.CLOSEPAREN)) {\r\n      let param = this.parseParameter(tn, isConstructor); // reports\r\n      if (!param) return null;\r\n      if (seenRest !== null && !reportedRest) {\r\n        this.error(\r\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\r\n          seenRest.name.range\r\n        );\r\n        reportedRest = true;\r\n      }\r\n      switch (param.parameterKind) {\r\n        default: {\r\n          if (seenOptional) {\r\n            this.error(\r\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\r\n              param.name.range\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case ParameterKind.OPTIONAL: {\r\n          seenOptional = true;\r\n          break;\r\n        }\r\n        case ParameterKind.REST: {\r\n          seenRest = param;\r\n          break;\r\n        }\r\n      }\r\n      parameters.push(param);\r\n      if (!tn.skip(Token.COMMA)) {\r\n        if (tn.skip(Token.CLOSEPAREN)) {\r\n          break;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n    return parameters;\r\n  }\r\n\r\n  parseParameter(\r\n    tn: Tokenizer,\r\n    isConstructor: bool = false\r\n  ): ParameterNode | null {\r\n\r\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\r\n\r\n    var isRest = false;\r\n    var isOptional = false;\r\n    var startRange: Range | null = null;\r\n    var accessFlags: CommonFlags = CommonFlags.NONE;\r\n    if (isConstructor) {\r\n      if (tn.skip(Token.PUBLIC)) {\r\n        startRange = tn.range();\r\n        accessFlags |= CommonFlags.PUBLIC;\r\n      } else if (tn.skip(Token.PROTECTED)) {\r\n        startRange = tn.range();\r\n        accessFlags |= CommonFlags.PROTECTED;\r\n      } else if (tn.skip(Token.PRIVATE)) {\r\n        startRange = tn.range();\r\n        accessFlags |= CommonFlags.PRIVATE;\r\n      }\r\n      if (tn.peek() == Token.READONLY) {\r\n        let state = tn.mark();\r\n        tn.next();\r\n        if (tn.peek() != Token.COLON) { // modifier\r\n          tn.discard(state);\r\n          if (!startRange) startRange = tn.range();\r\n          accessFlags |= CommonFlags.READONLY;\r\n        } else { // identifier\r\n          tn.reset(state);\r\n        }\r\n      }\r\n    }\r\n    if (tn.skip(Token.DOT_DOT_DOT)) {\r\n      if (accessFlags) {\r\n        this.error(\r\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\r\n          tn.range()\r\n        );\r\n      } else {\r\n        startRange = tn.range();\r\n      }\r\n      isRest = true;\r\n    }\r\n    if (tn.skipIdentifier()) {\r\n      if (!isRest) startRange = tn.range();\r\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      let type: TypeNode | null = null;\r\n      if (isOptional = tn.skip(Token.QUESTION)) {\r\n        if (isRest) {\r\n          this.error(\r\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\r\n            identifier.range\r\n          );\r\n        }\r\n      }\r\n      if (tn.skip(Token.COLON)) {\r\n        type = this.parseType(tn);\r\n        if (!type) return null;\r\n      } else {\r\n        type = Node.createOmittedType(tn.range(tn.pos));\r\n      }\r\n      let initializer: Expression | null = null;\r\n      if (tn.skip(Token.EQUALS)) {\r\n        if (isRest) {\r\n          this.error(\r\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\r\n            identifier.range\r\n          );\r\n        }\r\n        if (isOptional) {\r\n          this.error(\r\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\r\n            identifier.range\r\n          );\r\n        } else {\r\n          isOptional = true;\r\n        }\r\n        initializer = this.parseExpression(tn, Precedence.COMMA + 1);\r\n        if (!initializer) return null;\r\n      }\r\n      let param = Node.createParameter(\r\n        isRest\r\n          ? ParameterKind.REST\r\n          : isOptional\r\n            ? ParameterKind.OPTIONAL\r\n            : ParameterKind.DEFAULT,\r\n        identifier,\r\n        type,\r\n        initializer,\r\n        Range.join(assert(startRange), tn.range())\r\n      );\r\n      param.flags |= accessFlags;\r\n      return param;\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseFunction(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n    startPos: i32\r\n  ): FunctionDeclaration | null {\r\n\r\n    // at 'function':\r\n    //  Identifier\r\n    //  ('<' TypeParameters)?\r\n    //  '(' Parameters (':' Type)?\r\n    //  '{' Statement* '}'\r\n    //  ';'?\r\n\r\n    if (!tn.skipIdentifier()) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range(tn.pos)\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    var signatureStart = -1;\r\n\r\n    var typeParameters: TypeParameterNode[] | null = null;\r\n    if (tn.skip(Token.LESSTHAN)) {\r\n      signatureStart = tn.tokenPos;\r\n      typeParameters = this.parseTypeParameters(tn);\r\n      if (!typeParameters) return null;\r\n      flags |= CommonFlags.GENERIC;\r\n    }\r\n\r\n    if (!tn.skip(Token.OPENPAREN)) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(tn.pos), \"(\"\r\n      );\r\n      return null;\r\n    }\r\n\r\n    if (signatureStart < 0) {\r\n      signatureStart = tn.tokenPos;\r\n    }\r\n\r\n    var parameters = this.parseParameters(tn);\r\n    if (!parameters) return null;\r\n    var thisType = this.parseParametersThis;\r\n\r\n    var isSetter = (flags & CommonFlags.SET) != 0;\r\n    if (isSetter) {\r\n      if (parameters.length != 1) {\r\n        this.error(\r\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\r\n          name.range\r\n        ); // recoverable\r\n      }\r\n      if (parameters.length > 0 && parameters[0].initializer !== null) {\r\n        this.error(\r\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\r\n          name.range\r\n        ); // recoverable\r\n      }\r\n    }\r\n\r\n    if (flags & CommonFlags.GET) {\r\n      if (parameters.length) {\r\n        this.error(\r\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\r\n          name.range\r\n        ); // recoverable\r\n      }\r\n    }\r\n\r\n    var returnType: TypeNode | null = null;\r\n    if (tn.skip(Token.COLON)) {\r\n      returnType = this.parseType(tn, true, isSetter);\r\n      if (!returnType) return null;\r\n    }\r\n\r\n    if (!returnType) {\r\n      returnType = Node.createOmittedType(\r\n        tn.range(tn.pos)\r\n      );\r\n      if (!isSetter) {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          returnType.range\r\n        ); // recoverable\r\n      }\r\n    }\r\n\r\n    var signature = Node.createFunctionType(\r\n      parameters,\r\n      returnType,\r\n      thisType,\r\n      false,\r\n      tn.range(signatureStart, tn.pos)\r\n    );\r\n\r\n    var body: Statement | null = null;\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      if (flags & CommonFlags.AMBIENT) {\r\n        this.error(\r\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n\r\n      body = this.parseBlockStatement(tn, false);\r\n      if (!body) return null;\r\n    } else if (!(flags & CommonFlags.AMBIENT)) {\r\n      this.error(\r\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n        tn.range(tn.pos)\r\n      );\r\n    }\r\n\r\n    var ret = Node.createFunctionDeclaration(\r\n      name,\r\n      decorators,\r\n      flags,\r\n      typeParameters,\r\n      signature,\r\n      body,\r\n      ArrowKind.NONE,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\r\n    var startPos = tn.tokenPos;\r\n    var name: IdentifierExpression;\r\n    var arrowKind = ArrowKind.NONE;\r\n\r\n    // either at 'function':\r\n    //  Identifier?\r\n    //  '(' Parameters (':' Type)?\r\n    //  Statement\r\n\r\n    if (tn.token == Token.FUNCTION) {\r\n      if (tn.skipIdentifier()) {\r\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      } else { // empty name\r\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\r\n      }\r\n      if (!tn.skip(Token.OPENPAREN)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(tn.pos), \"(\"\r\n        );\r\n        return null;\r\n      }\r\n\r\n      // or at '(' of arrow function:\r\n      //  Parameters (':' Type)?\r\n      //  Statement\r\n\r\n    } else {\r\n      arrowKind = ArrowKind.ARROW_PARENTHESIZED;\r\n      assert(tn.token == Token.OPENPAREN);\r\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\r\n    }\r\n\r\n    // TODO: type parameters? doesn't seem worth it.\r\n\r\n    var signatureStart = tn.pos;\r\n    var parameters = this.parseParameters(tn);\r\n    if (!parameters) return null;\r\n\r\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\r\n  }\r\n\r\n  private parseFunctionExpressionCommon(\r\n    tn: Tokenizer,\r\n    name: IdentifierExpression,\r\n    parameters: ParameterNode[],\r\n    explicitThis: NamedTypeNode | null,\r\n    arrowKind: ArrowKind,\r\n    startPos: i32 = -1,\r\n    signatureStart: i32 = -1\r\n  ): FunctionExpression | null {\r\n    if (startPos < 0) startPos = name.range.start;\r\n    if (signatureStart < 0) signatureStart = startPos;\r\n\r\n    var returnType: TypeNode | null = null;\r\n    if (arrowKind != ArrowKind.ARROW_SINGLE && tn.skip(Token.COLON)) {\r\n      returnType = this.parseType(tn);\r\n      if (!returnType) return null;\r\n    } else {\r\n      returnType = Node.createOmittedType(tn.range(tn.pos));\r\n    }\r\n\r\n    if (arrowKind) {\r\n      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(tn.pos), \"=>\"\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var signature = Node.createFunctionType(\r\n      parameters,\r\n      returnType,\r\n      explicitThis,\r\n      false,\r\n      tn.range(signatureStart, tn.pos)\r\n    );\r\n\r\n    var body: Statement | null = null;\r\n    if (arrowKind) {\r\n      if (tn.skip(Token.OPENBRACE)) {\r\n        body = this.parseBlockStatement(tn, false);\r\n      } else {\r\n        let bodyExpression = this.parseExpression(tn, Precedence.COMMA + 1);\r\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\r\n      }\r\n    } else {\r\n      if (!tn.skip(Token.OPENBRACE)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(tn.pos), \"{\"\r\n        );\r\n        return null;\r\n      }\r\n      body = this.parseBlockStatement(tn, false);\r\n    }\r\n    if (!body) return null;\r\n\r\n    var declaration = Node.createFunctionDeclaration(\r\n      name,\r\n      null,\r\n      CommonFlags.NONE,\r\n      null,\r\n      signature,\r\n      body,\r\n      arrowKind,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    return Node.createFunctionExpression(declaration);\r\n  }\r\n\r\n  parseClassOrInterface(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n    startPos: i32\r\n  ): ClassDeclaration | null {\r\n\r\n    // at ('class' | 'interface'):\r\n    //   Identifier\r\n    //   ('<' TypeParameters)?\r\n    //   ('extends' Type)?\r\n    //   ('implements' Type (',' Type)*)?\r\n    //   '{' ClassMember* '}'\r\n\r\n    var isInterface = tn.token == Token.INTERFACE;\r\n\r\n    if (!tn.skipIdentifier()) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var identifier = Node.createIdentifierExpression(\r\n      tn.readIdentifier(),\r\n      tn.range()\r\n    );\r\n\r\n    var typeParameters: TypeParameterNode[] | null = null;\r\n    if (tn.skip(Token.LESSTHAN)) {\r\n      typeParameters = this.parseTypeParameters(tn);\r\n      if (!typeParameters) return null;\r\n      flags |= CommonFlags.GENERIC;\r\n    }\r\n\r\n    var extendsType: NamedTypeNode | null = null;\r\n    if (tn.skip(Token.EXTENDS)) {\r\n      let type = this.parseType(tn);\r\n      if (!type) return null;\r\n      if (type.kind != NodeKind.NAMEDTYPE) {\r\n        this.error(\r\n          DiagnosticCode.Identifier_expected,\r\n          type.range\r\n        );\r\n        return null;\r\n      }\r\n      extendsType = <NamedTypeNode>type;\r\n    }\r\n\r\n    var implementsTypes: NamedTypeNode[] | null = null;\r\n    if (tn.skip(Token.IMPLEMENTS)) {\r\n      if (isInterface) {\r\n        this.error(\r\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n      do {\r\n        let type = this.parseType(tn);\r\n        if (!type) return null;\r\n        if (type.kind != NodeKind.NAMEDTYPE) {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            type.range\r\n          );\r\n          return null;\r\n        }\r\n        if (!isInterface) {\r\n          if (!implementsTypes) implementsTypes = [];\r\n          implementsTypes.push(<NamedTypeNode>type);\r\n        }\r\n      } while (tn.skip(Token.COMMA));\r\n    }\r\n\r\n    if (!tn.skip(Token.OPENBRACE)) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var members = new Array<DeclarationStatement>();\r\n    var declaration: ClassDeclaration;\r\n    if (isInterface) {\r\n      assert(!implementsTypes);\r\n      declaration = Node.createInterfaceDeclaration(\r\n        identifier,\r\n        decorators,\r\n        flags,\r\n        typeParameters,\r\n        extendsType,\r\n        null,\r\n        members,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n    } else {\r\n      declaration = Node.createClassDeclaration(\r\n        identifier,\r\n        decorators,\r\n        flags,\r\n        typeParameters,\r\n        extendsType,\r\n        implementsTypes,\r\n        members,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n    }\r\n    if (!tn.skip(Token.CLOSEBRACE)) {\r\n      do {\r\n        let member = this.parseClassMember(tn, declaration);\r\n        if (member) {\r\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\r\n            declaration.indexSignature = <IndexSignatureNode>member;\r\n          } else {\r\n            assert(member instanceof DeclarationStatement);\r\n            members.push(<DeclarationStatement>member);\r\n          }\r\n        } else {\r\n          this.skipStatement(tn);\r\n          if (tn.skip(Token.ENDOFFILE)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"}\"\r\n            );\r\n            return null;\r\n          }\r\n        }\r\n      } while (!tn.skip(Token.CLOSEBRACE));\r\n    }\r\n    declaration.range.end = tn.pos;\r\n    return declaration;\r\n  }\r\n\r\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\r\n\r\n    // at 'class': Identifier? '{' ... '}'\r\n\r\n    var startPos = tn.tokenPos;\r\n    var name: IdentifierExpression;\r\n\r\n    if (tn.skipIdentifier()) {\r\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    } else {\r\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\r\n    }\r\n\r\n    if (!tn.skip(Token.OPENBRACE)) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(tn.pos), \"{\"\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var members = new Array<DeclarationStatement>();\r\n    var declaration = Node.createClassDeclaration(\r\n      name,\r\n      null,\r\n      CommonFlags.NONE,\r\n      null,\r\n      null,\r\n      null,\r\n      members,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    if (!tn.skip(Token.CLOSEBRACE)) {\r\n      do {\r\n        let member = this.parseClassMember(tn, declaration);\r\n        if (member) {\r\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\r\n            declaration.indexSignature = <IndexSignatureNode>member;\r\n          } else {\r\n            assert(declaration instanceof DeclarationStatement);\r\n            members.push(<DeclarationStatement>member);\r\n          }\r\n        } else {\r\n          this.skipStatement(tn);\r\n          if (tn.skip(Token.ENDOFFILE)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"}\"\r\n            );\r\n            return null;\r\n          }\r\n        }\r\n      } while (!tn.skip(Token.CLOSEBRACE));\r\n    }\r\n    declaration.range.end = tn.pos;\r\n    return Node.createClassExpression(declaration);\r\n  }\r\n\r\n  parseClassMember(\r\n    tn: Tokenizer,\r\n    parent: ClassDeclaration\r\n  ): Node | null {\r\n\r\n    // before:\r\n    //   ('public' | 'private' | 'protected')?\r\n    //   ('static' | 'abstract')?\r\n    //   'readonly'?\r\n    //   ('get' | 'set')?\r\n    //   Identifier ...\r\n\r\n    var isInterface = parent.kind == NodeKind.INTERFACEDECLARATION;\r\n    var startPos = 0;\r\n    var decorators: DecoratorNode[] | null = null;\r\n    if (tn.skip(Token.AT)) {\r\n      startPos = tn.tokenPos;\r\n      do {\r\n        let decorator = this.parseDecorator(tn);\r\n        if (!decorator) break;\r\n        if (!decorators) decorators = new Array();\r\n        decorators.push(decorator);\r\n      } while (tn.skip(Token.AT));\r\n      if (isInterface && decorators !== null) {\r\n        this.error(\r\n          DiagnosticCode.Decorators_are_not_valid_here,\r\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\r\n        );\r\n      }\r\n    }\r\n\r\n    // inherit ambient status\r\n    var flags = parent.flags & CommonFlags.AMBIENT;\r\n\r\n    // implemented methods are virtual\r\n    if (isInterface) flags |= CommonFlags.VIRTUAL;\r\n\r\n    var accessStart = 0;\r\n    var accessEnd = 0;\r\n    if (tn.skip(Token.PUBLIC)) {\r\n      if (isInterface) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(), \"public\"\r\n        );\r\n      } else {\r\n        flags |= CommonFlags.PUBLIC;\r\n        accessStart = tn.tokenPos;\r\n        accessEnd = tn.pos;\r\n      }\r\n      if (!startPos) startPos = tn.tokenPos;\r\n    } else if (tn.skip(Token.PRIVATE)) {\r\n      if (isInterface) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(), \"private\"\r\n        );\r\n      } else {\r\n        flags |= CommonFlags.PRIVATE;\r\n        accessStart = tn.tokenPos;\r\n        accessEnd = tn.pos;\r\n      }\r\n      if (!startPos) startPos = tn.tokenPos;\r\n    } else if (tn.skip(Token.PROTECTED)) {\r\n      if (isInterface) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(), \"protected\"\r\n        );\r\n      } else {\r\n        flags |= CommonFlags.PROTECTED;\r\n        accessStart = tn.tokenPos;\r\n        accessEnd = tn.pos;\r\n      }\r\n      if (!startPos) startPos = tn.tokenPos;\r\n    }\r\n\r\n    var staticStart = 0;\r\n    var staticEnd = 0;\r\n    var abstractStart = 0;\r\n    var abstractEnd = 0;\r\n    if (tn.skip(Token.STATIC)) {\r\n      if (isInterface) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(), \"static\"\r\n        );\r\n      } else {\r\n        flags |= CommonFlags.STATIC;\r\n        staticStart = tn.tokenPos;\r\n        staticEnd = tn.pos;\r\n      }\r\n      if (!startPos) startPos = tn.tokenPos;\r\n    } else {\r\n      flags |= CommonFlags.INSTANCE;\r\n      if (tn.skip(Token.ABSTRACT)) {\r\n        if (isInterface || !parent.is(CommonFlags.ABSTRACT)) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(), \"abstract\"\r\n          );\r\n        } else {\r\n          flags |= CommonFlags.ABSTRACT;\r\n          abstractStart = tn.tokenPos;\r\n          abstractEnd = tn.pos;\r\n        }\r\n        if (!startPos) startPos = tn.tokenPos;\r\n      }\r\n      if (parent.flags & CommonFlags.GENERIC) flags |= CommonFlags.GENERIC_CONTEXT;\r\n    }\r\n\r\n    var readonlyStart = 0;\r\n    var readonlyEnd = 0;\r\n    if (tn.peek() == Token.READONLY) {\r\n      let state = tn.mark();\r\n      tn.next();\r\n      if (tn.peek() != Token.COLON) { // modifier\r\n        tn.discard(state);\r\n        flags |= CommonFlags.READONLY;\r\n        readonlyStart = tn.tokenPos;\r\n        readonlyEnd = tn.pos;\r\n        if (!startPos) startPos = readonlyStart;\r\n      } else { // identifier\r\n        tn.reset(state);\r\n      }\r\n    }\r\n\r\n    // check if accessor: ('get' | 'set') ^\\n Identifier\r\n    var state = tn.mark();\r\n    var isConstructor = false;\r\n    var isGetter = false;\r\n    var getStart = 0;\r\n    var getEnd = 0;\r\n    var isSetter = false;\r\n    var setStart = 0;\r\n    var setEnd = 0;\r\n    if (!isInterface) {\r\n      if (tn.skip(Token.GET)) {\r\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n          flags |= CommonFlags.GET;\r\n          isGetter = true;\r\n          getStart = tn.tokenPos;\r\n          getEnd = tn.pos;\r\n          if (!startPos) startPos = getStart;\r\n          if (flags & CommonFlags.READONLY) {\r\n            this.error(\r\n              DiagnosticCode._0_modifier_cannot_be_used_here,\r\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\r\n            ); // recoverable\r\n          }\r\n        } else {\r\n          tn.reset(state);\r\n        }\r\n      } else if (tn.skip(Token.SET)) {\r\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n          flags |= CommonFlags.SET;\r\n          isSetter = true;\r\n          setStart = tn.tokenPos;\r\n          setEnd = tn.pos;\r\n          if (!startPos) startPos = setStart;\r\n          if (flags & CommonFlags.READONLY) {\r\n            this.error(\r\n              DiagnosticCode._0_modifier_cannot_be_used_here,\r\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\r\n            ); // recoverable\r\n          }\r\n        } else {\r\n          tn.reset(state);\r\n        }\r\n      } else if (tn.skip(Token.CONSTRUCTOR)) {\r\n        flags |= CommonFlags.CONSTRUCTOR;\r\n        isConstructor = true;\r\n        if (!startPos) startPos = tn.tokenPos;\r\n        if (flags & CommonFlags.STATIC) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(staticStart, staticEnd), \"static\"\r\n          ); // recoverable\r\n        }\r\n        if (flags & CommonFlags.ABSTRACT) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(abstractStart, abstractEnd), \"abstract\"\r\n          ); // recoverable\r\n        }\r\n        if (flags & CommonFlags.READONLY) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\r\n          ); // recoverable\r\n        }\r\n      }\r\n    }\r\n\r\n    var isGetterOrSetter = isGetter || isSetter;\r\n    var name: IdentifierExpression;\r\n    if (isConstructor) {\r\n      name = Node.createConstructorExpression(tn.range());\r\n    } else {\r\n      if (!isGetterOrSetter && tn.skip(Token.OPENBRACKET)) {\r\n        if (!startPos) startPos = tn.tokenPos;\r\n        // TODO: also handle symbols, which might have some of these modifiers\r\n        if (flags & CommonFlags.PUBLIC) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(accessStart, accessEnd), \"public\"\r\n          ); // recoverable\r\n        } else if (flags & CommonFlags.PROTECTED) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(accessStart, accessEnd), \"protected\"\r\n          ); // recoverable\r\n        } else if (flags & CommonFlags.PRIVATE) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(accessStart, accessEnd), \"protected\"\r\n          ); // recoverable\r\n        }\r\n        if (flags & CommonFlags.STATIC) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(staticStart, staticEnd), \"static\"\r\n          ); // recoverable\r\n        }\r\n        if (flags & CommonFlags.ABSTRACT) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            tn.range(abstractStart, abstractEnd), \"abstract\"\r\n          ); // recoverable\r\n        }\r\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\r\n        if (!retIndex) {\r\n          if (flags & CommonFlags.READONLY) {\r\n            this.error(\r\n              DiagnosticCode._0_modifier_cannot_be_used_here,\r\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\r\n            ); // recoverable\r\n          }\r\n          return null;\r\n        }\r\n        tn.skip(Token.SEMICOLON);\r\n        return retIndex;\r\n      }\r\n      if (!tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\r\n        this.error(\r\n          DiagnosticCode.Identifier_expected,\r\n          tn.range()\r\n        );\r\n        return null;\r\n      }\r\n      if (!startPos) startPos = tn.tokenPos;\r\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    }\r\n    var typeParameters: TypeParameterNode[] | null = null;\r\n    if (tn.skip(Token.LESSTHAN)) {\r\n      let typeParametersStart = tn.tokenPos;\r\n      typeParameters = this.parseTypeParameters(tn);\r\n      if (!typeParameters) return null;\r\n      if (isConstructor) {\r\n        this.error(\r\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\r\n          tn.range(typeParametersStart, tn.pos)\r\n        ); // recoverable\r\n      } else if (isGetterOrSetter) {\r\n        this.error(\r\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\r\n          tn.range(typeParametersStart, tn.pos)\r\n        ); // recoverable\r\n      } else {\r\n        flags |= CommonFlags.GENERIC;\r\n      }\r\n    }\r\n\r\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      let signatureStart = tn.tokenPos;\r\n      let parameters = this.parseParameters(tn, isConstructor);\r\n      if (!parameters) return null;\r\n      let thisType = this.parseParametersThis;\r\n      if (isConstructor) {\r\n        for (let i = 0, k = parameters.length; i < k; ++i) {\r\n          let parameter = parameters[i];\r\n          if (parameter.isAny(\r\n            CommonFlags.PUBLIC |\r\n            CommonFlags.PROTECTED |\r\n            CommonFlags.PRIVATE |\r\n            CommonFlags.READONLY\r\n          )) {\r\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\r\n              parameter.name,\r\n              null,\r\n              parameter.flags | CommonFlags.INSTANCE,\r\n              parameter.type,\r\n              null, // initialized via parameter\r\n              parameter.range\r\n            );\r\n            implicitFieldDeclaration.parameterIndex = i;\r\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\r\n            parent.members.push(implicitFieldDeclaration);\r\n          }\r\n        }\r\n      } else if (isGetter) {\r\n        if (parameters.length) {\r\n          this.error(\r\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\r\n            name.range\r\n          );\r\n        }\r\n      } else if (isSetter) {\r\n        if (parameters.length != 1) {\r\n          this.error(\r\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\r\n            name.range\r\n          );\r\n        }\r\n        if (parameters.length > 0 && parameters[0].initializer !== null) {\r\n          this.error(\r\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\r\n            name.range\r\n          );\r\n        }\r\n      } else if (name.text == \"constructor\") {\r\n        this.error(\r\n          DiagnosticCode._0_keyword_cannot_be_used_here,\r\n          name.range, \"constructor\"\r\n        );\r\n      }\r\n\r\n      let returnType: TypeNode | null = null;\r\n      if (tn.skip(Token.COLON)) {\r\n        if (name.kind == NodeKind.CONSTRUCTOR) {\r\n          this.error(\r\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\r\n            tn.range()\r\n          );\r\n        } else if (isSetter) {\r\n          this.error(\r\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\r\n            tn.range()\r\n          );\r\n        }\r\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.CONSTRUCTOR);\r\n        if (!returnType) return null;\r\n      } else {\r\n        returnType = Node.createOmittedType(tn.range(tn.pos));\r\n        if (!isSetter && name.kind != NodeKind.CONSTRUCTOR) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            returnType.range\r\n          ); // recoverable\r\n        }\r\n      }\r\n\r\n      let signature = Node.createFunctionType(\r\n        parameters,\r\n        returnType,\r\n        thisType,\r\n        false,\r\n        tn.range(signatureStart, tn.pos)\r\n      );\r\n\r\n      let body: Statement | null = null;\r\n      if (tn.skip(Token.OPENBRACE)) {\r\n        if (flags & CommonFlags.AMBIENT) {\r\n          this.error(\r\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\r\n            tn.range()\r\n          ); // recoverable\r\n        } else if (flags & CommonFlags.ABSTRACT) {\r\n          this.error(\r\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\r\n            tn.range(), name.text\r\n          ); // recoverable\r\n        } else if (isInterface) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \";\"\r\n          ); // recoverable\r\n        }\r\n        body = this.parseBlockStatement(tn, false);\r\n        if (!body) return null;\r\n      } else if (!isInterface && !(flags & (CommonFlags.AMBIENT | CommonFlags.ABSTRACT))) {\r\n        this.error(\r\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n\r\n      let retMethod = Node.createMethodDeclaration(\r\n        name,\r\n        decorators,\r\n        flags,\r\n        typeParameters,\r\n        signature,\r\n        body,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n      if (!(isInterface && tn.skip(Token.COMMA))) {\r\n        tn.skip(Token.SEMICOLON);\r\n      }\r\n      return retMethod;\r\n\r\n    } else if (isConstructor) {\r\n      this.error(\r\n        DiagnosticCode.Constructor_implementation_is_missing,\r\n        name.range\r\n      );\r\n\r\n    } else if (isGetterOrSetter) {\r\n      this.error(\r\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n        name.range\r\n      );\r\n\r\n    // field: (':' Type)? ('=' Expression)? ';'?\r\n    } else {\r\n      if (flags & CommonFlags.ABSTRACT) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(abstractStart, abstractEnd), \"abstract\"\r\n        ); // recoverable\r\n      }\r\n\r\n      if (flags & CommonFlags.GET) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(getStart, getEnd), \"get\"\r\n        ); // recoverable\r\n      }\r\n\r\n      if (flags & CommonFlags.SET) {\r\n        this.error(\r\n          DiagnosticCode._0_modifier_cannot_be_used_here,\r\n          tn.range(setStart, setEnd), \"set\"\r\n        ); // recoverable\r\n      }\r\n\r\n      let type: TypeNode | null = null;\r\n      if (tn.skip(Token.QUESTION)) {\r\n        this.error(\r\n          DiagnosticCode.Optional_properties_are_not_supported,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n      }\r\n      if (tn.skip(Token.EXCLAMATION)) {\r\n        flags |= CommonFlags.DEFINITELY_ASSIGNED;\r\n      }\r\n      if (tn.skip(Token.COLON)) {\r\n        type = this.parseType(tn);\r\n        if (!type) return null;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n      let initializer: Expression | null = null;\r\n      if (tn.skip(Token.EQUALS)) {\r\n        initializer = this.parseExpression(tn);\r\n        if (!initializer) return null;\r\n      }\r\n      let range = tn.range(startPos, tn.pos);\r\n      if (\r\n        (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0 &&\r\n        (isInterface || initializer !== null || (flags & CommonFlags.STATIC) != 0)\r\n      ) {\r\n        this.error(\r\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\r\n          range\r\n        );\r\n      }\r\n      let retField = Node.createFieldDeclaration(\r\n        name,\r\n        decorators,\r\n        flags,\r\n        type,\r\n        initializer,\r\n        range\r\n      );\r\n      if (!(isInterface && tn.skip(Token.COMMA))) {\r\n        tn.skip(Token.SEMICOLON);\r\n      }\r\n      return retField;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseIndexSignature(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n  ): IndexSignatureNode | null {\r\n\r\n    // at: '[': 'key' ':' Type ']' ':' Type\r\n\r\n    if (decorators !== null && decorators.length > 0) {\r\n      this.error(\r\n        DiagnosticCode.Decorators_are_not_valid_here,\r\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\r\n      ); // recoverable\r\n    }\r\n\r\n    var start = tn.tokenPos;\r\n    if (tn.skipIdentifier()) {\r\n      let id = tn.readIdentifier();\r\n      if (id == \"key\") {\r\n        if (tn.skip(Token.COLON)) {\r\n          let keyType = this.parseType(tn);\r\n          if (!keyType) return null;\r\n          if (keyType.kind != NodeKind.NAMEDTYPE) {\r\n            this.error(\r\n              DiagnosticCode.Type_expected,\r\n              tn.range()\r\n            );\r\n            return null;\r\n          }\r\n          if (tn.skip(Token.CLOSEBRACKET)) {\r\n            if (tn.skip(Token.COLON)) {\r\n              let valueType = this.parseType(tn);\r\n              if (!valueType) return null;\r\n              if (valueType.kind != NodeKind.NAMEDTYPE) {\r\n                this.error(\r\n                  DiagnosticCode.Identifier_expected,\r\n                  valueType.range\r\n                );\r\n                return null;\r\n              }\r\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode._0_expected,\r\n                tn.range(), \":\"\r\n              );\r\n            }\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"]\"\r\n            );\r\n          }\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \":\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"key\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseNamespace(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n    startPos: i32\r\n  ): NamespaceDeclaration | null {\r\n\r\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\r\n\r\n    if (tn.skipIdentifier()) {\r\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      if (tn.skip(Token.OPENBRACE)) {\r\n        let members = new Array<Statement>();\r\n        let declaration = Node.createNamespaceDeclaration(\r\n          identifier,\r\n          decorators,\r\n          flags,\r\n          members,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          let member = this.parseTopLevelStatement(tn, declaration);\r\n          if (member) members.push(member);\r\n          else {\r\n            this.skipStatement(tn);\r\n            if (tn.skip(Token.ENDOFFILE)) {\r\n              this.error(\r\n                DiagnosticCode._0_expected,\r\n                tn.range(), \"}\"\r\n              );\r\n              return null;\r\n            }\r\n          }\r\n        }\r\n        declaration.range.end = tn.pos;\r\n        tn.skip(Token.SEMICOLON);\r\n        return declaration;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"{\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExport(\r\n    tn: Tokenizer,\r\n    startPos: i32,\r\n    isDeclare: bool\r\n  ): ExportStatement | null {\r\n\r\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\r\n\r\n    var path: StringLiteralExpression | null = null;\r\n    var currentSource = assert(this.currentSource);\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      let members = new Array<ExportMember>();\r\n      while (!tn.skip(Token.CLOSEBRACE)) {\r\n        let member = this.parseExportMember(tn);\r\n        if (!member) return null;\r\n        members.push(member);\r\n        if (!tn.skip(Token.COMMA)) {\r\n          if (tn.skip(Token.CLOSEBRACE)) {\r\n            break;\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"}\"\r\n            );\r\n            return null;\r\n          }\r\n        }\r\n      }\r\n      if (tn.skip(Token.FROM)) {\r\n        if (tn.skip(Token.STRINGLITERAL)) {\r\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.String_literal_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\r\n      if (path !== null) {\r\n        let internalPath = assert(ret.internalPath);\r\n        if (!this.seenlog.has(internalPath)) {\r\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\r\n          this.backlog.push(internalPath);\r\n          this.seenlog.add(internalPath);\r\n        }\r\n      }\r\n      tn.skip(Token.SEMICOLON);\r\n      return ret;\r\n    } else if (tn.skip(Token.ASTERISK)) {\r\n      if (tn.skip(Token.FROM)) {\r\n        if (tn.skip(Token.STRINGLITERAL)) {\r\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\r\n          let internalPath = assert(ret.internalPath);\r\n          let source = tn.source;\r\n          let exportPaths = source.exportPaths;\r\n          if (!exportPaths) source.exportPaths = [ internalPath ];\r\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\r\n          if (!this.seenlog.has(internalPath)) {\r\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\r\n            this.backlog.push(internalPath);\r\n          }\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.String_literal_expected,\r\n            tn.range()\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"from\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExportMember(\r\n    tn: Tokenizer\r\n  ): ExportMember | null {\r\n\r\n    // before: Identifier ('as' Identifier)?\r\n\r\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\r\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      let asIdentifier: IdentifierExpression | null = null;\r\n      if (tn.skip(Token.AS)) {\r\n        if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\r\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      if (asIdentifier) {\r\n        return Node.createExportMember(\r\n          identifier,\r\n          asIdentifier,\r\n          Range.join(identifier.range, asIdentifier.range)\r\n        );\r\n      }\r\n      return Node.createExportMember(\r\n        identifier,\r\n        null,\r\n        identifier.range\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExportDefaultAlias(\r\n    tn: Tokenizer,\r\n    startPos: i32,\r\n    defaultStart: i32,\r\n    defaultEnd: i32\r\n  ): ExportStatement {\r\n\r\n    // at 'export' 'default': [Known-To-Be-]Identifier\r\n\r\n    var name = tn.readIdentifier();\r\n    var range = tn.range();\r\n    var ret = Node.createExportStatement([\r\n      Node.createExportMember(\r\n        Node.createIdentifierExpression(name, range),\r\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\r\n        range\r\n      )\r\n    ], null, false, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseImport(\r\n    tn: Tokenizer\r\n  ): ImportStatement | null {\r\n\r\n    // at 'import':\r\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\r\n    //  'from' StringLiteral ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var members: ImportDeclaration[] | null = null;\r\n    var namespaceName: IdentifierExpression | null = null;\r\n    var skipFrom = false;\r\n    if (tn.skip(Token.OPENBRACE)) { // import { ... } from \"file\"\r\n      members = new Array();\r\n      while (!tn.skip(Token.CLOSEBRACE)) {\r\n        let member = this.parseImportDeclaration(tn);\r\n        if (!member) return null;\r\n        members.push(member);\r\n        if (!tn.skip(Token.COMMA)) {\r\n          if (tn.skip(Token.CLOSEBRACE)) {\r\n            break;\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"}\"\r\n            );\r\n            return null;\r\n          }\r\n        }\r\n      }\r\n    } else if (tn.skip(Token.ASTERISK)) { // import * from \"file\"\r\n      if (tn.skip(Token.AS)) {\r\n        if (tn.skipIdentifier()) {\r\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"as\"\r\n        );\r\n        return null;\r\n      }\r\n    } else if (tn.skip(Token.IDENTIFIER, IdentifierHandling.PREFER)) { // import Name from \"file\"\r\n      let name = tn.readIdentifier();\r\n      let range = tn.range();\r\n      members = [\r\n        Node.createImportDeclaration(\r\n          Node.createIdentifierExpression(\"default\", range),\r\n          Node.createIdentifierExpression(name, range),\r\n          range\r\n        )\r\n      ];\r\n      if (tn.skip(Token.COMMA)) {\r\n        // TODO: default + star, default + members\r\n        this.error(\r\n          DiagnosticCode.Not_implemented_0,\r\n          tn.range(),\r\n          \"Mixed default and named imports\"\r\n        );\r\n        return null;\r\n      }\r\n    } else { // import \"file\"\r\n      skipFrom = true;\r\n    }\r\n\r\n    if (skipFrom || tn.skip(Token.FROM)) {\r\n      if (tn.skip(Token.STRINGLITERAL)) {\r\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n        let ret: ImportStatement;\r\n        if (namespaceName) {\r\n          assert(!members);\r\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\r\n        } else {\r\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\r\n        }\r\n        let internalPath = ret.internalPath;\r\n        if (!this.seenlog.has(internalPath)) {\r\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\r\n          this.backlog.push(internalPath);\r\n        }\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.String_literal_expected,\r\n          tn.range()\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"from\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseImportDeclaration(\r\n    tn: Tokenizer\r\n  ): ImportDeclaration | null {\r\n\r\n    // before: Identifier ('as' Identifier)?\r\n\r\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\r\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      let asIdentifier: IdentifierExpression | null = null;\r\n      if (tn.skip(Token.AS)) {\r\n        if (tn.skipIdentifier()) {\r\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      if (asIdentifier) {\r\n        return Node.createImportDeclaration(\r\n          identifier,\r\n          asIdentifier,\r\n          Range.join(identifier.range, asIdentifier.range)\r\n        );\r\n      }\r\n      return Node.createImportDeclaration(\r\n        identifier,\r\n        null,\r\n        identifier.range\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExportImport(\r\n    tn: Tokenizer,\r\n    startPos: i32\r\n  ): ExportImportStatement | null {\r\n\r\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\r\n\r\n    if (tn.skipIdentifier()) {\r\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      if (tn.skip(Token.EQUALS)) {\r\n        if (tn.skipIdentifier()) {\r\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"=\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseStatement(\r\n    tn: Tokenizer,\r\n    topLevel: bool = false\r\n  ): Statement | null {\r\n\r\n    // at previous token\r\n\r\n    var state = tn.mark();\r\n    var token = tn.next();\r\n    var statement: Statement | null = null;\r\n    switch (token) {\r\n      case Token.BREAK: {\r\n        statement = this.parseBreak(tn);\r\n        break;\r\n      }\r\n      case Token.CONST: {\r\n        statement = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos);\r\n        break;\r\n      }\r\n      case Token.CONTINUE: {\r\n        statement = this.parseContinue(tn);\r\n        break;\r\n      }\r\n      case Token.DO: {\r\n        statement = this.parseDoStatement(tn);\r\n        break;\r\n      }\r\n      case Token.FOR: {\r\n        statement = this.parseForStatement(tn);\r\n        break;\r\n      }\r\n      case Token.IF: {\r\n        statement = this.parseIfStatement(tn);\r\n        break;\r\n      }\r\n      case Token.LET: {\r\n        statement = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos);\r\n        break;\r\n      }\r\n      case Token.VAR: {\r\n        statement = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos);\r\n        break;\r\n      }\r\n      case Token.OPENBRACE: {\r\n        statement = this.parseBlockStatement(tn, topLevel);\r\n        break;\r\n      }\r\n      case Token.RETURN: {\r\n        if (topLevel) {\r\n          this.error(\r\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\r\n            tn.range()\r\n          ); // recoverable\r\n        }\r\n        statement = this.parseReturn(tn);\r\n        break;\r\n      }\r\n      case Token.SEMICOLON: {\r\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\r\n      }\r\n      case Token.SWITCH: {\r\n        statement = this.parseSwitchStatement(tn);\r\n        break;\r\n      }\r\n      case Token.THROW: {\r\n        statement = this.parseThrowStatement(tn);\r\n        break;\r\n      }\r\n      case Token.TRY: {\r\n        statement = this.parseTryStatement(tn);\r\n        break;\r\n      }\r\n      case Token.VOID: {\r\n        statement = this.parseVoidStatement(tn);\r\n        break;\r\n      }\r\n      case Token.WHILE: {\r\n        statement = this.parseWhileStatement(tn);\r\n        break;\r\n      }\r\n      case Token.TYPE: { // also identifier\r\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\r\n          statement = this.parseTypeDeclaration(tn, CommonFlags.NONE, null, tn.tokenPos);\r\n          break;\r\n        }\r\n        // fall-through\r\n      }\r\n      default: {\r\n        tn.reset(state);\r\n        statement = this.parseExpressionStatement(tn);\r\n        break;\r\n      }\r\n    }\r\n    if (!statement) { // has been reported\r\n      tn.reset(state);\r\n      this.skipStatement(tn);\r\n    } else {\r\n      tn.discard(state);\r\n    }\r\n    return statement;\r\n  }\r\n\r\n  parseBlockStatement(\r\n    tn: Tokenizer,\r\n    topLevel: bool\r\n  ): BlockStatement | null {\r\n\r\n    // at '{': Statement* '}' ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var statements = new Array<Statement>();\r\n    while (!tn.skip(Token.CLOSEBRACE)) {\r\n      let state = tn.mark();\r\n      let statement = this.parseStatement(tn, topLevel);\r\n      if (!statement) {\r\n        if (tn.token == Token.ENDOFFILE) return null;\r\n        tn.reset(state);\r\n        this.skipStatement(tn);\r\n      } else {\r\n        tn.discard(state);\r\n        statements.push(statement);\r\n      }\r\n    }\r\n    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseBreak(\r\n    tn: Tokenizer\r\n  ): BreakStatement | null {\r\n\r\n    // at 'break': Identifier? ';'?\r\n\r\n    var identifier: IdentifierExpression | null = null;\r\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n      tn.next(IdentifierHandling.PREFER);\r\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    }\r\n    var ret = Node.createBreakStatement(identifier, tn.range());\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseContinue(\r\n    tn: Tokenizer\r\n  ): ContinueStatement | null {\r\n\r\n    // at 'continue': Identifier? ';'?\r\n\r\n    var identifier: IdentifierExpression | null = null;\r\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n      tn.next(IdentifierHandling.PREFER);\r\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    }\r\n    var ret = Node.createContinueStatement(identifier, tn.range());\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseDoStatement(\r\n    tn: Tokenizer\r\n  ): DoStatement | null {\r\n\r\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var statement = this.parseStatement(tn);\r\n    if (!statement) return null;\r\n\r\n    if (tn.skip(Token.WHILE)) {\r\n\r\n      if (tn.skip(Token.OPENPAREN)) {\r\n        let condition = this.parseExpression(tn);\r\n        if (!condition) return null;\r\n\r\n        if (tn.skip(Token.CLOSEPAREN)) {\r\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"(\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"while\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExpressionStatement(\r\n    tn: Tokenizer\r\n  ): ExpressionStatement | null {\r\n\r\n    // at previous token\r\n\r\n    var expr = this.parseExpression(tn);\r\n    if (!expr) return null;\r\n\r\n    var ret = Node.createExpressionStatement(expr);\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseForStatement(\r\n    tn: Tokenizer\r\n  ): Statement | null {\r\n\r\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\r\n\r\n    var startPos = tn.tokenPos;\r\n\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      let initializer: Statement | null = null;\r\n\r\n      if (tn.skip(Token.CONST)) {\r\n        initializer = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos, true);\r\n      } else if (tn.skip(Token.LET)) {\r\n        initializer = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos, true);\r\n      } else if (tn.skip(Token.VAR)) {\r\n        initializer = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos, true);\r\n\r\n      } else if (!tn.skip(Token.SEMICOLON)) {\r\n        initializer = this.parseExpressionStatement(tn);\r\n        if (!initializer) return null;\r\n      }\r\n\r\n      if (initializer) {\r\n        if (tn.skip(Token.OF)) {\r\n          // TODO: for (let [key, val] of ...)\r\n          if (initializer.kind == NodeKind.EXPRESSION) {\r\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.IDENTIFIER) {\r\n              this.error(\r\n                DiagnosticCode.Identifier_expected,\r\n                initializer.range\r\n              );\r\n              return null;\r\n            }\r\n            return this.parseForOfStatement(tn, startPos, initializer);\r\n          }\r\n          if (initializer.kind == NodeKind.VARIABLE) {\r\n            let declarations = (<VariableStatement>initializer).declarations;\r\n            for (let i = 0, k = declarations.length; i < k; ++i) {\r\n              let declaration = declarations[i];\r\n              let initializer = declaration.initializer;\r\n              if (initializer) {\r\n                this.error(\r\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\r\n                  initializer.range\r\n                ); // recoverable\r\n              }\r\n            }\r\n            return this.parseForOfStatement(tn, startPos, initializer);\r\n          }\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            initializer.range\r\n          );\r\n          return null;\r\n        }\r\n        // non-for..of needs type or initializer\r\n        if (initializer.kind == NodeKind.VARIABLE) {\r\n          let declarations = (<VariableStatement>initializer).declarations;\r\n          for (let i = 0, k = declarations.length; i < k; ++i) {\r\n            let declaration = declarations[i];\r\n            if (!declaration.initializer) {\r\n              if (declaration.flags & CommonFlags.CONST) {\r\n                this.error(\r\n                  DiagnosticCode._const_declarations_must_be_initialized,\r\n                  declaration.name.range\r\n                );\r\n              } else if (!declaration.type) {\r\n                this.error(\r\n                  DiagnosticCode.Type_expected,\r\n                  declaration.name.range.atEnd\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (tn.token == Token.SEMICOLON) {\r\n        let condition: ExpressionStatement | null = null;\r\n        if (!tn.skip(Token.SEMICOLON)) {\r\n          condition = this.parseExpressionStatement(tn);\r\n          if (!condition) return null;\r\n        }\r\n\r\n        if (tn.token == Token.SEMICOLON) {\r\n          let incrementor: Expression | null = null;\r\n          if (!tn.skip(Token.CLOSEPAREN)) {\r\n            incrementor = this.parseExpression(tn);\r\n            if (!incrementor) return null;\r\n\r\n            if (!tn.skip(Token.CLOSEPAREN)) {\r\n              this.error(\r\n                DiagnosticCode._0_expected,\r\n                tn.range(), \")\"\r\n              );\r\n              return null;\r\n            }\r\n          }\r\n\r\n          let statement = this.parseStatement(tn);\r\n          if (!statement) return null;\r\n\r\n          return Node.createForStatement(\r\n            initializer,\r\n            condition\r\n              ? condition.expression\r\n              : null,\r\n            incrementor,\r\n            statement,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \";\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \";\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseForOfStatement(\r\n    tn: Tokenizer,\r\n    startPos: i32,\r\n    variable: Statement,\r\n  ): ForOfStatement | null {\r\n\r\n    // at 'of': Expression ')' Statement\r\n\r\n    var iterable = this.parseExpression(tn);\r\n    if (!iterable) return null;\r\n\r\n    if (!tn.skip(Token.CLOSEPAREN)) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \")\"\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var statement = this.parseStatement(tn);\r\n    if (!statement) return null;\r\n\r\n    return Node.createForOfStatement(\r\n      variable,\r\n      iterable,\r\n      statement,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n  }\r\n\r\n  parseIfStatement(\r\n    tn: Tokenizer\r\n  ): IfStatement | null {\r\n\r\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      let condition = this.parseExpression(tn);\r\n      if (!condition) return null;\r\n      if (tn.skip(Token.CLOSEPAREN)) {\r\n        let statement = this.parseStatement(tn);\r\n        if (!statement) return null;\r\n        let elseStatement: Statement | null = null;\r\n        if (tn.skip(Token.ELSE)) {\r\n          elseStatement = this.parseStatement(tn);\r\n          if (!elseStatement) return null;\r\n        }\r\n        return Node.createIfStatement(\r\n          condition,\r\n          statement,\r\n          elseStatement,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseSwitchStatement(\r\n    tn: Tokenizer\r\n  ): SwitchStatement | null {\r\n\r\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      let condition = this.parseExpression(tn);\r\n      if (!condition) return null;\r\n      if (tn.skip(Token.CLOSEPAREN)) {\r\n        if (tn.skip(Token.OPENBRACE)) {\r\n          let switchCases = new Array<SwitchCase>();\r\n          while (!tn.skip(Token.CLOSEBRACE)) {\r\n            let switchCase = this.parseSwitchCase(tn);\r\n            if (!switchCase) return null;\r\n            switchCases.push(switchCase);\r\n          }\r\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"{\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseSwitchCase(\r\n    tn: Tokenizer\r\n  ): SwitchCase | null {\r\n\r\n    var startPos = tn.tokenPos;\r\n    var statements: Statement[],\r\n        statement: Statement | null;\r\n\r\n    // 'case' Expression ':' Statement*\r\n\r\n    if (tn.skip(Token.CASE)) {\r\n      let label = this.parseExpression(tn);\r\n      if (!label) return null;\r\n      if (tn.skip(Token.COLON)) {\r\n        statements = new Array<Statement>();\r\n        while (\r\n          tn.peek() != Token.CASE &&\r\n          tn.nextToken != Token.DEFAULT &&\r\n          tn.nextToken != Token.CLOSEBRACE\r\n        ) {\r\n          statement = this.parseStatement(tn);\r\n          if (!statement) return null;\r\n          statements.push(statement);\r\n        }\r\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \":\"\r\n        );\r\n      }\r\n\r\n      // 'default' ':' Statement*\r\n\r\n    } else if (tn.skip(Token.DEFAULT)) {\r\n      if (tn.skip(Token.COLON)) {\r\n        statements = new Array<Statement>();\r\n        while (\r\n          tn.peek() != Token.CASE &&\r\n          tn.nextToken != Token.DEFAULT &&\r\n          tn.nextToken != Token.CLOSEBRACE\r\n        ) {\r\n          statement = this.parseStatement(tn);\r\n          if (!statement) return null;\r\n          statements.push(statement);\r\n        }\r\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \":\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._case_or_default_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseThrowStatement(\r\n    tn: Tokenizer\r\n  ): ThrowStatement | null {\r\n\r\n    // at 'throw': Expression ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var expression = this.parseExpression(tn);\r\n    if (!expression) return null;\r\n    var ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseTryStatement(\r\n    tn: Tokenizer\r\n  ): TryStatement | null {\r\n\r\n    // at 'try':\r\n    //   '{' Statement* '}'\r\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\r\n    //   ('finally' '{' Statement* '}'? ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var stmt: Statement | null;\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      let statements = new Array<Statement>();\r\n      while (!tn.skip(Token.CLOSEBRACE)) {\r\n        stmt = this.parseStatement(tn);\r\n        if (!stmt) return null;\r\n        statements.push(stmt);\r\n      }\r\n      let catchVariable: IdentifierExpression | null = null;\r\n      let catchStatements: Statement[] | null = null;\r\n      let finallyStatements: Statement[] | null = null;\r\n      if (tn.skip(Token.CATCH)) {\r\n        if (!tn.skip(Token.OPENPAREN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"(\"\r\n          );\r\n          return null;\r\n        }\r\n        if (!tn.skipIdentifier()) {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        if (!tn.skip(Token.CLOSEPAREN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n        if (!tn.skip(Token.OPENBRACE)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"{\"\r\n          );\r\n          return null;\r\n        }\r\n        catchStatements = [];\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          stmt = this.parseStatement(tn);\r\n          if (!stmt) return null;\r\n          catchStatements.push(stmt);\r\n        }\r\n      }\r\n      if (tn.skip(Token.FINALLY)) {\r\n        if (!tn.skip(Token.OPENBRACE)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"{\"\r\n          );\r\n          return null;\r\n        }\r\n        finallyStatements = [];\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          stmt = this.parseStatement(tn);\r\n          if (!stmt) return null;\r\n          finallyStatements.push(stmt);\r\n        }\r\n      }\r\n      if (!(catchStatements || finallyStatements)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"catch\"\r\n        );\r\n        return null;\r\n      }\r\n      let ret = Node.createTryStatement(\r\n        statements,\r\n        catchVariable,\r\n        catchStatements,\r\n        finallyStatements,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n      tn.skip(Token.SEMICOLON);\r\n      return ret;\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseTypeDeclaration(\r\n    tn: Tokenizer,\r\n    flags: CommonFlags,\r\n    decorators: DecoratorNode[] | null,\r\n    startPos: i32\r\n  ): TypeDeclaration | null {\r\n\r\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' Type ';'?\r\n\r\n    if (tn.skipIdentifier()) {\r\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      let typeParameters: TypeParameterNode[] | null = null;\r\n      if (tn.skip(Token.LESSTHAN)) {\r\n        typeParameters = this.parseTypeParameters(tn);\r\n        if (!typeParameters) return null;\r\n        flags |= CommonFlags.GENERIC;\r\n      }\r\n      if (tn.skip(Token.EQUALS)) {\r\n        let type = this.parseType(tn);\r\n        if (!type) return null;\r\n        let ret = Node.createTypeDeclaration(\r\n          name,\r\n          decorators,\r\n          flags,\r\n          typeParameters,\r\n          type,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"=\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseVoidStatement(\r\n    tn: Tokenizer\r\n  ): VoidStatement | null {\r\n\r\n    // at 'void': Expression ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var expression = this.parseExpression(tn, Precedence.GROUPING);\r\n    if (!expression) return null;\r\n    var ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseWhileStatement(\r\n    tn: Tokenizer\r\n  ): WhileStatement | null {\r\n\r\n    // at 'while': '(' Expression ')' Statement ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      let expression = this.parseExpression(tn);\r\n      if (!expression) return null;\r\n      if (tn.skip(Token.CLOSEPAREN)) {\r\n        let statement = this.parseStatement(tn);\r\n        if (!statement) return null;\r\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // expressions\r\n\r\n  parseExpressionStart(\r\n    tn: Tokenizer\r\n  ): Expression | null {\r\n    var token = tn.next(IdentifierHandling.PREFER);\r\n    var startPos = tn.tokenPos;\r\n    switch (token) {\r\n\r\n      // TODO: SpreadExpression, YieldExpression\r\n      case Token.DOT_DOT_DOT:\r\n      case Token.YIELD: // fallthrough to unsupported UnaryPrefixExpression\r\n\r\n      // UnaryPrefixExpression\r\n      case Token.EXCLAMATION:\r\n      case Token.TILDE:\r\n      case Token.PLUS:\r\n      case Token.MINUS:\r\n      case Token.TYPEOF:\r\n      case Token.VOID:\r\n      case Token.DELETE: {\r\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\r\n        if (!operand) return null;\r\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\r\n      }\r\n      case Token.PLUS_PLUS:\r\n      case Token.MINUS_MINUS: {\r\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\r\n        if (!operand) return null;\r\n        switch (operand.kind) {\r\n          case NodeKind.IDENTIFIER:\r\n          case NodeKind.ELEMENTACCESS:\r\n          case NodeKind.PROPERTYACCESS: break;\r\n          default: {\r\n            this.error(\r\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\r\n              operand.range\r\n            );\r\n          }\r\n        }\r\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\r\n      }\r\n\r\n      // NewExpression\r\n      case Token.NEW: {\r\n        if (!tn.skipIdentifier()) {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n        let typeName = this.parseTypeName(tn);\r\n        if (!typeName) return null;\r\n        let typeArguments: TypeNode[] | null = null;\r\n        let arguments_: Expression[] | null = null;\r\n        if (\r\n          tn.skip(Token.OPENPAREN) ||\r\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\r\n        ) {\r\n          arguments_ = this.parseArguments(tn);\r\n          if (!arguments_) return null;\r\n        } else {\r\n          arguments_ = []; // new Type;\r\n        }\r\n        return Node.createNewExpression(\r\n          typeName,\r\n          typeArguments,\r\n          arguments_,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n      }\r\n\r\n      // Special IdentifierExpression\r\n      case Token.NULL: return Node.createNullExpression(tn.range());\r\n      case Token.TRUE: return Node.createTrueExpression(tn.range());\r\n      case Token.FALSE: return Node.createFalseExpression(tn.range());\r\n      case Token.THIS: return Node.createThisExpression(tn.range());\r\n      case Token.CONSTRUCTOR: return Node.createConstructorExpression(tn.range());\r\n\r\n      // ParenthesizedExpression or FunctionExpression\r\n      case Token.OPENPAREN: {\r\n\r\n        // determine whether this is a function expression\r\n        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)\r\n          return this.parseFunctionExpressionCommon(\r\n            tn,\r\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\r\n            [],\r\n            null,\r\n            ArrowKind.ARROW_PARENTHESIZED\r\n          );\r\n        }\r\n        let state = tn.mark();\r\n        let again = true;\r\n        do {\r\n          switch (tn.next(IdentifierHandling.PREFER)) {\r\n\r\n            // function expression\r\n            case Token.DOT_DOT_DOT: {\r\n              tn.reset(state);\r\n              return this.parseFunctionExpression(tn);\r\n            }\r\n            // can be both\r\n            case Token.IDENTIFIER: {\r\n              tn.readIdentifier();\r\n              switch (tn.next()) {\r\n\r\n                // if we got here, check for arrow\r\n                case Token.CLOSEPAREN: {\r\n                  if (\r\n                    !tn.skip(Token.COLON) &&\r\n                    !tn.skip(Token.EQUALS_GREATERTHAN)\r\n                  ) {\r\n                    again = false;\r\n                    break;\r\n                  }\r\n                  // fall-through\r\n                }\r\n                // function expression\r\n                case Token.COLON: {    // type annotation\r\n                  tn.reset(state);\r\n                  return this.parseFunctionExpression(tn);\r\n                }\r\n                // optional parameter or parenthesized\r\n                case Token.QUESTION: {\r\n                  if (\r\n                    tn.skip(Token.COLON) ||   // optional parameter with type\r\n                    tn.skip(Token.COMMA) ||   // optional parameter without type\r\n                    tn.skip(Token.CLOSEPAREN) // last optional parameter without type\r\n                  ) {\r\n                    tn.reset(state);\r\n                    return this.parseFunctionExpression(tn);\r\n                  }\r\n                  again = false; // parenthesized\r\n                  break;\r\n                }\r\n                case Token.COMMA: {\r\n                  break; // continue\r\n                }\r\n                // parenthesized expression\r\n                // case Token.EQUALS:  // missing type annotation for simplicity\r\n                default: {\r\n                  again = false;\r\n                  break;\r\n                }\r\n              }\r\n              break;\r\n            }\r\n            // parenthesized expression\r\n            default: {\r\n              again = false;\r\n              break;\r\n            }\r\n          }\r\n        } while (again);\r\n        tn.reset(state);\r\n\r\n        // parse parenthesized\r\n        let inner = this.parseExpression(tn);\r\n        if (!inner) return null;\r\n        if (!tn.skip(Token.CLOSEPAREN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\r\n        return this.maybeParseCallExpression(tn, inner);\r\n      }\r\n      // ArrayLiteralExpression\r\n      case Token.OPENBRACKET: {\r\n        let elementExpressions = new Array<Expression>();\r\n        while (!tn.skip(Token.CLOSEBRACKET)) {\r\n          let expr: Expression | null;\r\n          if (tn.peek() == Token.COMMA) {\r\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\r\n          } else {\r\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\r\n            if (!expr) return null;\r\n          }\r\n          elementExpressions.push(expr);\r\n          if (!tn.skip(Token.COMMA)) {\r\n            if (tn.skip(Token.CLOSEBRACKET)) {\r\n              break;\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode._0_expected,\r\n                tn.range(), \"]\"\r\n              );\r\n              return null;\r\n            }\r\n          }\r\n        }\r\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\r\n      }\r\n      // ObjectLiteralExpression\r\n      case Token.OPENBRACE: {\r\n        let startPos = tn.tokenPos;\r\n        let names = new Array<IdentifierExpression>();\r\n        let values = new Array<Expression>();\r\n        let name: IdentifierExpression;\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          if (!tn.skipIdentifier()) {\r\n            if (!tn.skip(Token.STRINGLITERAL)) {\r\n              this.error(\r\n                DiagnosticCode.Identifier_expected,\r\n                tn.range(),\r\n              );\r\n              return null;\r\n            }\r\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\r\n            name.isQuoted = true;\r\n          } else {\r\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n          }\r\n          names.push(name);\r\n          if (tn.skip(Token.COLON)) {\r\n            let value = this.parseExpression(tn, Precedence.COMMA + 1);\r\n            if (!value) return null;\r\n            values.push(value);\r\n          } else if (!name.isQuoted) {\r\n            values.push(name);\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \":\"\r\n            );\r\n            return null;\r\n          }\r\n          if (!tn.skip(Token.COMMA)) {\r\n            if (tn.skip(Token.CLOSEBRACE)) {\r\n              break;\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode._0_expected,\r\n                tn.range(), \"}\"\r\n              );\r\n              return null;\r\n            }\r\n          }\r\n        }\r\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\r\n      }\r\n      // AssertionExpression (unary prefix)\r\n      case Token.LESSTHAN: {\r\n        let toType = this.parseType(tn);\r\n        if (!toType) return null;\r\n        if (!tn.skip(Token.GREATERTHAN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \">\"\r\n          );\r\n          return null;\r\n        }\r\n        let expr = this.parseExpression(tn, Precedence.CALL);\r\n        if (!expr) return null;\r\n        return Node.createAssertionExpression(\r\n          AssertionKind.PREFIX,\r\n          expr,\r\n          toType,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n      }\r\n      case Token.IDENTIFIER: {\r\n        let identifierText = tn.readIdentifier();\r\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\r\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\r\n        if (tn.skip(Token.TEMPLATELITERAL)) {\r\n          return this.parseTemplateLiteral(tn, identifier);\r\n        }\r\n        if (tn.peek(true) == Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {\r\n          return this.parseFunctionExpressionCommon(\r\n            tn,\r\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\r\n            [\r\n              Node.createParameter(\r\n                ParameterKind.DEFAULT,\r\n                identifier,\r\n                Node.createOmittedType(identifier.range.atEnd),\r\n                null,\r\n                identifier.range\r\n              )\r\n            ],\r\n            null,\r\n            ArrowKind.ARROW_SINGLE,\r\n            startPos\r\n          );\r\n        }\r\n        return this.maybeParseCallExpression(tn, identifier, true);\r\n      }\r\n      case Token.SUPER: {\r\n        if (tn.peek() != Token.DOT && tn.nextToken != Token.OPENPAREN) {\r\n          this.error(\r\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\r\n            tn.range()\r\n          );\r\n        }\r\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\r\n        return this.maybeParseCallExpression(tn, expr);\r\n      }\r\n      case Token.STRINGLITERAL: {\r\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\r\n      }\r\n      case Token.TEMPLATELITERAL: {\r\n        return this.parseTemplateLiteral(tn);\r\n      }\r\n      case Token.INTEGERLITERAL: {\r\n        let value = tn.readInteger();\r\n        tn.checkForIdentifierStartAfterNumericLiteral();\r\n        return Node.createIntegerLiteralExpression(value, tn.range(startPos, tn.pos));\r\n      }\r\n      case Token.FLOATLITERAL: {\r\n        let value = tn.readFloat();\r\n        tn.checkForIdentifierStartAfterNumericLiteral();\r\n        return Node.createFloatLiteralExpression(value, tn.range(startPos, tn.pos));\r\n      }\r\n      // RegexpLiteralExpression\r\n      // note that this also continues on invalid ones so the surrounding AST remains intact\r\n      case Token.SLASH: {\r\n        let regexpPattern = tn.readRegexpPattern(); // also reports\r\n        if (!tn.skip(Token.SLASH)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"/\"\r\n          );\r\n          return null;\r\n        }\r\n        return Node.createRegexpLiteralExpression(\r\n          regexpPattern,\r\n          tn.readRegexpFlags(), // also reports\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n      }\r\n      case Token.FUNCTION: {\r\n        let expr = this.parseFunctionExpression(tn);\r\n        if (!expr) return null;\r\n        return this.maybeParseCallExpression(tn, expr);\r\n      }\r\n      case Token.CLASS: {\r\n        return this.parseClassExpression(tn);\r\n      }\r\n      default: {\r\n        if (token == Token.ENDOFFILE) {\r\n          this.error(\r\n            DiagnosticCode.Unexpected_end_of_text,\r\n            tn.range(startPos)\r\n          );\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Expression_expected,\r\n            tn.range()\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  tryParseTypeArgumentsBeforeArguments(\r\n    tn: Tokenizer\r\n  ): TypeNode[] | null {\r\n\r\n    // at '<': Type (',' Type)* '>' '('\r\n\r\n    var state = tn.mark();\r\n    if (!tn.skip(Token.LESSTHAN)) return null;\r\n    var start = tn.tokenPos;\r\n    var typeArguments: TypeNode[] | null = null;\r\n    do {\r\n      if (tn.peek() === Token.GREATERTHAN) {\r\n        break;\r\n      }\r\n      let type = this.parseType(tn, true, true);\r\n      if (!type) {\r\n        tn.reset(state);\r\n        return null;\r\n      }\r\n      if (!typeArguments) typeArguments = [ type ];\r\n      else typeArguments.push(type);\r\n    } while (tn.skip(Token.COMMA));\r\n    if (tn.skip(Token.GREATERTHAN)) {\r\n      let end = tn.pos;\r\n      if (tn.skip(Token.OPENPAREN)) {\r\n        if (!typeArguments) {\r\n          this.error(\r\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\r\n            tn.range(start, end)\r\n          );\r\n        }\r\n        return typeArguments;\r\n      }\r\n    }\r\n    tn.reset(state);\r\n    return null;\r\n  }\r\n\r\n  parseArguments(\r\n    tn: Tokenizer\r\n  ): Expression[] | null {\r\n\r\n    // at '(': (Expression (',' Expression)*)? ')'\r\n\r\n    var args = new Array<Expression>();\r\n    while (!tn.skip(Token.CLOSEPAREN)) {\r\n      let expr = this.parseExpression(tn, Precedence.COMMA + 1);\r\n      if (!expr) return null;\r\n      args.push(expr);\r\n      if (!tn.skip(Token.COMMA)) {\r\n        if (tn.skip(Token.CLOSEPAREN)) {\r\n          break;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n    return args;\r\n  }\r\n\r\n  parseExpression(\r\n    tn: Tokenizer,\r\n    precedence: Precedence = Precedence.COMMA\r\n  ): Expression | null {\r\n    assert(precedence != Precedence.NONE);\r\n    var expr = this.parseExpressionStart(tn);\r\n    if (!expr) return null;\r\n    var startPos = expr.range.start;\r\n\r\n    // precedence climbing\r\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\r\n    var nextPrecedence: Precedence;\r\n    while (\r\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\r\n    ) {\r\n      let token = tn.next();\r\n      switch (token) {\r\n\r\n        // AssertionExpression\r\n        case Token.AS: {\r\n          if (tn.skip(Token.CONST)) {\r\n            expr = Node.createAssertionExpression(\r\n              AssertionKind.CONST,\r\n              expr,\r\n              null,\r\n              tn.range(startPos, tn.pos)\r\n            );\r\n          } else {\r\n            let toType = this.parseType(tn); // reports\r\n            if (!toType) return null;\r\n            expr = Node.createAssertionExpression(\r\n              AssertionKind.AS,\r\n              expr,\r\n              toType,\r\n              tn.range(startPos, tn.pos)\r\n            );\r\n          }\r\n          break;\r\n        }\r\n        case Token.EXCLAMATION: {\r\n          expr = Node.createAssertionExpression(\r\n            AssertionKind.NONNULL,\r\n            expr,\r\n            null,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          expr = this.maybeParseCallExpression(tn, expr);\r\n          break;\r\n        }\r\n        // InstanceOfExpression\r\n        case Token.INSTANCEOF: {\r\n          let isType = this.parseType(tn); // reports\r\n          if (!isType) return null;\r\n          expr = Node.createInstanceOfExpression(\r\n            expr,\r\n            isType,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n        }\r\n        // ElementAccessExpression\r\n        case Token.OPENBRACKET: {\r\n          let next = this.parseExpression(tn); // reports\r\n          if (!next) return null;\r\n          if (!tn.skip(Token.CLOSEBRACKET)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"]\"\r\n            );\r\n            return null;\r\n          }\r\n          expr = Node.createElementAccessExpression(\r\n            expr,\r\n            next,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          expr = this.maybeParseCallExpression(tn, expr);\r\n          break;\r\n        }\r\n        // UnaryPostfixExpression\r\n        case Token.PLUS_PLUS:\r\n        case Token.MINUS_MINUS: {\r\n          if (\r\n            expr.kind != NodeKind.IDENTIFIER &&\r\n            expr.kind != NodeKind.ELEMENTACCESS &&\r\n            expr.kind != NodeKind.PROPERTYACCESS\r\n          ) {\r\n            this.error(\r\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\r\n              expr.range\r\n            );\r\n          }\r\n          expr = Node.createUnaryPostfixExpression(\r\n            token,\r\n            expr,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n        }\r\n        // TernaryExpression\r\n        case Token.QUESTION: {\r\n          let ifThen = this.parseExpression(tn);\r\n          if (!ifThen) return null;\r\n          if (!tn.skip(Token.COLON)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \":\"\r\n            );\r\n            return null;\r\n          }\r\n          let ifElse = this.parseExpression(tn, precedence > Precedence.COMMA\r\n            ? Precedence.COMMA + 1\r\n            : Precedence.COMMA\r\n          );\r\n          if (!ifElse) return null;\r\n          expr = Node.createTernaryExpression(\r\n            expr,\r\n            ifThen,\r\n            ifElse,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n        }\r\n        // CommaExpression\r\n        case Token.COMMA: {\r\n          let commaExprs: Expression[] = [ expr ];\r\n          do {\r\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\r\n            if (!expr) return null;\r\n            commaExprs.push(expr);\r\n          } while (tn.skip(Token.COMMA));\r\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\r\n          break;\r\n        }\r\n        // PropertyAccessExpression\r\n        case Token.DOT: {\r\n          if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) { // expr '.' Identifier\r\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            expr = Node.createPropertyAccessExpression(\r\n              expr,\r\n              next,\r\n              tn.range(startPos, tn.pos)\r\n            );\r\n          } else {\r\n            let next = this.parseExpression(tn, nextPrecedence + 1);\r\n            if (!next) return null;\r\n            if (next.kind == NodeKind.CALL) { // expr '.' CallExpression\r\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\r\n              if (!expr) return null;\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode.Identifier_expected,\r\n                next.range\r\n              );\r\n              return null;\r\n            }\r\n          }\r\n          if (tn.skip(Token.TEMPLATELITERAL)) {\r\n            expr = this.parseTemplateLiteral(tn, expr);\r\n            if (!expr) return null;\r\n          } else {\r\n            expr = this.maybeParseCallExpression(tn, expr, true);\r\n          }\r\n          break;\r\n        }\r\n        // BinaryExpression (right associative)\r\n        case Token.EQUALS:\r\n        case Token.PLUS_EQUALS:\r\n        case Token.MINUS_EQUALS:\r\n        case Token.ASTERISK_ASTERISK_EQUALS:\r\n        case Token.ASTERISK_EQUALS:\r\n        case Token.SLASH_EQUALS:\r\n        case Token.PERCENT_EQUALS:\r\n        case Token.LESSTHAN_LESSTHAN_EQUALS:\r\n        case Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n        case Token.AMPERSAND_EQUALS:\r\n        case Token.CARET_EQUALS:\r\n        case Token.BAR_EQUALS:\r\n        case Token.ASTERISK_ASTERISK: {\r\n          let next = this.parseExpression(tn, nextPrecedence);\r\n          if (!next) return null;\r\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\r\n          break;\r\n        }\r\n        // BinaryExpression\r\n        case Token.LESSTHAN:\r\n        case Token.GREATERTHAN:\r\n        case Token.LESSTHAN_EQUALS:\r\n        case Token.GREATERTHAN_EQUALS:\r\n        case Token.EQUALS_EQUALS:\r\n        case Token.EQUALS_EQUALS_EQUALS:\r\n        case Token.EXCLAMATION_EQUALS_EQUALS:\r\n        case Token.EXCLAMATION_EQUALS:\r\n        case Token.PLUS:\r\n        case Token.MINUS:\r\n        case Token.ASTERISK:\r\n        case Token.SLASH:\r\n        case Token.PERCENT:\r\n        case Token.LESSTHAN_LESSTHAN:\r\n        case Token.GREATERTHAN_GREATERTHAN:\r\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\r\n        case Token.AMPERSAND:\r\n        case Token.BAR:\r\n        case Token.CARET:\r\n        case Token.AMPERSAND_AMPERSAND:\r\n        case Token.BAR_BAR: {\r\n          let next = this.parseExpression(tn, nextPrecedence + 1);\r\n          if (!next) return null;\r\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\r\n          break;\r\n        }\r\n        default: assert(false); // filtered by determinePrecedence\r\n      }\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  private parseTemplateLiteral(tn: Tokenizer, tag: Expression | null = null): Expression | null {\r\n    // at '`': ... '`'\r\n    var startPos = tag ? tag.range.start : tn.tokenPos;\r\n    var parts = new Array<string>();\r\n    var rawParts = new Array<string>();\r\n    var exprs = new Array<Expression>();\r\n    parts.push(tn.readString(0, tag != null));\r\n    rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\r\n    while (tn.readingTemplateString) {\r\n      let expr = this.parseExpression(tn);\r\n      if (!expr) return null;\r\n      exprs.push(expr);\r\n      if (!tn.skip(Token.CLOSEBRACE)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"}\"\r\n        );\r\n        return null;\r\n      }\r\n      parts.push(tn.readString(CharCode.BACKTICK, tag != null));\r\n      rawParts.push(tn.source.text.substring(tn.readStringStart, tn.readStringEnd));\r\n    }\r\n    return Node.createTemplateLiteralExpression(tag, parts, rawParts, exprs, tn.range(startPos, tn.pos));\r\n  }\r\n\r\n  private joinPropertyCall(\r\n    tn: Tokenizer,\r\n    startPos: i32,\r\n    expr: Expression,\r\n    call: CallExpression\r\n  ): Expression | null {\r\n    var callee = call.expression;\r\n    switch (callee.kind) {\r\n      case NodeKind.IDENTIFIER: { // join property access and use as call target\r\n        call.expression = Node.createPropertyAccessExpression(\r\n          expr,\r\n          <IdentifierExpression>callee,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n        break;\r\n      }\r\n      case NodeKind.CALL: { // join call target und wrap the original call around it\r\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\r\n        if (!inner) return null;\r\n        call.expression = inner;\r\n        call.range = tn.range(startPos, tn.pos);\r\n        break;\r\n      }\r\n      default: {\r\n        this.error(\r\n          DiagnosticCode.Identifier_expected,\r\n          call.range\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n    return call;\r\n  }\r\n\r\n  private maybeParseCallExpression(\r\n    tn: Tokenizer,\r\n    expr: Expression,\r\n    potentiallyGeneric: bool = false\r\n  ): Expression {\r\n    var typeArguments: TypeNode[] | null = null;\r\n    while (\r\n      tn.skip(Token.OPENPAREN) ||\r\n      potentiallyGeneric &&\r\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\r\n    ) {\r\n      let args = this.parseArguments(tn);\r\n      if (!args) break;\r\n      expr = Node.createCallExpression( // is again callable\r\n        expr,\r\n        typeArguments,\r\n        args,\r\n        tn.range(expr.range.start, tn.pos)\r\n      );\r\n      potentiallyGeneric = false;\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\r\n  skipStatement(tn: Tokenizer): void {\r\n    tn.peek(true);\r\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\r\n    do {\r\n      let nextToken = tn.peek(true);\r\n      if (\r\n        nextToken == Token.ENDOFFILE ||   // next step should handle this\r\n        nextToken == Token.SEMICOLON      // end of the statement for sure\r\n      ) {\r\n        tn.next();\r\n        break;\r\n      }\r\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\r\n      switch (tn.next()) {\r\n        case Token.IDENTIFIER: {\r\n          tn.readIdentifier();\r\n          break;\r\n        }\r\n        case Token.STRINGLITERAL:\r\n        case Token.TEMPLATELITERAL: {\r\n          tn.readString();\r\n          break;\r\n        }\r\n        case Token.INTEGERLITERAL: {\r\n          tn.readInteger();\r\n          tn.checkForIdentifierStartAfterNumericLiteral();\r\n          break;\r\n        }\r\n        case Token.FLOATLITERAL: {\r\n          tn.readFloat();\r\n          tn.checkForIdentifierStartAfterNumericLiteral();\r\n          break;\r\n        }\r\n        case Token.OPENBRACE: {\r\n          this.skipBlock(tn);\r\n          break;\r\n        }\r\n      }\r\n    } while (true);\r\n    tn.readingTemplateString = false;\r\n  }\r\n\r\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\r\n  skipBlock(tn: Tokenizer): void {\r\n    // at '{': ... '}'\r\n    var depth = 1;\r\n    var again = true;\r\n    do {\r\n      switch (tn.next()) {\r\n        case Token.ENDOFFILE: {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"}\"\r\n          );\r\n          again = false;\r\n          break;\r\n        }\r\n        case Token.OPENBRACE: {\r\n          ++depth;\r\n          break;\r\n        }\r\n        case Token.CLOSEBRACE: {\r\n          --depth;\r\n          if (!depth) again = false;\r\n          break;\r\n        }\r\n        case Token.IDENTIFIER: {\r\n          tn.readIdentifier();\r\n          break;\r\n        }\r\n        case Token.STRINGLITERAL: {\r\n          tn.readString();\r\n          break;\r\n        }\r\n        case Token.INTEGERLITERAL: {\r\n          tn.readInteger();\r\n          tn.checkForIdentifierStartAfterNumericLiteral();\r\n          break;\r\n        }\r\n        case Token.FLOATLITERAL: {\r\n          tn.readFloat();\r\n          tn.checkForIdentifierStartAfterNumericLiteral();\r\n          break;\r\n        }\r\n      }\r\n    } while (again);\r\n  }\r\n}\r\n\r\n/** Operator precedence from least to largest. */\r\nexport const enum Precedence {\r\n  NONE,\r\n  COMMA,\r\n  SPREAD,\r\n  YIELD,\r\n  ASSIGNMENT,\r\n  CONDITIONAL,\r\n  LOGICAL_OR,\r\n  LOGICAL_AND,\r\n  BITWISE_OR,\r\n  BITWISE_XOR,\r\n  BITWISE_AND,\r\n  EQUALITY,\r\n  RELATIONAL,\r\n  SHIFT,\r\n  ADDITIVE,\r\n  MULTIPLICATIVE,\r\n  EXPONENTIATED,\r\n  UNARY_PREFIX,\r\n  UNARY_POSTFIX,\r\n  CALL,\r\n  MEMBERACCESS,\r\n  GROUPING\r\n}\r\n\r\n/** Determines the precende of a non-starting token. */\r\nfunction determinePrecedence(kind: Token): Precedence {\r\n  switch (kind) {\r\n    case Token.COMMA: return Precedence.COMMA;\r\n    case Token.EQUALS:\r\n    case Token.PLUS_EQUALS:\r\n    case Token.MINUS_EQUALS:\r\n    case Token.ASTERISK_ASTERISK_EQUALS:\r\n    case Token.ASTERISK_EQUALS:\r\n    case Token.SLASH_EQUALS:\r\n    case Token.PERCENT_EQUALS:\r\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\r\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n    case Token.AMPERSAND_EQUALS:\r\n    case Token.CARET_EQUALS:\r\n    case Token.BAR_EQUALS: return Precedence.ASSIGNMENT;\r\n    case Token.QUESTION: return Precedence.CONDITIONAL;\r\n    case Token.BAR_BAR: return Precedence.LOGICAL_OR;\r\n    case Token.AMPERSAND_AMPERSAND: return Precedence.LOGICAL_AND;\r\n    case Token.BAR: return Precedence.BITWISE_OR;\r\n    case Token.CARET: return Precedence.BITWISE_XOR;\r\n    case Token.AMPERSAND: return Precedence.BITWISE_AND;\r\n    case Token.EQUALS_EQUALS:\r\n    case Token.EXCLAMATION_EQUALS:\r\n    case Token.EQUALS_EQUALS_EQUALS:\r\n    case Token.EXCLAMATION_EQUALS_EQUALS: return Precedence.EQUALITY;\r\n    case Token.AS:\r\n    case Token.IN:\r\n    case Token.INSTANCEOF:\r\n    case Token.LESSTHAN:\r\n    case Token.GREATERTHAN:\r\n    case Token.LESSTHAN_EQUALS:\r\n    case Token.GREATERTHAN_EQUALS: return Precedence.RELATIONAL;\r\n    case Token.LESSTHAN_LESSTHAN:\r\n    case Token.GREATERTHAN_GREATERTHAN:\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return Precedence.SHIFT;\r\n    case Token.PLUS:\r\n    case Token.MINUS: return Precedence.ADDITIVE;\r\n    case Token.ASTERISK:\r\n    case Token.SLASH:\r\n    case Token.PERCENT: return Precedence.MULTIPLICATIVE;\r\n    case Token.ASTERISK_ASTERISK: return Precedence.EXPONENTIATED;\r\n    case Token.PLUS_PLUS:\r\n    case Token.MINUS_MINUS: return Precedence.UNARY_POSTFIX;\r\n    case Token.DOT:\r\n    case Token.NEW:\r\n    case Token.OPENBRACKET:\r\n    case Token.EXCLAMATION: return Precedence.MEMBERACCESS;\r\n  }\r\n  return Precedence.NONE;\r\n}\r\n","/**\r\n * @fileoverview Utility to find all locals used in an expression.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Visitor\r\n} from \"./pass\";\r\n\r\nimport {\r\n  ExpressionRef\r\n} from \"../module\";\r\n\r\nimport {\r\n  _BinaryenLocalGetGetIndex,\r\n  _BinaryenLocalSetGetIndex\r\n} from \"../glue/binaryen\";\r\n\r\nclass FindUsedLocalsVisitor extends Visitor {\r\n  used: Set<i32>;\r\n\r\n  constructor(used: Set<i32> = new Set()) {\r\n    super();\r\n    this.used = used;\r\n  }\r\n  \r\n  /** @override */\r\n  visitLocalGet(localGet: ExpressionRef): void {\r\n    this.used.add(<i32>_BinaryenLocalGetGetIndex(localGet));\r\n  }\r\n\r\n  /** @override */\r\n  visitLocalSet(localSet: ExpressionRef): void {\r\n    this.used.add(<i32>_BinaryenLocalSetGetIndex(localSet));\r\n  }\r\n}\r\n\r\nvar singleton: FindUsedLocalsVisitor | null = null;\r\n\r\n/** Finds the indexes of all locals used in the specified expression. */\r\nexport function findUsedLocals(\r\n  expr: ExpressionRef,\r\n  used: Set<i32> = new Set()\r\n): Set<i32> {\r\n  var visitor = singleton;\r\n  if (!visitor) singleton = visitor = new FindUsedLocalsVisitor(used);\r\n  else visitor.used = used;\r\n  visitor.visit(expr);\r\n  return used;\r\n}\r\n","/**\r\n * @fileoverview Infrastructure for custom Binaryen passes.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Module,\r\n  ExpressionId,\r\n  ExpressionRef,\r\n  FunctionRef,\r\n  GlobalRef,\r\n  Index,\r\n  StringRef\r\n} from \"../module\";\r\n\r\nimport {\r\n  _BinaryenExpressionGetId,\r\n  _BinaryenBlockGetNumChildren,\r\n  _BinaryenBlockGetChildAt,\r\n  _BinaryenIfGetCondition,\r\n  _BinaryenIfGetIfTrue,\r\n  _BinaryenIfGetIfFalse,\r\n  _BinaryenLoopGetBody,\r\n  _BinaryenBreakGetCondition,\r\n  _BinaryenBreakGetValue,\r\n  _BinaryenGetNumFunctions,\r\n  _BinaryenGetFunctionByIndex,\r\n  _BinaryenGetNumGlobals,\r\n  _BinaryenGetGlobalByIndex,\r\n  _BinaryenFunctionGetBody,\r\n  _BinaryenSwitchGetCondition,\r\n  _BinaryenSwitchGetValue,\r\n  _BinaryenCallGetNumOperands,\r\n  _BinaryenCallGetOperandAt,\r\n  _BinaryenCallIndirectGetNumOperands,\r\n  _BinaryenCallIndirectGetOperandAt,\r\n  _BinaryenLocalSetGetValue,\r\n  _BinaryenGlobalSetGetValue,\r\n  _BinaryenGlobalGetInitExpr,\r\n  _BinaryenLoadGetPtr,\r\n  _BinaryenStoreGetPtr,\r\n  _BinaryenStoreGetValue,\r\n  _BinaryenUnaryGetValue,\r\n  _BinaryenBinaryGetLeft,\r\n  _BinaryenBinaryGetRight,\r\n  _BinaryenSelectGetIfTrue,\r\n  _BinaryenSelectGetIfFalse,\r\n  _BinaryenSelectGetCondition,\r\n  _BinaryenDropGetValue,\r\n  _BinaryenBlockSetChildAt,\r\n  _BinaryenCallIndirectGetTarget,\r\n  _BinaryenReturnGetValue,\r\n  _BinaryenMemoryGrowGetDelta,\r\n  _BinaryenAtomicRMWGetPtr,\r\n  _BinaryenAtomicRMWGetValue,\r\n  _BinaryenAtomicCmpxchgGetPtr,\r\n  _BinaryenAtomicCmpxchgGetExpected,\r\n  _BinaryenAtomicCmpxchgGetReplacement,\r\n  _BinaryenAtomicWaitGetPtr,\r\n  _BinaryenAtomicWaitGetExpected,\r\n  _BinaryenAtomicWaitGetTimeout,\r\n  _BinaryenAtomicNotifyGetPtr,\r\n  _BinaryenSIMDExtractGetVec,\r\n  _BinaryenSIMDReplaceGetVec,\r\n  _BinaryenSIMDReplaceGetValue,\r\n  _BinaryenSIMDShuffleGetLeft,\r\n  _BinaryenSIMDShuffleGetRight,\r\n  _BinaryenSIMDTernaryGetA,\r\n  _BinaryenSIMDTernaryGetB,\r\n  _BinaryenSIMDTernaryGetC,\r\n  _BinaryenSIMDShiftGetVec,\r\n  _BinaryenSIMDShiftGetShift,\r\n  _BinaryenSIMDLoadGetPtr,\r\n  _BinaryenMemoryInitGetDest,\r\n  _BinaryenMemoryInitGetOffset,\r\n  _BinaryenMemoryInitGetSize,\r\n  _BinaryenMemoryCopyGetDest,\r\n  _BinaryenMemoryCopyGetSource,\r\n  _BinaryenMemoryCopyGetSize,\r\n  _BinaryenMemoryFillGetDest,\r\n  _BinaryenMemoryFillGetValue,\r\n  _BinaryenMemoryFillGetSize,\r\n  _BinaryenRefIsGetValue,\r\n  _BinaryenTryGetBody,\r\n  _BinaryenTryGetNumCatchBodies,\r\n  _BinaryenTryGetCatchBodyAt,\r\n  _BinaryenThrowGetNumOperands,\r\n  _BinaryenThrowGetOperandAt,\r\n  _BinaryenTupleMakeGetOperandAt,\r\n  _BinaryenTupleMakeGetNumOperands,\r\n  _BinaryenIfSetCondition,\r\n  _BinaryenIfSetIfTrue,\r\n  _BinaryenIfSetIfFalse,\r\n  _BinaryenLoopSetBody,\r\n  _BinaryenBreakSetCondition,\r\n  _BinaryenBreakSetValue,\r\n  _BinaryenSwitchSetCondition,\r\n  _BinaryenSwitchSetValue,\r\n  _BinaryenCallSetOperandAt,\r\n  _BinaryenCallIndirectSetTarget,\r\n  _BinaryenCallIndirectSetOperandAt,\r\n  _BinaryenLocalSetSetValue,\r\n  _BinaryenGlobalSetSetValue,\r\n  _BinaryenLoadSetPtr,\r\n  _BinaryenStoreSetPtr,\r\n  _BinaryenStoreSetValue,\r\n  _BinaryenUnarySetValue,\r\n  _BinaryenExpressionFinalize,\r\n  _BinaryenBinarySetLeft,\r\n  _BinaryenBinarySetRight,\r\n  _BinaryenSelectSetIfTrue,\r\n  _BinaryenSelectSetIfFalse,\r\n  _BinaryenSelectSetCondition,\r\n  _BinaryenDropSetValue,\r\n  _BinaryenReturnSetValue,\r\n  _BinaryenMemoryGrowSetDelta,\r\n  _BinaryenAtomicRMWSetPtr,\r\n  _BinaryenAtomicRMWSetValue,\r\n  _BinaryenAtomicCmpxchgSetPtr,\r\n  _BinaryenAtomicCmpxchgSetExpected,\r\n  _BinaryenAtomicCmpxchgSetReplacement,\r\n  _BinaryenAtomicWaitSetPtr,\r\n  _BinaryenAtomicWaitSetExpected,\r\n  _BinaryenAtomicWaitSetTimeout,\r\n  _BinaryenAtomicNotifySetPtr,\r\n  _BinaryenSIMDExtractSetVec,\r\n  _BinaryenSIMDReplaceSetVec,\r\n  _BinaryenSIMDReplaceSetValue,\r\n  _BinaryenSIMDShuffleSetLeft,\r\n  _BinaryenSIMDShuffleSetRight,\r\n  _BinaryenSIMDTernarySetA,\r\n  _BinaryenSIMDTernarySetB,\r\n  _BinaryenSIMDTernarySetC,\r\n  _BinaryenSIMDShiftSetVec,\r\n  _BinaryenSIMDShiftSetShift,\r\n  _BinaryenSIMDLoadSetPtr,\r\n  _BinaryenSIMDLoadStoreLaneGetPtr,\r\n  _BinaryenSIMDLoadStoreLaneGetVec,\r\n  _BinaryenSIMDLoadStoreLaneSetPtr,\r\n  _BinaryenSIMDLoadStoreLaneSetVec,\r\n  _BinaryenMemoryInitSetDest,\r\n  _BinaryenMemoryInitSetOffset,\r\n  _BinaryenMemoryInitSetSize,\r\n  _BinaryenMemoryCopySetDest,\r\n  _BinaryenMemoryCopySetSource,\r\n  _BinaryenMemoryCopySetSize,\r\n  _BinaryenMemoryFillSetDest,\r\n  _BinaryenMemoryFillSetValue,\r\n  _BinaryenMemoryFillSetSize,\r\n  _BinaryenRefIsSetValue,\r\n  _BinaryenTrySetBody,\r\n  _BinaryenTrySetCatchBodyAt,\r\n  _BinaryenThrowSetOperandAt,\r\n  _BinaryenTupleMakeSetOperandAt,\r\n  _BinaryenBlockGetName,\r\n  _BinaryenLoopGetName,\r\n  _BinaryenBreakGetName,\r\n  _BinaryenSwitchGetDefaultName,\r\n  _BinaryenSwitchGetNumNames,\r\n  _BinaryenSwitchGetNameAt,\r\n  _BinaryenCallGetTarget,\r\n  _BinaryenLocalGetGetIndex,\r\n  _BinaryenLocalSetGetIndex,\r\n  _BinaryenGlobalGetGetName,\r\n  _BinaryenGlobalSetGetName,\r\n  _BinaryenAtomicNotifyGetNotifyCount,\r\n  _BinaryenAtomicNotifySetNotifyCount,\r\n  _BinaryenRefFuncGetFunc,\r\n  _BinaryenThrowGetTag,\r\n  _BinaryenTupleExtractGetTuple,\r\n  _BinaryenTupleExtractSetTuple,\r\n  _BinaryenRefEqGetLeft,\r\n  _BinaryenRefEqGetRight,\r\n  _BinaryenRefEqSetLeft,\r\n  _BinaryenRefEqSetRight,\r\n  _BinaryenFunctionSetBody,\r\n  _BinaryenI31NewGetValue,\r\n  _BinaryenI31GetGetI31,\r\n  _BinaryenI31NewSetValue,\r\n  _BinaryenI31GetSetI31\r\n} from \"../glue/binaryen\";\r\n\r\n/** Base class of custom Binaryen visitors. */\r\nexport abstract class Visitor {\r\n  /** Expression stack. */\r\n  private stack: ExpressionRef[] = new Array<ExpressionRef>();\r\n\r\n  /** Gets the current expression being walked. */\r\n  get currentExpression(): ExpressionRef {\r\n    var currentExpression = this._currentExpression;\r\n    if (!currentExpression) throw new Error(\"not walking expressions\");\r\n    return currentExpression;\r\n  }\r\n  _currentExpression: ExpressionRef = 0;\r\n\r\n  /** Gets the parent expression of the current expression being walked. Returns zero if already the top-most expression. */\r\n  get parentExpressionOrNull(): ExpressionRef {\r\n    var stack = this.stack;\r\n    var length = stack.length;\r\n    return length ? stack[length - 1] : 0;\r\n  }\r\n\r\n  // Expressions\r\n\r\n  visitBlock(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitIf(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitLoop(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitBreak(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSwitch(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitCallPre(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitCall(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitCallIndirectPre(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitCallIndirect(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitLocalGet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitLocalSet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitGlobalGet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitGlobalSet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitLoad(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitStore(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitConst(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitUnary(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitBinary(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSelect(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitDrop(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitReturn(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitMemorySize(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitMemoryGrow(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitNop(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitUnreachable(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitAtomicRMW(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitAtomicCmpxchg(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitAtomicWait(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitAtomicNotify(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitAtomicFence(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDExtract(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDReplace(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDShuffle(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDTernary(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDShift(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDLoad(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitSIMDLoadStoreLane(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitMemoryInit(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitDataDrop(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitMemoryCopy(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitMemoryFill(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitPop(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefNull(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefIs(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefFunc(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefEq(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitTry(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitThrow(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRethrow(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitTupleMake(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitTupleExtract(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitI31New(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitI31Get(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitCallRef(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefTest(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefCast(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitBrOn(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRttCanon(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRttSub(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitStructNew(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitStructGet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitStructSet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitArrayNew(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitArrayGet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitArraySet(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitArrayLen(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitRefAs(expr: ExpressionRef): void {\r\n    // unimp\r\n  }\r\n\r\n  // Immediates\r\n\r\n  visitName(name: StringRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitLabel(name: StringRef): void {\r\n    // unimp\r\n  }\r\n\r\n  visitIndex(index: Index): void {\r\n    // unimp\r\n  }\r\n\r\n  visitTag(name: StringRef): void {\r\n    // unimp\r\n  }\r\n\r\n  // Delegate\r\n\r\n  /** Visits any expression, delegating to the respective visitor methods. */\r\n  visit(expr: ExpressionRef): void {\r\n    let previousExpression = this._currentExpression;\r\n    this._currentExpression = assert(expr);\r\n    switch (_BinaryenExpressionGetId(expr)) {\r\n      case ExpressionId.Block: {\r\n        this.stack.push(expr);\r\n        let name = _BinaryenBlockGetName(expr);\r\n        if (name) this.visitLabel(name);\r\n        for (let i: Index = 0, n = _BinaryenBlockGetNumChildren(expr); i < n; ++i) {\r\n          this.visit(_BinaryenBlockGetChildAt(expr, i));\r\n        }\r\n        assert(this.stack.pop() == expr);\r\n        this.visitBlock(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.If: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenIfGetCondition(expr));\r\n        this.visit(_BinaryenIfGetIfTrue(expr));\r\n        let ifFalse = _BinaryenIfGetIfFalse(expr);\r\n        if (ifFalse) this.visit(ifFalse);\r\n        assert(this.stack.pop() == expr);\r\n        this.visitIf(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Loop: {\r\n        this.stack.push(expr);\r\n        let name = _BinaryenLoopGetName(expr);\r\n        if (name) this.visitLabel(name);\r\n        this.visit(_BinaryenLoopGetBody(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitLoop(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Break: {\r\n        this.stack.push(expr);\r\n        this.visitLabel(_BinaryenBreakGetName(expr));\r\n        let condition = _BinaryenBreakGetCondition(expr);\r\n        if (condition) this.visit(condition);\r\n        let value = _BinaryenBreakGetValue(expr);\r\n        if (value) this.visit(value);\r\n        assert(this.stack.pop() == expr);\r\n        this.visitBreak(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Switch: {\r\n        this.stack.push(expr);\r\n        let defaultName = _BinaryenSwitchGetDefaultName(expr);\r\n        if (defaultName) this.visitLabel(defaultName);\r\n        let numNames = _BinaryenSwitchGetNumNames(expr);\r\n        for (let i: Index = 0; i < numNames; ++i) {\r\n          this.visitLabel(_BinaryenSwitchGetNameAt(expr, i));\r\n        }\r\n        this.visit(_BinaryenSwitchGetCondition(expr));\r\n        let value = _BinaryenSwitchGetValue(expr);\r\n        if (value) this.visit(value);\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSwitch(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Call: {\r\n        this.visitCallPre(expr);\r\n        this.stack.push(expr);\r\n        this.visitName(_BinaryenCallGetTarget(expr));\r\n        let numOperands = _BinaryenCallGetNumOperands(expr);\r\n        for (let i: Index = 0; i < numOperands; ++i) {\r\n          this.visit(_BinaryenCallGetOperandAt(expr, i));\r\n        }\r\n        assert(this.stack.pop() == expr);\r\n        this.visitCall(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.CallIndirect: {\r\n        this.visitCallIndirectPre(expr);\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenCallIndirectGetTarget(expr));\r\n        for (let i: Index = 0, k = _BinaryenCallIndirectGetNumOperands(expr); i < k; ++i) {\r\n          this.visit(_BinaryenCallIndirectGetOperandAt(expr, i));\r\n        }\r\n        assert(this.stack.pop() == expr);\r\n        this.visitCallIndirect(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.LocalGet: {\r\n        this.stack.push(expr);\r\n        this.visitIndex(_BinaryenLocalGetGetIndex(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitLocalGet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.LocalSet: {\r\n        this.stack.push(expr);\r\n        this.visitIndex(_BinaryenLocalSetGetIndex(expr));\r\n        this.visit(_BinaryenLocalSetGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitLocalSet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.GlobalGet: {\r\n        this.stack.push(expr);\r\n        this.visitName(_BinaryenGlobalGetGetName(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitGlobalGet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.GlobalSet: {\r\n        this.stack.push(expr);\r\n        this.visitName(_BinaryenGlobalSetGetName(expr));\r\n        this.visit(_BinaryenGlobalSetGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitGlobalSet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Load: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenLoadGetPtr(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitLoad(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Store: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenStoreGetPtr(expr));\r\n        this.visit(_BinaryenStoreGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitStore(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Const: {\r\n        this.visitConst(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Unary: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenUnaryGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitUnary(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Binary: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenBinaryGetLeft(expr));\r\n        this.visit(_BinaryenBinaryGetRight(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitBinary(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Select: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSelectGetIfTrue(expr));\r\n        this.visit(_BinaryenSelectGetIfFalse(expr));\r\n        this.visit(_BinaryenSelectGetCondition(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSelect(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Drop: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenDropGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitDrop(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Return: {\r\n        let value = _BinaryenReturnGetValue(expr);\r\n        if (value) {\r\n          this.stack.push(expr);\r\n          this.visit(value);\r\n          assert(this.stack.pop() == expr);\r\n        }\r\n        this.visitReturn(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.MemorySize: {\r\n        this.visitMemorySize(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.MemoryGrow: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenMemoryGrowGetDelta(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitMemoryGrow(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Nop: {\r\n        this.visitNop(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Unreachable: {\r\n        this.visitUnreachable(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.AtomicRMW: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenAtomicRMWGetPtr(expr));\r\n        this.visit(_BinaryenAtomicRMWGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitAtomicRMW(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.AtomicCmpxchg: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenAtomicCmpxchgGetPtr(expr));\r\n        this.visit(_BinaryenAtomicCmpxchgGetExpected(expr));\r\n        this.visit(_BinaryenAtomicCmpxchgGetReplacement(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitAtomicCmpxchg(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.AtomicWait: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenAtomicWaitGetPtr(expr));\r\n        this.visit(_BinaryenAtomicWaitGetExpected(expr));\r\n        this.visit(_BinaryenAtomicWaitGetTimeout(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitAtomicWait(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.AtomicNotify: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenAtomicNotifyGetPtr(expr));\r\n        this.visit(_BinaryenAtomicNotifyGetNotifyCount(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitAtomicNotify(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.AtomicFence: {\r\n        this.visitAtomicFence(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDExtract: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDExtractGetVec(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDExtract(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDReplace: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDReplaceGetVec(expr));\r\n        this.visit(_BinaryenSIMDReplaceGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDReplace(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDShuffle: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDShuffleGetLeft(expr));\r\n        this.visit(_BinaryenSIMDShuffleGetRight(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDShuffle(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDTernary: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDTernaryGetA(expr));\r\n        this.visit(_BinaryenSIMDTernaryGetB(expr));\r\n        this.visit(_BinaryenSIMDTernaryGetC(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDTernary(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDShift: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDShiftGetVec(expr));\r\n        this.visit(_BinaryenSIMDShiftGetShift(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDShift(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDLoad: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDLoadGetPtr(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDLoad(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.SIMDLoadStoreLane: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenSIMDLoadStoreLaneGetPtr(expr));\r\n        this.visit(_BinaryenSIMDLoadStoreLaneGetVec(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitSIMDLoadStoreLane(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.MemoryInit: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenMemoryInitGetDest(expr));\r\n        this.visit(_BinaryenMemoryInitGetOffset(expr));\r\n        this.visit(_BinaryenMemoryInitGetSize(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitMemoryInit(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.DataDrop: {\r\n        this.visitDataDrop(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.MemoryCopy: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenMemoryCopyGetDest(expr));\r\n        this.visit(_BinaryenMemoryCopyGetSource(expr));\r\n        this.visit(_BinaryenMemoryCopyGetSize(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitMemoryCopy(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.MemoryFill: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenMemoryFillGetDest(expr));\r\n        this.visit(_BinaryenMemoryFillGetValue(expr));\r\n        this.visit(_BinaryenMemoryFillGetSize(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitMemoryFill(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Pop: {\r\n        this.visitPop(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefNull: {\r\n        this.visitRefNull(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefIs: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenRefIsGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRefIs(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefFunc: {\r\n        this.stack.push(expr);\r\n        this.visitName(_BinaryenRefFuncGetFunc(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRefFunc(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefEq: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenRefEqGetLeft(expr));\r\n        this.visit(_BinaryenRefEqGetRight(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRefEq(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Try: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenTryGetBody(expr));\r\n        let numCatchBodies = _BinaryenTryGetNumCatchBodies(expr);\r\n        for (let i: Index = 0; i < numCatchBodies; ++i) {\r\n          this.visit(_BinaryenTryGetCatchBodyAt(expr, i));\r\n        }\r\n        assert(this.stack.pop() == expr);\r\n        this.visitTry(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Throw: {\r\n        this.stack.push(expr);\r\n        this.visitTag(_BinaryenThrowGetTag(expr));\r\n        let numOperands = _BinaryenThrowGetNumOperands(expr);\r\n        for (let i: Index = 0; i < numOperands; ++i) {\r\n          this.visit(_BinaryenThrowGetOperandAt(expr, i));\r\n        }\r\n        assert(this.stack.pop() == expr);\r\n        this.visitThrow(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.Rethrow: {\r\n        this.visitRethrow(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.TupleMake: {\r\n        let numOperands = _BinaryenTupleMakeGetNumOperands(expr);\r\n        if (numOperands) {\r\n          this.stack.push(expr);\r\n          for (let i: Index = 0; i < numOperands; ++i) {\r\n            this.visit(_BinaryenTupleMakeGetOperandAt(expr, i));\r\n          }\r\n          assert(this.stack.pop() == expr);\r\n        }\r\n        this.visitTupleMake(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.TupleExtract: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenTupleExtractGetTuple(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitTupleExtract(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.I31New: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenI31NewGetValue(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitI31New(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.I31Get: {\r\n        this.stack.push(expr);\r\n        this.visit(_BinaryenI31GetGetI31(expr));\r\n        assert(this.stack.pop() == expr);\r\n        this.visitI31Get(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.CallRef: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitCallRef(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefTest: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRefTest(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefCast: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRefCast(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.BrOn: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitBrOn(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RttCanon: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRttCanon(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RttSub: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRttSub(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.StructNew: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitStructNew(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.StructGet: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitStructGet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.StructSet: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitStructSet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.ArrayNew: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitArrayNew(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.ArrayGet: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitArrayGet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.ArraySet: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitArraySet(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.ArrayLen: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitArrayLen(expr);\r\n        break;\r\n      }\r\n      case ExpressionId.RefAs: {\r\n        this.stack.push(expr);\r\n        assert(false); // TODO\r\n        assert(this.stack.pop() == expr);\r\n        this.visitRefAs(expr);\r\n        break;\r\n      }\r\n      default: throw new Error(\"unexpected expression kind\");\r\n    }\r\n    this._currentExpression = previousExpression;\r\n  }\r\n}\r\n\r\n/** Base class of custom Binaryen passes. */\r\nexport abstract class Pass extends Visitor {\r\n\r\n  /** Gets the current function being walked. */\r\n  get currentFunction(): FunctionRef {\r\n    var currentFunction = this._currentFunction;\r\n    if (!currentFunction) throw new Error(\"not walking a function\");\r\n    return currentFunction;\r\n  }\r\n  private _currentFunction: FunctionRef = 0;\r\n\r\n  /** Gets the current global being walked. */\r\n  get currentGlobal(): GlobalRef {\r\n    var currentGlobal = this._currentGlobal;\r\n    if (!currentGlobal) throw new Error(\"not walking a global\");\r\n    return currentGlobal;\r\n  }\r\n  private _currentGlobal: GlobalRef = 0;\r\n\r\n  /** Constructs a new Binaryen pass. */\r\n  constructor(readonly module: Module) {\r\n    super();\r\n  }\r\n\r\n  // Walking\r\n\r\n  /** Walks the entire module. */\r\n  walkModule(): void {\r\n    this.walkFunctions();\r\n    this.walkGlobals();\r\n  }\r\n\r\n  /** Walks all functions. */\r\n  walkFunctions(): void {\r\n    var moduleRef = this.module.ref;\r\n    for (let i: Index = 0, k = _BinaryenGetNumFunctions(moduleRef); i < k; ++i) {\r\n      this.walkFunction(_BinaryenGetFunctionByIndex(moduleRef, i));\r\n    }\r\n  }\r\n\r\n  /** Walks a specific function. */\r\n  walkFunction(func: FunctionRef): void {\r\n    var body = _BinaryenFunctionGetBody(func);\r\n    if (body) {\r\n      this._currentFunction = func;\r\n      this.visit(body);\r\n      this._currentFunction = 0;\r\n    }\r\n  }\r\n\r\n  /** Walks all global variables. */\r\n  walkGlobals(): void {\r\n    var moduleRef = this.module.ref;\r\n    for (let i: Index = 0, k = _BinaryenGetNumGlobals(moduleRef); i < k; ++i) {\r\n      this.walkGlobal(_BinaryenGetGlobalByIndex(moduleRef, i));\r\n    }\r\n  }\r\n\r\n  /** Walks a specific global variable. */\r\n  walkGlobal(global: GlobalRef): void {\r\n    this._currentGlobal = global;\r\n    var init = _BinaryenGlobalGetInitExpr(global);\r\n    if (init) this.visit(init);\r\n    this._currentGlobal = 0;\r\n  }\r\n\r\n  // Utility\r\n\r\n  /** Replaces the current expression with the specified replacement. */\r\n  replaceCurrent(replacement: ExpressionRef): void {\r\n    var search = this.currentExpression;\r\n    var func = this.currentFunction;\r\n    var body = _BinaryenFunctionGetBody(func);\r\n    if (body == search) {\r\n      _BinaryenFunctionSetBody(func, replacement);\r\n    } else {\r\n      var parent = assert(this.parentExpressionOrNull);\r\n      var replaced = replaceChild(parent, search, replacement);\r\n      if (!replaced) throw Error(\"failed to replace expression\");\r\n      _BinaryenExpressionFinalize(parent);\r\n    }\r\n  }\r\n}\r\n\r\n/** Replaces an expression within a parent expression. Returns the replaced expression on success, otherwise `0`. */\r\nexport function replaceChild(\r\n  /** Parent expression containing `search`. */\r\n  parent: ExpressionRef,\r\n  /** Expression to replace. */\r\n  search: ExpressionRef,\r\n  /** Expression to replace `search` with. */\r\n  replacement: ExpressionRef\r\n): ExpressionRef {\r\n  switch (_BinaryenExpressionGetId(parent)) {\r\n    case ExpressionId.Block: {\r\n      let numChildren = _BinaryenBlockGetNumChildren(parent);\r\n      for (let i: Index = 0; i < numChildren; ++i) {\r\n        let child = _BinaryenBlockGetChildAt(parent, i);\r\n        if (child == search) {\r\n          _BinaryenBlockSetChildAt(parent, i, replacement);\r\n          return child;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.If: {\r\n      let condition = _BinaryenIfGetCondition(parent);\r\n      if (condition == search) {\r\n        _BinaryenIfSetCondition(parent, replacement);\r\n        return condition;\r\n      }\r\n      let ifTrue = _BinaryenIfGetIfTrue(parent);\r\n      if (ifTrue == search) {\r\n        _BinaryenIfSetIfTrue(parent, replacement);\r\n        return ifTrue;\r\n      }\r\n      let ifFalse = _BinaryenIfGetIfFalse(parent);\r\n      if (ifFalse == search) {\r\n        _BinaryenIfSetIfFalse(parent, replacement);\r\n        return ifFalse;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Loop: {\r\n      let body = _BinaryenLoopGetBody(parent);\r\n      if (body == search) {\r\n        _BinaryenLoopSetBody(parent, replacement);\r\n        return body;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Break: {\r\n      let condition = _BinaryenBreakGetCondition(parent);\r\n      if (condition == search) {\r\n        _BinaryenBreakSetCondition(parent, replacement);\r\n        return condition;\r\n      }\r\n      let value = _BinaryenBreakGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenBreakSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Switch: {\r\n      let condition = _BinaryenSwitchGetCondition(parent);\r\n      if (condition == search) {\r\n        _BinaryenSwitchSetCondition(parent, replacement);\r\n        return condition;\r\n      }\r\n      let value = _BinaryenSwitchGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenSwitchSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Call: {\r\n      let numOperands = _BinaryenCallGetNumOperands(parent);\r\n      for (let i: Index = 0; i < numOperands; ++i) {\r\n        let operand = _BinaryenCallGetOperandAt(parent, i);\r\n        if (operand == search) {\r\n          _BinaryenCallSetOperandAt(parent, i, replacement);\r\n          return operand;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.CallIndirect: {\r\n      let target = _BinaryenCallIndirectGetTarget(parent);\r\n      if (target == search) {\r\n        _BinaryenCallIndirectSetTarget(parent, replacement);\r\n        return target;\r\n      }\r\n      let numOperands = _BinaryenCallIndirectGetNumOperands(parent);\r\n      for (let i: Index = 0; i < numOperands; ++i) {\r\n        let operand = _BinaryenCallIndirectGetOperandAt(parent, i);\r\n        if (operand == search) {\r\n          _BinaryenCallIndirectSetOperandAt(parent, i, replacement);\r\n          return operand;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.LocalGet: {\r\n      break;\r\n    }\r\n    case ExpressionId.LocalSet: {\r\n      let value = _BinaryenLocalSetGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenLocalSetSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.GlobalGet: {\r\n      break;\r\n    }\r\n    case ExpressionId.GlobalSet: {\r\n      let value = _BinaryenGlobalSetGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenGlobalSetSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Load: {\r\n      let ptr = _BinaryenLoadGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenLoadSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Store: {\r\n      let ptr = _BinaryenStoreGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenStoreSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      let value = _BinaryenStoreGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenStoreSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Const: {\r\n      break;\r\n    }\r\n    case ExpressionId.Unary: {\r\n      let value = _BinaryenUnaryGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenUnarySetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Binary: {\r\n      let left = _BinaryenBinaryGetLeft(parent);\r\n      if (left == search) {\r\n        _BinaryenBinarySetLeft(parent, replacement);\r\n        return left;\r\n      }\r\n      let right = _BinaryenBinaryGetRight(parent);\r\n      if (right == search) {\r\n        _BinaryenBinarySetRight(parent, replacement);\r\n        return right;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Select: {\r\n      let ifTrue = _BinaryenSelectGetIfTrue(parent);\r\n      if (ifTrue == search) {\r\n        _BinaryenSelectSetIfTrue(parent, replacement);\r\n        return ifTrue;\r\n      }\r\n      let ifFalse = _BinaryenSelectGetIfFalse(parent);\r\n      if (ifFalse == search) {\r\n        _BinaryenSelectSetIfFalse(parent, replacement);\r\n        return ifFalse;\r\n      }\r\n      let condition = _BinaryenSelectGetCondition(parent);\r\n      if (condition == search) {\r\n        _BinaryenSelectSetCondition(parent, replacement);\r\n        return condition;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Drop: {\r\n      let value = _BinaryenDropGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenDropSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Return: {\r\n      let value = _BinaryenReturnGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenReturnSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.MemorySize: {\r\n      break;\r\n    }\r\n    case ExpressionId.MemoryGrow: {\r\n      let delta = _BinaryenMemoryGrowGetDelta(parent);\r\n      if (delta == search) {\r\n        _BinaryenMemoryGrowSetDelta(parent, replacement);\r\n        return delta;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Nop: {\r\n      break;\r\n    }\r\n    case ExpressionId.Unreachable: {\r\n      break;\r\n    }\r\n    case ExpressionId.AtomicRMW: {\r\n      let ptr = _BinaryenAtomicRMWGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenAtomicRMWSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      let value = _BinaryenAtomicRMWGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenAtomicRMWSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.AtomicCmpxchg: {\r\n      let ptr = _BinaryenAtomicCmpxchgGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenAtomicCmpxchgSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      let expected = _BinaryenAtomicCmpxchgGetExpected(parent);\r\n      if (expected == search) {\r\n        _BinaryenAtomicCmpxchgSetExpected(parent, replacement);\r\n        return expected;\r\n      }\r\n      let repl = _BinaryenAtomicCmpxchgGetReplacement(parent);\r\n      if (repl == search) {\r\n        _BinaryenAtomicCmpxchgSetReplacement(parent, replacement);\r\n        return repl;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.AtomicWait: {\r\n      let ptr = _BinaryenAtomicWaitGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenAtomicWaitSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      let expected = _BinaryenAtomicWaitGetExpected(parent);\r\n      if (expected == search) {\r\n        _BinaryenAtomicWaitSetExpected(parent, replacement);\r\n        return expected;\r\n      }\r\n      let timeout = _BinaryenAtomicWaitGetTimeout(parent);\r\n      if (timeout == search) {\r\n        _BinaryenAtomicWaitSetTimeout(parent, replacement);\r\n        return timeout;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.AtomicNotify: {\r\n      let ptr = _BinaryenAtomicNotifyGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenAtomicNotifySetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      let notifyCount = _BinaryenAtomicNotifyGetNotifyCount(parent);\r\n      if (notifyCount == search) {\r\n        _BinaryenAtomicNotifySetNotifyCount(parent, replacement);\r\n        return notifyCount;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.AtomicFence: {\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDExtract: {\r\n      let vec = _BinaryenSIMDExtractGetVec(parent);\r\n      if (vec == search) {\r\n        _BinaryenSIMDExtractSetVec(parent, replacement);\r\n        return vec;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDReplace: {\r\n      let vec = _BinaryenSIMDReplaceGetVec(parent);\r\n      if (vec == search) {\r\n        _BinaryenSIMDReplaceSetVec(parent, replacement);\r\n        return vec;\r\n      }\r\n      let value = _BinaryenSIMDReplaceGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenSIMDReplaceSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDShuffle: {\r\n      let left = _BinaryenSIMDShuffleGetLeft(parent);\r\n      if (left == search) {\r\n        _BinaryenSIMDShuffleSetLeft(parent, replacement);\r\n        return left;\r\n      }\r\n      let right = _BinaryenSIMDShuffleGetRight(parent);\r\n      if (right == search) {\r\n        _BinaryenSIMDShuffleSetRight(parent, replacement);\r\n        return right;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDTernary: {\r\n      let a = _BinaryenSIMDTernaryGetA(parent);\r\n      if (a == search) {\r\n        _BinaryenSIMDTernarySetA(parent, replacement);\r\n        return a;\r\n      }\r\n      let b = _BinaryenSIMDTernaryGetB(parent);\r\n      if (b == search) {\r\n        _BinaryenSIMDTernarySetB(parent, replacement);\r\n        return b;\r\n      }\r\n      let c = _BinaryenSIMDTernaryGetC(parent);\r\n      if (c == search) {\r\n        _BinaryenSIMDTernarySetC(parent, replacement);\r\n        return c;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDShift: {\r\n      let vec = _BinaryenSIMDShiftGetVec(parent);\r\n      if (vec == search) {\r\n        _BinaryenSIMDShiftSetVec(parent, replacement);\r\n        return vec;\r\n      }\r\n      let shift = _BinaryenSIMDShiftGetShift(parent);\r\n      if (shift == search) {\r\n        _BinaryenSIMDShiftSetShift(parent, replacement);\r\n        return shift;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDLoad: {\r\n      let ptr = _BinaryenSIMDLoadGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenSIMDLoadSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.SIMDLoadStoreLane: {\r\n      let ptr = _BinaryenSIMDLoadStoreLaneGetPtr(parent);\r\n      if (ptr == search) {\r\n        _BinaryenSIMDLoadStoreLaneSetPtr(parent, replacement);\r\n        return ptr;\r\n      }\r\n      let vec = _BinaryenSIMDLoadStoreLaneGetVec(parent);\r\n      if (vec == search) {\r\n        _BinaryenSIMDLoadStoreLaneSetVec(parent, replacement);\r\n        return ptr;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.MemoryInit: {\r\n      let dest = _BinaryenMemoryInitGetDest(parent);\r\n      if (dest == search) {\r\n        _BinaryenMemoryInitSetDest(parent, replacement);\r\n        return dest;\r\n      }\r\n      let offset = _BinaryenMemoryInitGetOffset(parent);\r\n      if (offset == search) {\r\n        _BinaryenMemoryInitSetOffset(parent, replacement);\r\n        return offset;\r\n      }\r\n      let size = _BinaryenMemoryInitGetSize(parent);\r\n      if (size == search) {\r\n        _BinaryenMemoryInitSetSize(parent, replacement);\r\n        return size;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.DataDrop: {\r\n      break;\r\n    }\r\n    case ExpressionId.MemoryCopy: {\r\n      let dest = _BinaryenMemoryCopyGetDest(parent);\r\n      if (dest == search) {\r\n        _BinaryenMemoryCopySetDest(parent, replacement);\r\n        return dest;\r\n      }\r\n      let source = _BinaryenMemoryCopyGetSource(parent);\r\n      if (source == search) {\r\n        _BinaryenMemoryCopySetSource(parent, replacement);\r\n        return source;\r\n      }\r\n      let size = _BinaryenMemoryCopyGetSize(parent);\r\n      if (size == search) {\r\n        _BinaryenMemoryCopySetSize(parent, replacement);\r\n        return size;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.MemoryFill: {\r\n      let dest = _BinaryenMemoryFillGetDest(parent);\r\n      if (dest == search) {\r\n        _BinaryenMemoryFillSetDest(parent, replacement);\r\n        return dest;\r\n      }\r\n      let value = _BinaryenMemoryFillGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenMemoryFillSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      let size = _BinaryenMemoryFillGetSize(parent);\r\n      if (size == search) {\r\n        _BinaryenMemoryFillSetSize(parent, replacement);\r\n        return size;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Pop: {\r\n      break;\r\n    }\r\n    case ExpressionId.RefNull: {\r\n      break;\r\n    }\r\n    case ExpressionId.RefIs: {\r\n      let value = _BinaryenRefIsGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenRefIsSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.RefFunc: {\r\n      break;\r\n    }\r\n    case ExpressionId.RefEq: {\r\n      let left = _BinaryenRefEqGetLeft(parent);\r\n      if (left == search) {\r\n        _BinaryenRefEqSetLeft(parent, replacement);\r\n        return left;\r\n      }\r\n      let right = _BinaryenRefEqGetRight(parent);\r\n      if (right == search) {\r\n        _BinaryenRefEqSetRight(parent, replacement);\r\n        return right;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Try: {\r\n      let body = _BinaryenTryGetBody(parent);\r\n      if (body == search) {\r\n        _BinaryenTrySetBody(parent, replacement);\r\n        return body;\r\n      }\r\n      let numCatchBodies = _BinaryenTryGetNumCatchBodies(parent);\r\n      for (let i: Index = 0; i < numCatchBodies; ++i) {\r\n        let catchBody = _BinaryenTryGetCatchBodyAt(parent, i);\r\n        if (catchBody == search) {\r\n          _BinaryenTrySetCatchBodyAt(parent, i, replacement);\r\n          return catchBody;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Throw: {\r\n      let numOperands = _BinaryenThrowGetNumOperands(parent);\r\n      for (let i: Index = 0; i < numOperands; ++i) {\r\n        let operand = _BinaryenThrowGetOperandAt(parent, i);\r\n        if (operand == search) {\r\n          _BinaryenThrowSetOperandAt(parent, i, replacement);\r\n          return operand;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.Rethrow: {\r\n      break;\r\n    }\r\n    case ExpressionId.TupleMake: {\r\n      let numOperands = _BinaryenTupleMakeGetNumOperands(parent);\r\n      for (let i: Index = 0; i < numOperands; ++i) {\r\n        let operand = _BinaryenTupleMakeGetOperandAt(parent, i);\r\n        if (operand == search) {\r\n          _BinaryenTupleMakeSetOperandAt(parent, i, replacement);\r\n          return operand;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.TupleExtract: {\r\n      let tuple = _BinaryenTupleExtractGetTuple(parent);\r\n      if (tuple == search) {\r\n        _BinaryenTupleExtractSetTuple(parent, replacement);\r\n        return tuple;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.I31New: {\r\n      let value = _BinaryenI31NewGetValue(parent);\r\n      if (value == search) {\r\n        _BinaryenI31NewSetValue(parent, replacement);\r\n        return value;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.I31Get: {\r\n      let i31Expr = _BinaryenI31GetGetI31(parent);\r\n      if (i31Expr == search) {\r\n        _BinaryenI31GetSetI31(parent, replacement);\r\n        return i31Expr;\r\n      }\r\n      break;\r\n    }\r\n    case ExpressionId.CallRef: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.RefTest: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.RefCast: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.BrOn: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.RttCanon: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.RttSub: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.StructNew: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.StructGet: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.StructSet: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.ArrayNew: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.ArrayGet: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.ArraySet: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.ArrayLen: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    case ExpressionId.RefAs: {\r\n      assert(false); // TODO\r\n      break;\r\n    }\r\n    default: throw new Error(\"unexpected expression id\");\r\n  }\r\n  return 0;\r\n}\r\n","/**\r\n * @fileoverview A lightweight store instrumentation pass.\r\n * \r\n * Can be used to find rogue stores to protected memory addresses like object\r\n * headers or similar, without going overboard with instrumentation. Also\r\n * passes a flag whether a store originates within the runtime or other code.\r\n * \r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Pass\r\n} from \"./pass\";\r\n\r\nimport {\r\n  Compiler\r\n} from \"../compiler\";\r\n\r\nimport {\r\n  createType,\r\n  ExpressionRef,\r\n  TypeRef\r\n} from \"../module\";\r\n\r\nimport {\r\n  _BinaryenFunctionGetName,\r\n  _BinaryenStoreGetBytes,\r\n  _BinaryenStoreGetOffset,\r\n  _BinaryenStoreGetPtr,\r\n  _BinaryenStoreSetPtr\r\n} from \"../glue/binaryen\";\r\n\r\n/** Instruments stores to also call an import. */\r\nexport class RtraceMemory extends Pass {\r\n  /** Whether we've seen any stores. */\r\n  seenStores: bool = false;\r\n  /** Target pointer type. */\r\n  ptrType: TypeRef;\r\n\r\n  constructor(compiler: Compiler) {\r\n    super(compiler.module);\r\n    this.ptrType = compiler.options.sizeTypeRef;\r\n  }\r\n\r\n  checkRT(): bool {\r\n    var functionName = this.module.readStringCached(_BinaryenFunctionGetName(this.currentFunction))!;\r\n    return functionName.startsWith(\"~lib/rt/\");\r\n  }\r\n\r\n  /** @override */\r\n  visitStore(store: ExpressionRef): void {\r\n    var module = this.module;\r\n    var ptr = _BinaryenStoreGetPtr(store);\r\n    var offset = _BinaryenStoreGetOffset(store);\r\n    var bytes = _BinaryenStoreGetBytes(store);\r\n    // onstore(ptr: usize, offset: i32, bytes: i32, isRT: bool) -> ptr\r\n    _BinaryenStoreSetPtr(store,\r\n      module.call(\"~onstore\", [\r\n        ptr,\r\n        module.i32(offset),\r\n        module.i32(bytes),\r\n        module.i32(i32(this.checkRT()))\r\n      ], this.ptrType)\r\n    );\r\n    this.seenStores = true;\r\n  }\r\n\r\n  // TODO: MemoryFill, Atomics\r\n\r\n  /** @override */\r\n  walkModule(): void {\r\n    super.walkModule();\r\n    if (this.seenStores) {\r\n      this.module.addFunctionImport(\"~onstore\", \"rtrace\", \"onstore\",\r\n        createType([ this.ptrType, TypeRef.I32, TypeRef.I32, TypeRef.I32 ]),\r\n        this.ptrType\r\n      );\r\n    }\r\n  }\r\n}\r\n","/**\r\n * @fileoverview Shadow stack instrumentation for a precise GC.\r\n * \r\n * Instruments function arguments and local assignments marked with a 'tostack'\r\n * call to also do stores to a shadow stack of managed values only.\r\n * \r\n * Consider a simple call to a function looking like the following, taking\r\n * managed arguments, plus assigning managed values to locals:\r\n * \r\n *   function foo(a: Obj, b: Obj): Obj {\r\n *     var c = __tostack(a) // slot 2\r\n *     __collect()\r\n *     return b\r\n *   }\r\n *   \r\n *   foo(__tostack(a), __tostack(b)) // slot 0, 1\r\n * \r\n * At the call to `__collect()` the 32-bit stack frame of the function is:\r\n * \r\n *   Offset | Value stored\r\n *   -------|----------------------------\r\n *      0   | First managed argument 'a'\r\n *      4   | Second managed argument 'b'\r\n *   -------|----------------------------\r\n *      8   | First managed local 'c'\r\n * \r\n * We are splitting the frame in two halves as annotated since both halves are\r\n * only known separately for indirect calls, with the first half becoming an\r\n * extension of the calling function's stack frame by means of treating the\r\n * arguments as if these were locals beyond the caller's `numLocals`. Function\r\n * arguments stay a bit longer on the stack than usually, but we also don't have\r\n * to modify the stack pointer pre-call at all this way. The caller's amended\r\n * stack frame when assuming one managed local may look like this:\r\n * \r\n *   Offset | Value stored\r\n *   -------|----------------------------\r\n *      0   | First managed local '?'\r\n *      4   | Extended with first managed argument 'a'\r\n *      8   | Extended with second managed argument 'b'\r\n * \r\n * with the callee's stack frame becoming just:\r\n * \r\n *   Offset | Value stored\r\n *   -------|----------------------------\r\n *      0   | First managed local 'c'\r\n * \r\n * Instrumentation added below looks about like the following, with the stack\r\n * growing downwards and 't' and 'r' being new temporary locals:\r\n * \r\n *   // callee frameSize = 1 * sizeof<usize>()\r\n *   function foo(a: usize, b: usize): usize {\r\n *     memory.fill(__stack_pointer -= frameSize, 0, frameSize)\r\n *     store<usize>(__stack_pointer, c = a, 0 * sizeof<usize>())\r\n *     __collect()\r\n *     var r = b\r\n *     __stack_pointer += frameSize\r\n *     return r\r\n *   }\r\n * \r\n *   // caller frameSize = (numLocalSlots + 2 [by extension]) * sizeof<usize>()\r\n *   (\r\n *     r = foo(\r\n *       ( t = a,\r\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 0) * sizeof<usize>()),\r\n *         t ),\r\n *       ( t = b,\r\n *         store<usize>(__stack_pointer, t, (numLocalSlots + 1) * sizeof<usize>()),\r\n *         t )\r\n *     ),\r\n *     r\r\n *   )\r\n * \r\n * Also note that we have to `memory.fill` the second half because the first\r\n * assignment to a local may happen at a later point within the function. The\r\n * invariant we need to maintain for a precise GC is that it only sees zeroes\r\n * or valid pointers, but never an invalid pointer left on the stack earlier.\r\n * Since most frames are small, we unroll a sequence of `store`s up to a frame\r\n * size of 16 bytes, and `memory.fill`, if available, beyond.\r\n * \r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Pass\r\n} from \"./pass\";\r\n\r\nimport {\r\n  _BinaryenAddFunction,\r\n  _BinaryenAddFunctionExport,\r\n  _BinaryenCallGetNumOperands,\r\n  _BinaryenCallGetOperandAt,\r\n  _BinaryenCallGetTarget,\r\n  _BinaryenCallIndirectGetNumOperands,\r\n  _BinaryenCallIndirectGetOperandAt,\r\n  _BinaryenCallIndirectSetOperandAt,\r\n  _BinaryenCallSetOperandAt,\r\n  _BinaryenExportGetKind,\r\n  _BinaryenExportGetName,\r\n  _BinaryenExportGetValue,\r\n  _BinaryenExpressionGetId,\r\n  _BinaryenExpressionGetType,\r\n  _BinaryenFunctionGetBody,\r\n  _BinaryenFunctionGetName,\r\n  _BinaryenFunctionGetNumLocals,\r\n  _BinaryenFunctionGetNumVars,\r\n  _BinaryenFunctionGetParams,\r\n  _BinaryenFunctionGetResults,\r\n  _BinaryenFunctionGetVar,\r\n  _BinaryenFunctionSetBody,\r\n  _BinaryenGetExport,\r\n  _BinaryenGetFunction,\r\n  _BinaryenLocalSetGetIndex,\r\n  _BinaryenLocalSetGetValue,\r\n  _BinaryenLocalSetIsTee,\r\n  _BinaryenLocalSetSetValue,\r\n  _BinaryenRemoveExport,\r\n  _BinaryenRemoveFunction,\r\n  _BinaryenReturnGetValue,\r\n  _BinaryenReturnSetValue,\r\n  _free\r\n} from \"../glue/binaryen\";\r\n\r\nimport {\r\n  ExpressionId,\r\n  ExpressionRef,\r\n  FunctionRef,\r\n  Index,\r\n  BinaryOp,\r\n  TypeRef,\r\n  allocPtrArray,\r\n  Module,\r\n  ExternalKind,\r\n  ExportRef,\r\n  expandType,\r\n  isConstZero\r\n} from \"../module\";\r\n\r\nimport {\r\n  Compiler,\r\n  Options\r\n} from \"../compiler\";\r\n\r\nimport {\r\n  Feature\r\n} from \"../common\";\r\n\r\nimport {\r\n  BuiltinNames\r\n} from \"../builtins\";\r\n\r\ntype LocalIndex = Index;\r\ntype SlotIndex = Index;\r\ntype SlotMap = Map<LocalIndex,SlotIndex>;\r\ntype TempMap = Map<TypeRef,LocalIndex>;\r\n\r\n/** Attempts to match the `__tostack(value)` pattern. Returns `value` if a match, otherwise `0`.  */\r\nfunction matchPattern(module: Module, expr: ExpressionRef): ExpressionRef {\r\n  if (_BinaryenExpressionGetId(expr) == ExpressionId.Call && module.readStringCached(_BinaryenCallGetTarget(expr)) == BuiltinNames.tostack) {\r\n    assert(_BinaryenCallGetNumOperands(expr) == 1);\r\n    return _BinaryenCallGetOperandAt(expr, 0);\r\n  }\r\n  return 0;\r\n}\r\n\r\n/** Tests whether a `value` matched by `matchTostack` needs a slot. */\r\nfunction needsSlot(module: Module, value: ExpressionRef): bool {\r\n  switch (_BinaryenExpressionGetId(value)) {\r\n    // no need to stack null pointers\r\n    case ExpressionId.Const: return !isConstZero(value);\r\n    // already kept in another slot\r\n    case ExpressionId.LocalGet:\r\n    case ExpressionId.LocalSet: return false; // tee\r\n  }\r\n  return true;\r\n}\r\n\r\n/** Instruments a module with a shadow stack for precise GC. */\r\nexport class ShadowStackPass extends Pass {\r\n  /** Stack frame slots, per function. */\r\n  slotMaps: Map<FunctionRef, SlotMap> = new Map();\r\n  /** Temporary locals, per function. */\r\n  tempMaps: Map<FunctionRef, TempMap> = new Map();\r\n  /** Exports (with managed operands) map. */\r\n  exportMap: Map<string,i32[]> = new Map();\r\n  /** Compiler reference. */\r\n  compiler: Compiler;\r\n\r\n  constructor(compiler: Compiler) {\r\n    super(compiler.module);\r\n    this.compiler = compiler;\r\n  }\r\n\r\n  /** Compiler options. */\r\n  get options(): Options { return this.compiler.options; }\r\n  /** Target pointer type. */\r\n  get ptrType(): TypeRef { return this.options.sizeTypeRef; }\r\n  /** Target pointer size. */\r\n  get ptrSize(): i32 { return this.ptrType == TypeRef.I64 ? 8 : 4; }\r\n  /** Target pointer addition operation. */\r\n  get ptrBinaryAdd(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.AddI64 : BinaryOp.AddI32; }\r\n  /** Target pointer subtraction operation. */\r\n  get ptrBinarySub(): BinaryOp { return this.ptrType == TypeRef.I64 ? BinaryOp.SubI64 : BinaryOp.SubI32; }\r\n\r\n  /** Gets a constant with the specified value of the target pointer type. */\r\n  ptrConst(value: i32): ExpressionRef {\r\n    return this.ptrType == TypeRef.I64\r\n      ? this.module.i64(value)\r\n      : this.module.i32(value);\r\n  }\r\n\r\n  /** Notes the presence of a slot for the specified (imaginary) local, returning the slot index. */\r\n  noteSlot(func: FunctionRef, localIndex: Index): i32 {\r\n    let slotMap: SlotMap;\r\n    if (this.slotMaps.has(func)) {\r\n      slotMap = changetype<SlotMap>(this.slotMaps.get(func));\r\n      if (slotMap.has(localIndex)) {\r\n        return changetype<i32>(slotMap.get(localIndex));\r\n      }\r\n    } else {\r\n      slotMap = new Map();\r\n      this.slotMaps.set(func, slotMap);\r\n    }\r\n    let slotIndex = slotMap.size;\r\n    slotMap.set(localIndex, slotIndex);\r\n    return slotIndex;\r\n  }\r\n\r\n  /** Notes the presence of an exported function taking managed operands. */\r\n  noteExport(name: string, managedOperandIndices: i32[]): void {\r\n    if (!managedOperandIndices.length) return;\r\n    this.exportMap.set(name, managedOperandIndices);\r\n  }\r\n\r\n  /** Gets a shared temporary local of the given type in the specified functions. */\r\n  getSharedTemp(func: FunctionRef, type: TypeRef): Index {\r\n    let tempMap: TempMap;\r\n    if (this.tempMaps.has(func)) {\r\n      tempMap = changetype<TempMap>(this.tempMaps.get(func));\r\n      if (tempMap.has(type)) {\r\n        return changetype<Index>(tempMap.get(type));\r\n      }\r\n    } else {\r\n      tempMap = new Map();\r\n      this.tempMaps.set(func, tempMap);\r\n    }\r\n    let numLocals = _BinaryenFunctionGetNumLocals(func);\r\n    let localIndex = numLocals + tempMap.size;\r\n    tempMap.set(type, localIndex);\r\n    return localIndex;\r\n  }\r\n\r\n  /** Makes an expression modifying the stack pointer by the given offset. */\r\n  makeStackOffset(offset: i32): ExpressionRef {\r\n    assert(offset != 0);\r\n    var module = this.module;\r\n    var expr = module.global_set(BuiltinNames.stack_pointer,\r\n      module.binary(offset >= 0 ? this.ptrBinaryAdd : this.ptrBinarySub,\r\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n        this.ptrConst(abs(offset))\r\n      )\r\n    );\r\n    if (offset > 0) return expr;\r\n    return module.block(null, [\r\n      expr,\r\n      this.makeStackCheck()\r\n    ], TypeRef.None);\r\n  }\r\n\r\n  /** Makes a sequence of expressions zeroing the stack frame. */\r\n  makeStackFill(frameSize: i32, stmts: ExpressionRef[]): void {\r\n    assert(frameSize > 0);\r\n    var module = this.module;\r\n    if (this.options.hasFeature(Feature.BULK_MEMORY) && frameSize > 16) {\r\n      stmts.push(\r\n        module.memory_fill(\r\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n          module.i32(0), // TODO: Wasm64 also i32?\r\n          this.ptrConst(frameSize)\r\n        )\r\n      );\r\n    } else {\r\n      let remain = frameSize;\r\n      while (remain >= 8) {\r\n        // store<i64>(__stack_pointer, 0, frameSize - remain)\r\n        stmts.push(\r\n          module.store(8,\r\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n            module.i64(0),\r\n            TypeRef.I64,\r\n            frameSize - remain\r\n          )\r\n        );\r\n        remain -= 8;\r\n      }\r\n      if (remain) {\r\n        assert(remain == 4);\r\n        // store<i32>(__stack_pointer, 0, frameSize - remain)\r\n        stmts.push(\r\n          module.store(4,\r\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n            module.i32(0),\r\n            TypeRef.I32,\r\n            frameSize - remain\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private hasStackCheckFunction: bool = false;\r\n\r\n  /** Makes a check that the current stack pointer is valid. */\r\n  makeStackCheck(): ExpressionRef {\r\n    var module = this.module;\r\n    if (!this.hasStackCheckFunction) {\r\n      this.hasStackCheckFunction = true;\r\n      module.addFunction(\"~stack_check\", TypeRef.None, TypeRef.None, null,\r\n        module.if(\r\n          module.binary(BinaryOp.LtI32,\r\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n            module.global_get(BuiltinNames.data_end, this.ptrType)\r\n          ),\r\n          this.compiler.makeStaticAbort(this.compiler.ensureStaticString(\"stack overflow\"), this.compiler.program.nativeSource)\r\n        )\r\n      );\r\n    }\r\n    return module.call(\"~stack_check\", null, TypeRef.None);\r\n  }\r\n\r\n  private updateCallOperands(operands: ExpressionRef[]): i32 {\r\n    var module = this.module;\r\n    var numSlots = 0;\r\n    for (let i = 0, k = operands.length; i < k; ++i) {\r\n      let operand = operands[i];\r\n      let match = matchPattern(module, operand);\r\n      if (!match) continue;\r\n      if (!needsSlot(module, match)) {\r\n        operands[i] = match;\r\n        continue;\r\n      }\r\n      let currentFunction = this.currentFunction;\r\n      let numLocals = _BinaryenFunctionGetNumLocals(currentFunction);\r\n      let slotIndex = this.noteSlot(currentFunction, numLocals + this.callSlotOffset + i);\r\n      let temp = this.getSharedTemp(currentFunction, this.ptrType);\r\n      let stmts = new Array<ExpressionRef>();\r\n      // t = value\r\n      stmts.push(\r\n        module.local_set(temp, match, false)\r\n      );\r\n      // store<usize>(__stack_pointer, t, slotIndex * ptrSize)\r\n      stmts.push(\r\n        module.store(this.ptrSize,\r\n          module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n          module.local_get(temp, this.ptrType),\r\n          this.ptrType, slotIndex * this.ptrSize\r\n        )\r\n      );\r\n      // -> t\r\n      stmts.push(\r\n        module.local_get(temp, this.ptrType)\r\n      );\r\n      operands[i] = module.block(null, stmts, this.ptrType);\r\n      ++numSlots;\r\n    }\r\n    return numSlots;\r\n  }\r\n\r\n  /** Slot offset accounting for nested calls. */\r\n  private callSlotOffset: i32 = 0;\r\n  /** Slot offset stack in nested calls. */\r\n  private callSlotStack: i32[] = new Array();\r\n\r\n  /** @override */\r\n  visitCallPre(call: ExpressionRef): void {\r\n    var numOperands = _BinaryenCallGetNumOperands(call);\r\n    var operands = new Array<ExpressionRef>(numOperands);\r\n    for (let i: Index = 0; i < numOperands; ++i) {\r\n      operands[i] = _BinaryenCallGetOperandAt(call, i);\r\n    }\r\n    let numSlots = this.updateCallOperands(operands);\r\n    for (let i = 0, k = operands.length; i < k; ++i) {\r\n      _BinaryenCallSetOperandAt(call, i, operands[i]);\r\n    }\r\n    if (numSlots) {\r\n      // Reserve these slots for us so nested calls use their own\r\n      this.callSlotOffset += numSlots;\r\n    }\r\n    this.callSlotStack.push(numSlots);\r\n  }\r\n\r\n  /** @override */\r\n  visitCall(call: ExpressionRef): void {\r\n    let numSlots = this.callSlotStack.pop();\r\n    if (numSlots) this.callSlotOffset -= numSlots;\r\n  }\r\n\r\n  /** @override */\r\n  visitCallIndirectPre(callIndirect: ExpressionRef): void {\r\n    let numOperands = _BinaryenCallIndirectGetNumOperands(callIndirect);\r\n    let operands = new Array<ExpressionRef>(numOperands);\r\n    for (let i: Index = 0; i < numOperands; ++i) {\r\n      operands[i] = _BinaryenCallIndirectGetOperandAt(callIndirect, i);\r\n    }\r\n    let numSlots = this.updateCallOperands(operands);\r\n    for (let i = 0, k = operands.length; i < k; ++i) {\r\n      _BinaryenCallIndirectSetOperandAt(callIndirect, i, operands[i]);\r\n    }\r\n    if (numSlots) {\r\n      // Reserve these slots for us so nested calls use their own\r\n      this.callSlotOffset += numSlots;\r\n    }\r\n    this.callSlotStack.push(numSlots);\r\n  }\r\n\r\n  /** @override */\r\n  visitCallIndirect(callIndirect: ExpressionRef): void {\r\n    let numSlots = this.callSlotStack.pop();\r\n    if (numSlots) this.callSlotOffset -= numSlots;\r\n  }\r\n\r\n  /** @override */\r\n  visitLocalSet(localSet: ExpressionRef): void {\r\n    let module = this.module;\r\n    let value = _BinaryenLocalSetGetValue(localSet);\r\n    let match = matchPattern(module, value);\r\n    if (!match) return;\r\n    if (!needsSlot(module, match)) {\r\n      _BinaryenLocalSetSetValue(localSet, match);\r\n      return;\r\n    }\r\n    let index = _BinaryenLocalSetGetIndex(localSet);\r\n    let slotIndex = this.noteSlot(this.currentFunction, index);\r\n    let stmts = new Array<ExpressionRef>();\r\n    // store<usize>(__stack_pointer, local = match, slotIndex * ptrSize)\r\n    stmts.push(\r\n      module.store(this.ptrSize,\r\n        module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n        module.local_tee(index, match, false),\r\n        this.ptrType, slotIndex * this.ptrSize\r\n      )\r\n    );\r\n    if (_BinaryenLocalSetIsTee(localSet)) {\r\n      // -> local\r\n      stmts.push(\r\n        module.local_get(index, this.ptrType)\r\n      );\r\n      this.replaceCurrent(module.flatten(stmts, this.ptrType));\r\n    } else {\r\n      this.replaceCurrent(module.flatten(stmts, TypeRef.None));\r\n    }\r\n  }\r\n\r\n  /** Updates a function with additional locals etc. */\r\n  updateFunction(funcRef: FunctionRef): void {\r\n    let name = _BinaryenFunctionGetName(funcRef);\r\n    let params = _BinaryenFunctionGetParams(funcRef);\r\n    let results = _BinaryenFunctionGetResults(funcRef);\r\n    let body = assert(_BinaryenFunctionGetBody(funcRef));\r\n    let numVars = _BinaryenFunctionGetNumVars(funcRef);\r\n    let vars = new Array<TypeRef>();\r\n    for (let i: Index = 0; i < numVars; ++i) {\r\n      vars[i] = _BinaryenFunctionGetVar(funcRef, i);\r\n    }\r\n    let tempMaps = this.tempMaps;\r\n    if (tempMaps.has(funcRef)) {\r\n      let tempMap = changetype<TempMap>(tempMaps.get(funcRef));\r\n      for (let _keys = Map_keys(tempMap), i = 0, k = _keys.length; i < k; ++i) {\r\n        vars.push(_keys[i]);\r\n      }\r\n    }\r\n    let moduleRef = this.module.ref;\r\n    _BinaryenRemoveFunction(moduleRef, name);\r\n    let cArr = allocPtrArray(vars);\r\n    _BinaryenAddFunction(moduleRef, name, params, results, cArr, vars.length, body);\r\n    _free(cArr);\r\n  }\r\n\r\n  /** Updates a function export taking managed arguments. */\r\n  updateExport(exportRef: ExportRef, managedOperandIndices: i32[]): void {\r\n    var module = this.module;\r\n    var moduleRef = module.ref;\r\n    assert(_BinaryenExportGetKind(exportRef) == ExternalKind.Function);\r\n\r\n    var internalNameRef = _BinaryenExportGetValue(exportRef);\r\n    var internalName = module.readStringCached(internalNameRef)!;\r\n    var externalNameRef = _BinaryenExportGetName(exportRef);\r\n    var funcRef = _BinaryenGetFunction(moduleRef, internalNameRef);\r\n    var params = _BinaryenFunctionGetParams(funcRef);\r\n    var paramTypes = expandType(params);\r\n    var numParams = paramTypes.length;\r\n    var results = _BinaryenFunctionGetResults(funcRef);\r\n    var numLocals = numParams;\r\n    var vars = new Array<TypeRef>();\r\n    var numSlots = assert(managedOperandIndices.length);\r\n    var frameSize = numSlots * this.ptrSize;\r\n    var wrapperName = \"export:\" + internalName;\r\n    var wrapperNameRef = module.allocStringCached(wrapperName);\r\n\r\n    if (_BinaryenGetFunction(moduleRef, wrapperNameRef) == 0) {\r\n      let stmts = new Array<ExpressionRef>();\r\n      // __stack_pointer -= frameSize\r\n      stmts.push(\r\n        this.makeStackOffset(-frameSize)\r\n      );\r\n      for (let slotIndex = 0; slotIndex < numSlots; ++slotIndex) {\r\n        // store<usize>(__stack_pointer, $local, slotIndex * ptrSize)\r\n        stmts.push(\r\n          module.store(this.ptrSize,\r\n            module.global_get(BuiltinNames.stack_pointer, this.ptrType),\r\n            module.local_get(managedOperandIndices[slotIndex], this.ptrType),\r\n            this.ptrType, slotIndex * this.ptrSize\r\n          )\r\n        );\r\n      }\r\n      let forwardedOperands = new Array<ExpressionRef>(numParams);\r\n      for (let i = 0; i < numParams; ++i) {\r\n        forwardedOperands[i] = module.local_get(i, paramTypes[i]);\r\n      }\r\n      if (results != TypeRef.None) {\r\n        let tempIndex = numLocals++;\r\n        vars.push(results);\r\n        // t = original(...)\r\n        stmts.push(\r\n          module.local_set(tempIndex,\r\n            module.call(internalName, forwardedOperands, results),\r\n            false // internal\r\n          )\r\n        );\r\n        // __stack_pointer += frameSize\r\n        stmts.push(\r\n          this.makeStackOffset(+frameSize)\r\n        );\r\n        // -> t\r\n        stmts.push(\r\n          module.local_get(tempIndex, results)\r\n        );\r\n      } else {\r\n        // original(...)\r\n        stmts.push(\r\n          module.call(internalName, forwardedOperands, results)\r\n        );\r\n        // __stack_pointer += frameSize\r\n        stmts.push(\r\n          this.makeStackOffset(+frameSize)\r\n        );\r\n      }\r\n      let cArr = allocPtrArray(vars);\r\n      _BinaryenAddFunction(moduleRef, wrapperNameRef, params, results, cArr, vars.length,\r\n        module.block(null, stmts, results)\r\n      );\r\n      _free(cArr);\r\n    }\r\n    _BinaryenRemoveExport(moduleRef, externalNameRef);\r\n    _BinaryenAddFunctionExport(moduleRef, wrapperNameRef, externalNameRef);\r\n  }\r\n\r\n  /** @override */\r\n  walkModule(): void {\r\n    // Run the pass normally\r\n    super.walkModule();\r\n\r\n    // Instrument returns in functions utilizing stack slots\r\n    var module = this.module;\r\n    var instrumentReturns = new InstrumentReturns(this);\r\n    for (let _keys = Map_keys(this.slotMaps), i = 0, k = _keys.length; i < k; ++i) {\r\n      let func = _keys[i];\r\n      let slotMap = changetype<SlotMap>(this.slotMaps.get(func));\r\n      let frameSize = slotMap.size * this.ptrSize;\r\n\r\n      // Instrument function returns\r\n      instrumentReturns.frameSize = frameSize;\r\n      instrumentReturns.walkFunction(func);\r\n\r\n      // Instrument function entry\r\n      let stmts = new Array<ExpressionRef>();\r\n      // __stack_pointer -= frameSize\r\n      stmts.push(\r\n        this.makeStackOffset(-frameSize)\r\n      );\r\n      // memory.fill(__stack_pointer, 0, frameSize)\r\n      this.makeStackFill(frameSize, stmts);\r\n      \r\n      // Handle implicit return\r\n      let body = _BinaryenFunctionGetBody(func);\r\n      let bodyType = _BinaryenExpressionGetType(body);\r\n      if (bodyType == TypeRef.Unreachable) {\r\n        // body\r\n        stmts.push(\r\n          body\r\n        );\r\n      } else if (bodyType == TypeRef.None) {\r\n        // body\r\n        stmts.push(\r\n          body\r\n        );\r\n        // __stack_pointer += frameSize\r\n        stmts.push(\r\n          this.makeStackOffset(+frameSize)\r\n        );\r\n      } else {\r\n        let temp = this.getSharedTemp(func, bodyType);\r\n        // t = body\r\n        stmts.push(\r\n          module.local_set(temp, body, false)\r\n        );\r\n        // __stack_pointer += frameSize\r\n        stmts.push(\r\n          this.makeStackOffset(+frameSize)\r\n        );\r\n        // -> t\r\n        stmts.push(\r\n          module.local_get(temp, bodyType)\r\n        );\r\n      }\r\n      _BinaryenFunctionSetBody(func, module.flatten(stmts, bodyType));\r\n    }\r\n\r\n    // Update functions we added more locals to\r\n    // TODO: _BinaryenFunctionAddVar ?\r\n    for (let _keys = Map_keys(this.tempMaps), i = 0, k = _keys.length; i < k; ++i) {\r\n      this.updateFunction(_keys[i]);\r\n    }\r\n\r\n    // Update exports taking managed arguments\r\n    var exportMap = this.exportMap;\r\n    for (let _keys = Map_keys(exportMap), i = 0, k = _keys.length; i < k; ++i) {\r\n      let exportName = _keys[i];\r\n      let exportRef = _BinaryenGetExport(module.ref, module.allocStringCached(exportName));\r\n      let managedOperandIndices = changetype<i32[]>(exportMap.get(exportName));\r\n      this.updateExport(exportRef, managedOperandIndices);\r\n    }\r\n  }\r\n}\r\n\r\n/** Companion pass instrumenting `return` statements to restore the stack frame. */\r\nclass InstrumentReturns extends Pass {\r\n  /** Parent pass. */\r\n  parentPass: ShadowStackPass;\r\n  /** Frame size of the current function being processed. */\r\n  frameSize: i32 = 0;\r\n\r\n  constructor(shadowStack: ShadowStackPass) {\r\n    super(shadowStack.module);\r\n    this.parentPass = shadowStack;\r\n  }\r\n\r\n  /** @override */\r\n  visitReturn(ret: ExpressionRef): void {\r\n    assert(this.frameSize);\r\n    var module = this.module;\r\n    var value = _BinaryenReturnGetValue(ret);\r\n    var stmts = new Array<ExpressionRef>();\r\n    if (value) {\r\n      let returnType = _BinaryenExpressionGetType(value);\r\n      let temp = this.parentPass.getSharedTemp(this.currentFunction, returnType);\r\n      // t = value\r\n      stmts.push(\r\n        module.local_set(temp, value, false)\r\n      );\r\n      // __stack_pointer += frameSize\r\n      stmts.push(\r\n        this.parentPass.makeStackOffset(+this.frameSize)\r\n      );\r\n      // return t\r\n      _BinaryenReturnSetValue(ret, module.local_get(temp, returnType));\r\n    } else {\r\n      // __stack_pointer += frameSize\r\n      stmts.push(\r\n        this.parentPass.makeStackOffset(+this.frameSize)\r\n      );\r\n      // return\r\n    }\r\n    stmts.push(\r\n      ret\r\n    );\r\n    this.replaceCurrent(module.flatten(stmts, TypeRef.Unreachable));\r\n  }\r\n}","/**\r\n * @fileoverview AssemblyScript's intermediate representation.\r\n *\r\n * The compiler uses Binaryen IR, which is fairly low level, as its\r\n * primary intermediate representation, with the following structures\r\n * holding any higher level information that cannot be represented by\r\n * Binaryen IR alone, for example higher level types.\r\n *\r\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\r\n * composed of `Element`s in a `Program`. Each class or function is\r\n * represented by a \"prototype\" holding all the relevant information,\r\n * including each's concrete instances. If a class or function is not\r\n * generic, there is exactly one instance, otherwise there is one for\r\n * each concrete set of type arguments.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\n// Element                    Base class of all elements\r\n// DeclaredElement          Base class of elements with a declaration\r\n//  TypedElement           Base class of elements resolving to a type\r\n//   TypeDefinition       Type alias declaration\r\n//   VariableLikeElement  Base class of all variable-like elements\r\n//    EnumValue          Enum value\r\n//    Global             File global\r\n//    Local              Function local\r\n//    Field              Class field (instance only)\r\n//    Property           Class property\r\n//   IndexSignature       Class index signature\r\n//   Function             Concrete function instance\r\n//   Class                Concrete class instance\r\n//  Namespace              Namespace with static members\r\n//  FunctionPrototype      Prototype of concrete function instances\r\n//  FieldPrototype         Prototype of concrete field instances\r\n//  PropertyPrototype      Prototype of concrete property instances\r\n//  ClassPrototype         Prototype of concrete classe instances\r\n// File                     File, analogous to Source in the AST\r\n\r\nimport {\r\n  CommonFlags,\r\n  PATH_DELIMITER,\r\n  STATIC_DELIMITER,\r\n  INSTANCE_DELIMITER,\r\n  GETTER_PREFIX,\r\n  SETTER_PREFIX,\r\n  INNER_DELIMITER,\r\n  LIBRARY_SUBST,\r\n  INDEX_SUFFIX,\r\n  STUB_DELIMITER,\r\n  CommonNames,\r\n  Feature,\r\n  Target\r\n} from \"./common\";\r\n\r\nimport {\r\n  Options\r\n} from \"./compiler\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticMessage,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Type,\r\n  TypeKind,\r\n  Signature,\r\n  TypeFlags\r\n} from \"./types\";\r\n\r\nimport {\r\n  Token,\r\n  Range\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  Node,\r\n  NodeKind,\r\n  Source,\r\n  SourceKind,\r\n  DecoratorNode,\r\n  DecoratorKind,\r\n  TypeParameterNode,\r\n  TypeNode,\r\n  NamedTypeNode,\r\n  FunctionTypeNode,\r\n  ArrowKind,\r\n\r\n  Expression,\r\n  IdentifierExpression,\r\n  LiteralKind,\r\n  StringLiteralExpression,\r\n\r\n  Statement,\r\n  ClassDeclaration,\r\n  DeclarationStatement,\r\n  EnumDeclaration,\r\n  EnumValueDeclaration,\r\n  ExportMember,\r\n  ExportDefaultStatement,\r\n  ExportStatement,\r\n  FieldDeclaration,\r\n  FunctionDeclaration,\r\n  ImportDeclaration,\r\n  ImportStatement,\r\n  InterfaceDeclaration,\r\n  MethodDeclaration,\r\n  NamespaceDeclaration,\r\n  TypeDeclaration,\r\n  VariableDeclaration,\r\n  VariableLikeDeclarationStatement,\r\n  VariableStatement,\r\n  ParameterKind\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Module,\r\n  FunctionRef,\r\n  MemorySegment\r\n} from \"./module\";\r\n\r\nimport {\r\n  CharCode,\r\n  writeI8,\r\n  writeI16,\r\n  writeI32,\r\n  writeF32,\r\n  writeF64,\r\n  writeI64,\r\n  writeI32AsI64,\r\n  writeI64AsI32\r\n} from \"./util\";\r\n\r\nimport {\r\n  Resolver\r\n} from \"./resolver\";\r\n\r\nimport {\r\n  Flow\r\n} from \"./flow\";\r\n\r\nimport {\r\n  Parser\r\n} from \"./parser\";\r\n\r\nimport {\r\n  BuiltinNames\r\n} from \"./builtins\";\r\n\r\n// Memory manager constants\r\nconst AL_SIZE = 16;\r\nconst AL_MASK = AL_SIZE - 1;\r\n\r\n/** Represents a yet unresolved `import`. */\r\nclass QueuedImport {\r\n  constructor(\r\n    /** File being imported into. */\r\n    public localFile: File,\r\n    /** Identifier within the local file. */\r\n    public localIdentifier: IdentifierExpression,\r\n    /** Identifier within the other file. Is an `import *` if not set. */\r\n    public foreignIdentifier: IdentifierExpression | null,\r\n    /** Path to the other file. */\r\n    public foreignPath: string,\r\n    /** Alternative path to the other file. */\r\n    public foreignPathAlt: string\r\n  ) {}\r\n}\r\n\r\n/** Represents a yet unresolved `export`. */\r\nclass QueuedExport {\r\n  constructor(\r\n    /** Identifier within the local file. */\r\n    public localIdentifier: IdentifierExpression,\r\n    /** Identifier within the other file. */\r\n    public foreignIdentifier: IdentifierExpression,\r\n    /** Path to the other file if a re-export. */\r\n    public foreignPath: string | null,\r\n    /** Alternative path to the other file if a re-export. */\r\n    public foreignPathAlt: string | null\r\n  ) {}\r\n}\r\n\r\n/** Represents a yet unresolved `export *`. */\r\nclass QueuedExportStar {\r\n  // stored in a map with localFile as the key\r\n  constructor(\r\n    /** Path to the other file. */\r\n    public foreignPath: string,\r\n    /** Alternative path to the other file. */\r\n    public foreignPathAlt: string,\r\n    /** Reference to the path literal for reporting. */\r\n    public pathLiteral: StringLiteralExpression\r\n  ) {}\r\n}\r\n\r\n/** Represents the kind of an operator overload. */\r\nexport enum OperatorKind {\r\n  INVALID,\r\n\r\n  // indexed access\r\n  INDEXED_GET,            // a[]\r\n  INDEXED_SET,            // a[]=b\r\n  UNCHECKED_INDEXED_GET,  // unchecked(a[])\r\n  UNCHECKED_INDEXED_SET,  // unchecked(a[]=b)\r\n\r\n  // binary\r\n  ADD,                    // a + b\r\n  SUB,                    // a - b\r\n  MUL,                    // a * b\r\n  DIV,                    // a / b\r\n  REM,                    // a % b\r\n  POW,                    // a ** b\r\n  BITWISE_AND,            // a & b\r\n  BITWISE_OR,             // a | b\r\n  BITWISE_XOR,            // a ^ b\r\n  BITWISE_SHL,            // a << b\r\n  BITWISE_SHR,            // a >> b\r\n  BITWISE_SHR_U,          // a >>> b\r\n  EQ,                     // a == b\r\n  NE,                     // a != b\r\n  GT,                     // a > b\r\n  GE,                     // a >= b\r\n  LT,                     // a < b\r\n  LE,                     // a <= b\r\n\r\n  // unary prefix\r\n  PLUS,                   // +a\r\n  MINUS,                  // -a\r\n  NOT,                    // !a\r\n  BITWISE_NOT,            // ~a\r\n  PREFIX_INC,             // ++a\r\n  PREFIX_DEC,             // --a\r\n\r\n  // unary postfix\r\n  POSTFIX_INC,            // a++\r\n  POSTFIX_DEC             // a--\r\n\r\n  // not overridable:\r\n  // IDENTITY             // a === b\r\n  // LOGICAL_AND          // a && b\r\n  // LOGICAL_OR           // a || b\r\n}\r\n\r\nexport namespace OperatorKind {\r\n\r\n  /** Returns the operator kind represented by the specified decorator and string argument. */\r\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\r\n    assert(arg.length);\r\n    switch (decoratorKind) {\r\n      case DecoratorKind.OPERATOR:\r\n      case DecoratorKind.OPERATOR_BINARY: {\r\n        switch (arg.charCodeAt(0)) {\r\n          case CharCode.OPENBRACKET: {\r\n            if (arg == \"[]\") return OperatorKind.INDEXED_GET;\r\n            if (arg == \"[]=\") return OperatorKind.INDEXED_SET;\r\n            break;\r\n          }\r\n          case CharCode.OPENBRACE: {\r\n            if (arg == \"{}\") return OperatorKind.UNCHECKED_INDEXED_GET;\r\n            if (arg == \"{}=\") return OperatorKind.UNCHECKED_INDEXED_SET;\r\n            break;\r\n          }\r\n          case CharCode.PLUS: {\r\n            if (arg == \"+\") return OperatorKind.ADD;\r\n            break;\r\n          }\r\n          case CharCode.MINUS: {\r\n            if (arg == \"-\") return OperatorKind.SUB;\r\n            break;\r\n          }\r\n          case CharCode.ASTERISK: {\r\n            if (arg == \"*\") return OperatorKind.MUL;\r\n            if (arg == \"**\") return OperatorKind.POW;\r\n            break;\r\n          }\r\n          case CharCode.SLASH: {\r\n            if (arg == \"/\") return OperatorKind.DIV;\r\n            break;\r\n          }\r\n          case CharCode.PERCENT: {\r\n            if (arg == \"%\") return OperatorKind.REM;\r\n            break;\r\n          }\r\n          case CharCode.AMPERSAND: {\r\n            if (arg == \"&\") return OperatorKind.BITWISE_AND;\r\n            break;\r\n          }\r\n          case CharCode.BAR: {\r\n            if (arg == \"|\") return OperatorKind.BITWISE_OR;\r\n            break;\r\n          }\r\n          case CharCode.CARET: {\r\n            if (arg == \"^\") return OperatorKind.BITWISE_XOR;\r\n            break;\r\n          }\r\n          case CharCode.EQUALS: {\r\n            if (arg == \"==\") return OperatorKind.EQ;\r\n            break;\r\n          }\r\n          case CharCode.EXCLAMATION: {\r\n            if (arg == \"!=\") return OperatorKind.NE;\r\n            break;\r\n          }\r\n          case CharCode.GREATERTHAN: {\r\n            if (arg == \">\") return OperatorKind.GT;\r\n            if (arg == \">=\") return OperatorKind.GE;\r\n            if (arg == \">>\") return OperatorKind.BITWISE_SHR;\r\n            if (arg == \">>>\") return OperatorKind.BITWISE_SHR_U;\r\n            break;\r\n          }\r\n          case CharCode.LESSTHAN: {\r\n            if (arg == \"<\") return OperatorKind.LT;\r\n            if (arg == \"<=\") return OperatorKind.LE;\r\n            if (arg == \"<<\") return OperatorKind.BITWISE_SHL;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case DecoratorKind.OPERATOR_PREFIX: {\r\n        switch (arg.charCodeAt(0)) {\r\n          case CharCode.PLUS: {\r\n            if (arg == \"+\") return OperatorKind.PLUS;\r\n            if (arg == \"++\") return OperatorKind.PREFIX_INC;\r\n            break;\r\n          }\r\n          case CharCode.MINUS: {\r\n            if (arg == \"-\") return OperatorKind.MINUS;\r\n            if (arg == \"--\") return OperatorKind.PREFIX_DEC;\r\n            break;\r\n          }\r\n          case CharCode.EXCLAMATION: {\r\n            if (arg == \"!\") return OperatorKind.NOT;\r\n            break;\r\n          }\r\n          case CharCode.TILDE: {\r\n            if (arg == \"~\") return OperatorKind.BITWISE_NOT;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case DecoratorKind.OPERATOR_POSTFIX: {\r\n        switch (arg.charCodeAt(0)) {\r\n          case CharCode.PLUS: {\r\n            if (arg == \"++\") return OperatorKind.POSTFIX_INC;\r\n            break;\r\n          }\r\n          case CharCode.MINUS: {\r\n            if (arg == \"--\") return OperatorKind.POSTFIX_DEC;\r\n            break;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    return OperatorKind.INVALID;\r\n  }\r\n\r\n  /** Converts a binary operator token to the respective operator kind. */\r\n  export function fromBinaryToken(token: Token): OperatorKind {\r\n    switch (token) {\r\n      case Token.PLUS:\r\n      case Token.PLUS_EQUALS: return OperatorKind.ADD;\r\n      case Token.MINUS:\r\n      case Token.MINUS_EQUALS: return OperatorKind.SUB;\r\n      case Token.ASTERISK:\r\n      case Token.ASTERISK_EQUALS: return OperatorKind.MUL;\r\n      case Token.SLASH:\r\n      case Token.SLASH_EQUALS: return OperatorKind.DIV;\r\n      case Token.PERCENT:\r\n      case Token.PERCENT_EQUALS: return OperatorKind.REM;\r\n      case Token.ASTERISK_ASTERISK:\r\n      case Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;\r\n      case Token.AMPERSAND:\r\n      case Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;\r\n      case Token.BAR:\r\n      case Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;\r\n      case Token.CARET:\r\n      case Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;\r\n      case Token.LESSTHAN_LESSTHAN:\r\n      case Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;\r\n      case Token.GREATERTHAN_GREATERTHAN:\r\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;\r\n      case Token.EQUALS_EQUALS: return OperatorKind.EQ;\r\n      case Token.EXCLAMATION_EQUALS: return OperatorKind.NE;\r\n      case Token.GREATERTHAN: return OperatorKind.GT;\r\n      case Token.GREATERTHAN_EQUALS: return OperatorKind.GE;\r\n      case Token.LESSTHAN: return OperatorKind.LT;\r\n      case Token.LESSTHAN_EQUALS: return OperatorKind.LE;\r\n    }\r\n    return OperatorKind.INVALID;\r\n  }\r\n\r\n  /** Converts a unary prefix operator token to the respective operator kind. */\r\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\r\n    switch (token) {\r\n      case Token.PLUS: return OperatorKind.PLUS;\r\n      case Token.MINUS: return OperatorKind.MINUS;\r\n      case Token.EXCLAMATION: return OperatorKind.NOT;\r\n      case Token.TILDE: return OperatorKind.BITWISE_NOT;\r\n      case Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;\r\n      case Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;\r\n    }\r\n    return OperatorKind.INVALID;\r\n  }\r\n\r\n  /** Converts a unary postfix operator token to the respective operator kind. */\r\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\r\n    switch (token) {\r\n      case Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;\r\n      case Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;\r\n    }\r\n    return OperatorKind.INVALID;\r\n  }\r\n}\r\n\r\n/** Represents an AssemblyScript program. */\r\nexport class Program extends DiagnosticEmitter {\r\n\r\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\r\n  constructor(\r\n    /** Compiler options. */\r\n    public options: Options,\r\n    /** Shared array of diagnostic messages (emitted so far). */\r\n    diagnostics: DiagnosticMessage[] | null = null\r\n  ) {\r\n    super(diagnostics);\r\n    var nativeSource = new Source(SourceKind.LIBRARY_ENTRY, LIBRARY_SUBST + \".wasm\", \"[native code]\");\r\n    this.nativeSource = nativeSource;\r\n    this.parser = new Parser(this.diagnostics, this.sources);\r\n    this.resolver = new Resolver(this);\r\n    var nativeFile = new File(this, nativeSource);\r\n    this.nativeFile = nativeFile;\r\n    this.filesByName.set(nativeFile.internalName, nativeFile);\r\n  }\r\n\r\n  /** Parser instance. */\r\n  parser: Parser;\r\n  /** Resolver instance. */\r\n  resolver!: Resolver;\r\n  /** Array of sources. */\r\n  sources: Source[] = [];\r\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\r\n  diagnosticsOffset: i32 = 0;\r\n  /** Special native code source. */\r\n  nativeSource: Source;\r\n  /** Special native code range. */\r\n  get nativeRange(): Range { return this.nativeSource.range; }\r\n  /** Special native code file. */\r\n  nativeFile!: File;\r\n  /** Next class id. */\r\n  nextClassId: u32 = 0;\r\n  /** Next signature id. */\r\n  nextSignatureId: i32 = 0;\r\n  /** An indicator if the program has been initialized. */\r\n  initialized: bool = false;\r\n\r\n  // Lookup maps\r\n\r\n  /** Files by unique internal name. */\r\n  filesByName: Map<string,File> = new Map();\r\n  /** Elements by unique internal name in element space. */\r\n  elementsByName: Map<string,Element> = new Map();\r\n  /** Elements by declaration. */\r\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\r\n  /** Element instances by unique internal name. */\r\n  instancesByName: Map<string,Element> = new Map();\r\n  /** Classes wrapping basic types like `i32`. */\r\n  wrapperClasses: Map<Type,Class> = new Map();\r\n  /** Managed classes contained in the program, by id. */\r\n  managedClasses: Map<i32,Class> = new Map();\r\n  /** A set of unique function signatures contained in the program, by id. */\r\n  uniqueSignatures: Signature[] = new Array<Signature>(0);\r\n\r\n  // Standard library\r\n\r\n  /** Gets the standard `ArrayBufferView` instance. */\r\n  get arrayBufferViewInstance(): Class {\r\n    var cached = this._arrayBufferViewInstance;\r\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\r\n    return cached;\r\n  }\r\n  private _arrayBufferViewInstance: Class | null = null;\r\n\r\n  /** Gets the standard `ArrayBuffer` instance. */\r\n  get arrayBufferInstance(): Class {\r\n    var cached = this._arrayBufferInstance;\r\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\r\n    return cached;\r\n  }\r\n  private _arrayBufferInstance: Class | null = null;\r\n\r\n  /** Gets the standard `Array` prototype. */\r\n  get arrayPrototype(): ClassPrototype {\r\n    var cached = this._arrayPrototype;\r\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _arrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `StaticArray` prototype. */\r\n  get staticArrayPrototype(): ClassPrototype {\r\n    var cached = this._staticArrayPrototype;\r\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _staticArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Set` prototype. */\r\n  get setPrototype(): ClassPrototype {\r\n    var cached = this._setPrototype;\r\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _setPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Map` prototype. */\r\n  get mapPrototype(): ClassPrototype {\r\n    var cached = this._mapPrototype;\r\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _mapPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Function` prototype. */\r\n  get functionPrototype(): ClassPrototype {\r\n    var cached = this._functionPrototype;\r\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _functionPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Int8Array` prototype. */\r\n  get int8ArrayPrototype(): ClassPrototype {\r\n    var cached = this._int8ArrayPrototype;\r\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _int8ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Int16Array` prototype. */\r\n  get int16ArrayPrototype(): ClassPrototype {\r\n    var cached = this._int16ArrayPrototype;\r\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _int16ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Int32Array` prototype. */\r\n  get int32ArrayPrototype(): ClassPrototype {\r\n    var cached = this._int32ArrayPrototype;\r\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _int32ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Int64Array` prototype. */\r\n  get int64ArrayPrototype(): ClassPrototype {\r\n    var cached = this._int64ArrayPrototype;\r\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _int64ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Uint8Array` prototype. */\r\n  get uint8ArrayPrototype(): ClassPrototype {\r\n    var cached = this._uint8ArrayPrototype;\r\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Uint8ClampedArray` prototype. */\r\n  get uint8ClampedArrayPrototype(): ClassPrototype {\r\n    var cached = this._uint8ClampedArrayPrototype;\r\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Uint16Array` prototype. */\r\n  get uint16ArrayPrototype(): ClassPrototype {\r\n    var cached = this._uint16ArrayPrototype;\r\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Uint32Array` prototype. */\r\n  get uint32ArrayPrototype(): ClassPrototype {\r\n    var cached = this._uint32ArrayPrototype;\r\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Uint64Array` prototype. */\r\n  get uint64ArrayPrototype(): ClassPrototype {\r\n    var cached = this._uint64ArrayPrototype;\r\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Float32Array` prototype. */\r\n  get float32ArrayPrototype(): ClassPrototype {\r\n    var cached = this._float32ArrayPrototype;\r\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _float32ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `Float64Array` prototype. */\r\n  get float64ArrayPrototype(): ClassPrototype {\r\n    var cached = this._float64ArrayPrototype;\r\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.CLASS_PROTOTYPE);\r\n    return cached;\r\n  }\r\n  private _float64ArrayPrototype: ClassPrototype | null = null;\r\n\r\n  /** Gets the standard `String` instance. */\r\n  get stringInstance(): Class {\r\n    var cached = this._stringInstance;\r\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\r\n    return cached;\r\n  }\r\n  private _stringInstance: Class | null = null;\r\n\r\n  /** Gets the standard `Object` instance. */\r\n  get objectInstance(): Class {\r\n    var cached = this._objectInstance;\r\n    if (!cached) this._objectInstance = cached = this.requireClass(CommonNames.Object);\r\n    return cached;\r\n  }\r\n  private _objectInstance: Class | null = null;\r\n\r\n  /** Gets the standard `TemplateStringsArray` instance. */\r\n  get templateStringsArrayInstance(): Class {\r\n    var cached = this._templateStringsArrayInstance;\r\n    if (!cached) this._templateStringsArrayInstance = cached = this.requireClass(CommonNames.TemplateStringsArray);\r\n    return cached;\r\n  }\r\n  private _templateStringsArrayInstance: Class | null = null;\r\n\r\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\r\n  get abortInstance(): Function | null {\r\n    var prototype = this.lookup(CommonNames.abort);\r\n    if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE) return null;\r\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\r\n  }\r\n\r\n  // Runtime interface\r\n\r\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\r\n  get allocInstance(): Function {\r\n    var cached = this._allocInstance;\r\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\r\n    return cached;\r\n  }\r\n  private _allocInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\r\n  get reallocInstance(): Function {\r\n    var cached = this._reallocInstance;\r\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\r\n    return cached;\r\n  }\r\n  private _reallocInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\r\n  get freeInstance(): Function {\r\n    var cached = this._freeInstance;\r\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\r\n    return cached;\r\n  }\r\n  private _freeInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\r\n  get newInstance(): Function {\r\n    var cached = this._newInstance;\r\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\r\n    return cached;\r\n  }\r\n  private _newInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\r\n  get renewInstance(): Function {\r\n    var cached = this._renewInstance;\r\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\r\n    return cached;\r\n  }\r\n  private _renewInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void` instance. */\r\n  get linkInstance(): Function {\r\n    var cached = this._linkInstance;\r\n    if (!cached) this._linkInstance = cached = this.requireFunction(CommonNames.link);\r\n    return cached;\r\n  }\r\n  private _linkInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__collect(): void` instance. */\r\n  get collectInstance(): Function {\r\n    var cached = this._collectInstance;\r\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\r\n    return cached;\r\n  }\r\n  private _collectInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\r\n  get visitInstance(): Function {\r\n    var cached = this._visitInstance;\r\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\r\n    return cached;\r\n  }\r\n  private _visitInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */\r\n  get typeinfoInstance(): Function {\r\n    var cached = this._typeinfoInstance;\r\n    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);\r\n    return cached;\r\n  }\r\n  private _typeinfoInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */\r\n  get instanceofInstance(): Function {\r\n    var cached = this._instanceofInstance;\r\n    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);\r\n    return cached;\r\n  }\r\n  private _instanceofInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\r\n  get newBufferInstance(): Function {\r\n    var cached = this._newBufferInstance;\r\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\r\n    return cached;\r\n  }\r\n  private _newBufferInstance: Function | null = null;\r\n\r\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\r\n  get newArrayInstance(): Function {\r\n    var cached = this._newArrayInstance;\r\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\r\n    return cached;\r\n  }\r\n  private _newArrayInstance: Function | null = null;\r\n\r\n  /** Gets the runtime's internal `BLOCK` instance. */\r\n  get BLOCKInstance(): Class {\r\n    var cached = this._BLOCKInstance;\r\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\r\n    return cached;\r\n  }\r\n  private _BLOCKInstance: Class | null = null;\r\n\r\n  /** Gets the runtime's internal `OBJECT` instance. */\r\n  get OBJECTInstance(): Class {\r\n    var cached = this._OBJECTInstance;\r\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\r\n    return cached;\r\n  }\r\n  private _OBJECTInstance: Class | null = null;\r\n\r\n  // Utility\r\n\r\n  /** Tests whether this is a WASI program. */\r\n  get isWasi(): bool {\r\n    return this.elementsByName.has(CommonNames.ASC_WASI);\r\n  }\r\n\r\n  /** Obtains the source matching the specified internal path. */\r\n  getSource(internalPath: string): string | null {\r\n    var sources = this.sources;\r\n    for (let i = 0; i < sources.length; ++i) {\r\n      let source = sources[i];\r\n      if (source.internalPath == internalPath) return source.text;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Gets the overhead of a memory manager block. */\r\n  get blockOverhead(): i32 {\r\n    // BLOCK | data...\r\n    //       ^ 16b alignment\r\n    return this.BLOCKInstance.nextMemoryOffset;\r\n  }\r\n\r\n  /** Gets the overhead of a managed object, excl. block overhead, incl. alignment. */\r\n  get objectOverhead(): i32 {\r\n    // OBJECT+align | data...\r\n    //         0  ^ 16b alignment\r\n    return (this.OBJECTInstance.nextMemoryOffset - this.blockOverhead + AL_MASK) & ~AL_MASK;\r\n  }\r\n\r\n  /** Gets the total overhead of a managed object, incl. block overhead. */\r\n  get totalOverhead(): i32 {\r\n    // BLOCK | OBJECT+align | data...\r\n    //      = TOTAL       ^ 16b alignment\r\n    return this.blockOverhead + this.objectOverhead;\r\n  }\r\n\r\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\r\n  computeBlockStart(currentOffset: i32): i32 {\r\n    var blockOverhead = this.blockOverhead;\r\n    return ((currentOffset + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\r\n  }\r\n\r\n  /** Computes the next properly aligned offset of a memory manager block, given the current bump offset. */\r\n  computeBlockStart64(currentOffset: i64): i64 {\r\n    var blockOverhead = i64_new(this.blockOverhead);\r\n    return i64_sub(i64_align(i64_add(currentOffset, blockOverhead), AL_SIZE), blockOverhead);\r\n  }\r\n\r\n  /** Computes the size of a memory manager block, excl. block overhead. */\r\n  computeBlockSize(payloadSize: i32, isManaged: bool): i32 {\r\n    // see: std/rt/tlsf.ts, computeSize; becomes mmInfo\r\n    if (isManaged) payloadSize += this.objectOverhead;\r\n    // we know that payload must be aligned, and that block sizes must be chosen\r\n    // so that blocks are adjacent with the next payload aligned. hence, block\r\n    // size is payloadSize rounded up to where the next block would start:\r\n    var blockSize = this.computeBlockStart(payloadSize);\r\n    // make sure that block size is valid according to TLSF requirements\r\n    var blockOverhead = this.blockOverhead;\r\n    var blockMinsize = ((3 * this.options.usizeType.byteSize + blockOverhead + AL_MASK) & ~AL_MASK) - blockOverhead;\r\n    if (blockSize < blockMinsize) blockSize = blockMinsize;\r\n    const blockMaxsize = 1 << 30; // 1 << (FL_BITS + SB_BITS - 1), exclusive\r\n    const tagsMask = 3;\r\n    if (blockSize >= blockMaxsize || (blockSize & tagsMask) != 0) {\r\n      throw new Error(\"invalid block size\");\r\n    }\r\n    return blockSize;\r\n  }\r\n\r\n  /** Creates a native variable declaration. */\r\n  makeNativeVariableDeclaration(\r\n    /** The simple name of the variable */\r\n    name: string,\r\n    /** Flags indicating specific traits, e.g. `CONST`. */\r\n    flags: CommonFlags = CommonFlags.NONE\r\n  ): VariableDeclaration {\r\n    var range = this.nativeSource.range;\r\n    return Node.createVariableDeclaration(\r\n      Node.createIdentifierExpression(name, range),\r\n      null, flags, null, null, range\r\n    );\r\n  }\r\n\r\n  /** Creates a native type declaration. */\r\n  makeNativeTypeDeclaration(\r\n    /** The simple name of the type. */\r\n    name: string,\r\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\r\n    flags: CommonFlags = CommonFlags.NONE\r\n  ): TypeDeclaration {\r\n    var range = this.nativeSource.range;\r\n    var identifier = Node.createIdentifierExpression(name, range);\r\n    return Node.createTypeDeclaration(\r\n      identifier,\r\n      null, flags, null,\r\n      Node.createOmittedType(range),\r\n      range\r\n    );\r\n  }\r\n\r\n  // a dummy signature for programmatically generated native functions\r\n  private nativeDummySignature: FunctionTypeNode | null = null;\r\n\r\n  /** Creates a native function declaration. */\r\n  makeNativeFunctionDeclaration(\r\n    /** The simple name of the function. */\r\n    name: string,\r\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\r\n    flags: CommonFlags = CommonFlags.NONE\r\n  ): FunctionDeclaration {\r\n    var range = this.nativeSource.range;\r\n    var signature = this.nativeDummySignature;\r\n    if (!signature) {\r\n      this.nativeDummySignature = signature = Node.createFunctionType([],\r\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\r\n          Node.createSimpleTypeName(CommonNames.void_, range),\r\n          null, false, range\r\n        ),\r\n        null, false, range\r\n      );\r\n    }\r\n    return Node.createFunctionDeclaration(\r\n      Node.createIdentifierExpression(name, range),\r\n      null, flags, null, signature, null, ArrowKind.NONE, range\r\n    );\r\n  }\r\n\r\n  /** Creates a native namespace declaration. */\r\n  makeNativeNamespaceDeclaration(\r\n    /** The simple name of the namespace. */\r\n    name: string,\r\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\r\n    flags: CommonFlags = CommonFlags.NONE\r\n  ): NamespaceDeclaration {\r\n    var range = this.nativeSource.range;\r\n    return Node.createNamespaceDeclaration(\r\n      Node.createIdentifierExpression(name, range),\r\n      null, flags, [], range\r\n    );\r\n  }\r\n\r\n  /** Creates a native function. */\r\n  makeNativeFunction(\r\n    /** The simple name of the function. */\r\n    name: string,\r\n    /** Concrete function signature. */\r\n    signature: Signature,\r\n    /** Parent element, usually a file, class or namespace. */\r\n    parent: Element = this.nativeFile,\r\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\r\n    flags: CommonFlags = CommonFlags.NONE,\r\n    /** Decorator flags representing built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ): Function {\r\n    return new Function(\r\n      name,\r\n      new FunctionPrototype(\r\n        name,\r\n        parent,\r\n        this.makeNativeFunctionDeclaration(name, flags),\r\n        decoratorFlags\r\n      ),\r\n      null,\r\n      signature\r\n    );\r\n  }\r\n\r\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\r\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\r\n    var elementsByDeclaration = this.elementsByDeclaration;\r\n    return elementsByDeclaration.has(declaration)\r\n      ? assert(elementsByDeclaration.get(declaration))\r\n      : null;\r\n  }\r\n\r\n  /** Initializes the program and its elements prior to compilation. */\r\n  initialize(): void {\r\n    if (this.initialized) return;\r\n    this.initialized = true;\r\n\r\n    var options = this.options;\r\n\r\n    // register native types\r\n    this.registerNativeType(CommonNames.i8, Type.i8);\r\n    this.registerNativeType(CommonNames.i16, Type.i16);\r\n    this.registerNativeType(CommonNames.i32, Type.i32);\r\n    this.registerNativeType(CommonNames.i64, Type.i64);\r\n    this.registerNativeType(CommonNames.isize, options.isizeType);\r\n    this.registerNativeType(CommonNames.u8, Type.u8);\r\n    this.registerNativeType(CommonNames.u16, Type.u16);\r\n    this.registerNativeType(CommonNames.u32, Type.u32);\r\n    this.registerNativeType(CommonNames.u64, Type.u64);\r\n    this.registerNativeType(CommonNames.usize, options.usizeType);\r\n    this.registerNativeType(CommonNames.bool, Type.bool);\r\n    this.registerNativeType(CommonNames.f32, Type.f32);\r\n    this.registerNativeType(CommonNames.f64, Type.f64);\r\n    this.registerNativeType(CommonNames.void_, Type.void);\r\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\r\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\r\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\r\n      CommonNames.native,\r\n      this.nativeFile,\r\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.EXPORT | CommonFlags.GENERIC),\r\n      DecoratorFlags.BUILTIN\r\n    ));\r\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\r\n      CommonNames.indexof,\r\n      this.nativeFile,\r\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.EXPORT | CommonFlags.GENERIC),\r\n      DecoratorFlags.BUILTIN\r\n    ));\r\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\r\n      CommonNames.valueof,\r\n      this.nativeFile,\r\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.EXPORT | CommonFlags.GENERIC),\r\n      DecoratorFlags.BUILTIN\r\n    ));\r\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\r\n      CommonNames.returnof,\r\n      this.nativeFile,\r\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.EXPORT | CommonFlags.GENERIC),\r\n      DecoratorFlags.BUILTIN\r\n    ));\r\n    this.nativeFile.add(CommonNames.nonnull, new TypeDefinition(\r\n      CommonNames.nonnull,\r\n      this.nativeFile,\r\n      this.makeNativeTypeDeclaration(CommonNames.nonnull, CommonFlags.EXPORT | CommonFlags.GENERIC),\r\n      DecoratorFlags.BUILTIN\r\n    ));\r\n\r\n    // The following types might not be enabled by compiler options, so the\r\n    // compiler needs to check this condition whenever such a value is created\r\n    // respectively stored or loaded.\r\n    this.registerNativeType(CommonNames.v128, Type.v128);\r\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\r\n    this.registerNativeType(CommonNames.externref, Type.externref);\r\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\r\n    this.registerNativeType(CommonNames.eqref, Type.eqref);\r\n    this.registerNativeType(CommonNames.i31ref, Type.i31ref);\r\n    this.registerNativeType(CommonNames.dataref, Type.dataref);\r\n\r\n    // register compiler hints\r\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\r\n      i64_new(options.isWasm64 ? Target.WASM64 : Target.WASM32));\r\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\r\n      i64_new(options.noAssert ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\r\n      i64_new(options.memoryBase, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\r\n      i64_new(options.tableBase, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\r\n      i64_new(options.optimizeLevelHint, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\r\n      i64_new(options.shrinkLevelHint, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\r\n      i64_new(options.lowMemoryLimit, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_EXPORT_RUNTIME, Type.bool,\r\n      i64_new(options.exportRuntime ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MAJOR, Type.i32,\r\n      i64_new(options.bundleMajorVersion));\r\n    this.registerConstantInteger(CommonNames.ASC_VERSION_MINOR, Type.i32,\r\n      i64_new(options.bundleMinorVersion));\r\n    this.registerConstantInteger(CommonNames.ASC_VERSION_PATCH, Type.i32,\r\n      i64_new(options.bundlePatchVersion));\r\n\r\n    // register feature hints\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\r\n      i64_new(options.hasFeature(Feature.SIGN_EXTENSION) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\r\n      i64_new(options.hasFeature(Feature.MUTABLE_GLOBALS) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\r\n      i64_new(options.hasFeature(Feature.NONTRAPPING_F2I) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\r\n      i64_new(options.hasFeature(Feature.BULK_MEMORY) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\r\n      i64_new(options.hasFeature(Feature.SIMD) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\r\n      i64_new(options.hasFeature(Feature.THREADS) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\r\n      i64_new(options.hasFeature(Feature.EXCEPTION_HANDLING) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\r\n      i64_new(options.hasFeature(Feature.TAIL_CALLS) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\r\n      i64_new(options.hasFeature(Feature.REFERENCE_TYPES) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\r\n      i64_new(options.hasFeature(Feature.MULTI_VALUE) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\r\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\r\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\r\n      i64_new(options.hasFeature(Feature.MEMORY64) ? 1 : 0, 0));\r\n\r\n    // remember deferred elements\r\n    var queuedImports = new Array<QueuedImport>();\r\n    var queuedExports = new Map<File,Map<string,QueuedExport>>();\r\n    var queuedExportsStar = new Map<File,QueuedExportStar[]>();\r\n    var queuedExtends = new Array<ClassPrototype>();\r\n    var queuedImplements = new Array<ClassPrototype>();\r\n\r\n    // initialize relevant declaration-like statements of the entire program\r\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\r\n      let source = this.sources[i];\r\n      let file = new File(this, source);\r\n      this.filesByName.set(file.internalName, file);\r\n      let statements = source.statements;\r\n      for (let j = 0, l = statements.length; j < l; ++j) {\r\n        let statement = statements[j];\r\n        switch (statement.kind) {\r\n          case NodeKind.EXPORT: {\r\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\r\n            break;\r\n          }\r\n          case NodeKind.EXPORTDEFAULT: {\r\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\r\n            break;\r\n          }\r\n          case NodeKind.IMPORT: {\r\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\r\n            break;\r\n          }\r\n          case NodeKind.VARIABLE: {\r\n            this.initializeVariables(<VariableStatement>statement, file);\r\n            break;\r\n          }\r\n          case NodeKind.CLASSDECLARATION: {\r\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\r\n            break;\r\n          }\r\n          case NodeKind.ENUMDECLARATION: {\r\n            this.initializeEnum(<EnumDeclaration>statement, file);\r\n            break;\r\n          }\r\n          case NodeKind.FUNCTIONDECLARATION: {\r\n            this.initializeFunction(<FunctionDeclaration>statement, file);\r\n            break;\r\n          }\r\n          case NodeKind.INTERFACEDECLARATION: {\r\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\r\n            break;\r\n          }\r\n          case NodeKind.NAMESPACEDECLARATION: {\r\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\r\n            break;\r\n          }\r\n          case NodeKind.TYPEDECLARATION: {\r\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // queued exports * should be linkable now that all files have been processed\r\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\r\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\r\n      let file = _keys[i];\r\n      let starExports = assert(queuedExportsStar.get(file));\r\n      for (let j = 0, l = starExports.length; j < l; ++j) {\r\n        let exportStar = unchecked(starExports[j]);\r\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\r\n        if (!foreignFile) {\r\n          this.error(\r\n            DiagnosticCode.File_0_not_found,\r\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\r\n          );\r\n          continue;\r\n        }\r\n        file.ensureExportStar(foreignFile);\r\n      }\r\n    }\r\n\r\n    // queued imports should be resolvable now through traversing exports and queued exports.\r\n    // note that imports may depend upon imports, so repeat until there's no more progress.\r\n    do {\r\n      let i = 0, madeProgress = false;\r\n      while (i < queuedImports.length) {\r\n        let queuedImport = queuedImports[i];\r\n        let localIdentifier = queuedImport.localIdentifier;\r\n        let foreignIdentifier = queuedImport.foreignIdentifier;\r\n        // File must be found here, as it would otherwise already have been reported by the parser\r\n        let foreignFile = assert(this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt));\r\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\r\n          let element = this.lookupForeign(\r\n            foreignIdentifier.text,\r\n            foreignFile,\r\n            queuedExports\r\n          );\r\n          if (element) {\r\n            queuedImport.localFile.add(\r\n              localIdentifier.text,\r\n              element,\r\n              localIdentifier // isImport\r\n            );\r\n            queuedImports.splice(i, 1);\r\n            madeProgress = true;\r\n          } else {\r\n            ++i;\r\n          }\r\n        } else { // i.e. import * as bar from \"./bar\"\r\n          let localFile = queuedImport.localFile;\r\n          let localName = localIdentifier.text;\r\n          localFile.add(\r\n            localName,\r\n            foreignFile.asAliasNamespace(\r\n              localName,\r\n              localFile,\r\n              localIdentifier\r\n            ),\r\n            localIdentifier // isImport\r\n          );\r\n          queuedImports.splice(i, 1);\r\n          madeProgress = true;\r\n        }\r\n      }\r\n      if (!madeProgress) {\r\n        // report queued imports we were unable to resolve\r\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\r\n          let queuedImport = queuedImports[j];\r\n          let foreignIdentifier = queuedImport.foreignIdentifier;\r\n          if (foreignIdentifier) {\r\n            this.error(\r\n              DiagnosticCode.Module_0_has_no_exported_member_1,\r\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\r\n            );\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    } while (true);\r\n\r\n    // queued exports should be resolvable now that imports are finalized\r\n    // TODO: for (let [file, exports] of queuedExports) {\r\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\r\n      let file = unchecked(_keys[i]);\r\n      let exports = assert(queuedExports.get(file));\r\n      // TODO: for (let [exportName, queuedExport] of exports) {\r\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\r\n        let exportName = unchecked(exportNames[j]);\r\n        let queuedExport = assert(exports.get(exportName));\r\n        let localName = queuedExport.localIdentifier.text;\r\n        let foreignPath = queuedExport.foreignPath;\r\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\r\n          // File must be found here, as it would otherwise already have been reported by the parser\r\n          let foreignFile = assert(this.lookupForeignFile(foreignPath, assert(queuedExport.foreignPathAlt)));\r\n          let element = this.lookupForeign(localName, foreignFile, queuedExports);\r\n          if (element) {\r\n            file.ensureExport(exportName, element);\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode.Module_0_has_no_exported_member_1,\r\n              queuedExport.localIdentifier.range,\r\n              foreignPath, localName\r\n            );\r\n          }\r\n        } else { // i.e. export { foo [as bar] }\r\n          let element = file.lookupInSelf(localName);\r\n          if (element) {\r\n            file.ensureExport(exportName, element);\r\n          } else {\r\n            let globalElement = this.lookup(localName);\r\n            if (globalElement !== null && isDeclaredElement(globalElement.kind)) { // export { memory }\r\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode.Module_0_has_no_exported_member_1,\r\n                queuedExport.foreignIdentifier.range,\r\n                file.internalName, queuedExport.foreignIdentifier.text\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)\r\n    assert(this.arrayBufferInstance.id == 0);\r\n    assert(this.stringInstance.id == 1);\r\n    assert(this.arrayBufferViewInstance.id == 2);\r\n\r\n    // register classes backing basic types\r\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\r\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\r\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\r\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\r\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\r\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\r\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\r\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\r\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\r\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\r\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\r\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\r\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\r\n    if (options.hasFeature(Feature.SIMD)) this.registerWrapperClass(Type.v128, CommonNames.V128);\r\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) {\r\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\r\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\r\n      if (options.hasFeature(Feature.GC)) {\r\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\r\n        this.registerWrapperClass(Type.eqref, CommonNames.Eqref);\r\n        this.registerWrapperClass(Type.i31ref, CommonNames.I31ref);\r\n        this.registerWrapperClass(Type.dataref, CommonNames.Dataref);\r\n      }\r\n    }\r\n\r\n    // resolve prototypes of extended classes or interfaces\r\n    var resolver = this.resolver;\r\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\r\n      let thisPrototype = queuedExtends[i];\r\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\r\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\r\n      if (!baseElement) continue;\r\n      if (thisPrototype.kind == ElementKind.CLASS_PROTOTYPE) {\r\n        if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {\r\n          let basePrototype = <ClassPrototype>baseElement;\r\n          if (basePrototype.hasDecorator(DecoratorFlags.FINAL)) {\r\n            this.error(\r\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\r\n              extendsNode.range, basePrototype.identifierNode.text\r\n            );\r\n          }\r\n          if (\r\n            basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=\r\n            thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)\r\n          ) {\r\n            this.error(\r\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\r\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\r\n            );\r\n          }\r\n          thisPrototype.basePrototype = basePrototype;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.A_class_may_only_extend_another_class,\r\n            extendsNode.range\r\n          );\r\n        }\r\n      } else if (thisPrototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\r\n        if (baseElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\r\n          thisPrototype.basePrototype = <InterfacePrototype>baseElement;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\r\n            extendsNode.range\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // resolve prototypes of implemented interfaces\r\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\r\n      let thisPrototype = queuedImplements[i];\r\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\r\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\r\n        let implementsNode = implementsNodes[j];\r\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\r\n        if (!interfaceElement) continue;\r\n        if (interfaceElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\r\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\r\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\r\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\r\n          interfacePrototypes.push(interfacePrototype);\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.A_class_can_only_implement_an_interface,\r\n            implementsNode.range\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // check for virtual overloads in extended classes and implemented interfaces\r\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\r\n      let thisPrototype = queuedExtends[i];\r\n      let basePrototype = thisPrototype.basePrototype;\r\n      if (basePrototype) {\r\n        this.markVirtuals(thisPrototype, basePrototype);\r\n      }\r\n    }\r\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\r\n      let thisPrototype = queuedImplements[i];\r\n      let basePrototype = thisPrototype.basePrototype;\r\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\r\n      if (basePrototype) {\r\n        this.markVirtuals(thisPrototype, basePrototype);\r\n      }\r\n      if (interfacePrototypes) {\r\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\r\n          this.markVirtuals(thisPrototype, interfacePrototypes[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // set up global aliases\r\n    {\r\n      let globalAliases = options.globalAliases;\r\n      if (!globalAliases) globalAliases = new Map();\r\n      let isWasi = this.isWasi;\r\n      if (!globalAliases.has(CommonNames.abort)) {\r\n        globalAliases.set(CommonNames.abort,\r\n          isWasi\r\n            ? BuiltinNames.wasiAbort\r\n            : BuiltinNames.abort\r\n        );\r\n      }\r\n      if (!globalAliases.has(CommonNames.trace)) {\r\n        globalAliases.set(CommonNames.trace,\r\n          isWasi\r\n            ? BuiltinNames.wasiTrace\r\n            : BuiltinNames.trace\r\n        );\r\n      }\r\n      if (!globalAliases.has(CommonNames.seed)) {\r\n        globalAliases.set(CommonNames.seed,\r\n          isWasi\r\n            ? BuiltinNames.wasiSeed\r\n            : BuiltinNames.seed\r\n        );\r\n      }\r\n      if (!globalAliases.has(CommonNames.Math)) {\r\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\r\n      }\r\n      if (!globalAliases.has(CommonNames.Mathf)) {\r\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\r\n      }\r\n      // TODO: for (let [alias, name] of globalAliases) {\r\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\r\n        let alias = unchecked(_keys[i]);\r\n        let name = changetype<string>(globalAliases.get(alias));\r\n        assert(name != null);\r\n        if (!name.length) {\r\n          this.elementsByName.delete(alias);\r\n          continue;\r\n        }\r\n        let firstChar = name.charCodeAt(0);\r\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\r\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\r\n        } else {\r\n          let elementsByName = this.elementsByName;\r\n          if (elementsByName.has(name)) {\r\n            elementsByName.set(alias, assert(elementsByName.get(name)));\r\n          } else {\r\n            throw new Error(\"no such global element: \" + name);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\r\n    // TODO: for (let file of this.filesByName.values()) {\r\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\r\n      let file = unchecked(_values[i]);\r\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\r\n        this.markModuleExports(file);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Marks virtual members in a base class overloaded in this class. */\r\n  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {\r\n    // TODO: make this work with interfaaces as well\r\n    var thisInstanceMembers = thisPrototype.instanceMembers;\r\n    if (thisInstanceMembers) {\r\n      do {\r\n        let baseInstanceMembers = basePrototype.instanceMembers;\r\n        if (baseInstanceMembers) {\r\n          for (let _values = Map_values(thisInstanceMembers), j = 0, l = _values.length; j < l; ++j) {\r\n            let thisMember = _values[j];\r\n            if (\r\n              !thisMember.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.PRIVATE) &&\r\n              baseInstanceMembers.has(thisMember.name)\r\n            ) {\r\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\r\n              if (\r\n                thisMember.kind == ElementKind.FUNCTION_PROTOTYPE &&\r\n                baseMember.kind == ElementKind.FUNCTION_PROTOTYPE\r\n              ) {\r\n                let thisMethod = <FunctionPrototype>thisMember;\r\n                let baseMethod = <FunctionPrototype>baseMember;\r\n                if (!thisMethod.visibilityEquals(baseMethod)) {\r\n                  this.errorRelated(\r\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\r\n                    thisMethod.identifierNode.range, baseMethod.identifierNode.range\r\n                  );\r\n                }\r\n                baseMember.set(CommonFlags.VIRTUAL);\r\n                let overloads = baseMethod.overloads;\r\n                if (!overloads) baseMethod.overloads = overloads = new Set();\r\n                overloads.add(<FunctionPrototype>thisMember);\r\n                let baseMethodInstances = baseMethod.instances;\r\n                if (baseMethodInstances) {\r\n                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\r\n                    let baseMethodInstance = _values[a];\r\n                    baseMethodInstance.set(CommonFlags.VIRTUAL);\r\n                  }\r\n                }\r\n              } else if (\r\n                thisMember.kind == ElementKind.PROPERTY_PROTOTYPE &&\r\n                baseMember.kind == ElementKind.PROPERTY_PROTOTYPE\r\n              ) {\r\n                let thisProperty = <PropertyPrototype>thisMember;\r\n                let baseProperty = <PropertyPrototype>baseMember;\r\n                if (!thisProperty.visibilityEquals(baseProperty)) {\r\n                  this.errorRelated(\r\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\r\n                    thisProperty.identifierNode.range, baseProperty.identifierNode.range\r\n                  );\r\n                }\r\n                baseProperty.set(CommonFlags.VIRTUAL);\r\n                let baseGetter = baseProperty.getterPrototype;\r\n                if (baseGetter) {\r\n                  baseGetter.set(CommonFlags.VIRTUAL);\r\n                  let thisGetter = thisProperty.getterPrototype;\r\n                  if (thisGetter) {\r\n                    let overloads = baseGetter.overloads;\r\n                    if (!overloads) baseGetter.overloads = overloads = new Set();\r\n                    overloads.add(thisGetter);\r\n                  }\r\n                  let baseGetterInstances = baseGetter.instances;\r\n                  if (baseGetterInstances) {\r\n                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\r\n                      let baseGetterInstance = _values[a];\r\n                      baseGetterInstance.set(CommonFlags.VIRTUAL);\r\n                    }\r\n                  }\r\n                }\r\n                let baseSetter = baseProperty.setterPrototype;\r\n                if (baseSetter !== null && thisProperty.setterPrototype !== null) {\r\n                  baseSetter.set(CommonFlags.VIRTUAL);\r\n                  let thisSetter = thisProperty.setterPrototype;\r\n                  if (thisSetter) {\r\n                    let overloads = baseSetter.overloads;\r\n                    if (!overloads) baseSetter.overloads = overloads = new Set();\r\n                    overloads.add(thisSetter);\r\n                  }\r\n                  let baseSetterInstances = baseSetter.instances;\r\n                  if (baseSetterInstances) {\r\n                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\r\n                      let baseSetterInstance = _values[a];\r\n                      baseSetterInstance.set(CommonFlags.VIRTUAL);\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                this.errorRelated(\r\n                  DiagnosticCode.Duplicate_identifier_0,\r\n                  thisMember.identifierNode.range,\r\n                  baseMember.identifierNode.range,\r\n                  baseMember.identifierNode.text\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n        let nextPrototype = basePrototype.basePrototype;\r\n        if (!nextPrototype) break;\r\n        basePrototype = nextPrototype;\r\n      } while (true);\r\n    }\r\n  }\r\n\r\n  /** Looks up the element of the specified name in the global scope. */\r\n  lookup(name: string): Element | null {\r\n    var elements = this.elementsByName;\r\n    if (elements.has(name)) return assert(elements.get(name));\r\n    return null;\r\n  }\r\n\r\n  /** Requires that a global library element of the specified kind is present and returns it. */\r\n  private require(name: string, kind: ElementKind): Element {\r\n    var element = this.lookup(name);\r\n    if (!element) throw new Error(\"Missing standard library component: \" + name);\r\n    if (element.kind != kind) throw Error(\"Invalid standard library component kind: \" + name);\r\n    return element;\r\n  }\r\n\r\n  /** Requires that a global variable is present and returns it. */\r\n  requireGlobal(name: string): Global {\r\n    return <Global>this.require(name, ElementKind.GLOBAL);\r\n  }\r\n\r\n  /** Requires that a non-generic global class is present and returns it. */\r\n  requireClass(name: string): Class {\r\n    var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);\r\n    var resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\r\n    if (!resolved) throw new Error(\"Invalid standard library class: \" + name);\r\n    return resolved;\r\n  }\r\n\r\n  /** Requires that a global function is present and returns it. */\r\n  requireFunction(name: string, typeArguments: Type[] | null = null): Function {\r\n    var prototype = <FunctionPrototype>this.require(name, ElementKind.FUNCTION_PROTOTYPE);\r\n    var resolved = this.resolver.resolveFunction(prototype, typeArguments);\r\n    if (!resolved) throw new Error(\"Invalid standard library function: \" + name);\r\n    return resolved;\r\n  }\r\n\r\n  /** Marks all exports of the specified file as module exports. */\r\n  private markModuleExports(file: File): void {\r\n    var exports = file.exports;\r\n    if (exports) {\r\n      // TODO: for (let element of exports.values()) {\r\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\r\n        let element = unchecked(_values[j]);\r\n        this.markModuleExport(element);\r\n      }\r\n    }\r\n    var exportsStar = file.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        this.markModuleExports(exportsStar[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Marks an element and its children as a module export. */\r\n  private markModuleExport(element: Element): void {\r\n    element.set(CommonFlags.MODULE_EXPORT);\r\n    switch (element.kind) {\r\n      case ElementKind.CLASS_PROTOTYPE: {\r\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\r\n        if (instanceMembers) {\r\n          // TODO: for (let member of instanceMembers.values()) {\r\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\r\n            let member = unchecked(_values[i]);\r\n            this.markModuleExport(member);\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: {\r\n        let propertyPrototype = <PropertyPrototype>element;\r\n        let getterPrototype = propertyPrototype.getterPrototype;\r\n        if (getterPrototype) this.markModuleExport(getterPrototype);\r\n        let setterPrototype = propertyPrototype.setterPrototype;\r\n        if (setterPrototype) this.markModuleExport(setterPrototype);\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY:\r\n      case ElementKind.FUNCTION:\r\n      case ElementKind.FIELD:\r\n      case ElementKind.CLASS: assert(false); // assumes that there are no instances yet\r\n    }\r\n    var staticMembers = element.members;\r\n    if (staticMembers) {\r\n      // TODO: for (let member of staticMembers.values()) {\r\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        this.markModuleExport(member);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Registers a native type with the program. */\r\n  private registerNativeType(name: string, type: Type): void {\r\n    var element = new TypeDefinition(\r\n      name,\r\n      this.nativeFile,\r\n      this.makeNativeTypeDeclaration(name, CommonFlags.EXPORT),\r\n      DecoratorFlags.BUILTIN\r\n    );\r\n    element.setType(type);\r\n    this.nativeFile.add(name, element);\r\n  }\r\n\r\n  /** Registers the wrapper class of a non-class type. */\r\n  private registerWrapperClass(type: Type, className: string): void {\r\n    var wrapperClasses = this.wrapperClasses;\r\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\r\n    var element = assert(this.lookup(className));\r\n    assert(element.kind == ElementKind.CLASS_PROTOTYPE);\r\n    var classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\r\n    classElement.wrappedType = type;\r\n    wrapperClasses.set(type, classElement);\r\n  }\r\n\r\n  /** Registers a constant integer value within the global scope. */\r\n  registerConstantInteger(name: string, type: Type, value: i64): void {\r\n    assert(type.isIntegerInclReference);\r\n    var global = new Global(\r\n      name,\r\n      this.nativeFile,\r\n      DecoratorFlags.NONE,\r\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\r\n    );\r\n    global.setConstantIntegerValue(value, type);\r\n    this.nativeFile.add(name, global);\r\n  }\r\n\r\n  /** Registers a constant float value within the global scope. */\r\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\r\n    assert(type.isFloatValue);\r\n    var global = new Global(\r\n      name,\r\n      this.nativeFile,\r\n      DecoratorFlags.NONE,\r\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\r\n    );\r\n    global.setConstantFloatValue(value, type);\r\n    this.nativeFile.add(name, global);\r\n  }\r\n\r\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\r\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\r\n    var elementsByName = this.elementsByName;\r\n    if (elementsByName.has(name)) {\r\n      let existing = assert(elementsByName.get(name));\r\n      // NOTE: this is effectively only performed when merging native types with\r\n      // their respective namespaces in std/builtins, but can also trigger when a\r\n      // user has multiple global elements of the same name in different files,\r\n      // which might result in unexpected shared symbols accross files. considering\r\n      // this a wonky feature for now that we might want to revisit later.\r\n      if (existing !== element) {\r\n        let merged = tryMerge(existing, element);\r\n        if (!merged) {\r\n          if (isDeclaredElement(existing.kind)) {\r\n            this.errorRelated(\r\n              DiagnosticCode.Duplicate_identifier_0,\r\n              element.identifierNode.range,\r\n              (<DeclaredElement>existing).declaration.name.range,\r\n              name\r\n            );\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode.Duplicate_identifier_0,\r\n              element.identifierNode.range, name\r\n            );\r\n          }\r\n          return element;\r\n        }\r\n        element = merged;\r\n      }\r\n    }\r\n    elementsByName.set(name, element);\r\n    return element;\r\n  }\r\n\r\n  /** Tries to locate a foreign file given its normalized path. */\r\n  private lookupForeignFile(\r\n    /** Normalized path to the other file. */\r\n    foreignPath: string,\r\n    /** Alternative normalized path to the other file. */\r\n    foreignPathAlt: string\r\n  ): File | null {\r\n    var filesByName = this.filesByName;\r\n    return filesByName.has(foreignPath)\r\n      ? assert(filesByName.get(foreignPath))\r\n      : filesByName.has(foreignPathAlt)\r\n        ? assert(filesByName.get(foreignPathAlt))\r\n        : null;\r\n  }\r\n\r\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\r\n  private lookupForeign(\r\n    /** Identifier within the other file. */\r\n    foreignName: string,\r\n    /** The other file. */\r\n    foreignFile: File,\r\n    /** So far queued exports. */\r\n    queuedExports: Map<File,Map<string,QueuedExport>>\r\n  ): DeclaredElement | null {\r\n    do {\r\n      // check if already resolved\r\n      let element = foreignFile.lookupExport(foreignName);\r\n      if (element) return element;\r\n\r\n      // follow queued exports\r\n      if (queuedExports.has(foreignFile)) {\r\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\r\n        if (fileQueuedExports.has(foreignName)) {\r\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\r\n          let queuedExportForeignPath = queuedExport.foreignPath;\r\n\r\n          // re-exported from another file\r\n          if (queuedExportForeignPath) {\r\n            let otherFile = this.lookupForeignFile(queuedExportForeignPath, assert(queuedExport.foreignPathAlt));\r\n            if (!otherFile) return null;\r\n            foreignName = queuedExport.localIdentifier.text;\r\n            foreignFile = otherFile;\r\n            continue;\r\n          }\r\n\r\n          // exported from this file\r\n          element = foreignFile.lookupInSelf(queuedExport.localIdentifier.text);\r\n          if (element) return element;\r\n        }\r\n      }\r\n      break;\r\n    } while (true);\r\n\r\n    // follow star exports\r\n    var exportsStar = foreignFile.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        let element = this.lookupForeign(foreignName, exportsStar[i], queuedExports);\r\n        if (element) return element;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Validates that only supported decorators are present. */\r\n  private checkDecorators(\r\n    /** Decorators present on an element. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\r\n    acceptedFlags: DecoratorFlags\r\n  ): DecoratorFlags {\r\n    var flags = DecoratorFlags.NONE;\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        let decorator = decorators[i];\r\n        let kind = DecoratorKind.fromNode(decorator.name);\r\n        let flag = DecoratorFlags.fromKind(kind);\r\n        if (flag) {\r\n          if (flag == DecoratorFlags.BUILTIN) {\r\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\r\n              this.error(\r\n                DiagnosticCode.Decorator_0_is_not_valid_here,\r\n                decorator.range, decorator.name.range.toString()\r\n              );\r\n            } else {\r\n              flags |= flag;\r\n            }\r\n          } else if (!(acceptedFlags & flag)) {\r\n            this.error(\r\n              DiagnosticCode.Decorator_0_is_not_valid_here,\r\n              decorator.range, decorator.name.range.toString()\r\n            );\r\n          } else if (flags & flag) {\r\n            this.error(\r\n              DiagnosticCode.Duplicate_decorator,\r\n              decorator.range\r\n            );\r\n          } else {\r\n            flags |= flag;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return flags;\r\n  }\r\n\r\n  /** Initializes a class declaration. */\r\n  private initializeClass(\r\n    /** The declaration to initialize. */\r\n    declaration: ClassDeclaration,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element,\r\n    /** So far queued `extends` clauses. */\r\n    queuedExtends: ClassPrototype[],\r\n    /** So far queued `implements` clauses. */\r\n    queuedImplements: ClassPrototype[]\r\n  ): ClassPrototype | null {\r\n    var name = declaration.name.text;\r\n    var element = new ClassPrototype(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators,\r\n        DecoratorFlags.GLOBAL |\r\n        DecoratorFlags.FINAL |\r\n        DecoratorFlags.UNMANAGED\r\n      )\r\n    );\r\n    if (!parent.add(name, element)) return null;\r\n\r\n    // remember classes that implement interfaces\r\n    var implementsTypes = declaration.implementsTypes;\r\n    if (implementsTypes) {\r\n      let numImplementsTypes = implementsTypes.length;\r\n      if (numImplementsTypes) {\r\n        // cannot implement interfaces when unmanaged\r\n        if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {\r\n          this.error(\r\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\r\n            Range.join(\r\n              declaration.name.range,\r\n              implementsTypes[numImplementsTypes - 1].range\r\n            )\r\n          );\r\n        } else {\r\n          queuedImplements.push(element);\r\n        }\r\n      }\r\n    }\r\n\r\n    // remember classes that extend another class\r\n    if (declaration.extendsType) queuedExtends.push(element);\r\n\r\n    // initialize members\r\n    var memberDeclarations = declaration.members;\r\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\r\n      let memberDeclaration = memberDeclarations[i];\r\n      switch (memberDeclaration.kind) {\r\n        case NodeKind.FIELDDECLARATION: {\r\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\r\n          break;\r\n        }\r\n        case NodeKind.METHODDECLARATION: {\r\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\r\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\r\n            this.initializeProperty(methodDeclaration, element);\r\n          } else {\r\n            let method = this.initializeMethod(methodDeclaration, element);\r\n            if (method !== null && methodDeclaration.name.kind == NodeKind.CONSTRUCTOR) {\r\n              element.constructorPrototype = method;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case NodeKind.INDEXSIGNATURE: break; // ignored for now\r\n        default: assert(false); // class member expected\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Initializes a field of a class or interface. */\r\n  private initializeField(\r\n    /** The declaration to initialize. */\r\n    declaration: FieldDeclaration,\r\n    /** Parent class. */\r\n    parent: ClassPrototype\r\n  ): void {\r\n    var name = declaration.name.text;\r\n    var decorators = declaration.decorators;\r\n    var element: DeclaredElement;\r\n    var acceptedFlags: DecoratorFlags = DecoratorFlags.UNSAFE;\r\n    if (parent.is(CommonFlags.AMBIENT)) {\r\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\r\n    }\r\n    if (declaration.is(CommonFlags.STATIC)) { // global variable\r\n      assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);\r\n      acceptedFlags |= DecoratorFlags.LAZY;\r\n      if (declaration.is(CommonFlags.READONLY)) {\r\n        acceptedFlags |= DecoratorFlags.INLINE;\r\n      }\r\n      element = new Global(\r\n        name,\r\n        parent,\r\n        this.checkDecorators(decorators, acceptedFlags),\r\n        declaration\r\n      );\r\n      if (!parent.add(name, element)) return;\r\n    } else { // actual instance field\r\n      assert(!declaration.isAny(CommonFlags.ABSTRACT | CommonFlags.GET | CommonFlags.SET));\r\n      element = new FieldPrototype(\r\n        name,\r\n        parent,\r\n        declaration,\r\n        this.checkDecorators(decorators, acceptedFlags)\r\n      );\r\n      if (!parent.addInstance(name, element)) return;\r\n    }\r\n  }\r\n\r\n  /** Initializes a method of a class or interface. */\r\n  private initializeMethod(\r\n    /** The declaration to initialize. */\r\n    declaration: MethodDeclaration,\r\n    /** Parent class. */\r\n    parent: ClassPrototype\r\n  ): FunctionPrototype | null {\r\n    var name = declaration.name.text;\r\n    var isStatic = declaration.is(CommonFlags.STATIC);\r\n    var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE;\r\n    if (!declaration.is(CommonFlags.GENERIC)) {\r\n      acceptedFlags |= DecoratorFlags.OPERATOR_BINARY\r\n                    |  DecoratorFlags.OPERATOR_PREFIX\r\n                    |  DecoratorFlags.OPERATOR_POSTFIX;\r\n    }\r\n    if (parent.is(CommonFlags.AMBIENT)) {\r\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\r\n    }\r\n    var element = new FunctionPrototype(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators, acceptedFlags)\r\n    );\r\n    if (isStatic) { // global function\r\n      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);\r\n      if (!parent.add(name, element)) return null;\r\n    } else { // actual instance method\r\n      if (!parent.addInstance(name, element)) return null;\r\n    }\r\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\r\n    return element;\r\n  }\r\n\r\n  /** Checks that operator overloads are generally valid, if present. */\r\n  private checkOperatorOverloads(\r\n    /** Decorators to check. */\r\n    decorators: DecoratorNode[] | null,\r\n    /** Decorated method. */\r\n    prototype: FunctionPrototype,\r\n    /** Parent class. */\r\n    classPrototype: ClassPrototype\r\n  ): void {\r\n    if (decorators) {\r\n      for (let i = 0, k = decorators.length; i < k; ++i) {\r\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\r\n        switch (decorator.decoratorKind) {\r\n          case DecoratorKind.OPERATOR:\r\n          case DecoratorKind.OPERATOR_BINARY:\r\n          case DecoratorKind.OPERATOR_PREFIX:\r\n          case DecoratorKind.OPERATOR_POSTFIX: {\r\n            let args = decorator.args;\r\n            let numArgs = args ? args.length : 0;\r\n            if (numArgs == 1) {\r\n              let firstArg = (<Expression[]>decorator.args)[0];\r\n              if (firstArg.isLiteralKind(LiteralKind.STRING)) {\r\n                let text = (<StringLiteralExpression>firstArg).value;\r\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\r\n                if (kind == OperatorKind.INVALID) {\r\n                  this.error(\r\n                    DiagnosticCode._0_is_not_a_valid_operator,\r\n                    firstArg.range, text\r\n                  );\r\n                } else {\r\n                  let overloads = classPrototype.overloadPrototypes;\r\n                  if (overloads.has(kind)) {\r\n                    this.error(\r\n                      DiagnosticCode.Duplicate_function_implementation,\r\n                      firstArg.range\r\n                    );\r\n                  } else {\r\n                    prototype.operatorKind = kind;\r\n                    overloads.set(kind, prototype);\r\n                  }\r\n                }\r\n              } else {\r\n                this.error(\r\n                  DiagnosticCode.String_literal_expected,\r\n                  firstArg.range\r\n                );\r\n              }\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode.Expected_0_arguments_but_got_1,\r\n                decorator.range, \"1\", numArgs.toString()\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\r\n  private ensureProperty(\r\n    /** The declaration of the getter or setter introducing the property. */\r\n    declaration: MethodDeclaration,\r\n    /** Parent class. */\r\n    parent: ClassPrototype\r\n  ): PropertyPrototype | null {\r\n    var name = declaration.name.text;\r\n    if (declaration.is(CommonFlags.STATIC)) {\r\n      let parentMembers = parent.members;\r\n      if (parentMembers !== null && parentMembers.has(name)) {\r\n        let element = assert(parentMembers.get(name));\r\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\r\n      } else {\r\n        let element = new PropertyPrototype(name, parent, declaration);\r\n        if (!parent.add(name, element)) return null;\r\n        return element;\r\n      }\r\n    } else {\r\n      let parentMembers = parent.instanceMembers;\r\n      if (parentMembers !== null && parentMembers.has(name)) {\r\n        let element = assert(parentMembers.get(name));\r\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\r\n      } else {\r\n        let element = new PropertyPrototype(name, parent, declaration);\r\n        if (!parent.addInstance(name, element)) return null;\r\n        return element;\r\n      }\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Duplicate_property_0,\r\n      declaration.name.range, name\r\n    );\r\n    return null;\r\n  }\r\n\r\n  /** Initializes a property of a class. */\r\n  private initializeProperty(\r\n    /** The declaration of the getter or setter. */\r\n    declaration: MethodDeclaration,\r\n    /** Parent class. */\r\n    parent: ClassPrototype\r\n  ): void {\r\n    var property = this.ensureProperty(declaration, parent);\r\n    if (!property) return;\r\n    var name = declaration.name.text;\r\n    var isGetter = declaration.is(CommonFlags.GET);\r\n    if (isGetter) {\r\n      if (property.getterPrototype) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_property_0,\r\n          declaration.name.range, name\r\n        );\r\n        return;\r\n      }\r\n    } else {\r\n      if (property.setterPrototype) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_property_0,\r\n          declaration.name.range, name\r\n        );\r\n        return;\r\n      }\r\n    }\r\n    var element = new FunctionPrototype(\r\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\r\n      property,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators,\r\n        DecoratorFlags.INLINE | DecoratorFlags.UNSAFE\r\n      )\r\n    );\r\n    if (isGetter) {\r\n      property.getterPrototype = element;\r\n    } else {\r\n      property.setterPrototype = element;\r\n    }\r\n  }\r\n\r\n  /** Initializes an enum. */\r\n  private initializeEnum(\r\n    /** The declaration to initialize. */\r\n    declaration: EnumDeclaration,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element\r\n  ): Enum | null {\r\n    var name = declaration.name.text;\r\n    var element = new Enum(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators,\r\n        DecoratorFlags.GLOBAL |\r\n        DecoratorFlags.INLINE |\r\n        DecoratorFlags.LAZY\r\n      )\r\n    );\r\n    if (!parent.add(name, element)) return null;\r\n    var values = declaration.values;\r\n    for (let i = 0, k = values.length; i < k; ++i) {\r\n      this.initializeEnumValue(values[i], element);\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Initializes an enum value. */\r\n  private initializeEnumValue(\r\n    /** The declaration to initialize. */\r\n    declaration: EnumValueDeclaration,\r\n    /** Parent enum. */\r\n    parent: Enum\r\n  ): void {\r\n    var name = declaration.name.text;\r\n    var element = new EnumValue(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators,\r\n        DecoratorFlags.NONE\r\n      )\r\n    );\r\n    if (!parent.add(name, element)) return;\r\n  }\r\n\r\n  /** Initializes an `export` statement. */\r\n  private initializeExports(\r\n    /** The statement to initialize. */\r\n    statement: ExportStatement,\r\n    /** Parent file. */\r\n    parent: File,\r\n    /** So far queued `export`s. */\r\n    queuedExports: Map<File,Map<string,QueuedExport>>,\r\n    /** So far queued `export *`s. */\r\n    queuedExportsStar: Map<File,QueuedExportStar[]>\r\n  ): void {\r\n    var members = statement.members;\r\n    if (members) { // export { foo, bar } [from \"./baz\"]\r\n      for (let i = 0, k = members.length; i < k; ++i) {\r\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\r\n      }\r\n    } else { // export * from \"./baz\"\r\n      let queued: QueuedExportStar[];\r\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\r\n      else queuedExportsStar.set(parent, queued = []);\r\n      let foreignPath = statement.internalPath!; // must be set for export *\r\n      queued.push(new QueuedExportStar(\r\n        foreignPath,\r\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\r\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\r\n          : foreignPath + INDEX_SUFFIX,\r\n        assert(statement.path)\r\n      ));\r\n    }\r\n  }\r\n\r\n  /** Initializes a single `export` member. Does not handle `export *`. */\r\n  private initializeExport(\r\n    /** The member to initialize. */\r\n    member: ExportMember,\r\n    /** Local file. */\r\n    localFile: File,\r\n    /** Path to the other file, if present. */\r\n    foreignPath: string | null,\r\n    /** So far queued `export`s. */\r\n    queuedExports: Map<File,Map<string,QueuedExport>>\r\n  ): void {\r\n    var localName = member.localName.text;\r\n    var foreignName = member.exportedName.text;\r\n\r\n    // check for duplicates\r\n    var element = localFile.lookupExport(foreignName);\r\n    if (element) {\r\n      this.error(\r\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n        member.exportedName.range, foreignName\r\n      );\r\n      return;\r\n    }\r\n    // local element, i.e. export { foo [as bar] }\r\n    if (foreignPath === null) {\r\n\r\n      // resolve right away if the local element already exists\r\n      if (element = localFile.lookupInSelf(localName)) {\r\n        localFile.ensureExport(foreignName, element);\r\n\r\n      // otherwise queue it\r\n      } else {\r\n        let queued: Map<string,QueuedExport>;\r\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\r\n        else queuedExports.set(localFile, queued = new Map());\r\n        queued.set(foreignName, new QueuedExport(\r\n          member.localName,\r\n          member.exportedName,\r\n          null, null\r\n        ));\r\n      }\r\n\r\n    // foreign element, i.e. export { foo } from \"./bar\"\r\n    } else {\r\n      let queued: Map<string,QueuedExport>;\r\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\r\n      else queuedExports.set(localFile, queued = new Map());\r\n      queued.set(foreignName, new QueuedExport(\r\n        member.localName,\r\n        member.exportedName,\r\n        foreignPath,\r\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\r\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\r\n          : foreignPath + INDEX_SUFFIX\r\n      ));\r\n    }\r\n  }\r\n\r\n  private initializeExportDefault(\r\n    /** The statement to initialize. */\r\n    statement: ExportDefaultStatement,\r\n    /** Parent file. */\r\n    parent: File,\r\n    /** So far queued `extends` clauses. */\r\n    queuedExtends: Array<ClassPrototype>,\r\n    /** So far queued `implements` clauses. */\r\n    queuedImplements: ClassPrototype[]\r\n  ): void {\r\n    var declaration = statement.declaration;\r\n    var element: DeclaredElement | null = null;\r\n    switch (declaration.kind) {\r\n      case NodeKind.ENUMDECLARATION: {\r\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\r\n        break;\r\n      }\r\n      case NodeKind.FUNCTIONDECLARATION: {\r\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\r\n        break;\r\n      }\r\n      case NodeKind.CLASSDECLARATION: {\r\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\r\n        break;\r\n      }\r\n      case NodeKind.INTERFACEDECLARATION: {\r\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\r\n        break;\r\n      }\r\n      case NodeKind.NAMESPACEDECLARATION: {\r\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\r\n        break;\r\n      }\r\n      default: assert(false);\r\n    }\r\n    if (element) {\r\n      let exports = parent.exports;\r\n      if (!exports) parent.exports = exports = new Map();\r\n      else {\r\n        if (exports.has(\"default\")) {\r\n          let existing = assert(exports.get(\"default\"));\r\n          this.errorRelated(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range,\r\n            existing.declaration.name.range,\r\n            \"default\"\r\n          );\r\n          return;\r\n        }\r\n      }\r\n      exports.set(\"default\", element);\r\n    }\r\n  }\r\n\r\n  /** Initializes an `import` statement. */\r\n  private initializeImports(\r\n    /** The statement to initialize. */\r\n    statement: ImportStatement,\r\n    /** Parent file. */\r\n    parent: File,\r\n    /** So far queued `import`s. */\r\n    queuedImports: QueuedImport[],\r\n    /** So far queued `export`s. */\r\n    queuedExports: Map<File,Map<string,QueuedExport>>\r\n  ): void {\r\n    var declarations = statement.declarations;\r\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\r\n      for (let i = 0, k = declarations.length; i < k; ++i) {\r\n        this.initializeImport(\r\n          declarations[i],\r\n          parent,\r\n          statement.internalPath,\r\n          queuedImports,\r\n          queuedExports\r\n        );\r\n      }\r\n    } else {\r\n      let namespaceName = statement.namespaceName;\r\n      if (namespaceName) { // import * as foo from \"./bar\"\r\n        queuedImports.push(new QueuedImport(\r\n          parent,\r\n          namespaceName,\r\n          null, // indicates import *\r\n          statement.internalPath,\r\n          statement.internalPath + INDEX_SUFFIX\r\n        ));\r\n      } else {\r\n        // import \"./foo\"\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\r\n  private initializeImport( // { foo [as bar] }\r\n    /** The declaration to initialize. */\r\n    declaration: ImportDeclaration,\r\n    /** Parent file. */\r\n    parent: File,\r\n    /** Path to the other file. */\r\n    foreignPath: string,\r\n    /** So far queued `import`s. */\r\n    queuedImports: QueuedImport[],\r\n    /** So far queued `export`s. */\r\n    queuedExports: Map<File,Map<string,QueuedExport>>\r\n  ): void {\r\n    var foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\r\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\r\n      : foreignPath + INDEX_SUFFIX;\r\n\r\n    // resolve right away if the element exists\r\n    var foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\r\n    if (foreignFile) {\r\n      var element = this.lookupForeign(declaration.foreignName.text, foreignFile, queuedExports);\r\n      if (element) {\r\n        parent.add(declaration.name.text, element, declaration.name /* isImport */);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // otherwise queue it\r\n    queuedImports.push(new QueuedImport(\r\n      parent,\r\n      declaration.name,\r\n      declaration.foreignName,\r\n      foreignPath,\r\n      foreignPathAlt\r\n    ));\r\n  }\r\n\r\n  /** Initializes a function. Does not handle methods. */\r\n  private initializeFunction(\r\n    /** The declaration to initialize. */\r\n    declaration: FunctionDeclaration,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element\r\n  ): FunctionPrototype | null {\r\n    var name = declaration.name.text;\r\n    var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN;\r\n    if (declaration.is(CommonFlags.AMBIENT)) {\r\n      validDecorators |= DecoratorFlags.EXTERNAL;\r\n    } else {\r\n      validDecorators |= DecoratorFlags.INLINE;\r\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.EXPORT)) {\r\n        validDecorators |= DecoratorFlags.LAZY;\r\n      }\r\n    }\r\n    if (!declaration.is(CommonFlags.INSTANCE)) {\r\n      if (parent.kind != ElementKind.CLASS_PROTOTYPE) {\r\n        validDecorators |= DecoratorFlags.GLOBAL;\r\n      }\r\n    }\r\n    var element = new FunctionPrototype(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators, validDecorators)\r\n    );\r\n    if (!parent.add(name, element)) return null;\r\n    return element;\r\n  }\r\n\r\n  /** Initializes an interface. */\r\n  private initializeInterface(\r\n    /** The declaration to initialize. */\r\n    declaration: InterfaceDeclaration,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element,\r\n    /** So far queued `extends` clauses. */\r\n    queuedExtends: ClassPrototype[],\r\n  ): InterfacePrototype | null {\r\n    var name = declaration.name.text;\r\n    var element = new InterfacePrototype(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators,\r\n        DecoratorFlags.GLOBAL\r\n      )\r\n    );\r\n    if (!parent.add(name, element)) return null;\r\n\r\n    // remember interfaces that extend another interface\r\n    if (declaration.extendsType) queuedExtends.push(element);\r\n\r\n    var memberDeclarations = declaration.members;\r\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\r\n      let memberDeclaration = memberDeclarations[i];\r\n      switch (memberDeclaration.kind) {\r\n        case NodeKind.FIELDDECLARATION: {\r\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\r\n          break;\r\n        }\r\n        case NodeKind.METHODDECLARATION: {\r\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\r\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\r\n            this.initializeProperty(methodDeclaration, element);\r\n          } else {\r\n            this.initializeMethod(methodDeclaration, element);\r\n          }\r\n          break;\r\n        }\r\n        default: assert(false); // interface member expected\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Initializes a field of an interface, as a property. */\r\n  private initializeFieldAsProperty(\r\n    /** Field declaration. */\r\n    declaration: FieldDeclaration,\r\n    /** Parent interface. */\r\n    parent: InterfacePrototype\r\n  ): void {\r\n    var typeNode = declaration.type;\r\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\r\n    this.initializeProperty(\r\n      Node.createMethodDeclaration(\r\n        declaration.name,\r\n        declaration.decorators,\r\n        declaration.flags | CommonFlags.GET,\r\n        null,\r\n        Node.createFunctionType(\r\n          [],\r\n          typeNode,\r\n          null,\r\n          false,\r\n          declaration.range\r\n        ),\r\n        null,\r\n        declaration.range\r\n      ),\r\n      parent\r\n    );\r\n    if (!declaration.is(CommonFlags.READONLY)) {\r\n      this.initializeProperty(\r\n        Node.createMethodDeclaration(\r\n          declaration.name,\r\n          declaration.decorators,\r\n          declaration.flags | CommonFlags.SET,\r\n          null,\r\n          Node.createFunctionType(\r\n            [\r\n              Node.createParameter(\r\n                ParameterKind.DEFAULT,\r\n                declaration.name,\r\n                typeNode,\r\n                null,\r\n                declaration.name.range\r\n              )\r\n            ],\r\n            Node.createOmittedType(declaration.name.range.atEnd),\r\n            null,\r\n            false,\r\n            declaration.range\r\n          ),\r\n          null,\r\n          declaration.range\r\n        ),\r\n        parent\r\n      );\r\n    }\r\n  }\r\n\r\n  /** Initializes a namespace. */\r\n  private initializeNamespace(\r\n    /** The declaration to initialize. */\r\n    declaration: NamespaceDeclaration,\r\n    /** Parent element, usually a file or another namespace. */\r\n    parent: Element,\r\n    /** So far queued `extends` clauses. */\r\n    queuedExtends: ClassPrototype[],\r\n    /** So far queued `implements` clauses. */\r\n    queuedImplements: ClassPrototype[]\r\n  ): DeclaredElement | null {\r\n    var name = declaration.name.text;\r\n    var original = new Namespace(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL)\r\n    );\r\n    if (!parent.add(name, original)) return null;\r\n    var element = assert(parent.lookupInSelf(name)); // possibly merged\r\n    var members = declaration.members;\r\n    for (let i = 0, k = members.length; i < k; ++i) {\r\n      let member = members[i];\r\n      switch (member.kind) {\r\n        case NodeKind.CLASSDECLARATION: {\r\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\r\n          break;\r\n        }\r\n        case NodeKind.ENUMDECLARATION: {\r\n          this.initializeEnum(<EnumDeclaration>member, original);\r\n          break;\r\n        }\r\n        case NodeKind.FUNCTIONDECLARATION: {\r\n          this.initializeFunction(<FunctionDeclaration>member, original);\r\n          break;\r\n        }\r\n        case NodeKind.INTERFACEDECLARATION: {\r\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\r\n          break;\r\n        }\r\n        case NodeKind.NAMESPACEDECLARATION: {\r\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\r\n          break;\r\n        }\r\n        case NodeKind.TYPEDECLARATION: {\r\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\r\n          break;\r\n        }\r\n        case NodeKind.VARIABLE: {\r\n          this.initializeVariables(<VariableStatement>member, original);\r\n          break;\r\n        }\r\n        default: assert(false); // namespace member expected\r\n      }\r\n    }\r\n    if (original != element) copyMembers(original, element); // keep original parent\r\n    return element;\r\n  }\r\n\r\n  /** Initializes a `type` definition. */\r\n  private initializeTypeDefinition(\r\n    /** The declaration to initialize. */\r\n    declaration: TypeDeclaration,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element\r\n  ): void {\r\n    var name = declaration.name.text;\r\n    var element = new TypeDefinition(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      this.checkDecorators(declaration.decorators, DecoratorFlags.NONE)\r\n    );\r\n    parent.add(name, element); // reports\r\n  }\r\n\r\n  /** Initializes a variable statement. */\r\n  private initializeVariables(\r\n    /** The statement to initialize. */\r\n    statement: VariableStatement,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element\r\n  ): void {\r\n    var declarations = statement.declarations;\r\n    for (let i = 0, k = declarations.length; i < k; ++i) {\r\n      let declaration = declarations[i];\r\n      let name = declaration.name.text;\r\n      let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;\r\n      if (declaration.is(CommonFlags.DECLARE)) {\r\n        acceptedFlags |= DecoratorFlags.EXTERNAL;\r\n      }\r\n      if (declaration.is(CommonFlags.CONST)) {\r\n        acceptedFlags |= DecoratorFlags.INLINE;\r\n      }\r\n      let element = new Global(\r\n        name,\r\n        parent,\r\n        this.checkDecorators(declaration.decorators, acceptedFlags),\r\n        declaration\r\n      );\r\n      if (!parent.add(name, element)) continue; // reports\r\n    }\r\n  }\r\n\r\n  /** Determines the element type of a built-in array. */\r\n  // determineBuiltinArrayType(target: Class): Type | null {\r\n  //   switch (target.internalName) {\r\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\r\n  //     case BuiltinSymbols.Uint8ClampedArray:\r\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\r\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\r\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\r\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\r\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\r\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\r\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\r\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\r\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\r\n  //   }\r\n  //   var current: Class | null = target;\r\n  //   var arrayPrototype = this.arrayPrototype;\r\n  //   do {\r\n  //     if (current.prototype == arrayPrototype) { // Array<T>\r\n  //       let typeArguments = assert(current.typeArguments);\r\n  //       assert(typeArguments.length == 1);\r\n  //       return typeArguments[0];\r\n  //     }\r\n  //   } while (current = current.base);\r\n  //   return null;\r\n  // }\r\n}\r\n\r\n/** Indicates the specific kind of an {@link Element}. */\r\nexport enum ElementKind {\r\n  /** A {@link Global}. */\r\n  GLOBAL,\r\n  /** A {@link Local}. */\r\n  LOCAL,\r\n  /** An {@link Enum}. */\r\n  ENUM,\r\n  /** An {@link EnumValue}. */\r\n  ENUMVALUE,\r\n  /** A {@link FunctionPrototype}. */\r\n  FUNCTION_PROTOTYPE,\r\n  /** A {@link Function}. */\r\n  FUNCTION,\r\n  /** A {@link ClassPrototype}. */\r\n  CLASS_PROTOTYPE,\r\n  /** A {@link Class}. */\r\n  CLASS,\r\n  /** An {@link InterfacePrototype}. */\r\n  INTERFACE_PROTOTYPE,\r\n  /** An {@link Interface}. */\r\n  INTERFACE,\r\n  /** A {@link FieldPrototype}. */\r\n  FIELD_PROTOTYPE,\r\n  /** A {@link Field}. */\r\n  FIELD,\r\n  /** A {@link PropertyPrototype}.  */\r\n  PROPERTY_PROTOTYPE,\r\n  /** A {@link Property}. */\r\n  PROPERTY,\r\n  /** A {@link Namespace}. */\r\n  NAMESPACE,\r\n  /** A {@link File}. */\r\n  FILE,\r\n  /** A {@link TypeDefinition}.  */\r\n  TYPEDEFINITION,\r\n  /** An {@link IndexSignature}. */\r\n  INDEXSIGNATURE\r\n}\r\n\r\n/** Indicates built-in decorators that are present. */\r\nexport enum DecoratorFlags {\r\n  /** No flags set. */\r\n  NONE = 0,\r\n  /** Is a program global. */\r\n  GLOBAL = 1 << 0,\r\n  /** Is a binary operator overload. */\r\n  OPERATOR_BINARY = 1 << 1,\r\n  /** Is a unary prefix operator overload. */\r\n  OPERATOR_PREFIX = 1 << 2,\r\n  /** Is a unary postfix operator overload. */\r\n  OPERATOR_POSTFIX = 1 << 3,\r\n  /** Is an unmanaged class. */\r\n  UNMANAGED = 1 << 4,\r\n  /** Is a final class. */\r\n  FINAL = 1 << 5,\r\n  /** Is always inlined. */\r\n  INLINE = 1 << 6,\r\n  /** Is using a different external name. */\r\n  EXTERNAL = 1 << 7,\r\n  /** Is a builtin. */\r\n  BUILTIN = 1 << 8,\r\n  /** Is compiled lazily. */\r\n  LAZY = 1 << 9,\r\n  /** Is considered unsafe code. */\r\n  UNSAFE = 1 << 10\r\n}\r\n\r\nexport namespace DecoratorFlags {\r\n\r\n  /** Translates a decorator kind to the respective decorator flag. */\r\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\r\n    switch (kind) {\r\n      case DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;\r\n      case DecoratorKind.OPERATOR:\r\n      case DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;\r\n      case DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;\r\n      case DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;\r\n      case DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;\r\n      case DecoratorKind.FINAL: return DecoratorFlags.FINAL;\r\n      case DecoratorKind.INLINE: return DecoratorFlags.INLINE;\r\n      case DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;\r\n      case DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;\r\n      case DecoratorKind.LAZY: return DecoratorFlags.LAZY;\r\n      case DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;\r\n      default: return DecoratorFlags.NONE;\r\n    }\r\n  }\r\n}\r\n\r\n/** Base class of all program elements. */\r\nexport abstract class Element {\r\n\r\n  /** Parent element. */\r\n  parent!: Element;\r\n  /** Common flags indicating specific traits. */\r\n  flags: CommonFlags = CommonFlags.NONE;\r\n  /** Decorator flags indicating annotated traits. */\r\n  decoratorFlags: DecoratorFlags = DecoratorFlags.NONE;\r\n  /** Member elements. */\r\n  members: Map<string,DeclaredElement> | null = null;\r\n  /** Shadowing type in type space, if any. */\r\n  shadowType: TypeDefinition | null = null;\r\n\r\n  /** Constructs a new program element. */\r\n  protected constructor(\r\n    /** Specific element kind. */\r\n    public kind: ElementKind,\r\n    /** Simple name. */\r\n    public name: string,\r\n    /** Internal name referring to this element. */\r\n    public internalName: string,\r\n    /** Containing {@link Program}. */\r\n    public program: Program,\r\n    /** Parent element. */\r\n    parent: Element | null\r\n  ) {\r\n    this.program = program;\r\n    this.name = name;\r\n    this.internalName = internalName;\r\n    if (parent) {\r\n      this.parent = parent;\r\n    } else {\r\n      assert(this.kind == ElementKind.FILE);\r\n      this.parent = this; // special case to keep this.parent non-nullable\r\n    }\r\n  }\r\n\r\n  /** Gets the enclosing file. */\r\n  get file(): File {\r\n    var current: Element = this;\r\n    do {\r\n      current = current.parent;\r\n      if (current.kind == ElementKind.FILE) return <File>current;\r\n    } while (true);\r\n  }\r\n\r\n  /** Tests if this element has a specific flag or flags. */\r\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\r\n  /** Tests if this element has any of the specified flags. */\r\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\r\n  /** Sets a specific flag or flags. */\r\n  set(flag: CommonFlags): void { this.flags |= flag; }\r\n  /** Unsets the specific flag or flags. */\r\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\r\n  /** Tests if this element has a specific decorator flag or flags. */\r\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\r\n\r\n  /** Looks up the element with the specified name within this element. */\r\n  lookupInSelf(name: string): DeclaredElement | null {\r\n    var members = this.members;\r\n    if (members !== null && members.has(name)) return assert(members.get(name));\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the element with the specified name relative to this element, like in JS. */\r\n  abstract lookup(name: string): Element | null;\r\n\r\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\r\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\r\n    var originalDeclaration = element.declaration;\r\n    var members = this.members;\r\n    if (!members) this.members = members = new Map();\r\n    else if (members.has(name)) {\r\n      let existing = assert(members.get(name));\r\n      if (existing.parent !== this) {\r\n        // override non-own element\r\n      } else {\r\n        let merged = tryMerge(existing, element);\r\n        if (merged) {\r\n          element = merged; // use merged element\r\n        } else {\r\n          let reportedIdentifier = localIdentifierIfImport\r\n            ? localIdentifierIfImport\r\n            : element.identifierNode;\r\n          if (isDeclaredElement(existing.kind)) {\r\n            this.program.errorRelated(\r\n              DiagnosticCode.Duplicate_identifier_0,\r\n              reportedIdentifier.range,\r\n              (<DeclaredElement>existing).identifierNode.range,\r\n              reportedIdentifier.text\r\n            );\r\n          } else {\r\n            this.program.error(\r\n              DiagnosticCode.Duplicate_identifier_0,\r\n              reportedIdentifier.range, reportedIdentifier.text\r\n            );\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    members.set(name, element);\r\n    var program = this.program;\r\n    if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !(<FunctionPrototype>element).isBound) {\r\n      // prefer unbound prototypes in global lookup maps\r\n      program.elementsByName.set(element.internalName, element);\r\n      program.elementsByDeclaration.set(originalDeclaration, element);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Checks if this element is public, explicitly or implicitly. */\r\n  get isPublic(): bool {\r\n    return !this.isAny(CommonFlags.PRIVATE | CommonFlags.PROTECTED);\r\n  }\r\n\r\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\r\n  get isImplicitlyPublic(): bool {\r\n    return this.isPublic && !this.is(CommonFlags.PUBLIC);\r\n  }\r\n\r\n  /** Checks if the visibility of this element equals the specified. */\r\n  visibilityEquals(other: Element): bool {\r\n    if (this.isPublic == other.isPublic) return true;\r\n    const vis = CommonFlags.PRIVATE | CommonFlags.PROTECTED;\r\n    return (this.flags & vis) == (other.flags & vis);\r\n  }\r\n\r\n  /** Returns a string representation of this element. */\r\n  toString(): string {\r\n    return this.internalName + \", kind=\" + this.kind.toString();\r\n  }\r\n}\r\n\r\n// Kinds of all declared elements\r\nvar declaredElements = new Set<ElementKind>();\r\n\r\n/** Tests if the specified element kind indicates a declared element. */\r\nexport function isDeclaredElement(kind: ElementKind): bool {\r\n  return declaredElements.has(kind);\r\n}\r\n\r\n/** Base class of elements with an associated declaration statement. */\r\nexport abstract class DeclaredElement extends Element {\r\n\r\n  /** Constructs a new declared program element. */\r\n  protected constructor(\r\n    /** Specific element kind. */\r\n    kind: ElementKind,\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Internal name referring to this element. */\r\n    internalName: string,\r\n    /** Containing {@link Program}. */\r\n    program: Program,\r\n    /** Parent element. */\r\n    parent: Element | null,\r\n    /** Declaration reference. */\r\n    public declaration: DeclarationStatement\r\n  ) {\r\n    super(kind, name, internalName, program, parent);\r\n    declaredElements.add(kind);\r\n    // It is necessary to have access to identifiers of all members and exports\r\n    // for reporting purposes and this is the lowest common denominator. Comes\r\n    // at the expense of not having more specific type information in derived\r\n    // classes, though. Instead, derived classes implement getters for other\r\n    // important AST nodes directly through manual casting, allowing the resolver\r\n    // etc. to not worry about actual declarations.\r\n    this.declaration = declaration;\r\n    this.flags = declaration.flags; // inherit\r\n  }\r\n\r\n  /** Tests if this element is a library element. */\r\n  get isDeclaredInLibrary(): bool {\r\n    return this.declaration.range.source.isLibrary;\r\n  }\r\n\r\n  /** Gets the associated identifier node. */\r\n  get identifierNode(): IdentifierExpression {\r\n    return this.declaration.name;\r\n  }\r\n\r\n  /** Gets the signature node, if applicable, along the identifier node. */\r\n  get identifierAndSignatureRange(): Range {\r\n    var declaration = this.declaration;\r\n    var identifierNode = declaration.name;\r\n    if (declaration.kind == NodeKind.FUNCTIONDECLARATION || declaration.kind == NodeKind.METHODDECLARATION) {\r\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\r\n      return Range.join(identifierNode.range, signatureNode.range);\r\n    }\r\n    return identifierNode.range;\r\n  }\r\n\r\n  /** Gets the assiciated decorator nodes. */\r\n  get decoratorNodes(): DecoratorNode[] | null {\r\n    return this.declaration.decorators;\r\n  }\r\n\r\n  /** Checks if this element is a compatible override of the specified. */\r\n  isCompatibleOverride(base: DeclaredElement): bool {\r\n    var self: DeclaredElement = this; // TS\r\n    var kind = self.kind;\r\n    if (kind == base.kind) {\r\n      switch (kind) {\r\n        case ElementKind.FUNCTION: {\r\n          return (<Function>self).signature.isAssignableTo((<Function>base).signature, /* sameSize */ true);\r\n        }\r\n        case ElementKind.PROPERTY: {\r\n          let selfProperty = <Property>self;\r\n          let baseProperty = <Property>base;\r\n          let selfGetter = selfProperty.getterInstance;\r\n          let baseGetter = baseProperty.getterInstance;\r\n          if (selfGetter) {\r\n            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {\r\n              return false;\r\n            }\r\n          } else if (baseGetter) {\r\n            return false;\r\n          }\r\n          let selfSetter = selfProperty.setterInstance;\r\n          let baseSetter = baseProperty.setterInstance;\r\n          if (selfSetter) {\r\n            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {\r\n              return false;\r\n            }\r\n          } else if (baseSetter) {\r\n            return false;\r\n          }\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n\r\n// Kinds of all typed elements\r\nvar typedElements = new Set<ElementKind>();\r\n\r\n/** Checks if the specified element kind indicates a typed element. */\r\nexport function isTypedElement(kind: ElementKind): bool {\r\n  return typedElements.has(kind);\r\n}\r\n\r\n/** Base class of elements that can be resolved to a concrete type. */\r\nexport abstract class TypedElement extends DeclaredElement {\r\n\r\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\r\n  type: Type = Type.void;\r\n\r\n  constructor(\r\n    /** Specific element kind. */\r\n    kind: ElementKind,\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Internal name referring to this element. */\r\n    internalName: string,\r\n    /** Containing {@link Program}. */\r\n    program: Program,\r\n    /** Parent element. */\r\n    parent: Element | null,\r\n    /** Declaration reference. */\r\n    declaration: DeclarationStatement\r\n  ) {\r\n    super(kind, name, internalName, program, parent, declaration);\r\n    typedElements.add(kind);\r\n  }\r\n\r\n  /** Sets the resolved type of this element. */\r\n  setType(type: Type): void {\r\n    assert(!this.is(CommonFlags.RESOLVED));\r\n    this.type = type;\r\n    this.set(CommonFlags.RESOLVED);\r\n  }\r\n}\r\n\r\n/** A file representing the implicit top-level namespace of a source. */\r\nexport class File extends Element {\r\n\r\n  /** File exports. */\r\n  exports: Map<string,DeclaredElement> | null = null;\r\n  /** File re-exports. */\r\n  exportsStar: File[] | null = null;\r\n  /** Top-level start function of this file. */\r\n  startFunction!: Function;\r\n  /** Array of `import * as X` alias namespaces of this file. */\r\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\r\n\r\n  /** Constructs a new file. */\r\n  constructor(\r\n    /** Program this file belongs to. */\r\n    program: Program,\r\n    /** Source of this file. */\r\n    public source: Source\r\n  ) {\r\n    super(\r\n      ElementKind.FILE,\r\n      source.normalizedPath,\r\n      source.internalPath,\r\n      program,\r\n      null // special case for files\r\n    );\r\n    this.source = source;\r\n    assert(!program.filesByName.has(this.internalName));\r\n    program.filesByName.set(this.internalName, this);\r\n    var startFunction = this.program.makeNativeFunction(\r\n      \"start:\" + this.internalName,\r\n      new Signature(program, null, Type.void),\r\n      this\r\n    );\r\n    startFunction.internalName = startFunction.name;\r\n    this.startFunction = startFunction;\r\n  }\r\n\r\n  /* @override */\r\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\r\n    if (element.hasDecorator(DecoratorFlags.GLOBAL)) {\r\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\r\n    }\r\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\r\n    element = assert(this.lookupInSelf(name)); // possibly merged locally\r\n    if (element.is(CommonFlags.EXPORT) && !localIdentifierIfImport) {\r\n      this.ensureExport(\r\n        element.name,\r\n        element\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /* @override */\r\n  lookupInSelf(name: string): DeclaredElement | null {\r\n    var element = super.lookupInSelf(name);\r\n    if (element) return element;\r\n    var exportsStar = this.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        if (element = exportsStar[i].lookupInSelf(name)) return element;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    var element = this.lookupInSelf(name);\r\n    if (element) return element;\r\n    return this.program.lookup(name);\r\n  }\r\n\r\n  /** Ensures that an element is an export of this file. */\r\n  ensureExport(name: string, element: DeclaredElement): void {\r\n    var exports = this.exports;\r\n    if (!exports) this.exports = exports = new Map();\r\n    exports.set(name, element);\r\n    if (this.source.sourceKind == SourceKind.LIBRARY_ENTRY) this.program.ensureGlobal(name, element);\r\n\r\n    // Also, add to the namespaces that capture our exports\r\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\r\n      let ns = this.aliasNamespaces[i];\r\n      ns.add(name, element);\r\n    }\r\n  }\r\n\r\n  /** Ensures that another file is a re-export of this file. */\r\n  ensureExportStar(file: File): void {\r\n    var exportsStar = this.exportsStar;\r\n    if (!exportsStar) this.exportsStar = exportsStar = [];\r\n    else if (exportsStar.includes(file)) return;\r\n    exportsStar.push(file);\r\n  }\r\n\r\n  /** Looks up the export of the specified name. */\r\n  lookupExport(name: string): DeclaredElement | null {\r\n    var exports = this.exports;\r\n    if (exports !== null && exports.has(name)) return assert(exports.get(name));\r\n    var exportsStar = this.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        let element = exportsStar[i].lookupExport(name);\r\n        if (element) return element;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Creates an imported namespace from this file. */\r\n  asAliasNamespace(\r\n    name: string,\r\n    parent: Element,\r\n    localIdentifier: IdentifierExpression\r\n  ): Namespace {\r\n    var declaration = this.program.makeNativeNamespaceDeclaration(name);\r\n    declaration.name = localIdentifier;\r\n    var ns = new Namespace(name, parent, declaration);\r\n    ns.set(CommonFlags.SCOPED);\r\n    this.copyExportsToNamespace(ns);\r\n    // NOTE: Some exports are still queued, and can't yet be added here,\r\n    // so we remember all the alias namespaces and add to them as well\r\n    // when adding an element to the file.\r\n    this.aliasNamespaces.push(ns);\r\n    return ns;\r\n  }\r\n\r\n  /** Recursively copies the exports of this file to the specified namespace. */\r\n  private copyExportsToNamespace(ns: Namespace): void {\r\n    var exports = this.exports;\r\n    if (exports) {\r\n      // TODO: for (let [memberName, member] of exports) {\r\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\r\n        let memberName = unchecked(_keys[i]);\r\n        let member = assert(exports.get(memberName));\r\n        ns.add(memberName, member);\r\n      }\r\n    }\r\n    var exportsStar = this.exportsStar;\r\n    if (exportsStar) {\r\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\r\n        exportsStar[i].copyExportsToNamespace(ns);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** A type definition. */\r\nexport class TypeDefinition extends TypedElement {\r\n\r\n  /** Constructs a new type definition. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element,\r\n    /** Declaration reference. */\r\n    declaration: TypeDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ) {\r\n    super(\r\n      ElementKind.TYPEDEFINITION,\r\n      name,\r\n      mangleInternalName(name, parent, false),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n  }\r\n\r\n  /** Gets the associated type parameter nodes. */\r\n  get typeParameterNodes(): TypeParameterNode[] | null {\r\n    return (<TypeDeclaration>this.declaration).typeParameters;\r\n  }\r\n\r\n  /** Gets the associated type node. */\r\n  get typeNode(): TypeNode {\r\n    return (<TypeDeclaration>this.declaration).type;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A namespace that differs from a file in being user-declared with a name. */\r\nexport class Namespace extends DeclaredElement {\r\n\r\n  /** Constructs a new namespace. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element, usually a file or another namespace. */\r\n    parent: Element,\r\n    /** Declaration reference. */\r\n    declaration: NamespaceDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ) {\r\n    super(\r\n      ElementKind.NAMESPACE,\r\n      name,\r\n      mangleInternalName(name, parent, false),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    var inSelf = this.lookupInSelf(name);\r\n    if (inSelf) return inSelf;\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** An enum. */\r\nexport class Enum extends TypedElement {\r\n\r\n  /** Constructs a new enum. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element,\r\n    /** Declaration reference. */\r\n    declaration: EnumDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ) {\r\n    super(\r\n      ElementKind.ENUM,\r\n      name,\r\n      mangleInternalName(name, parent, false),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n    this.setType(Type.i32);\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    var inSelf = this.lookupInSelf(name);\r\n    if (inSelf) return inSelf;\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** Indicates the kind of an inlined constant value. */\r\nexport const enum ConstantValueKind {\r\n  /** No constant value. */\r\n  NONE,\r\n  /** Constant integer value. */\r\n  INTEGER,\r\n  /** Constant float value. */\r\n  FLOAT\r\n}\r\n\r\n/** Base class of all variable-like program elements. */\r\nexport abstract class VariableLikeElement extends TypedElement {\r\n\r\n  /** Constant value kind. */\r\n  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;\r\n  /** Constant integer value, if applicable. */\r\n  constantIntegerValue: i64 = i64_zero;\r\n  /** Constant float value, if applicable. */\r\n  constantFloatValue: f64 = 0;\r\n\r\n  /** Constructs a new variable-like element. */\r\n  protected constructor(\r\n    /** Specific element kind. */\r\n    kind: ElementKind,\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element, usually a file, namespace or class. */\r\n    parent: Element,\r\n    /** Declaration reference. Creates a native declaration if omitted. */\r\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\r\n  ) {\r\n    super(\r\n      kind,\r\n      name,\r\n      mangleInternalName(name, parent, false),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.flags = declaration.flags;\r\n  }\r\n\r\n  /** Gets the associated type node.s */\r\n  get typeNode(): TypeNode | null {\r\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\r\n  }\r\n\r\n  /** Gets the associated initializer node. */\r\n  get initializerNode(): Expression | null {\r\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\r\n  }\r\n\r\n  /** Applies a constant integer value to this element. */\r\n  setConstantIntegerValue(value: i64, type: Type): void {\r\n    assert(type.isIntegerInclReference);\r\n    this.type = type;\r\n    this.constantValueKind = ConstantValueKind.INTEGER;\r\n    this.constantIntegerValue = value;\r\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\r\n  }\r\n\r\n  /** Applies a constant float value to this element. */\r\n  setConstantFloatValue(value: f64, type: Type): void {\r\n    assert(type.isFloatValue);\r\n    this.type = type;\r\n    this.constantValueKind = ConstantValueKind.FLOAT;\r\n    this.constantFloatValue = value;\r\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\r\n  }\r\n\r\n  /** @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** An enum value. */\r\nexport class EnumValue extends VariableLikeElement {\r\n\r\n  /** Constructs a new enum value. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent enum. */\r\n    parent: Enum,\r\n    /** Declaration reference. */\r\n    declaration: EnumValueDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ) {\r\n    super(\r\n      ElementKind.ENUMVALUE,\r\n      name,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n    this.setType(Type.i32);\r\n  }\r\n\r\n  /** Whether this enum value is immutable. */\r\n  isImmutable: bool = false;\r\n\r\n  /** Gets the associated value node. */\r\n  get valueNode(): Expression | null {\r\n    return (<EnumValueDeclaration>this.declaration).initializer;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A global variable. */\r\nexport class Global extends VariableLikeElement {\r\n\r\n  /** Constructs a new global variable. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element, usually a file, namespace or static class. */\r\n    parent: Element,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags,\r\n    /** Declaration reference. Creates a native declaration if omitted. */\r\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\r\n  ) {\r\n    super(\r\n      ElementKind.GLOBAL,\r\n      name,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n  }\r\n}\r\n\r\n/** A function parameter. */\r\nexport class Parameter {\r\n  /** Constructs a new function parameter. */\r\n  constructor(\r\n    /** Parameter name. */\r\n    public name: string,\r\n    /** Parameter type. */\r\n    public type: Type,\r\n    /** Parameter initializer, if present. */\r\n    public initializer: Expression | null = null\r\n  ) {}\r\n}\r\n\r\n/** A local variable. */\r\nexport class Local extends VariableLikeElement {\r\n\r\n  /** Original name of the (temporary) local. */\r\n  private originalName: string;\r\n\r\n  /** Constructs a new local variable. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */\r\n    public index: i32,\r\n    /** Resolved type. */\r\n    type: Type,\r\n    /** Parent function. */\r\n    parent: Function,\r\n    /** Declaration reference. */\r\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\r\n  ) {\r\n    super(\r\n      ElementKind.LOCAL,\r\n      name,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.originalName = name;\r\n    this.index = index;\r\n    assert(type != Type.void);\r\n    this.setType(type);\r\n  }\r\n\r\n  /** Sets the temporary name of this local. */\r\n  setTemporaryName(name: string): void {\r\n    this.name = name;\r\n    this.internalName = mangleInternalName(name, this.parent, false);\r\n  }\r\n\r\n  /** Resets the temporary name of this local. */\r\n  resetTemporaryName(): void {\r\n    var name = this.originalName;\r\n    this.name = name;\r\n    this.internalName = mangleInternalName(name, this.parent, false);\r\n  }\r\n}\r\n\r\n/** A yet unresolved function prototype. */\r\nexport class FunctionPrototype extends DeclaredElement {\r\n\r\n  /** Operator kind, if an overload. */\r\n  operatorKind: OperatorKind = OperatorKind.INVALID;\r\n  /** Already resolved instances. */\r\n  instances: Map<string,Function> | null = null;\r\n  /** Methods overloading this one, if any. These are unbound. */\r\n  overloads: Set<FunctionPrototype> | null = null;\r\n\r\n  /** Clones of this prototype that are bounds to specific classes. */\r\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\r\n\r\n  /** Constructs a new function prototype. */\r\n  constructor(\r\n    /** Simple name */\r\n    name: string,\r\n    /** Parent element, usually a file, namespace or class (if a method). */\r\n    parent: Element,\r\n    /** Declaration reference. */\r\n    declaration: FunctionDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ) {\r\n    super(\r\n      ElementKind.FUNCTION_PROTOTYPE,\r\n      name,\r\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n  }\r\n\r\n  /** Gets the associated type parameter nodes. */\r\n  get typeParameterNodes(): TypeParameterNode[] | null {\r\n    return (<FunctionDeclaration>this.declaration).typeParameters;\r\n  }\r\n\r\n  /** Gets the associated function type node. */\r\n  get functionTypeNode(): FunctionTypeNode {\r\n    return (<FunctionDeclaration>this.declaration).signature;\r\n  }\r\n\r\n  /** Gets the associated body node. */\r\n  get bodyNode(): Statement | null {\r\n    return (<FunctionDeclaration>this.declaration).body;\r\n  }\r\n\r\n  /** Gets the arrow function kind. */\r\n  get arrowKind(): ArrowKind {\r\n    return (<FunctionDeclaration>this.declaration).arrowKind;\r\n  }\r\n\r\n  /** Tests if this prototype is bound to a class. */\r\n  get isBound(): bool {\r\n    var parent = this.parent;\r\n    return parent.kind == ElementKind.CLASS ||\r\n           parent.kind == ElementKind.PROPERTY_PROTOTYPE && (\r\n             parent.parent.kind == ElementKind.CLASS ||\r\n             parent.parent.kind == ElementKind.INTERFACE\r\n           );\r\n  }\r\n\r\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\r\n  toBound(classInstance: Class): FunctionPrototype {\r\n    assert(this.is(CommonFlags.INSTANCE));\r\n    assert(!this.isBound);\r\n    var boundPrototypes = this.boundPrototypes;\r\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\r\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\r\n    var declaration = this.declaration;\r\n    assert(declaration.kind == NodeKind.METHODDECLARATION);\r\n    var bound = new FunctionPrototype(\r\n      this.name,\r\n      classInstance, // !\r\n      <MethodDeclaration>declaration,\r\n      this.decoratorFlags\r\n    );\r\n    bound.flags = this.flags;\r\n    bound.operatorKind = this.operatorKind;\r\n    bound.overloads = this.overloads;\r\n    // NOTE: this.instances holds instances per bound class / unbound\r\n    boundPrototypes.set(classInstance, bound);\r\n    return bound;\r\n  }\r\n\r\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\r\n  getResolvedInstance(instanceKey: string): Function | null {\r\n    var instances = this.instances;\r\n    if (instances !== null && instances.has(instanceKey)) return assert(instances.get(instanceKey));\r\n    return null;\r\n  }\r\n\r\n  /** Sets the resolved instance for the specified instance key. */\r\n  setResolvedInstance(instanceKey: string, instance: Function): void {\r\n    var instances = this.instances;\r\n    if (!instances) this.instances = instances = new Map();\r\n    else assert(!instances.has(instanceKey));\r\n    instances.set(instanceKey, instance);\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A resolved function. */\r\nexport class Function extends TypedElement {\r\n\r\n  /** Function prototype. */\r\n  prototype: FunctionPrototype;\r\n  /** Function signature. */\r\n  signature: Signature;\r\n  /** Map of locals by name. */\r\n  localsByName: Map<string,Local> = new Map();\r\n  /** Array of locals by index. */\r\n  localsByIndex: Local[] = [];\r\n  /** List of additional non-parameter locals. */\r\n  additionalLocals: Type[] = [];\r\n  /** Concrete type arguments. */\r\n  typeArguments: Type[] | null;\r\n  /** Contextual type arguments. */\r\n  contextualTypeArguments: Map<string,Type> | null;\r\n  /** Default control flow. */\r\n  flow!: Flow;\r\n  /** Remembered debug locations. */\r\n  debugLocations: Range[] = [];\r\n  /** Function reference, if compiled. */\r\n  ref: FunctionRef = 0;\r\n  /** Varargs stub for calling with omitted arguments. */\r\n  varargsStub: Function | null = null;\r\n  /** Virtual stub for calling overloads. */\r\n  virtualStub: Function | null = null;\r\n  /** Runtime memory segment, if created. */\r\n  memorySegment: MemorySegment | null = null;\r\n  /** Original function, if a stub. Otherwise `this`. */\r\n  original!: Function;\r\n\r\n  /** Counting id of inline operations involving this function. */\r\n  nextInlineId: i32 = 0;\r\n  /** Counting id of anonymous inner functions. */\r\n  nextAnonymousId: i32 = 0;\r\n\r\n  /** Constructs a new concrete function. */\r\n  constructor(\r\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\r\n    nameInclTypeParameters: string,\r\n    /** Respective function prototype. */\r\n    prototype: FunctionPrototype,\r\n    /** Concrete type arguments. */\r\n    typeArguments: Type[] | null,\r\n    /** Concrete signature. */\r\n    signature: Signature, // pre-resolved\r\n    /** Contextual type arguments inherited from its parent class, if any. */\r\n    contextualTypeArguments: Map<string,Type> | null = null\r\n  ) {\r\n    super(\r\n      ElementKind.FUNCTION,\r\n      nameInclTypeParameters,\r\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\r\n      prototype.program,\r\n      prototype.parent,\r\n      prototype.declaration\r\n    );\r\n    this.prototype = prototype;\r\n    this.typeArguments = typeArguments;\r\n    this.signature = signature;\r\n    this.flags = prototype.flags | CommonFlags.RESOLVED;\r\n    this.decoratorFlags = prototype.decoratorFlags;\r\n    this.contextualTypeArguments = contextualTypeArguments;\r\n    this.original = this;\r\n    var program = prototype.program;\r\n    this.type = signature.type;\r\n    if (!prototype.is(CommonFlags.AMBIENT)) {\r\n      let localIndex = 0;\r\n      let thisType = signature.thisType;\r\n      if (thisType) {\r\n        let local = new Local(\r\n          CommonNames.this_,\r\n          localIndex++,\r\n          thisType,\r\n          this\r\n        );\r\n        this.localsByName.set(CommonNames.this_, local);\r\n        this.localsByIndex[local.index] = local;\r\n      }\r\n      let parameterTypes = signature.parameterTypes;\r\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n        let parameterType = parameterTypes[i];\r\n        let parameterName = this.getParameterName(i);\r\n        let local = new Local(\r\n          parameterName,\r\n          localIndex++,\r\n          parameterType,\r\n          this\r\n        );\r\n        this.localsByName.set(parameterName, local);\r\n        this.localsByIndex[local.index] = local;\r\n      }\r\n    }\r\n    this.flow = Flow.createParent(this);\r\n    registerConcreteElement(program, this);\r\n  }\r\n\r\n  /** Gets the name of the parameter at the specified index. */\r\n  getParameterName(index: i32): string {\r\n    var parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\r\n    return parameters.length > index\r\n      ? parameters[index].name.text\r\n      : getDefaultParameterName(index);\r\n  }\r\n\r\n  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */\r\n  newStub(postfix: string): Function {\r\n    var stub = new Function(\r\n      this.original.name + STUB_DELIMITER + postfix,\r\n      this.prototype,\r\n      this.typeArguments,\r\n      this.signature.clone(),\r\n      this.contextualTypeArguments\r\n    );\r\n    stub.original = this.original;\r\n    stub.set(this.flags & ~CommonFlags.COMPILED | CommonFlags.STUB);\r\n    return stub;\r\n  }\r\n\r\n  /** Adds a local of the specified type, with an optional name. */\r\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\r\n    // if it has a name, check previously as this method will throw otherwise\r\n    var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;\r\n    if (this.is(CommonFlags.INSTANCE)) ++localIndex;\r\n    var localName = name !== null\r\n      ? name\r\n      : \"var$\" + localIndex.toString();\r\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\r\n    var local = new Local(\r\n      localName,\r\n      localIndex,\r\n      type,\r\n      this,\r\n      declaration\r\n    );\r\n    if (name) {\r\n      if (this.localsByName.has(name)) throw new Error(\"duplicate local name\");\r\n      this.localsByName.set(name, local);\r\n    }\r\n    this.localsByIndex[local.index] = local;\r\n    this.additionalLocals.push(type);\r\n    return local;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    var locals = this.localsByName;\r\n    if (locals.has(name)) return assert(locals.get(name));\r\n    return this.parent.lookup(name);\r\n  }\r\n\r\n  // used by flows to keep track of temporary locals\r\n  tempI32s: Local[] | null = null;\r\n  tempI64s: Local[] | null = null;\r\n  tempF32s: Local[] | null = null;\r\n  tempF64s: Local[] | null = null;\r\n  tempV128s: Local[] | null = null;\r\n  tempFuncrefs: Local[] | null = null;\r\n  tempExternrefs: Local[] | null = null;\r\n  tempAnyrefs: Local[] | null = null;\r\n  tempEqrefs: Local[] | null = null;\r\n  tempI31refs: Local[] | null = null;\r\n  tempDatarefs: Local[] | null = null;\r\n\r\n  // used by flows to keep track of break labels\r\n  nextBreakId: i32 = 0;\r\n  breakStack: i32[] | null = null;\r\n  breakLabel: string | null = null;\r\n\r\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\r\n  finalize(module: Module, ref: FunctionRef): void {\r\n    this.ref = ref;\r\n    var breakStack = this.breakStack;\r\n    assert(!breakStack || !breakStack.length); // internal error\r\n    this.breakStack = breakStack = null;\r\n    this.breakLabel = null;\r\n    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\r\n    if (this.program.options.sourceMap) {\r\n      let debugLocations = this.debugLocations;\r\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\r\n        let range = debugLocations[i];\r\n        let source = range.source;\r\n        module.setDebugLocation(\r\n          ref,\r\n          range.debugInfoRef,\r\n          source.debugInfoIndex,\r\n          source.lineAt(range.start),\r\n          source.columnAt() - 1 // source maps are 0-based\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** A yet unresolved instance field prototype. */\r\nexport class FieldPrototype extends DeclaredElement {\r\n\r\n  /** Constructs a new field prototype. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent class. */\r\n    parent: ClassPrototype,\r\n    /** Declaration reference. */\r\n    declaration: FieldDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\r\n  ) {\r\n    super(\r\n      ElementKind.FIELD_PROTOTYPE,\r\n      name,\r\n      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.INSTANCE))),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n  }\r\n\r\n  /** Gets the associated type node. */\r\n  get typeNode(): TypeNode | null {\r\n    return (<FieldDeclaration>this.declaration).type;\r\n  }\r\n\r\n  /** Gets the associated initializer node. */\r\n  get initializerNode(): Expression | null {\r\n    return (<FieldDeclaration>this.declaration).initializer;\r\n  }\r\n\r\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\r\n  get parameterIndex(): i32 {\r\n    return (<FieldDeclaration>this.declaration).parameterIndex;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A resolved instance field. */\r\nexport class Field extends VariableLikeElement {\r\n\r\n  /** Field prototype reference. */\r\n  prototype: FieldPrototype;\r\n  /** Field memory offset, if an instance field. */\r\n  memoryOffset: i32 = -1;\r\n  /** Getter function reference, if compiled. */\r\n  getterRef: FunctionRef = 0;\r\n  /** Setter function reference, if compiled. */\r\n  setterRef: FunctionRef = 0;\r\n\r\n  /** Constructs a new field. */\r\n  constructor(\r\n    /** Respective field prototype. */\r\n    prototype: FieldPrototype,\r\n    /** Parent class. */\r\n    parent: Class,\r\n    /** Concrete type. */\r\n    type: Type\r\n  ) {\r\n    super(\r\n      ElementKind.FIELD,\r\n      prototype.name,\r\n      parent,\r\n      <VariableLikeDeclarationStatement>prototype.declaration\r\n    );\r\n    this.prototype = prototype;\r\n    this.flags = prototype.flags;\r\n    this.decoratorFlags = prototype.decoratorFlags;\r\n    assert(type != Type.void);\r\n    this.setType(type);\r\n    registerConcreteElement(this.program, this);\r\n  }\r\n\r\n  /** Gets the field's `this` type. */\r\n  get thisType(): Type {\r\n    var parent = this.parent;\r\n    assert(parent.kind == ElementKind.CLASS);\r\n    return (<Class>parent).type;\r\n  }\r\n\r\n  /** Gets the internal name of the respective getter function. */\r\n  get internalGetterName(): string {\r\n    var cached = this._internalGetterName;\r\n    if (cached === null) this._internalGetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + GETTER_PREFIX + this.name;\r\n    return cached;\r\n  }\r\n  private _internalGetterName: string | null = null;\r\n\r\n  /** Gets the internal name of the respective setter function. */\r\n  get internalSetterName(): string {\r\n    var cached = this._internalSetterName;\r\n    if (cached === null) this._internalSetterName = cached = this.parent.internalName + INSTANCE_DELIMITER + SETTER_PREFIX + this.name;\r\n    return cached;\r\n  }\r\n  private _internalSetterName: string | null = null;\r\n\r\n  /** Gets the signature of the respective getter function. */\r\n  get internalGetterSignature(): Signature {\r\n    var cached = this._internalGetterSignature;\r\n    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, null, this.type, this.thisType);\r\n    return cached;\r\n  }\r\n  private _internalGetterSignature: Signature | null = null;\r\n\r\n  /** Gets the signature of the respective setter function. */\r\n  get internalSetterSignature(): Signature {\r\n    var cached = this._internalSetterSignature;\r\n    if (!cached) this._internalGetterSignature = cached = new Signature(this.program, [ this.type ], Type.void, this.thisType);\r\n    return cached;\r\n  }\r\n  private _internalSetterSignature: Signature | null = null;\r\n}\r\n\r\n/** A property comprised of a getter and a setter function. */\r\nexport class PropertyPrototype extends DeclaredElement {\r\n\r\n  /** Getter prototype. */\r\n  getterPrototype: FunctionPrototype | null = null;\r\n  /** Setter prototype. */\r\n  setterPrototype: FunctionPrototype | null = null;\r\n  /** Property instance, if resolved. */\r\n  instance: Property | null = null;\r\n\r\n  /** Clones of this prototype that are bound to specific classes. */\r\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\r\n\r\n  /** Constructs a new property prototype. */\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element. Either a class prototype or instance. */\r\n    parent: Element,\r\n    /** Declaration of the getter or setter introducing the property. */\r\n    firstDeclaration: FunctionDeclaration\r\n  ) {\r\n    super(\r\n      ElementKind.PROPERTY_PROTOTYPE,\r\n      name,\r\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.INSTANCE)),\r\n      parent.program,\r\n      parent,\r\n      firstDeclaration\r\n    );\r\n    this.flags &= ~(CommonFlags.GET | CommonFlags.SET);\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n\r\n  /** Tests if this prototype is bound to a class. */\r\n  get isBound(): bool {\r\n    switch (this.parent.kind) {\r\n      case ElementKind.CLASS:\r\n      case ElementKind.INTERFACE: return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\r\n  toBound(classInstance: Class): PropertyPrototype {\r\n    assert(this.is(CommonFlags.INSTANCE));\r\n    assert(!this.isBound);\r\n    var boundPrototypes = this.boundPrototypes;\r\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\r\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\r\n    var firstDeclaration = this.declaration;\r\n    assert(firstDeclaration.kind == NodeKind.METHODDECLARATION);\r\n    var bound = new PropertyPrototype(\r\n      this.name,\r\n      classInstance, // !\r\n      <MethodDeclaration>firstDeclaration\r\n    );\r\n    bound.flags = this.flags;\r\n    var getterPrototype = this.getterPrototype;\r\n    if (getterPrototype) {\r\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\r\n    }\r\n    var setterPrototype = this.setterPrototype;\r\n    if (setterPrototype) {\r\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\r\n    }\r\n    boundPrototypes.set(classInstance, bound);\r\n    return bound;\r\n  }\r\n}\r\n\r\n/** A resolved property. */\r\nexport class Property extends VariableLikeElement {\r\n\r\n  /** Prototype reference. */\r\n  prototype: PropertyPrototype;\r\n  /** Getter instance. */\r\n  getterInstance: Function | null = null;\r\n  /** Setter instance. */\r\n  setterInstance: Function | null = null;\r\n\r\n  /** Constructs a new property prototype. */\r\n  constructor(\r\n    /** Respective property prototype. */\r\n    prototype: PropertyPrototype,\r\n    /** Parent element, usually a static class prototype or class instance. */\r\n    parent: Element\r\n  ) {\r\n    super(\r\n      ElementKind.PROPERTY,\r\n      prototype.name,\r\n      parent,\r\n      Node.createVariableDeclaration(\r\n        prototype.identifierNode,\r\n        null,\r\n        prototype.is(CommonFlags.INSTANCE)\r\n          ? CommonFlags.INSTANCE\r\n          : CommonFlags.NONE,\r\n        null, null,\r\n        prototype.identifierNode.range\r\n      )\r\n    );\r\n    this.prototype = prototype;\r\n    this.flags = prototype.flags;\r\n    this.decoratorFlags = prototype.decoratorFlags;\r\n    if (this.is(CommonFlags.INSTANCE)) {\r\n      registerConcreteElement(this.program, this);\r\n    }\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A resolved index signature. */\r\nexport class IndexSignature extends TypedElement {\r\n\r\n  /** Constructs a new index prototype. */\r\n  constructor(\r\n    /** Parent class. */\r\n    parent: Class\r\n  ) {\r\n    super(\r\n      ElementKind.INDEXSIGNATURE,\r\n      \"[]\",\r\n      parent.internalName + \"[]\",\r\n      parent.program,\r\n      parent,\r\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\r\n    );\r\n  }\r\n\r\n  /** Obtains the getter instance. */\r\n  getGetterInstance(isUnchecked: bool): Function | null {\r\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\r\n  }\r\n\r\n  /** Obtains the setter instance. */\r\n  getSetterInstance(isUnchecked: bool): Function | null {\r\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A yet unresolved class prototype. */\r\nexport class ClassPrototype extends DeclaredElement {\r\n\r\n  /** Instance member prototypes. */\r\n  instanceMembers: Map<string,DeclaredElement> | null = null;\r\n  /** Base class prototype, if applicable. */\r\n  basePrototype: ClassPrototype | null = null;\r\n  /** Interface prototypes, if applicable. */\r\n  interfacePrototypes: InterfacePrototype[] | null = null;\r\n  /** Constructor prototype. */\r\n  constructorPrototype: FunctionPrototype | null = null;\r\n  /** Operator overload prototypes. */\r\n  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\r\n  /** Already resolved instances. */\r\n  instances: Map<string,Class> | null = null;\r\n  /** Classes extending this class. */\r\n  extendees: Set<ClassPrototype> = new Set();\r\n\r\n  constructor(\r\n    /** Simple name. */\r\n    name: string,\r\n    /** Parent element, usually a file or namespace. */\r\n    parent: Element,\r\n    /** Declaration reference. */\r\n    declaration: ClassDeclaration,\r\n    /** Pre-checked flags indicating built-in decorators. */\r\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE,\r\n    _isInterface: bool = false // FIXME\r\n  ) {\r\n    super(\r\n      _isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE,\r\n      name,\r\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\r\n      parent.program,\r\n      parent,\r\n      declaration\r\n    );\r\n    this.decoratorFlags = decoratorFlags;\r\n  }\r\n\r\n  /** Gets the associated type parameter nodes. */\r\n  get typeParameterNodes(): TypeParameterNode[] | null {\r\n    return (<ClassDeclaration>this.declaration).typeParameters;\r\n  }\r\n  /** Gets the associated extends node. */\r\n  get extendsNode(): NamedTypeNode | null {\r\n    return (<ClassDeclaration>this.declaration).extendsType;\r\n  }\r\n  /** Gets the associated implements nodes. */\r\n  get implementsNodes(): NamedTypeNode[] | null {\r\n    return (<ClassDeclaration>this.declaration).implementsTypes;\r\n  }\r\n\r\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\r\n  get isBuiltinArray(): bool {\r\n    var arrayBufferViewInstance = this.program.arrayBufferViewInstance;\r\n    return arrayBufferViewInstance !== null\r\n        && this.extends(arrayBufferViewInstance.prototype);\r\n  }\r\n\r\n  /** Tests if this prototype extends the specified. */\r\n  extends(basePtototype: ClassPrototype | null): bool {\r\n    var current: ClassPrototype | null = this;\r\n    var seen = new Set<ClassPrototype>();\r\n    do {\r\n      // cannot directly or indirectly extend itself\r\n      if (seen.has(current)) break;\r\n      seen.add(current);\r\n      if (current === basePtototype) return true;\r\n      current = current.basePrototype;\r\n    } while (current);\r\n    return false;\r\n  }\r\n\r\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\r\n  addInstance(name: string, element: DeclaredElement): bool {\r\n    var originalDeclaration = element.declaration;\r\n    var instanceMembers = this.instanceMembers;\r\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\r\n    else if (instanceMembers.has(name)) {\r\n      let existing = assert(instanceMembers.get(name));\r\n      let merged = tryMerge(existing, element);\r\n      if (!merged) {\r\n        if (isDeclaredElement(existing.kind)) {\r\n          this.program.errorRelated(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            element.identifierNode.range,\r\n            (<DeclaredElement>existing).declaration.name.range,\r\n            element.identifierNode.text\r\n          );\r\n        } else {\r\n          this.program.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            element.identifierNode.range, element.identifierNode.text\r\n          );\r\n        }\r\n        return false;\r\n      }\r\n      element = merged;\r\n    }\r\n    instanceMembers.set(name, element);\r\n    if (element.is(CommonFlags.EXPORT) && this.is(CommonFlags.MODULE_EXPORT)) {\r\n      element.set(CommonFlags.MODULE_EXPORT); // propagate\r\n    }\r\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\r\n    return true;\r\n  }\r\n\r\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\r\n  getResolvedInstance(instanceKey: string): Class | null {\r\n    var instances = this.instances;\r\n    if (instances !== null && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\r\n    return null;\r\n  }\r\n\r\n  /** Sets the resolved instance for the specified instance key. */\r\n  setResolvedInstance(instanceKey: string, instance: Class): void {\r\n    var instances = this.instances;\r\n    if (!instances) this.instances = instances = new Map();\r\n    else assert(!instances.has(instanceKey));\r\n    instances.set(instanceKey, instance);\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n}\r\n\r\n/** A resolved class. */\r\nexport class Class extends TypedElement {\r\n\r\n  /** Class prototype. */\r\n  prototype: ClassPrototype;\r\n  /** Resolved type arguments. */\r\n  typeArguments: Type[] | null;\r\n  /** Base class, if applicable. */\r\n  base: Class | null = null;\r\n  /** Implemented interfaces, if applicable. */\r\n  interfaces: Set<Interface> | null = null;\r\n  /** Contextual type arguments for fields and methods. */\r\n  contextualTypeArguments: Map<string,Type> | null = null;\r\n  /** Current member memory offset. */\r\n  nextMemoryOffset: u32 = 0;\r\n  /** Constructor instance. */\r\n  constructorInstance: Function | null = null;\r\n  /** Operator overloads. */\r\n  overloads: Map<OperatorKind,Function> | null = null;\r\n  /** Index signature, if present. */\r\n  indexSignature: IndexSignature | null = null;\r\n  /** Unique class id. */\r\n  private _id: u32 = 0;\r\n  /** Runtime type information flags. */\r\n  rttiFlags: u32 = 0;\r\n  /** Wrapped type, if a wrapper for a basic type. */\r\n  wrappedType: Type | null = null;\r\n  /** Classes directly extending this class. */\r\n  extendees: Set<Class> | null = null;\r\n  /** Classes implementing this interface. */\r\n  implementers: Set<Class> | null = null;\r\n  /** Whether the field initialization check has already been performed. */\r\n  didCheckFieldInitialization: bool = false;\r\n  /** Runtime visitor function reference. */\r\n  visitRef: FunctionRef = 0;\r\n\r\n  /** Gets the unique runtime id of this class. */\r\n  get id(): u32 {\r\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\r\n  }\r\n\r\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\r\n  get isBuiltinArray(): bool {\r\n    return this.prototype.isBuiltinArray;\r\n  }\r\n\r\n  /** Tests if this class is array-like. */\r\n  get isArrayLike(): bool {\r\n    if (this.isBuiltinArray) return true;\r\n    var lengthField = this.lookupInSelf(\"length\");\r\n    return lengthField !== null && (\r\n      lengthField.kind == ElementKind.FIELD ||\r\n      (\r\n        lengthField.kind == ElementKind.PROPERTY_PROTOTYPE &&\r\n        (<PropertyPrototype>lengthField).getterPrototype !== null // TODO: resolve & check type?\r\n      )\r\n    ) && (\r\n      this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||\r\n      this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null\r\n    );\r\n  }\r\n\r\n  /** Constructs a new class. */\r\n  constructor(\r\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\r\n    nameInclTypeParameters: string,\r\n    /** The respective class prototype. */\r\n    prototype: ClassPrototype,\r\n    /** Concrete type arguments, if any. */\r\n    typeArguments: Type[] | null = null,\r\n    _isInterface: bool = false // FIXME\r\n  ) {\r\n    super(\r\n      _isInterface ? ElementKind.INTERFACE : ElementKind.CLASS,\r\n      nameInclTypeParameters,\r\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\r\n      prototype.program,\r\n      prototype.parent,\r\n      prototype.declaration\r\n    );\r\n    var program = this.program;\r\n    this.prototype = prototype;\r\n    this.flags = prototype.flags;\r\n    this.decoratorFlags = prototype.decoratorFlags;\r\n    this.typeArguments = typeArguments;\r\n    var usizeType = program.options.usizeType;\r\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\r\n    type.classReference = this;\r\n    this.setType(type);\r\n\r\n    if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {\r\n      let id = program.nextClassId++;\r\n      this._id = id;\r\n      program.managedClasses.set(id, this);\r\n    }\r\n\r\n    // apply pre-checked instance-specific contextual type arguments\r\n    var typeParameters = prototype.typeParameterNodes;\r\n    if (typeArguments) {\r\n      let numTypeArguments = typeArguments.length;\r\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\r\n        throw new Error(\"type argument count mismatch\");\r\n      }\r\n      if (numTypeArguments) {\r\n        let contextualTypeArguments = this.contextualTypeArguments;\r\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\r\n        for (let i = 0; i < numTypeArguments; ++i) {\r\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\r\n        }\r\n      }\r\n    } else if (typeParameters !== null && typeParameters.length > 0) {\r\n      throw new Error(\"type argument count mismatch\");\r\n    }\r\n    registerConcreteElement(program, this);\r\n  }\r\n\r\n  /** Sets the base class. */\r\n  setBase(base: Class): void {\r\n    assert(!this.base);\r\n    this.base = base;\r\n    var extendees = base.extendees;\r\n    if (!extendees) base.extendees = extendees = new Set();\r\n    extendees.add(this);\r\n\r\n    // Inherit contextual type arguments from base class\r\n    var inheritedTypeArguments = base.contextualTypeArguments;\r\n    if (inheritedTypeArguments) {\r\n      let contextualTypeArguments = this.contextualTypeArguments;\r\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\r\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\r\n        let baseName = unchecked(_keys[i]);\r\n        let baseType = assert(inheritedTypeArguments.get(baseName));\r\n        if (!contextualTypeArguments) {\r\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\r\n          contextualTypeArguments.set(baseName, baseType);\r\n        } else if (!contextualTypeArguments.has(baseName)) {\r\n          contextualTypeArguments.set(baseName, baseType);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Adds an interface. */\r\n  addInterface(iface: Interface): void {\r\n    var interfaces = this.interfaces;\r\n    if (!interfaces) this.interfaces = interfaces = new Set();\r\n    interfaces.add(iface);\r\n    var implementers = iface.implementers;\r\n    if (!implementers) iface.implementers = implementers = new Set();\r\n    implementers.add(this);\r\n  }\r\n\r\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\r\n  isAssignableTo(target: Class): bool {\r\n    var current: Class | null = this;\r\n    do {\r\n      if (current == target) return true;\r\n      if (target.kind == ElementKind.INTERFACE) {\r\n        let interfaces = current.interfaces;\r\n        if (interfaces) {\r\n          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\r\n            let iface = _values[i];\r\n            if (iface.isAssignableTo(target)) return true;\r\n          }\r\n        }\r\n      }\r\n      current = current.base;\r\n    } while (current);\r\n    return false;\r\n  }\r\n\r\n  /** Looks up the operator overload of the specified kind. */\r\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\r\n    if (unchecked) {\r\n      switch (kind) {\r\n        case OperatorKind.INDEXED_GET: {\r\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);\r\n          if (uncheckedOverload) return uncheckedOverload;\r\n          break;\r\n        }\r\n        case OperatorKind.INDEXED_SET: {\r\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);\r\n          if (uncheckedOverload) return uncheckedOverload;\r\n          break;\r\n        }\r\n        default: assert(false);\r\n      }\r\n    }\r\n    var instance: Class | null = this;\r\n    do {\r\n      let overloads = instance.overloads;\r\n      if (overloads != null && overloads.has(kind)) {\r\n        return assert(overloads.get(kind));\r\n      }\r\n      instance = instance.base;\r\n    } while (instance);\r\n    return null;\r\n  }\r\n\r\n  /* @override */\r\n  lookup(name: string): Element | null {\r\n    return this.parent.lookup(name);\r\n  }\r\n\r\n  /** Gets the method of the specified name, resolved with the given type arguments. */\r\n  getMethod(name: string, typeArguments: Type[] | null = null): Function | null {\r\n    var members = this.members;\r\n    if (members !== null && members.has(name)) {\r\n      let bound = changetype<Element>(members.get(name));\r\n      if (bound.kind == ElementKind.FUNCTION_PROTOTYPE) {\r\n        return this.program.resolver.resolveFunction(<FunctionPrototype>bound, typeArguments);\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Calculates the memory offset of the specified field. */\r\n  offsetof(fieldName: string): u32 {\r\n    var members = assert(this.members);\r\n    assert(members.has(fieldName));\r\n    var field = <Element>members.get(fieldName);\r\n    assert(field.kind == ElementKind.FIELD);\r\n    return (<Field>field).memoryOffset;\r\n  }\r\n\r\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\r\n  createBuffer(overhead: i32 = 0): Uint8Array {\r\n    var program = this.program;\r\n    var payloadSize = this.nextMemoryOffset + overhead;\r\n    var blockSize = program.computeBlockSize(payloadSize, true); // excl. overhead\r\n    var buffer = new Uint8Array(program.blockOverhead + blockSize);\r\n    var OBJECT = program.OBJECTInstance;\r\n    OBJECT.writeField(\"mmInfo\", blockSize, buffer, 0);\r\n    OBJECT.writeField(\"gcInfo\", 0, buffer, 0);\r\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\r\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\r\n    OBJECT.writeField(\"rtSize\", payloadSize, buffer, 0);\r\n    return buffer;\r\n  }\r\n\r\n  /** Writes a field value to a buffer and returns the number of bytes written. */\r\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.totalOverhead): i32 {\r\n    var element = this.lookupInSelf(name);\r\n    if (element !== null && element.kind == ElementKind.FIELD) {\r\n      let fieldInstance = <Field>element;\r\n      let offset = baseOffset + fieldInstance.memoryOffset;\r\n      let typeKind = fieldInstance.type.kind;\r\n      switch (typeKind) {\r\n        case TypeKind.I8:\r\n        case TypeKind.U8: {\r\n          assert(!i64_is(value));\r\n          writeI8(i32(value), buffer, offset);\r\n          return 1;\r\n        }\r\n        case TypeKind.I16:\r\n        case TypeKind.U16: {\r\n          assert(!i64_is(value));\r\n          writeI16(i32(value), buffer, offset);\r\n          return 2;\r\n        }\r\n        case TypeKind.I32:\r\n        case TypeKind.U32: {\r\n          assert(!i64_is(value));\r\n          writeI32(i32(value), buffer, offset);\r\n          return 4;\r\n        }\r\n        case TypeKind.ISIZE:\r\n        case TypeKind.USIZE: {\r\n          if (this.program.options.isWasm64) {\r\n            if (i64_is(value)) {\r\n              writeI64(value, buffer, offset);\r\n            } else {\r\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.USIZE);\r\n            }\r\n            return 8;\r\n          } else {\r\n            if (i64_is(value)) {\r\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.USIZE);\r\n            } else {\r\n              writeI32(i32(value), buffer, offset);\r\n            }\r\n            return 4;\r\n          }\r\n        }\r\n        case TypeKind.I64:\r\n        case TypeKind.U64: {\r\n          if (i64_is(value)) {\r\n            writeI64(value, buffer, offset);\r\n          } else {\r\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\r\n          }\r\n          return 8;\r\n        }\r\n        case TypeKind.F32: {\r\n          assert(!i64_is(value));\r\n          writeF32(f32(value), buffer, offset);\r\n          return 4;\r\n        }\r\n        case TypeKind.F64: {\r\n          assert(!i64_is(value));\r\n          writeF64(f64(value), buffer, offset);\r\n          return 8;\r\n        }\r\n      }\r\n    }\r\n    assert(false);\r\n    return 0;\r\n  }\r\n\r\n  /** Tests if this class extends the specified prototype. */\r\n  extends(prototype: ClassPrototype): bool {\r\n    return this.prototype.extends(prototype);\r\n  }\r\n\r\n  /** Gets the concrete type arguments to the specified extendend prototype. */\r\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\r\n    var current: Class | null = this;\r\n    do {\r\n      if (current.prototype === extendedPrototype) return current.typeArguments;\r\n      current = current.base;\r\n    } while (current);\r\n    return null;\r\n  }\r\n\r\n  /** Gets the value type of an array. Must be an array. */\r\n  getArrayValueType(): Type {\r\n    var current: Class = this;\r\n    var program = this.program;\r\n    var arrayPrototype = program.arrayPrototype;\r\n    if (this.extends(arrayPrototype)) {\r\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\r\n    }\r\n    var staticArrayPrototype = program.staticArrayPrototype;\r\n    if (this.extends(staticArrayPrototype)) {\r\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\r\n    }\r\n    var abvInstance = program.arrayBufferViewInstance;\r\n    while (current.base !== abvInstance) {\r\n      current = assert(current.base);\r\n    }\r\n    var prototype = current.prototype;\r\n    switch (prototype.name.charCodeAt(0)) {\r\n      case CharCode.F: {\r\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\r\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\r\n        break;\r\n      }\r\n      case CharCode.I: {\r\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\r\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\r\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\r\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\r\n        break;\r\n      }\r\n      case CharCode.U: {\r\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\r\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\r\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\r\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\r\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\r\n        break;\r\n      }\r\n    }\r\n    assert(false);\r\n    return Type.void;\r\n  }\r\n\r\n  /** Tests if this class is pointerfree. Useful to know for the GC. */\r\n  get isPointerfree(): bool {\r\n    var program = this.program;\r\n\r\n    var instanceMembers = this.members;\r\n    if (instanceMembers) {\r\n\r\n      // Check that there are no managed instance fields\r\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        if (member.kind == ElementKind.FIELD) {\r\n          let fieldType = (<Field>member).type;\r\n          if (fieldType.isManaged) return false;\r\n        }\r\n      }\r\n\r\n      // Check that this isn't a managed collection\r\n      if (instanceMembers.has(CommonNames.visit)) {\r\n        let prototype = this.prototype;\r\n        if (\r\n          prototype == program.arrayPrototype ||\r\n          prototype == program.staticArrayPrototype ||\r\n          prototype == program.setPrototype ||\r\n          prototype == program.mapPrototype\r\n        ) {\r\n          // Note that we cannot know for sure anymore as soon as the collection\r\n          // is extended, because user code may implement a custom visitor.\r\n          let typeArguments = assert(this.getTypeArgumentsTo(prototype));\r\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\r\n            if (typeArguments[i].isManaged) return false;\r\n          }\r\n          return true;\r\n        }\r\n        return false; // has a custom __visit\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Gets all extendees of this class (that do not have the specified instance member). */\r\n  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {\r\n    var extendees = this.extendees;\r\n    if (extendees) {\r\n      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {\r\n        let extendee = _values[i];\r\n        if (exceptIfMember) {\r\n          let instanceMembers = extendee.prototype.instanceMembers;\r\n          if (instanceMembers !== null && instanceMembers.has(exceptIfMember)) continue;\r\n        }\r\n        out.add(extendee);\r\n        extendee.getAllExtendees(exceptIfMember, out);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n}\r\n\r\n/** A yet unresolved interface. */\r\nexport class InterfacePrototype extends ClassPrototype {\r\n\r\n  /** Constructs a new interface prototype. */\r\n  constructor(\r\n    name: string,\r\n    parent: Element,\r\n    declaration: InterfaceDeclaration,\r\n    decoratorFlags: DecoratorFlags\r\n  ) {\r\n    super(\r\n      name,\r\n      parent,\r\n      declaration,\r\n      decoratorFlags,\r\n      true\r\n    );\r\n  }\r\n}\r\n\r\n/** A resolved interface. */\r\nexport class Interface extends Class { // FIXME\r\n\r\n  /** Constructs a new interface. */\r\n  constructor(\r\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\r\n    nameInclTypeParameters: string,\r\n    /** The respective class prototype. */\r\n    prototype: InterfacePrototype,\r\n    /** Concrete type arguments, if any. */\r\n    typeArguments: Type[] | null = null,\r\n  ) {\r\n    super(\r\n      nameInclTypeParameters,\r\n      prototype,\r\n      typeArguments,\r\n      true\r\n    );\r\n  }\r\n}\r\n\r\n/** Registers a concrete element with a program. */\r\nfunction registerConcreteElement(program: Program, element: Element): void {\r\n  assert(!program.instancesByName.has(element.internalName));\r\n  program.instancesByName.set(element.internalName, element);\r\n}\r\n\r\n/** Attempts to merge two elements. Returns the merged element on success. */\r\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\r\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\r\n  // suggesting to just merge what seems to be possible for now and revisit later.\r\n  assert(older.program === newer.program);\r\n  if (newer.members) return null;\r\n  var merged: DeclaredElement | null = null;\r\n  switch (older.kind) {\r\n    case ElementKind.FUNCTION_PROTOTYPE: {\r\n      switch (newer.kind) {\r\n        case ElementKind.NAMESPACE: {\r\n          copyMembers(newer, older);\r\n          merged = <DeclaredElement>older;\r\n          break;\r\n        }\r\n        case ElementKind.TYPEDEFINITION: {\r\n          if (!older.shadowType) {\r\n            older.shadowType = <TypeDefinition>newer;\r\n            copyMembers(newer, older);\r\n            merged = <DeclaredElement>older;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ElementKind.CLASS_PROTOTYPE:\r\n    case ElementKind.ENUM: {\r\n      if (newer.kind == ElementKind.NAMESPACE) {\r\n        copyMembers(newer, older);\r\n        merged = <DeclaredElement>older;\r\n        break;\r\n      }\r\n      break;\r\n    }\r\n    case ElementKind.NAMESPACE: {\r\n      switch (newer.kind) {\r\n        case ElementKind.ENUM:\r\n        case ElementKind.CLASS_PROTOTYPE:      // TS2434\r\n        case ElementKind.FUNCTION_PROTOTYPE: { // TS2434\r\n          copyMembers(older, newer);\r\n          merged = <DeclaredElement>newer;\r\n          break;\r\n        }\r\n        case ElementKind.NAMESPACE: {\r\n          copyMembers(newer, older);\r\n          merged = <DeclaredElement>older;\r\n          break;\r\n        }\r\n        case ElementKind.TYPEDEFINITION: {\r\n          if (!older.shadowType) {\r\n            older.shadowType = <TypeDefinition>newer;\r\n            copyMembers(newer, older);\r\n            merged = <DeclaredElement>older;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ElementKind.GLOBAL: {\r\n      if (newer.kind == ElementKind.TYPEDEFINITION) {\r\n        if (!older.shadowType) {\r\n          older.shadowType = <TypeDefinition>newer;\r\n          copyMembers(newer, older);\r\n          merged = <DeclaredElement>older;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case ElementKind.TYPEDEFINITION: {\r\n      switch (newer.kind) {\r\n        case ElementKind.GLOBAL:\r\n        case ElementKind.FUNCTION_PROTOTYPE:\r\n        case ElementKind.NAMESPACE: {\r\n          if (!newer.shadowType) {\r\n            newer.shadowType = <TypeDefinition>older;\r\n            copyMembers(older, newer);\r\n            merged = <DeclaredElement>newer;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n  }\r\n  if (merged) {\r\n    let olderIsExport = older.is(CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);\r\n    let newerIsExport = newer.is(CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);\r\n    if (olderIsExport != newerIsExport) {\r\n      older.program.error(\r\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\r\n        merged.identifierNode.range, merged.identifierNode.text\r\n      );\r\n    }\r\n  }\r\n  return merged;\r\n}\r\n\r\n/** Copies the members of `src` to `dest`. */\r\nfunction copyMembers(src: Element, dest: Element): void {\r\n  var srcMembers = src.members;\r\n  if (srcMembers) {\r\n    let destMembers = dest.members;\r\n    if (!destMembers) dest.members = destMembers = new Map();\r\n    // TODO: for (let [memberName, member] of srcMembers) {\r\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\r\n      let memberName = unchecked(_keys[i]);\r\n      let member = assert(srcMembers.get(memberName));\r\n      destMembers.set(memberName, member);\r\n    }\r\n  }\r\n}\r\n\r\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\r\nexport function mangleInternalName(name: string, parent: Element, isInstance: bool, asGlobal: bool = false): string {\r\n  switch (parent.kind) {\r\n    case ElementKind.FILE: {\r\n      if (asGlobal) return name;\r\n      return parent.internalName + PATH_DELIMITER + name;\r\n    }\r\n    case ElementKind.FUNCTION: {\r\n      if (asGlobal) return name;\r\n      assert(!isInstance);\r\n      return parent.internalName + INNER_DELIMITER + name;\r\n    }\r\n    case ElementKind.PROPERTY_PROTOTYPE: // properties are just containers\r\n    case ElementKind.PROPERTY: {         //\r\n      parent = parent.parent;\r\n      // fall-through\r\n    }\r\n    default: {\r\n      return mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.INSTANCE), asGlobal)\r\n           + (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name;\r\n    }\r\n  }\r\n}\r\n\r\n// Cached default parameter names used where names are unknown.\r\nvar cachedDefaultParameterNames: string[] = [];\r\n\r\n/** Gets the cached default parameter name for the specified index. */\r\nexport function getDefaultParameterName(index: i32): string {\r\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\r\n    cachedDefaultParameterNames.push(\"$\" + i.toString());\r\n  }\r\n  return cachedDefaultParameterNames[index];\r\n}\r\n","/**\r\n * @fileoverview Resolve infrastructure to obtain types and elements.\r\n *\r\n * Similar to the compiler making instructions of expressions, the resolver\r\n * obtains metadata of expressions. As such, for each `compileX` method in\r\n * the compiler there is one `lookupX` method in the resolver returning the\r\n * respective IR element, respectively one `resolveX` method returning the\r\n * respective type of an expression. It is also able to make new elements,\r\n * like instances of classes given its concrete type arguments.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  DiagnosticEmitter,\r\n  DiagnosticCode\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Program,\r\n  ElementKind,\r\n  OperatorKind,\r\n  Element,\r\n  Class,\r\n  ClassPrototype,\r\n  Interface,\r\n  Function,\r\n  FunctionPrototype,\r\n  VariableLikeElement,\r\n  Property,\r\n  PropertyPrototype,\r\n  Field,\r\n  FieldPrototype,\r\n  Global,\r\n  TypeDefinition,\r\n  TypedElement,\r\n  IndexSignature,\r\n  isTypedElement,\r\n  InterfacePrototype,\r\n  DeclaredElement\r\n} from \"./program\";\r\n\r\nimport {\r\n  Flow\r\n} from \"./flow\";\r\n\r\nimport {\r\n  Range\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  FunctionTypeNode,\r\n  ParameterKind,\r\n  TypeNode,\r\n  NodeKind,\r\n  NamedTypeNode,\r\n  TypeName,\r\n  TypeParameterNode,\r\n  Node,\r\n  IdentifierExpression,\r\n  CallExpression,\r\n  ElementAccessExpression,\r\n  PropertyAccessExpression,\r\n  LiteralExpression,\r\n  LiteralKind,\r\n  ParenthesizedExpression,\r\n  AssertionExpression,\r\n  Expression,\r\n  IntegerLiteralExpression,\r\n  UnaryPrefixExpression,\r\n  UnaryPostfixExpression,\r\n  AssertionKind,\r\n  BinaryExpression,\r\n  ThisExpression,\r\n  SuperExpression,\r\n  CommaExpression,\r\n  InstanceOfExpression,\r\n  TernaryExpression,\r\n  isTypeOmitted,\r\n  FunctionExpression,\r\n  NewExpression,\r\n  ArrayLiteralExpression\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Type,\r\n  Signature,\r\n  typesToString,\r\n  TypeKind\r\n} from \"./types\";\r\n\r\nimport {\r\n  CommonFlags,\r\n  CommonNames\r\n} from \"./common\";\r\n\r\nimport {\r\n  uniqueMap,\r\n  isPowerOf2\r\n} from \"./util\";\r\n\r\nimport {\r\n  Token,\r\n  operatorTokenToString\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  BuiltinNames\r\n} from \"./builtins\";\r\n\r\n/** Indicates whether errors are reported or not. */\r\nexport enum ReportMode {\r\n  /** Report errors. */\r\n  REPORT,\r\n  /** Swallow errors. */\r\n  SWALLOW\r\n}\r\n\r\n/** Provides tools to resolve types and expressions. */\r\nexport class Resolver extends DiagnosticEmitter {\r\n\r\n  /** The program this resolver belongs to. */\r\n  program: Program;\r\n\r\n  /** Target expression of the previously resolved property or element access. */\r\n  currentThisExpression: Expression | null = null;\r\n  /** Element expression of the previously resolved element access. */\r\n  currentElementExpression : Expression | null = null;\r\n\r\n  /** Constructs the resolver for the specified program. */\r\n  constructor(\r\n    /** The program to construct a resolver for. */\r\n    program: Program\r\n  ) {\r\n    super(program.diagnostics);\r\n    this.program = program;\r\n  }\r\n\r\n  // ====================================================== Types ======================================================\r\n\r\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\r\n  resolveType(\r\n    /** The type to resolve. */\r\n    node: TypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    switch (node.kind) {\r\n      case NodeKind.NAMEDTYPE: {\r\n        return this.resolveNamedType(\r\n          <NamedTypeNode>node,\r\n          ctxElement,\r\n          ctxTypes,\r\n          reportMode\r\n        );\r\n      }\r\n      case NodeKind.FUNCTIONTYPE: {\r\n        return this.resolveFunctionType(\r\n          <FunctionTypeNode>node,\r\n          ctxElement,\r\n          ctxTypes,\r\n          reportMode\r\n        );\r\n      }\r\n      default: assert(false);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\r\n  private resolveNamedType(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var nameNode = node.name;\r\n    var typeArgumentNodes = node.typeArguments;\r\n    var isSimpleType = !nameNode.next;\r\n\r\n    // Look up in contextual types if a simple type\r\n    if (isSimpleType) {\r\n      let simpleName = nameNode.identifier.text;\r\n      if (ctxTypes !== null && ctxTypes.has(simpleName)) {\r\n        let type = assert(ctxTypes.get(simpleName));\r\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_is_not_generic,\r\n              node.range, type.toString()\r\n            );\r\n          }\r\n        }\r\n        if (node.isNullable) {\r\n          if (type.isInternalReference) return type.asNullable();\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_cannot_be_nullable,\r\n              node.range, type.toString()\r\n            );\r\n          }\r\n        }\r\n        return type;\r\n      }\r\n    }\r\n\r\n    // Look up in context\r\n    var element = this.resolveTypeName(nameNode, ctxElement, reportMode);\r\n    if (!element) return null;\r\n\r\n    // Use shadow type if present (i.e. namespace sharing a type)\r\n    var shadowType = element.shadowType;\r\n    if (shadowType) {\r\n      element = shadowType;\r\n\r\n    } else {\r\n\r\n      // Handle enums (become i32)\r\n      if (element.kind == ElementKind.ENUM) {\r\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_is_not_generic,\r\n              node.range, element.internalName\r\n            );\r\n          }\r\n        }\r\n        if (node.isNullable) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_cannot_be_nullable,\r\n              node.range, element.name + \"/i32\"\r\n            );\r\n          }\r\n        }\r\n        return Type.i32;\r\n      }\r\n\r\n      // Handle classes and interfaces\r\n      if (\r\n        element.kind == ElementKind.CLASS_PROTOTYPE ||\r\n        element.kind == ElementKind.INTERFACE_PROTOTYPE\r\n      ) {\r\n        let instance = this.resolveClassInclTypeArguments(\r\n          <ClassPrototype>element,\r\n          typeArgumentNodes,\r\n          ctxElement,\r\n          uniqueMap<string,Type>(ctxTypes), // don't inherit\r\n          node,\r\n          reportMode\r\n        );\r\n        if (!instance) return null;\r\n        return node.isNullable ? instance.type.asNullable() : instance.type;\r\n      }\r\n    }\r\n\r\n    // Handle type definitions\r\n    if (element.kind == ElementKind.TYPEDEFINITION) {\r\n      let typeDefinition = <TypeDefinition>element;\r\n\r\n      // Shortcut already resolved (mostly builtins)\r\n      if (element.is(CommonFlags.RESOLVED)) {\r\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_is_not_generic,\r\n              node.range, element.internalName\r\n            );\r\n          }\r\n        }\r\n        let type = typeDefinition.type;\r\n        if (node.isNullable) {\r\n          if (type.isInternalReference) return type.asNullable();\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Type_0_cannot_be_nullable,\r\n              nameNode.range, nameNode.identifier.text\r\n            );\r\n          }\r\n        }\r\n        return type;\r\n      }\r\n\r\n      // Handle special built-in types\r\n      if (isSimpleType) {\r\n        let text = nameNode.identifier.text;\r\n        if (text == CommonNames.native) return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\r\n        if (text == CommonNames.indexof) return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\r\n        if (text == CommonNames.valueof) return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\r\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\r\n        if (text == CommonNames.nonnull) return this.resolveBuiltinNotNullableType(node, ctxElement, ctxTypes, reportMode);\r\n      }\r\n\r\n      // Resolve normally\r\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\r\n      let typeArguments: Type[] | null = null;\r\n      if (typeParameterNodes) {\r\n        typeArguments = this.resolveTypeArguments(\r\n          typeParameterNodes,\r\n          typeArgumentNodes,\r\n          ctxElement,\r\n          ctxTypes = uniqueMap(ctxTypes), // update\r\n          node,\r\n          reportMode\r\n        );\r\n        if (!typeArguments) return null;\r\n      } else if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n        this.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          node.range, nameNode.identifier.text\r\n        );\r\n      }\r\n      let type = this.resolveType(\r\n        typeDefinition.typeNode,\r\n        element,\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!type) return null;\r\n      if (node.isNullable) {\r\n        if (type.isInternalReference) return type.asNullable();\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_cannot_be_nullable,\r\n            nameNode.range, nameNode.identifier.text\r\n          );\r\n        }\r\n      }\r\n      return type;\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_find_name_0,\r\n        nameNode.range, nameNode.identifier.text\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\r\n  private resolveFunctionType(\r\n    /** The type to resolve. */\r\n    node: FunctionTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var explicitThisType = node.explicitThisType;\r\n    var thisType: Type | null = null;\r\n    if (explicitThisType) {\r\n      thisType = this.resolveType(\r\n        explicitThisType,\r\n        ctxElement,\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!thisType) return null;\r\n    }\r\n    var parameterNodes = node.parameters;\r\n    var numParameters = parameterNodes.length;\r\n    var parameterTypes = new Array<Type>(numParameters);\r\n    var requiredParameters = 0;\r\n    var hasRest = false;\r\n    for (let i = 0; i < numParameters; ++i) {\r\n      let parameterNode = parameterNodes[i];\r\n      switch (parameterNode.parameterKind) {\r\n        case ParameterKind.DEFAULT: {\r\n          requiredParameters = i + 1;\r\n          break;\r\n        }\r\n        case ParameterKind.REST: {\r\n          assert(i == numParameters);\r\n          hasRest = true;\r\n          break;\r\n        }\r\n      }\r\n      let parameterTypeNode = parameterNode.type;\r\n      if (isTypeOmitted(parameterTypeNode)) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            parameterTypeNode.range\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      let parameterType = this.resolveType(\r\n        parameterTypeNode,\r\n        ctxElement,\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!parameterType) return null;\r\n      parameterTypes[i] = parameterType;\r\n    }\r\n    var returnTypeNode = node.returnType;\r\n    var returnType: Type | null;\r\n    if (isTypeOmitted(returnTypeNode)) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          returnTypeNode.range\r\n        );\r\n      }\r\n      returnType = Type.void;\r\n    } else {\r\n      returnType = this.resolveType(\r\n        returnTypeNode,\r\n        ctxElement,\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!returnType) return null;\r\n    }\r\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\r\n    signature.requiredParameters = requiredParameters;\r\n    signature.hasRest = hasRest;\r\n    return node.isNullable ? signature.type.asNullable() : signature.type;\r\n  }\r\n\r\n  private resolveBuiltinNativeType(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\r\n    if (!typeArgumentNode) return null;\r\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\r\n    if (!typeArgument) return null;\r\n    switch (typeArgument.kind) {\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32: return Type.i32;\r\n      case TypeKind.ISIZE: if (!this.program.options.isWasm64) return Type.i32;\r\n      case TypeKind.I64: return Type.i64;\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: return Type.u32;\r\n      case TypeKind.USIZE: if (!this.program.options.isWasm64) return Type.u32;\r\n      case TypeKind.U64: return Type.u64;\r\n      case TypeKind.F32: return Type.f32;\r\n      case TypeKind.F64: return Type.f64;\r\n      case TypeKind.V128: return Type.v128;\r\n      case TypeKind.VOID: return Type.void;\r\n      default: assert(false);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private resolveBuiltinIndexofType(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\r\n    if (!typeArgumentNode) return null;\r\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\r\n    if (!typeArgument) return null;\r\n    var classReference = typeArgument.classReference;\r\n    if (!classReference) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n          typeArgumentNode.range, typeArgument.toString()\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    var overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\r\n    if (overload) {\r\n      if (overload.is(CommonFlags.STATIC)) {\r\n        assert(overload.signature.parameterTypes.length == 2);\r\n        return overload.signature.parameterTypes[1];\r\n      } else {\r\n        assert(overload.signature.parameterTypes.length == 1);\r\n        return overload.signature.parameterTypes[0];\r\n      }\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n        typeArgumentNode.range, typeArgument.toString()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private resolveBuiltinValueofType(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\r\n    if (!typeArgumentNode) return null;\r\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\r\n    if (!typeArgument) return null;\r\n    var classReference = typeArgument.getClassOrWrapper(this.program);\r\n    if (classReference) {\r\n      let overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\r\n      if (overload) return overload.signature.returnType;\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n        typeArgumentNode.range, typeArgument.toString()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private resolveBuiltinReturnTypeType(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventualy diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\r\n    if (!typeArgumentNode) return null;\r\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\r\n    if (!typeArgument) return null;\r\n    var signatureReference = typeArgument.getSignature();\r\n    if (signatureReference) return signatureReference.returnType;\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_has_no_call_signatures,\r\n        typeArgumentNode.range, typeArgument.toString()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private resolveBuiltinNotNullableType(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    const typeArgumentNode = this.ensureOneTypeArgument(node, reportMode);\r\n    if (!typeArgumentNode) return null;\r\n    var typeArgument = this.resolveType(typeArgumentNode, ctxElement, ctxTypes, reportMode);\r\n    if (!typeArgument) return null;\r\n    if (!typeArgument.isNullableReference) return typeArgument;\r\n    return typeArgument.nonNullableType;\r\n  }\r\n\r\n  /** Resolves a type name to the program element it refers to. */\r\n  resolveTypeName(\r\n    /** The type name to resolve. */\r\n    node: TypeName,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var element = ctxElement.lookup(node.identifier.text);\r\n    if (!element) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Cannot_find_name_0,\r\n          node.range, node.identifier.text\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    var prev = node;\r\n    var next = node.next;\r\n    while (next) {\r\n      if (!(element = element.lookupInSelf(next.identifier.text))) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n            next.range, next.identifier.text, prev.identifier.text\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      prev = next;\r\n      next = next.next;\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Resolves an array of type arguments to concrete types. */\r\n  resolveTypeArguments(\r\n    /** Type parameter nodes present. */\r\n    typeParameters: TypeParameterNode[],\r\n    /** Type argument nodes provided. */\r\n    typeArgumentNodes: TypeNode[] | null,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. Updated in place with the new set of contextual types. */\r\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\r\n    /** Alternative report node in case of empty type arguments. */\r\n    alternativeReportNode: Node | null = null,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type[] | null {\r\n    var minParameterCount = 0;\r\n    var maxParameterCount = 0;\r\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\r\n      if (!typeParameters[i].defaultType) ++minParameterCount;\r\n      ++maxParameterCount;\r\n    }\r\n    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\r\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          argumentCount\r\n            ? Range.join(\r\n                typeArgumentNodes![0].range,\r\n                typeArgumentNodes![argumentCount - 1].range\r\n              )\r\n            : alternativeReportNode!.range,\r\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\r\n          argumentCount.toString()\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    var typeArguments = new Array<Type>(maxParameterCount);\r\n    var oldCtxTypes = uniqueMap<string,Type>(ctxTypes);\r\n    ctxTypes.clear();\r\n    for (let i = 0; i < maxParameterCount; ++i) {\r\n      let type = i < argumentCount\r\n        ? this.resolveType( // reports\r\n            typeArgumentNodes![i],\r\n            ctxElement,\r\n            oldCtxTypes, // update\r\n            reportMode\r\n          )\r\n        : this.resolveType( // reports\r\n            assert(typeParameters[i].defaultType),\r\n            ctxElement,\r\n            uniqueMap<string,Type>(ctxTypes), // don't update\r\n            reportMode\r\n          );\r\n      if (!type) return null;\r\n      // TODO: check extendsType\r\n      ctxTypes.set(typeParameters[i].name.text, type);\r\n      typeArguments[i] = type;\r\n    }\r\n    return typeArguments;\r\n  }\r\n\r\n  /** Resolves respectively infers the concrete instance of a function by call context. */\r\n  maybeInferCall(\r\n    node: CallExpression,\r\n    prototype: FunctionPrototype,\r\n    ctxFlow: Flow,\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Function | null {\r\n    var typeArguments = node.typeArguments;\r\n\r\n    // resolve generic call if type arguments have been provided\r\n    if (typeArguments) {\r\n      if (!prototype.is(CommonFlags.GENERIC)) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_generic,\r\n            node.expression.range, prototype.internalName\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      return this.resolveFunctionInclTypeArguments(\r\n        prototype,\r\n        typeArguments,\r\n        ctxFlow.actualFunction,\r\n        uniqueMap(ctxFlow.contextualTypeArguments), // don't inherit\r\n        node,\r\n        reportMode\r\n      );\r\n    }\r\n\r\n    // infer generic call if type arguments have been omitted\r\n    if (prototype.is(CommonFlags.GENERIC)) {\r\n      let contextualTypeArguments = uniqueMap<string,Type>(ctxFlow.contextualTypeArguments);\r\n\r\n      // fill up contextual types with auto for each generic component\r\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\r\n      let numTypeParameters = typeParameterNodes.length;\r\n      let typeParameterNames = new Set<string>();\r\n      for (let i = 0; i < numTypeParameters; ++i) {\r\n        let name = typeParameterNodes[i].name.text;\r\n        contextualTypeArguments.set(name, Type.auto);\r\n        typeParameterNames.add(name);\r\n      }\r\n\r\n      let parameterNodes = prototype.functionTypeNode.parameters;\r\n      let numParameters = parameterNodes.length;\r\n      let argumentNodes = node.args;\r\n      let numArguments = argumentNodes.length;\r\n\r\n      // infer types with generic components while updating contextual types\r\n      for (let i = 0; i < numParameters; ++i) {\r\n        let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;\r\n        if (!argumentExpression) { // missing initializer -> too few arguments\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Expected_0_arguments_but_got_1,\r\n              node.range, numParameters.toString(), numArguments.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        let typeNode = parameterNodes[i].type;\r\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\r\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.SWALLOW);\r\n          if (type) this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);\r\n        }\r\n      }\r\n\r\n      // apply concrete types to the generic function signature\r\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\r\n      for (let i = 0; i < numTypeParameters; ++i) {\r\n        let typeParameterNode = typeParameterNodes[i];\r\n        let name = typeParameterNode.name.text;\r\n        if (contextualTypeArguments.has(name)) {\r\n          let inferredType = assert(contextualTypeArguments.get(name));\r\n          if (inferredType != Type.auto) {\r\n            resolvedTypeArguments[i] = inferredType;\r\n            continue;\r\n          }\r\n          let defaultType = typeParameterNode.defaultType;\r\n          if (defaultType) {\r\n            let resolvedDefaultType = this.resolveType(defaultType, ctxFlow.actualFunction, contextualTypeArguments, reportMode);\r\n            if (!resolvedDefaultType) return null;\r\n            resolvedTypeArguments[i] = resolvedDefaultType;\r\n            continue;\r\n          }\r\n        }\r\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\r\n        // invalid because the type is effectively unknown inside the function body\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_argument_expected,\r\n            node.expression.range.atEnd\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      return this.resolveFunction(\r\n        prototype,\r\n        resolvedTypeArguments,\r\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\r\n        reportMode\r\n      );\r\n    }\r\n\r\n    // otherwise resolve the non-generic call as usual\r\n    return this.resolveFunction(prototype, null, uniqueMap<string,Type>(), reportMode);\r\n  }\r\n\r\n  /** Updates contextual types with a possibly encapsulated inferred type. */\r\n  private propagateInferredGenericTypes(\r\n    /** The inferred type node. */\r\n    node: TypeNode,\r\n    /** The inferred type. */\r\n    type: Type,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\r\n    ctxTypes: Map<string,Type>,\r\n    /** The names of the type parameters being inferred. */\r\n    typeParameterNames: Set<string>\r\n  ): void {\r\n    if (node.kind == NodeKind.NAMEDTYPE) {\r\n      let namedTypeNode = <NamedTypeNode>node;\r\n      let typeArgumentNodes = namedTypeNode.typeArguments;\r\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\r\n        let classReference = type.classReference;\r\n        if (classReference) {\r\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxFlow.actualFunction);\r\n          if (!classPrototype || classPrototype.kind != ElementKind.CLASS_PROTOTYPE) return;\r\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\r\n            let typeArguments = classReference.typeArguments;\r\n            if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {\r\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\r\n                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);\r\n              }\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      } else { // foo<T>(bar: T)\r\n        let name = namedTypeNode.name.identifier.text;\r\n        if (ctxTypes.has(name)) {\r\n          let currentType = assert(ctxTypes.get(name));\r\n          if (currentType == Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {\r\n            ctxTypes.set(name, type);\r\n          }\r\n        }\r\n      }\r\n    } else if (node.kind == NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))\r\n      let functionTypeNode = <FunctionTypeNode>node;\r\n      let parameterNodes = functionTypeNode.parameters;\r\n      if (parameterNodes !== null && parameterNodes.length > 0) {\r\n        let signatureReference = type.signatureReference;\r\n        if (signatureReference) {\r\n          let parameterTypes = signatureReference.parameterTypes;\r\n          let thisType = signatureReference.thisType;\r\n          if (parameterTypes.length == parameterNodes.length && !thisType == !functionTypeNode.explicitThisType) {\r\n            for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n              this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);\r\n            }\r\n            this.propagateInferredGenericTypes(functionTypeNode.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);\r\n            if (thisType) this.propagateInferredGenericTypes(functionTypeNode.explicitThisType!, thisType, ctxFlow, ctxTypes, typeParameterNames);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Gets the concrete type of an element. */\r\n  getTypeOfElement(element: Element): Type | null {\r\n    var kind = element.kind;\r\n    if (kind == ElementKind.GLOBAL) {\r\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.SWALLOW)) return null;\r\n    }\r\n    if (isTypedElement(kind)) {\r\n      let type = (<TypedElement>element).type;\r\n      let classReference = type.getClassOrWrapper(this.program);\r\n      if (classReference) {\r\n        let wrappedType = classReference.wrappedType;\r\n        if (wrappedType) type = wrappedType;\r\n      }\r\n      return type;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Gets the element of a concrete type. */\r\n  getElementOfType(type: Type): Element | null {\r\n    let classReference = type.getClassOrWrapper(this.program);\r\n    if (classReference) return classReference;\r\n    return null;\r\n  }\r\n\r\n  // =================================================== Expressions ===================================================\r\n\r\n  /** Looks up the program element the specified expression refers to. */\r\n  lookupExpression(\r\n    /** The expression to look up. */\r\n    node: Expression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\r\n      node = (<ParenthesizedExpression>node).expression;\r\n    }\r\n    switch (node.kind) {\r\n      case NodeKind.ASSERTION: {\r\n        return this.lookupAssertionExpression(\r\n          <AssertionExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.BINARY: {\r\n        return this.lookupBinaryExpression(\r\n          <BinaryExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.CALL: {\r\n        return this.lookupCallExpression(\r\n          <CallExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.COMMA: {\r\n        return this.lookupCommaExpression(\r\n          <CommaExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.ELEMENTACCESS: {\r\n        return this.lookupElementAccessExpression(\r\n          <ElementAccessExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.FUNCTION: {\r\n        return this.lookupFunctionExpression(\r\n          <FunctionExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.IDENTIFIER:\r\n      case NodeKind.FALSE:\r\n      case NodeKind.NULL:\r\n      case NodeKind.TRUE: {\r\n        return this.lookupIdentifierExpression(\r\n          <IdentifierExpression>node,\r\n          ctxFlow, ctxFlow.actualFunction, reportMode\r\n        );\r\n      }\r\n      case NodeKind.THIS: {\r\n        return this.lookupThisExpression(\r\n          <ThisExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.SUPER: {\r\n        return this.lookupSuperExpression(\r\n          <SuperExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.INSTANCEOF: {\r\n        return this.lookupInstanceOfExpression(\r\n          <InstanceOfExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.LITERAL: {\r\n        return this.lookupLiteralExpression(\r\n          <LiteralExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.NEW: {\r\n        return this.lookupNewExpression(\r\n          <NewExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.PROPERTYACCESS: {\r\n        return this.lookupPropertyAccessExpression(\r\n          <PropertyAccessExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.TERNARY: {\r\n        return this.lookupTernaryExpression(\r\n          <TernaryExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.UNARYPOSTFIX: {\r\n        return this.lookupUnaryPostfixExpression(\r\n          <UnaryPostfixExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.UNARYPREFIX: {\r\n        return this.lookupUnaryPrefixExpression(\r\n          <UnaryPrefixExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return null;\r\n  }\r\n\r\n  /** Resolves an expression to its static type. */\r\n  resolveExpression(\r\n    /** The expression to resolve. */\r\n    node: Expression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\r\n      node = (<ParenthesizedExpression>node).expression;\r\n    }\r\n    switch (node.kind) {\r\n      case NodeKind.ASSERTION: {\r\n        return this.resolveAssertionExpression(\r\n          <AssertionExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.BINARY: {\r\n        return this.resolveBinaryExpression(\r\n          <BinaryExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.CALL: {\r\n        return this.resolveCallExpression(\r\n          <CallExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.COMMA: {\r\n        return this.resolveCommaExpression(\r\n          <CommaExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.ELEMENTACCESS: {\r\n        return this.resolveElementAccessExpression(\r\n          <ElementAccessExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.FUNCTION: {\r\n        return this.resolveFunctionExpression(\r\n          <FunctionExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.IDENTIFIER:\r\n      case NodeKind.FALSE:\r\n      case NodeKind.NULL:\r\n      case NodeKind.TRUE: {\r\n        return this.resolveIdentifierExpression(\r\n          <IdentifierExpression>node,\r\n          ctxFlow, ctxType, ctxFlow.actualFunction, reportMode\r\n        );\r\n      }\r\n      case NodeKind.THIS: {\r\n        return this.resolveThisExpression(\r\n          <ThisExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.SUPER: {\r\n        return this.resolveSuperExpression(\r\n          <SuperExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.INSTANCEOF: {\r\n        return this.resolveInstanceOfExpression(\r\n          <InstanceOfExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.LITERAL: {\r\n        return this.resolveLiteralExpression(\r\n          <LiteralExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.NEW: {\r\n        return this.resolveNewExpression(\r\n          <NewExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.PROPERTYACCESS: {\r\n        return this.resolvePropertyAccessExpression(\r\n          <PropertyAccessExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.TERNARY: {\r\n        return this.resolveTernaryExpression(\r\n          <TernaryExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.UNARYPOSTFIX: {\r\n        return this.resolveUnaryPostfixExpression(\r\n          <UnaryPostfixExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n      case NodeKind.UNARYPREFIX: {\r\n        return this.resolveUnaryPrefixExpression(\r\n          <UnaryPrefixExpression>node,\r\n          ctxFlow, ctxType, reportMode\r\n        );\r\n      }\r\n    }\r\n    assert(false);\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the program element the specified identifier expression refers to. */\r\n  lookupIdentifierExpression(\r\n    /** The expression to look up. */\r\n    node: IdentifierExpression,\r\n    /** Flow to search for scoped locals. */\r\n    ctxFlow: Flow,\r\n    /** Element to search. */\r\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    switch (node.kind) {\r\n      case NodeKind.TRUE:\r\n      case NodeKind.FALSE:\r\n      case NodeKind.NULL: {\r\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\r\n        return type ? this.getElementOfType(type) : null;\r\n      }\r\n    }\r\n    var name = node.text;\r\n    var element: Element | null;\r\n    if (element = ctxFlow.lookup(name)) {\r\n      this.currentThisExpression = null;\r\n      this.currentElementExpression = null;\r\n      return element;\r\n    }\r\n    var outerFlow = ctxFlow.outer;\r\n    if (outerFlow) {\r\n      if (element = outerFlow.lookup(name)) {\r\n        this.currentThisExpression = null;\r\n        this.currentElementExpression = null;\r\n        return element;\r\n      }\r\n    }\r\n    if (element = ctxElement.lookup(name)) {\r\n      this.currentThisExpression = null;\r\n      this.currentElementExpression = null;\r\n      return element;\r\n    }\r\n    if (element = this.program.lookup(name)) {\r\n      this.currentThisExpression = null;\r\n      this.currentElementExpression = null;\r\n      return element;\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_find_name_0,\r\n        node.range, name\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves an identifier to its static type. */\r\n  private resolveIdentifierExpression(\r\n    /** The expression to resolve. */\r\n    node: IdentifierExpression,\r\n    /** Flow to search for scoped locals. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** Element to search. */\r\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    switch (node.kind) {\r\n      case NodeKind.TRUE:\r\n      case NodeKind.FALSE: return Type.bool;\r\n      case NodeKind.NULL: {\r\n        let classReference = ctxType.getClass();\r\n        if (classReference) {\r\n          return classReference.type.asNullable();\r\n        } else {\r\n          let signatureReference = ctxType.getSignature();\r\n          if (signatureReference) {\r\n            return signatureReference.type.asNullable();\r\n          } else if (ctxType.isExternalReference) {\r\n            return ctxType; // TODO: nullable?\r\n          }\r\n        }\r\n        return this.program.options.usizeType;\r\n      }\r\n    }\r\n    var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\r\n    if (!element) return null;\r\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\r\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, uniqueMap<string,Type>(), reportMode);\r\n      if (!instance) return null;\r\n      element = instance;\r\n    }\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\r\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.REPORT): bool {\r\n    if (global.is(CommonFlags.RESOLVED)) return true;\r\n    var type: Type | null;\r\n    var typeNode = global.typeNode;\r\n    if (typeNode) {\r\n      type = this.resolveType(typeNode, global.parent, null, reportMode);\r\n    } else {\r\n      type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, Type.auto, reportMode);\r\n    }\r\n    if (!type) return false;\r\n    global.setType(type); // also sets resolved\r\n    return true;\r\n  }\r\n\r\n  /** Looks up the program element the specified property access expression refers to. */\r\n  private lookupPropertyAccessExpression(\r\n    /** The expression to look up. */\r\n    node: PropertyAccessExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var targetNode = node.expression;\r\n    var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\r\n    if (!target) return null;\r\n    var propertyName = node.property.text;\r\n\r\n    // Resolve variable-likes to their class type first\r\n    switch (target.kind) {\r\n      case ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\r\n      case ElementKind.ENUMVALUE:\r\n      case ElementKind.LOCAL:\r\n      case ElementKind.FIELD: { // someVar.prop\r\n        let variableLikeElement = <VariableLikeElement>target;\r\n        let type = variableLikeElement.type;\r\n        assert(type != Type.void);\r\n        let classReference = type.getClassOrWrapper(this.program);\r\n        if (!classReference) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n              node.property.range, propertyName, variableLikeElement.type.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        target = classReference;\r\n        break;\r\n      }\r\n      case ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop\r\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\r\n        if (!propertyInstance) return null;\r\n        target = propertyInstance;\r\n        // fall-through\r\n      }\r\n      case ElementKind.PROPERTY: { // someInstance.prop\r\n        let propertyInstance = <Property>target;\r\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\r\n        let type = getterInstance.signature.returnType;\r\n        let classReference = type.getClassOrWrapper(this.program);\r\n        if (!classReference) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n              node.property.range, propertyName, type.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        target = classReference;\r\n        break;\r\n      }\r\n      case ElementKind.INDEXSIGNATURE: { // someInstance[x].prop\r\n        let indexSignature = <IndexSignature>target;\r\n        let parent = indexSignature.parent;\r\n        assert(parent.kind == ElementKind.CLASS);\r\n        let classInstance = <Class>parent;\r\n        let elementExpression = assert(this.currentElementExpression);\r\n        let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET);\r\n        if (!indexedGet) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n              elementExpression.range, parent.internalName\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        let returnType = indexedGet.signature.returnType;\r\n        let classReference = returnType.getClassOrWrapper(this.program);\r\n        if (!classReference) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n              node.property.range, propertyName, returnType.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        target = classReference;\r\n        break;\r\n      }\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\r\n        let shadowType = target.shadowType;\r\n        if (shadowType) {\r\n          if (!shadowType.is(CommonFlags.RESOLVED)) {\r\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\r\n            if (resolvedType) shadowType.setType(resolvedType);\r\n          }\r\n          let classReference = shadowType.type.classReference;\r\n          if (classReference) target = classReference.prototype;\r\n          break;\r\n        } else if (!target.is(CommonFlags.GENERIC)) {\r\n          // Inherit from 'Function' if not overridden, i.e. fn.call\r\n          let members = target.members;\r\n          if (!members || !members.has(propertyName)) {\r\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);\r\n            if (functionInstance) {\r\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\r\n              if (wrapper) target = wrapper;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Look up the member within\r\n    switch (target.kind) {\r\n      case ElementKind.CLASS_PROTOTYPE:\r\n      case ElementKind.INTERFACE_PROTOTYPE:\r\n      case ElementKind.CLASS:\r\n      case ElementKind.INTERFACE: {\r\n        do {\r\n          let members = target.members;\r\n          if (members !== null && members.has(propertyName)) {\r\n            let member = assert(members.get(propertyName));\r\n            if (member.kind == ElementKind.PROPERTY_PROTOTYPE) {\r\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\r\n              if (!propertyInstance) return null;\r\n              member = propertyInstance;\r\n              if (propertyInstance.is(CommonFlags.STATIC)) {\r\n                this.currentThisExpression = null;\r\n              } else {\r\n                this.currentThisExpression = targetNode;\r\n              }\r\n            } else {\r\n              this.currentThisExpression = targetNode;\r\n            }\r\n            this.currentElementExpression = null;\r\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\r\n          }\r\n          // traverse inherited static members on the base prototype if target is a class prototype\r\n          if (\r\n            target.kind == ElementKind.CLASS_PROTOTYPE ||\r\n            target.kind == ElementKind.INTERFACE_PROTOTYPE\r\n          ) {\r\n            let classPrototype = <ClassPrototype>target;\r\n            let basePrototype = classPrototype.basePrototype;\r\n            if (basePrototype) {\r\n              target = basePrototype;\r\n            } else {\r\n              break;\r\n            }\r\n          // traverse inherited instance members on the base class if target is a class instance\r\n          } else if (\r\n            target.kind == ElementKind.CLASS ||\r\n            target.kind == ElementKind.INTERFACE\r\n          ) {\r\n            let classInstance = <Class>target;\r\n            let baseInstance = classInstance.base;\r\n            if (baseInstance) {\r\n              target = baseInstance;\r\n            } else {\r\n              break;\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        } while (true);\r\n        break;\r\n      }\r\n      default: { // enums or other namespace-like elements\r\n        let members = target.members;\r\n        if (members !== null && members.has(propertyName)) {\r\n          this.currentThisExpression = targetNode;\r\n          this.currentElementExpression = null;\r\n          return assert(members.get(propertyName)); // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\r\n        }\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n        node.property.range, propertyName, target.internalName\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a property access expression to its static type. */\r\n  private resolvePropertyAccessExpression(\r\n    /** The expression to resolve. */\r\n    node: PropertyAccessExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!element) return null;\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Looks up the program element the specified element access expression refers to. */\r\n  private lookupElementAccessExpression(\r\n    /** The expression to look up. */\r\n    node: ElementAccessExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var targetExpression = node.expression;\r\n    var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\r\n    if (!targetType) return null;\r\n    let classReference = targetType.getClassOrWrapper(this.program);\r\n    if (classReference) {\r\n      do {\r\n        let indexSignature = classReference.indexSignature;\r\n        if (indexSignature) {\r\n          this.currentThisExpression = targetExpression;\r\n          this.currentElementExpression = node.elementExpression;\r\n          return indexSignature;\r\n        }\r\n        classReference = classReference.base;\r\n      } while(classReference);\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n        targetExpression.range, targetType.toString()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves an element access expression to its static type. */\r\n  private resolveElementAccessExpression(\r\n    /** The expression to resolve. */\r\n    node: ElementAccessExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!element) return null;\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Determines the final type of an integer literal given the specified contextual type. */\r\n  determineIntegerLiteralType(\r\n    /** Integer literal value. */\r\n    intValue: i64,\r\n    /** Contextual type. */\r\n    ctxType: Type\r\n  ): Type {\r\n    if (ctxType.isValue) {\r\n      // compile to contextual type if matching\r\n      switch (ctxType.kind) {\r\n        case TypeKind.I8: {\r\n          if (i64_is_i8(intValue)) return Type.i8;\r\n          break;\r\n        }\r\n        case TypeKind.U8: {\r\n          if (i64_is_u8(intValue)) return Type.u8;\r\n          break;\r\n        }\r\n        case TypeKind.I16: {\r\n          if (i64_is_i16(intValue)) return Type.i16;\r\n          break;\r\n        }\r\n        case TypeKind.U16: {\r\n          if (i64_is_u16(intValue)) return Type.u16;\r\n          break;\r\n        }\r\n        case TypeKind.I32: {\r\n          if (i64_is_i32(intValue)) return Type.i32;\r\n          break;\r\n        }\r\n        case TypeKind.U32: {\r\n          if (i64_is_u32(intValue)) return Type.u32;\r\n          break;\r\n        }\r\n        case TypeKind.BOOL: {\r\n          if (i64_is_bool(intValue)) return Type.bool;\r\n          break;\r\n        }\r\n        case TypeKind.ISIZE: {\r\n          if (!this.program.options.isWasm64) {\r\n            if (i64_is_i32(intValue)) return Type.isize32;\r\n            break;\r\n          }\r\n          return Type.isize64;\r\n        }\r\n        case TypeKind.USIZE: {\r\n          if (!this.program.options.isWasm64) {\r\n            if (i64_is_u32(intValue)) return Type.usize32;\r\n            break;\r\n          }\r\n          return Type.usize64;\r\n        }\r\n        case TypeKind.I64: return Type.i64;\r\n        case TypeKind.U64: return Type.u64;\r\n        case TypeKind.F32: return Type.f32;\r\n        case TypeKind.F64: return Type.f64;\r\n      }\r\n    }\r\n    // otherwise compile to best fitting type\r\n    if (i64_is_i32(intValue)) return Type.i32;\r\n    if (i64_is_u32(intValue)) return Type.u32;\r\n    return Type.i64; // TODO: u64 if positive and larger than i64?\r\n  }\r\n\r\n  /** Looks up the program element the specified assertion expression refers to. */\r\n  private lookupAssertionExpression(\r\n    /** The expression to look up. */\r\n    node: AssertionExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    switch (node.assertionKind) {\r\n      case AssertionKind.AS:\r\n      case AssertionKind.PREFIX: {\r\n        let type = this.resolveType(\r\n          assert(node.toType), // must be set if not NONNULL\r\n          ctxFlow.actualFunction,\r\n          ctxFlow.contextualTypeArguments,\r\n          reportMode\r\n        );\r\n        if (!type) return null;\r\n        let element = this.getElementOfType(type);\r\n        if (element) return element;\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\r\n            node.range, type.toString()\r\n          );\r\n        }\r\n        this.currentThisExpression = null;\r\n        this.currentElementExpression = null;\r\n        return null;\r\n      }\r\n      case AssertionKind.NONNULL: {\r\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\r\n      }\r\n      case AssertionKind.CONST: {\r\n        // TODO: decide on the layout of ReadonlyArray first\r\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\r\n        // if (!element) return null;\r\n        // if (element.kind == ElementKind.CLASS && (<Class>element).extends(this.program.arrayPrototype)) {\r\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\r\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\r\n        // }\r\n        this.error(\r\n          DiagnosticCode.Not_implemented_0,\r\n          node.range,\r\n          \"Const assertion\"\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n    assert(false);\r\n    return null;\r\n  }\r\n\r\n  /** Resolves an assertion expression to its static type. */\r\n  private resolveAssertionExpression(\r\n    /** The expression to resolve. */\r\n    node: AssertionExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    switch (node.assertionKind) {\r\n      case AssertionKind.AS:\r\n      case AssertionKind.PREFIX: {\r\n        return this.resolveType(\r\n          assert(node.toType),\r\n          ctxFlow.actualFunction,\r\n          ctxFlow.contextualTypeArguments,\r\n          reportMode\r\n        );\r\n      }\r\n      case AssertionKind.NONNULL: {\r\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\r\n        return type ? type.nonNullableType : null;\r\n      }\r\n      case AssertionKind.CONST: {\r\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\r\n        if (!element) return null;\r\n        let type = this.getTypeOfElement(element);\r\n        if (!type) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n              node.range\r\n            );\r\n          }\r\n        }\r\n        return type;\r\n      }\r\n      default: assert(false);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the program element the specified unary prefix expression refers to. */\r\n  private lookupUnaryPrefixExpression(\r\n    /** The expression to look up. */\r\n    node: UnaryPrefixExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!type) return null;\r\n    var element = this.getElementOfType(type);\r\n    if (!element) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n          node.range, operatorTokenToString(node.operator), type.toString()\r\n        );\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Resolves an unary prefix expression to its static type. */\r\n  private resolveUnaryPrefixExpression(\r\n    /** The expression to resolve. */\r\n    node: UnaryPrefixExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var operand = node.operand;\r\n    var operator = node.operator;\r\n    switch (operator) {\r\n      case Token.MINUS: {\r\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\r\n        if (operand.isLiteralKind(LiteralKind.INTEGER)) {\r\n          return this.determineIntegerLiteralType(i64_sub(i64_zero, (<IntegerLiteralExpression>operand).value), ctxType);\r\n        }\r\n        // fall-through\r\n      }\r\n      case Token.PLUS:\r\n      case Token.PLUS_PLUS:\r\n      case Token.MINUS_MINUS: {\r\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\r\n        if (!type) return null;\r\n        let classReference = type.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        if (!type.isNumericValue) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              node.range, operatorTokenToString(operator), type.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        return type;\r\n      }\r\n      case Token.EXCLAMATION: {\r\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\r\n        if (!type) return null;\r\n        let classReference = type.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        return Type.bool; // incl. references\r\n      }\r\n      case Token.TILDE: {\r\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\r\n        if (!type) return null;\r\n        let classReference = type.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        if (!type.isNumericValue) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              node.range, \"~\", type.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        return type.intType;\r\n      }\r\n      case Token.DOT_DOT_DOT: {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Not_implemented_0,\r\n            node.range, \"Spread operator\"\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      default: assert(false);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the program element the specified unary postfix expression refers to. */\r\n  private lookupUnaryPostfixExpression(\r\n    /** The expression to resolve. */\r\n    node: UnaryPostfixExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!type) return null;\r\n    var element = this.getElementOfType(type);\r\n    if (!element) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n          node.range, operatorTokenToString(node.operator), type.toString()\r\n        );\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Resolves an unary postfix expression to its static type. */\r\n  private resolveUnaryPostfixExpression(\r\n    /** The expression to resolve. */\r\n    node: UnaryPostfixExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var operator = node.operator;\r\n    switch (operator) {\r\n      case Token.PLUS_PLUS:\r\n      case Token.MINUS_MINUS: {\r\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\r\n        if (!type) return null;\r\n        let classReference = type.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        if (!type.isNumericValue) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              node.range, operatorTokenToString(operator), type.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        return type;\r\n      }\r\n    }\r\n    assert(false);\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the program element the specified binary expression refers to. */\r\n  private lookupBinaryExpression(\r\n    /** The expression to look up. */\r\n    node: BinaryExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!type) return null;\r\n    var element = this.getElementOfType(type);\r\n    if (element) return element; // otherwise void\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\r\n        node.range, type.toString()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a binary expression to its static type. */\r\n  private resolveBinaryExpression(\r\n    /** The expression to resolve. */\r\n    node: BinaryExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var left = node.left;\r\n    var right = node.right;\r\n    var operator = node.operator;\r\n\r\n    switch (operator) {\r\n\r\n      // assignment: result is the target's type\r\n\r\n      case Token.EQUALS:\r\n      case Token.PLUS_EQUALS:\r\n      case Token.MINUS_EQUALS:\r\n      case Token.ASTERISK_EQUALS:\r\n      case Token.ASTERISK_ASTERISK_EQUALS:\r\n      case Token.SLASH_EQUALS:\r\n      case Token.PERCENT_EQUALS:\r\n      case Token.LESSTHAN_LESSTHAN_EQUALS:\r\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n      case Token.AMPERSAND_EQUALS:\r\n      case Token.BAR_EQUALS:\r\n      case Token.CARET_EQUALS: {\r\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n      }\r\n\r\n      // comparison: result is Bool, preferring overloads, integer/float only\r\n\r\n      case Token.LESSTHAN:\r\n      case Token.GREATERTHAN:\r\n      case Token.LESSTHAN_EQUALS:\r\n      case Token.GREATERTHAN_EQUALS: {\r\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n        if (!leftType) return null;\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        if (!leftType.isNumericValue) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              node.range, operatorTokenToString(operator), leftType.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        return Type.bool;\r\n      }\r\n\r\n      // equality: result is Bool, preferring overloads, incl. references\r\n\r\n      case Token.EQUALS_EQUALS:\r\n      case Token.EXCLAMATION_EQUALS: {\r\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n        if (!leftType) return null;\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        return Type.bool;\r\n      }\r\n\r\n      // identity: result is Bool, not supporting overloads\r\n\r\n      case Token.EQUALS_EQUALS_EQUALS:\r\n      case Token.EXCLAMATION_EQUALS_EQUALS: {\r\n        return Type.bool;\r\n      }\r\n\r\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\r\n\r\n      case Token.PLUS:\r\n      case Token.MINUS:\r\n      case Token.ASTERISK:\r\n      case Token.SLASH:\r\n      case Token.PERCENT: { // mod has special logic, but also behaves like this\r\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n        if (!leftType) return null;\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\r\n        if (!rightType) return null;\r\n        let commonType = Type.commonDenominator(leftType, rightType, false);\r\n        if (!commonType) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              node.range, leftType.toString(), rightType.toString()\r\n            );\r\n          }\r\n        }\r\n        return commonType;\r\n      }\r\n\r\n      // pow: result is common type of LHS and RHS, preferring overloads\r\n\r\n      case Token.ASTERISK_ASTERISK: {\r\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n        if (!leftType) return null;\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\r\n        if (!rightType) return null;\r\n        let commonType = Type.commonDenominator(leftType, rightType, false);\r\n        if (!commonType) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              node.range, leftType.toString(), rightType.toString()\r\n            );\r\n          }\r\n        }\r\n        return commonType;\r\n      }\r\n\r\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\r\n\r\n      case Token.LESSTHAN_LESSTHAN:\r\n      case Token.GREATERTHAN_GREATERTHAN:\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\r\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n        if (!leftType) return null;\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        if (!leftType.isIntegerValue) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\r\n              node.range, operatorTokenToString(operator), leftType.toString()\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n        return leftType;\r\n      }\r\n\r\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\r\n\r\n      case Token.AMPERSAND:\r\n      case Token.BAR:\r\n      case Token.CARET: {\r\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n        if (!leftType) return null;\r\n        let classReference = leftType.getClassOrWrapper(this.program);\r\n        if (classReference) {\r\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\r\n          if (overload) return overload.signature.returnType;\r\n        }\r\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\r\n        if (!rightType) return null;\r\n        let commonType = Type.commonDenominator(leftType, rightType, false);\r\n        if (!commonType || !commonType.isIntegerValue) {\r\n          if (reportMode == ReportMode.REPORT) {\r\n            this.error(\r\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\r\n            );\r\n          }\r\n        }\r\n        return commonType;\r\n      }\r\n\r\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\r\n\r\n      case Token.AMPERSAND_AMPERSAND:\r\n      case Token.BAR_BAR: {\r\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\r\n      }\r\n    }\r\n    assert(false);\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the program element the specified this expression refers to. */\r\n  private lookupThisExpression(\r\n    /** The expression to look up. */\r\n    node: ThisExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    if (ctxFlow.isInline) {\r\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\r\n      if (thisLocal) {\r\n        this.currentThisExpression = null;\r\n        this.currentElementExpression = null;\r\n        return thisLocal;\r\n      }\r\n    }\r\n    var parent = ctxFlow.actualFunction.parent;\r\n    if (parent) {\r\n      this.currentThisExpression = null;\r\n      this.currentElementExpression = null;\r\n      return parent;\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\r\n        node.range\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a this expression to its static type. */\r\n  private resolveThisExpression(\r\n    /** The expression to resolve. */\r\n    node: ThisExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!element) return null;\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Looks up the program element the specified super expression refers to. */\r\n  private lookupSuperExpression(\r\n    /** The expression to look up. */\r\n    node: SuperExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    if (ctxFlow.isInline) {\r\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\r\n      if (superLocal) {\r\n        this.currentThisExpression = null;\r\n        this.currentElementExpression = null;\r\n        return superLocal;\r\n      }\r\n    }\r\n    var parent: Element | null = ctxFlow.actualFunction.parent;\r\n    if (parent !== null && parent.kind == ElementKind.CLASS) {\r\n      let base = (<Class>parent).base;\r\n      if (base) {\r\n        this.currentThisExpression = null;\r\n        this.currentElementExpression = null;\r\n        return base;\r\n      }\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\r\n        node.range\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a super expression to its static type. */\r\n  private resolveSuperExpression(\r\n    /** The expression to resolve. */\r\n    node: SuperExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!element) return null;\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Looks up the program element the specified literal expression refers to. */\r\n  private lookupLiteralExpression(\r\n    /** The expression to look up. */\r\n    node: LiteralExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    this.currentThisExpression = node;\r\n    this.currentElementExpression = null;\r\n    switch (node.literalKind) {\r\n      case LiteralKind.INTEGER: {\r\n        let intType = this.determineIntegerLiteralType(\r\n          (<IntegerLiteralExpression>node).value,\r\n          ctxType\r\n        );\r\n        return assert(intType.getClassOrWrapper(this.program));\r\n      }\r\n      case LiteralKind.FLOAT: {\r\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\r\n        return assert(fltType.getClassOrWrapper(this.program));\r\n      }\r\n      case LiteralKind.STRING:\r\n      case LiteralKind.TEMPLATE: {\r\n        return this.program.stringInstance;\r\n      }\r\n      case LiteralKind.ARRAY: {\r\n        let classReference = ctxType.getClass();\r\n        if (classReference !== null && classReference.prototype == this.program.arrayPrototype) {\r\n          return this.getElementOfType(ctxType);\r\n        }\r\n        // otherwise infer, ignoring ctxType\r\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\r\n        let length = expressions.length;\r\n        let elementType = Type.auto;\r\n        let numNullLiterals = 0;\r\n        for (let i = 0, k = length; i < k; ++i) {\r\n          let expression = expressions[i];\r\n          if (expression) {\r\n            if (expression.kind == NodeKind.NULL && length > 1) {\r\n              ++numNullLiterals;\r\n            } else {\r\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\r\n              if (!currentType) return null;\r\n              if (elementType == Type.auto) elementType = currentType;\r\n              else if (currentType != elementType) {\r\n                let commonType = Type.commonDenominator(elementType, currentType, false);\r\n                if (commonType) elementType = commonType;\r\n                // otherwise triggers error on compilation\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (elementType /* still */ == Type.auto) {\r\n          if (numNullLiterals == length) { // all nulls infers as usize\r\n            elementType = this.program.options.usizeType;\r\n          } else {\r\n            if (reportMode == ReportMode.REPORT) {\r\n              this.error(\r\n                DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\r\n                node.range, \"T\"\r\n              );\r\n            }\r\n            return null;\r\n          }\r\n        }\r\n        if (\r\n          numNullLiterals > 0 &&\r\n          elementType.isInternalReference\r\n        ) {\r\n          elementType = elementType.asNullable();\r\n        }\r\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\r\n      }\r\n      case LiteralKind.OBJECT: {\r\n        if (ctxType.isClass) return ctxType.classReference;\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n            node.range\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n    assert(false);\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a literal expression to its static type. */\r\n  private resolveLiteralExpression(\r\n    /** The expression to resolve. */\r\n    node: LiteralExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!element) return null;\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Looks up the program element the specified call expression refers to. */\r\n  private lookupCallExpression(\r\n    /** The expression to look up. */\r\n    node: CallExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.void,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!type) return null;\r\n    var element = this.getElementOfType(type);\r\n    if (!element) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\r\n          node.range, type.toString()\r\n        );\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Resolves a call expression to its static type. */\r\n  private resolveCallExpression(\r\n    /** The expression to resolve. */\r\n    node: CallExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.void,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var targetExpression = node.expression;\r\n    var target = this.lookupExpression( // reports\r\n      targetExpression,\r\n      ctxFlow,\r\n      ctxType,\r\n      reportMode\r\n    );\r\n    if (!target) return null;\r\n    switch (target.kind) {\r\n      case ElementKind.FUNCTION_PROTOTYPE: {\r\n        let functionPrototype = <FunctionPrototype>target;\r\n        // `unchecked` behaves like parenthesized\r\n        if (\r\n          functionPrototype.internalName == BuiltinNames.unchecked &&\r\n          node.args.length > 0\r\n        ) {\r\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\r\n        }\r\n        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\r\n        if (!instance) return null;\r\n        return instance.signature.returnType;\r\n      }\r\n      case ElementKind.GLOBAL:\r\n      case ElementKind.LOCAL:\r\n      case ElementKind.FIELD: {\r\n        let varType = (<VariableLikeElement>target).type;\r\n        let varElement = this.getElementOfType(varType);\r\n        if (!varElement || varElement.kind != ElementKind.CLASS) {\r\n          break;\r\n        }\r\n        target = varElement;\r\n        // fall-through\r\n      }\r\n      case ElementKind.CLASS: {\r\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\r\n        if (typeArguments !== null && typeArguments.length > 0) {\r\n          let ftype = typeArguments[0];\r\n          let signatureReference = assert(ftype.signatureReference);\r\n          return signatureReference.returnType;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n        targetExpression.range, target.internalName\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Looks up the program element the specified comma expression refers to. */\r\n  private lookupCommaExpression(\r\n    /** The expression to look up. */\r\n    node: CommaExpression,\r\n    /** Flow to search for scoped locals. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var expressions = node.expressions;\r\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\r\n  }\r\n\r\n  /** Resolves a comma expression to its static type. */\r\n  private resolveCommaExpression(\r\n    /** The expression to resolve. */\r\n    node: CommaExpression,\r\n    /** Flow to search for scoped locals. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var expressions = node.expressions;\r\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\r\n  }\r\n\r\n  /** Looks up the program element the specified instanceof expression refers to. */\r\n  private lookupInstanceOfExpression(\r\n    /** The expression to look up. */\r\n    node: InstanceOfExpression,\r\n    /** Flow to search for scoped locals. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    return assert(Type.bool.getClassOrWrapper(this.program));\r\n  }\r\n\r\n  /** Resolves an instanceof expression to its static type. */\r\n  private resolveInstanceOfExpression(\r\n    /** The expression to resolve. */\r\n    node: InstanceOfExpression,\r\n    /** Flow to search for scoped locals. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type = Type.auto,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    return Type.bool;\r\n  }\r\n\r\n  /** Looks up the program element the specified ternary expression refers to. */\r\n  private lookupTernaryExpression(\r\n    /** The expression to look up. */\r\n    node: TernaryExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!type) return null;\r\n    var element = this.getElementOfType(type);\r\n    if (!element) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\r\n          node.range, type.toString()\r\n        );\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Resolves a ternary expression to its static type. */\r\n  private resolveTernaryExpression(\r\n    /** The expression to resolve. */\r\n    node: TernaryExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\r\n    if (!thenType) return null;\r\n    var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\r\n    if (!elseType) return null;\r\n    var commonType = Type.commonDenominator(thenType, elseType, false);\r\n    if (!commonType) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n          node.range, \"?:\", thenType.toString(), elseType.toString()\r\n        );\r\n      }\r\n    }\r\n    return commonType;\r\n  }\r\n\r\n  /** Looks up the program element the specified new expression refers to. */\r\n  private lookupNewExpression(\r\n    /** The expression to look up. */\r\n    node: NewExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var element = this.resolveTypeName(node.typeName, ctxFlow.actualFunction, reportMode);\r\n    if (!element) return null;\r\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\r\n      return this.resolveClassInclTypeArguments(\r\n        <ClassPrototype>element,\r\n        node.typeArguments,\r\n        ctxFlow.actualFunction,\r\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\r\n        node,\r\n        reportMode\r\n      );\r\n    }\r\n    if (reportMode == ReportMode.REPORT) {\r\n      this.error(\r\n        DiagnosticCode.This_expression_is_not_constructable,\r\n        node.range\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a new expression to its static type. */\r\n  private resolveNewExpression(\r\n    /** The expression to resolve. */\r\n    node: NewExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!element) return null;\r\n    var type = this.getTypeOfElement(element);\r\n    if (!type) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\r\n          node.range\r\n        );\r\n      }\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /** Looks up the program element the specified function expression refers to. */\r\n  private lookupFunctionExpression(\r\n    /** The expression to look up. */\r\n    node: FunctionExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Element | null {\r\n    var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\r\n    if (!type) return null;\r\n    var element = this.getElementOfType(type);\r\n    if (!element) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\r\n          node.range, type.toString()\r\n        );\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  /** Resolves a function expression to its static type. */\r\n  private resolveFunctionExpression(\r\n    /** The expression to resolve. */\r\n    node: FunctionExpression,\r\n    /** Contextual flow. */\r\n    ctxFlow: Flow,\r\n    /** Contextual type. */\r\n    ctxType: Type,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Type | null {\r\n    return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);\r\n  }\r\n\r\n  // ==================================================== Elements =====================================================\r\n\r\n  /** Resolves a function prototype using the specified concrete type arguments. */\r\n  resolveFunction(\r\n    /** The prototype of the function. */\r\n    prototype: FunctionPrototype,\r\n    /** Type arguments provided. */\r\n    typeArguments: Type[] | null,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Function | null {\r\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\r\n      ? prototype.parent.parent\r\n      : prototype.parent;\r\n    var classInstance: Class | null = null; // if an instance method\r\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\r\n\r\n    // Instance method prototypes are pre-bound to their concrete class as their parent\r\n    if (prototype.is(CommonFlags.INSTANCE)) {\r\n      assert(actualParent.kind == ElementKind.CLASS || actualParent.kind == ElementKind.INTERFACE);\r\n      classInstance = <Class>actualParent;\r\n\r\n      // check if this exact concrete class and function combination is known already\r\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\r\n      if (resolvedInstance) return resolvedInstance;\r\n\r\n      // inherit class specific type arguments\r\n      let classTypeArguments = classInstance.typeArguments;\r\n      if (classTypeArguments) {\r\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\r\n        let numClassTypeArguments = classTypeParameters.length;\r\n        assert(numClassTypeArguments == classTypeParameters.length);\r\n        for (let i = 0; i < numClassTypeArguments; ++i) {\r\n          let classTypeParameterName = classTypeParameters[i].name.text;\r\n          if (!ctxTypes.has(classTypeParameterName)) {\r\n            ctxTypes.set(\r\n              classTypeParameterName,\r\n              classTypeArguments[i]\r\n            );\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      assert(actualParent.kind != ElementKind.CLASS); // must not be pre-bound\r\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\r\n      if (resolvedInstance) return resolvedInstance;\r\n    }\r\n\r\n    // override whatever is contextual with actual function type arguments\r\n    var signatureNode = prototype.functionTypeNode;\r\n    var typeParameterNodes = prototype.typeParameterNodes;\r\n    var numFunctionTypeArguments: i32;\r\n    if (typeArguments !== null && (numFunctionTypeArguments = typeArguments.length) > 0) {\r\n      assert(typeParameterNodes !== null && numFunctionTypeArguments == typeParameterNodes.length);\r\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\r\n        ctxTypes.set(\r\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\r\n          typeArguments[i]\r\n        );\r\n      }\r\n    } else {\r\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\r\n    }\r\n\r\n    // resolve `this` type if applicable\r\n    var thisType: Type | null = null;\r\n    var explicitThisType = signatureNode.explicitThisType;\r\n    if (explicitThisType) {\r\n      thisType = this.resolveType(\r\n        explicitThisType,\r\n        prototype.parent, // relative to function\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!thisType) return null;\r\n      ctxTypes.set(CommonNames.this_, thisType);\r\n    } else if (classInstance) {\r\n      thisType = classInstance.type;\r\n      ctxTypes.set(CommonNames.this_, thisType);\r\n    }\r\n\r\n    // resolve parameter types\r\n    var signatureParameters = signatureNode.parameters;\r\n    var numSignatureParameters = signatureParameters.length;\r\n    var parameterTypes = new Array<Type>(numSignatureParameters);\r\n    var requiredParameters = 0;\r\n    for (let i = 0; i < numSignatureParameters; ++i) {\r\n      let parameterDeclaration = signatureParameters[i];\r\n      if (parameterDeclaration.parameterKind == ParameterKind.DEFAULT) {\r\n        requiredParameters = i + 1;\r\n      }\r\n      let typeNode = parameterDeclaration.type;\r\n      if (isTypeOmitted(typeNode)) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            typeNode.range\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      let parameterType = this.resolveType(\r\n        typeNode,\r\n        prototype.parent, // relative to function\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!parameterType) return null;\r\n      if (parameterType == Type.void) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            typeNode.range\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      parameterTypes[i] = parameterType;\r\n    }\r\n\r\n    // resolve return type\r\n    var returnType: Type;\r\n    if (prototype.is(CommonFlags.SET)) {\r\n      returnType = Type.void; // not annotated\r\n    } else if (prototype.is(CommonFlags.CONSTRUCTOR)) {\r\n      returnType = classInstance!.type; // not annotated\r\n    } else {\r\n      let typeNode = signatureNode.returnType;\r\n      if (isTypeOmitted(typeNode)) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            typeNode.range\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      let type = this.resolveType(\r\n        typeNode,\r\n        prototype.parent, // relative to function\r\n        ctxTypes,\r\n        reportMode\r\n      );\r\n      if (!type) return null;\r\n      returnType = type;\r\n    }\r\n\r\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\r\n    signature.requiredParameters = requiredParameters;\r\n\r\n    var nameInclTypeParameters = prototype.name;\r\n    if (instanceKey.length) nameInclTypeParameters += \"<\" + instanceKey + \">\";\r\n    var instance = new Function(\r\n      nameInclTypeParameters,\r\n      prototype,\r\n      typeArguments,\r\n      signature,\r\n      ctxTypes\r\n    );\r\n    prototype.setResolvedInstance(instanceKey, instance);\r\n    return instance;\r\n  }\r\n\r\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\r\n  resolveFunctionInclTypeArguments(\r\n    /** The prototype of the function. */\r\n    prototype: FunctionPrototype,\r\n    /** Type arguments provided to be resolved. */\r\n    typeArgumentNodes: TypeNode[] | null,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type>,\r\n    /** The node to use when reporting intermediate errors. */\r\n    reportNode: Node,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Function | null {\r\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\r\n      ? prototype.parent.parent\r\n      : prototype.parent;\r\n    var resolvedTypeArguments: Type[] | null = null;\r\n\r\n    // Resolve type arguments if generic\r\n    if (prototype.is(CommonFlags.GENERIC)) {\r\n\r\n      // If this is an instance method, first apply the class's type arguments\r\n      if (prototype.is(CommonFlags.INSTANCE)) {\r\n        assert(actualParent.kind == ElementKind.CLASS);\r\n        let classInstance = <Class>actualParent;\r\n        let classTypeArguments = classInstance.typeArguments;\r\n        if (classTypeArguments) {\r\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\r\n          let numClassTypeArguments = classTypeArguments.length;\r\n          assert(numClassTypeArguments == typeParameterNodes.length);\r\n          for (let i = 0; i < numClassTypeArguments; ++i) {\r\n            ctxTypes.set(\r\n              typeParameterNodes[i].name.text,\r\n              classTypeArguments[i]\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\r\n        assert(prototype.typeParameterNodes),\r\n        typeArgumentNodes,\r\n        ctxElement,\r\n        ctxTypes, // update\r\n        reportNode,\r\n        reportMode\r\n      );\r\n      if (!resolvedTypeArguments) return null;\r\n\r\n    // Otherwise make sure that no type arguments have been specified\r\n    } else {\r\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_generic,\r\n            reportNode.range, prototype.internalName\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Continue with concrete types\r\n    return this.resolveFunction(\r\n      prototype,\r\n      resolvedTypeArguments,\r\n      ctxTypes,\r\n      reportMode\r\n    );\r\n  }\r\n\r\n  /** Currently resolving classes. */\r\n  private resolveClassPending: Set<Class> = new Set();\r\n\r\n  /** Resolves a class prototype using the specified concrete type arguments. */\r\n  resolveClass(\r\n    /** The prototype of the class. */\r\n    prototype: ClassPrototype,\r\n    /** Type arguments provided. */\r\n    typeArguments: Type[] | null,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Class | null {\r\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\r\n\r\n    // Do not attempt to resolve the same class twice. This can return a class\r\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\r\n    var instance = prototype.getResolvedInstance(instanceKey);\r\n    if (instance) return instance;\r\n\r\n    // Otherwise create\r\n    var nameInclTypeParamters = prototype.name;\r\n    if (instanceKey.length) nameInclTypeParamters += \"<\" + instanceKey + \">\";\r\n    if (prototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\r\n      instance = new Interface(nameInclTypeParamters, <InterfacePrototype>prototype, typeArguments);\r\n    } else {\r\n      instance = new Class(nameInclTypeParamters, prototype, typeArguments);\r\n    }\r\n    prototype.setResolvedInstance(instanceKey, instance);\r\n    var pendingClasses = this.resolveClassPending;\r\n    pendingClasses.add(instance);\r\n\r\n    // Insert contextual type arguments for this operation. Internally, this method is always\r\n    // called with matching type parameter / argument counts.\r\n    if (typeArguments) {\r\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\r\n      let numTypeParameters = typeParameterNodes.length;\r\n      let numTypeArguments = typeArguments.length;\r\n      assert(numTypeArguments == numTypeParameters);\r\n      for (let i = 0; i < numTypeArguments; ++i) {\r\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\r\n      }\r\n    } else {\r\n      let typeParameterNodes = prototype.typeParameterNodes;\r\n      assert(!(typeParameterNodes !== null && typeParameterNodes.length > 0));\r\n    }\r\n    instance.contextualTypeArguments = ctxTypes;\r\n\r\n    var anyPending = false;\r\n\r\n    // Resolve base class if applicable\r\n    var basePrototype = prototype.basePrototype;\r\n    if (basePrototype) {\r\n      let current: ClassPrototype | null = basePrototype;\r\n      do {\r\n        if (current == prototype) {\r\n          this.error(\r\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\r\n            prototype.identifierNode.range,\r\n            prototype.internalName\r\n          );\r\n          return null;\r\n        }\r\n        current = current.basePrototype;\r\n      } while (current);\r\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\r\n      let base = this.resolveClassInclTypeArguments(\r\n        basePrototype,\r\n        extendsNode.typeArguments,\r\n        prototype.parent, // relative to derived class\r\n        uniqueMap(ctxTypes), // don't inherit\r\n        extendsNode,\r\n        reportMode\r\n      );\r\n      if (!base) return null;\r\n      instance.setBase(base);\r\n\r\n      // If the base class is still pending, yield here and instead resolve any\r\n      // derived classes once the base class's `finishResolveClass` is done.\r\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\r\n      // where `resolveClass` is called from other code.\r\n      if (pendingClasses.has(base)) anyPending = true;\r\n    }\r\n\r\n    // Resolve interfaces if applicable\r\n    var interfacePrototypes = prototype.interfacePrototypes;\r\n    if (interfacePrototypes) {\r\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\r\n        let interfacePrototype = interfacePrototypes[i];\r\n        let current: ClassPrototype | null = interfacePrototype;\r\n        do {\r\n          if (current == prototype) {\r\n            this.error(\r\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\r\n              prototype.identifierNode.range,\r\n              prototype.internalName\r\n            );\r\n            return null;\r\n          }\r\n          current = current.basePrototype;\r\n        } while (current);\r\n        let implementsNode = assert(prototype.implementsNodes![i]);\r\n        let iface = this.resolveClassInclTypeArguments(\r\n          interfacePrototype,\r\n          implementsNode.typeArguments,\r\n          prototype.parent,\r\n          uniqueMap(ctxTypes),\r\n          implementsNode,\r\n          reportMode\r\n        );\r\n        if (!iface) return null;\r\n        assert(iface.kind == ElementKind.INTERFACE);\r\n        instance.addInterface(<Interface>iface);\r\n\r\n        // Like above, if any implemented interface is still pending, yield\r\n        if (pendingClasses.has(iface)) anyPending = true;\r\n      }\r\n    }\r\n    if (anyPending) return instance;\r\n\r\n    // We only get here if the base class has been fully resolved already.\r\n    this.finishResolveClass(instance, reportMode);\r\n    return instance;\r\n  }\r\n\r\n  /** Finishes resolving the specified class. */\r\n  private finishResolveClass(\r\n    /** Class to finish resolving. */\r\n    instance: Class,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode\r\n  ): void {\r\n    var members = instance.members;\r\n    if (!members) instance.members = members = new Map();\r\n\r\n    var pendingClasses = this.resolveClassPending;\r\n    var unimplemented = new Map<string,DeclaredElement>();\r\n\r\n    // Alias interface members\r\n    var interfaces = instance.interfaces;\r\n    if (interfaces) {\r\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\r\n        let iface = _values[i];\r\n        assert(!pendingClasses.has(iface));\r\n        let ifaceMembers = iface.members;\r\n        if (ifaceMembers) {\r\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\r\n            let memberName = unchecked(_keys[i]);\r\n            let member = assert(ifaceMembers.get(memberName));\r\n            if (members.has(memberName)) {\r\n              let existing = assert(members.get(memberName));\r\n              if (!member.isCompatibleOverride(existing)) {\r\n                this.errorRelated(\r\n                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\r\n                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange\r\n                );\r\n                continue;\r\n              }\r\n            }\r\n            members.set(memberName, member);\r\n            unimplemented.set(memberName, member);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Alias base members\r\n    var memoryOffset: u32 = 0;\r\n    var base = instance.base;\r\n    if (base) {\r\n      assert(!pendingClasses.has(base));\r\n      let baseMembers = base.members;\r\n      if (baseMembers) {\r\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\r\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\r\n          let memberName = unchecked(_keys[i]);\r\n          let member = assert(baseMembers.get(memberName));\r\n          if (members.has(memberName)) {\r\n            let existing = assert(members.get(memberName));\r\n            if (!member.isCompatibleOverride(existing)) {\r\n              this.errorRelated(\r\n                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\r\n                member.identifierAndSignatureRange, existing.identifierAndSignatureRange\r\n              );\r\n              continue;\r\n            }\r\n          }\r\n          members.set(memberName, member);\r\n          if (member.is(CommonFlags.ABSTRACT)) {\r\n            unimplemented.set(memberName, member);\r\n          } else {\r\n            unimplemented.delete(memberName);\r\n          }\r\n        }\r\n      }\r\n      memoryOffset = base.nextMemoryOffset;\r\n    }\r\n\r\n    // Resolve instance members\r\n    var prototype = instance.prototype;\r\n    var instanceMemberPrototypes = prototype.instanceMembers;\r\n    var properties = new Array<Property>();\r\n    if (instanceMemberPrototypes) {\r\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\r\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\r\n        let member = unchecked(_values[i]);\r\n        let memberName = member.name;\r\n        switch (member.kind) {\r\n\r\n          case ElementKind.FIELD_PROTOTYPE: {\r\n            let fieldPrototype = <FieldPrototype>member;\r\n            let fieldTypeNode = fieldPrototype.typeNode;\r\n            let fieldType: Type | null = null;\r\n            // TODO: handle duplicate non-private fields specifically?\r\n            if (!fieldTypeNode) {\r\n              if (base) {\r\n                let baseMembers = base.members;\r\n                if (baseMembers !== null && baseMembers.has(fieldPrototype.name)) {\r\n                  let baseField = assert(baseMembers.get(fieldPrototype.name));\r\n                  if (!baseField.is(CommonFlags.PRIVATE)) {\r\n                    assert(baseField.kind == ElementKind.FIELD);\r\n                    fieldType = (<Field>baseField).type;\r\n                  }\r\n                }\r\n              }\r\n              if (!fieldType) {\r\n                if (reportMode == ReportMode.REPORT) {\r\n                  this.error(\r\n                    DiagnosticCode.Type_expected,\r\n                    fieldPrototype.identifierNode.range.atEnd\r\n                  );\r\n                }\r\n              }\r\n            } else {\r\n              fieldType = this.resolveType(\r\n                fieldTypeNode,\r\n                prototype.parent, // relative to class\r\n                instance.contextualTypeArguments,\r\n                reportMode\r\n              );\r\n              if (fieldType == Type.void) {\r\n                if (reportMode == ReportMode.REPORT) {\r\n                  this.error(\r\n                    DiagnosticCode.Type_expected,\r\n                    fieldTypeNode.range\r\n                  );\r\n                }\r\n                break;\r\n              }\r\n            }\r\n            if (!fieldType) break; // did report above\r\n            let fieldInstance = new Field(fieldPrototype, instance, fieldType);\r\n            assert(isPowerOf2(fieldType.byteSize));\r\n            let mask = fieldType.byteSize - 1;\r\n            if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\r\n            fieldInstance.memoryOffset = memoryOffset;\r\n            memoryOffset += fieldType.byteSize;\r\n            instance.add(memberName, fieldInstance); // reports\r\n            break;\r\n          }\r\n          case ElementKind.FUNCTION_PROTOTYPE: {\r\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\r\n            instance.add(boundPrototype.name, boundPrototype); // reports\r\n            break;\r\n          }\r\n          case ElementKind.PROPERTY_PROTOTYPE: {\r\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\r\n            instance.add(boundPrototype.name, boundPrototype); // reports\r\n            break;\r\n          }\r\n          default: assert(false);\r\n        }\r\n        if (!member.is(CommonFlags.ABSTRACT)) {\r\n          unimplemented.delete(memberName);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check that property getters and setters match\r\n    for (let i = 0, k = properties.length; i < k; ++i) {\r\n      let property = properties[i];\r\n      let propertyGetter = property.getterInstance;\r\n      if (!propertyGetter) {\r\n        this.error(\r\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\r\n          property.identifierNode.range, property.name\r\n        );\r\n      } else {\r\n        let propertySetter = property.setterInstance;\r\n        if (propertySetter !== null && !propertyGetter.visibilityEquals(propertySetter)) {\r\n          this.errorRelated(\r\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\r\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    if (instance.kind != ElementKind.INTERFACE) {\r\n\r\n      // Check that all required members are implemented\r\n      if (!instance.is(CommonFlags.ABSTRACT) && unimplemented.size > 0) {\r\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\r\n          let memberName = _keys[i];\r\n          let member = assert(unimplemented.get(memberName));\r\n          this.errorRelated(\r\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\r\n            instance.identifierNode.range, member.identifierNode.range,\r\n            instance.internalName, memberName, member.parent.internalName\r\n          );\r\n        }\r\n      }\r\n\r\n      // Finalize memory offset\r\n      instance.nextMemoryOffset = memoryOffset;\r\n\r\n      // Link _own_ constructor if present\r\n      {\r\n        let ctorPrototype = instance.lookupInSelf(CommonNames.constructor);\r\n        if (ctorPrototype !== null && ctorPrototype.parent === instance) {\r\n          assert(ctorPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n          let ctorInstance = this.resolveFunction(\r\n            <FunctionPrototype>ctorPrototype,\r\n            null,\r\n            assert(instance.contextualTypeArguments),\r\n            reportMode\r\n          );\r\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fully resolve operator overloads (don't have type parameters on their own)\r\n    var overloadPrototypes = prototype.overloadPrototypes;\r\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\r\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\r\n      let overloadKind = unchecked(_keys[i]);\r\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\r\n      assert(overloadKind != OperatorKind.INVALID);\r\n      if (overloadPrototype.is(CommonFlags.GENERIC)) {\r\n        // Already errored during initialization: AS212: Decorator '@operator' is not valid here\r\n        continue;\r\n      }\r\n      let operatorInstance: Function | null;\r\n      if (overloadPrototype.is(CommonFlags.INSTANCE)) {\r\n        let boundPrototype = overloadPrototype.toBound(instance);\r\n        operatorInstance = this.resolveFunction(\r\n          boundPrototype,\r\n          null,\r\n          uniqueMap<string,Type>(),\r\n          reportMode\r\n        );\r\n      } else {\r\n        operatorInstance = this.resolveFunction(\r\n          overloadPrototype,\r\n          null,\r\n          uniqueMap<string,Type>(),\r\n          reportMode\r\n        );\r\n      }\r\n      if (!operatorInstance) continue;\r\n      let overloads = instance.overloads;\r\n      if (!overloads) instance.overloads = overloads = new Map();\r\n      // inc/dec are special in that an instance overload attempts to re-assign\r\n      // the corresponding value, thus requiring a matching return type, while a\r\n      // static overload works like any other overload.\r\n      if (operatorInstance.is(CommonFlags.INSTANCE)) {\r\n        switch (overloadKind) {\r\n          case OperatorKind.PREFIX_INC:\r\n          case OperatorKind.PREFIX_DEC:\r\n          case OperatorKind.POSTFIX_INC:\r\n          case OperatorKind.POSTFIX_DEC: {\r\n            let returnType = operatorInstance.signature.returnType;\r\n            if (!returnType.isAssignableTo(instance.type)) {\r\n              if (reportMode == ReportMode.REPORT) {\r\n                this.error(\r\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (!overloads.has(overloadKind)) {\r\n        overloads.set(overloadKind, operatorInstance);\r\n        if (overloadKind == OperatorKind.INDEXED_GET || overloadKind == OperatorKind.INDEXED_SET) {\r\n          let index = instance.indexSignature;\r\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\r\n          if (overloadKind == OperatorKind.INDEXED_GET) {\r\n            index.setType(operatorInstance.signature.returnType);\r\n          }\r\n        }\r\n      } else {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_decorator,\r\n            operatorInstance.declaration.range\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove this class from pending\r\n    assert(pendingClasses.has(instance)); // must be pending\r\n    pendingClasses.delete(instance);\r\n\r\n    // Finish derived classes that we postponed in `resolveClass` due to the\r\n    // base class still being pending, again triggering `finishResolveClass`\r\n    // of any classes derived from those classes, ultimately leading to all\r\n    // pending classes being resolved.\r\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\r\n      let pending = _values[i];\r\n      let dependsOnInstance = pending.base === instance;\r\n      let interfaces = pending.interfaces;\r\n      if (interfaces) {\r\n        let anyPending = false;\r\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\r\n          let iface = _values2[j];\r\n          if (iface === instance) dependsOnInstance = true;\r\n          else if (pendingClasses.has(iface)) anyPending = true;\r\n        }\r\n        if (anyPending) continue;\r\n      }\r\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\r\n    }\r\n  }\r\n\r\n  /** Resolves a class prototype by first resolving the specified type arguments. */\r\n  resolveClassInclTypeArguments(\r\n    /** The prototype of the class. */\r\n    prototype: ClassPrototype,\r\n    /** Type arguments provided to be resolved. */\r\n    typeArgumentNodes: TypeNode[] | null,\r\n    /** Contextual element. */\r\n    ctxElement: Element,\r\n    /** Contextual types, i.e. `T`. */\r\n    ctxTypes: Map<string,Type>,\r\n    /** The node to use when reporting intermediate errors. */\r\n    reportNode: Node,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Class | null {\r\n    var resolvedTypeArguments: Type[] | null = null;\r\n\r\n    // Resolve type arguments if generic\r\n    if (prototype.is(CommonFlags.GENERIC)) {\r\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\r\n        assert(prototype.typeParameterNodes), // must be present if generic\r\n        typeArgumentNodes,\r\n        ctxElement,\r\n        ctxTypes, // update\r\n        reportNode,\r\n        reportMode\r\n      );\r\n      if (!resolvedTypeArguments) return null;\r\n\r\n    // Otherwise make sure that no type arguments have been specified\r\n    } else {\r\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\r\n        if (reportMode == ReportMode.REPORT) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_generic,\r\n            reportNode.range, prototype.internalName\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // Continue with concrete types\r\n    return this.resolveClass(\r\n      prototype,\r\n      resolvedTypeArguments,\r\n      ctxTypes,\r\n      reportMode\r\n    );\r\n  }\r\n\r\n  /** Resolves a property prototype. */\r\n  resolveProperty(\r\n    /** The prototype of the property. */\r\n    prototype: PropertyPrototype,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): Property | null {\r\n    var instance = prototype.instance;\r\n    if (instance) return instance;\r\n    prototype.instance = instance = new Property(prototype, prototype);\r\n    var getterPrototype = prototype.getterPrototype;\r\n    if (getterPrototype) {\r\n      let getterInstance = this.resolveFunction(\r\n        getterPrototype,\r\n        null,\r\n        uniqueMap<string,Type>(),\r\n        reportMode\r\n      );\r\n      if (getterInstance) {\r\n        instance.getterInstance = getterInstance;\r\n        instance.setType(getterInstance.signature.returnType);\r\n      }\r\n    }\r\n    var setterPrototype = prototype.setterPrototype;\r\n    if (setterPrototype) {\r\n      let setterInstance = this.resolveFunction(\r\n        setterPrototype,\r\n        null,\r\n        uniqueMap<string,Type>(),\r\n        reportMode\r\n      );\r\n      if (setterInstance) {\r\n        instance.setterInstance = setterInstance;\r\n        if (!instance.is(CommonFlags.RESOLVED)) {\r\n          assert(setterInstance.signature.parameterTypes.length == 1);\r\n          instance.setType(setterInstance.signature.parameterTypes[0]);\r\n        }\r\n      }\r\n    }\r\n    return instance;\r\n  }\r\n\r\n  private ensureOneTypeArgument(\r\n    /** The type to resolve. */\r\n    node: NamedTypeNode,\r\n    /** How to proceed with eventual diagnostics. */\r\n    reportMode: ReportMode = ReportMode.REPORT\r\n  ): TypeNode | null {\r\n    var typeArgumentNodes = node.typeArguments;\r\n    let numTypeArguments = 0;\r\n    if (!typeArgumentNodes || (numTypeArguments = typeArgumentNodes.length) != 1) {\r\n      if (reportMode == ReportMode.REPORT) {\r\n        this.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          node.range, \"1\", numTypeArguments.toString()\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    return typeArgumentNodes[0];\r\n  }\r\n}\r\n","/**\r\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\r\n *\r\n * The `Tokenizer` scans over a source file and returns one syntactic token\r\n * at a time that the parser will combine to an abstract syntax tree.\r\n *\r\n * It skips over trivia like comments and whitespace and provides a general\r\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\r\n * one token of lookahead otherwise.\r\n *\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticMessage,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Source,\r\n  CommentKind\r\n} from \"./ast\";\r\n\r\nimport {\r\n  CharCode,\r\n  isLineBreak,\r\n  isWhiteSpace,\r\n  isIdentifierStart,\r\n  isIdentifierPart,\r\n  isDecimalDigit,\r\n  isOctalDigit\r\n} from \"./util\";\r\n\r\n/** Named token types. */\r\nexport enum Token {\r\n\r\n  // keywords\r\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\r\n\r\n  ABSTRACT,\r\n  AS,\r\n  ASYNC,\r\n  AWAIT,        // ES2017\r\n  BREAK,        // ES2017\r\n  CASE,         // ES2017\r\n  CATCH,        // ES2017\r\n  CLASS,        // ES2017\r\n  CONST,        // ES2017\r\n  CONTINUE,     // ES2017\r\n  CONSTRUCTOR,\r\n  DEBUGGER,     // ES2017\r\n  DECLARE,\r\n  DEFAULT,      // ES2017\r\n  DELETE,       // ES2017\r\n  DO,           // ES2017\r\n  ELSE,         // ES2017\r\n  ENUM,         // ES2017 future\r\n  EXPORT,       // ES2017\r\n  EXTENDS,      // ES2017\r\n  FALSE,        // ES\r\n  FINALLY,      // ES2017\r\n  FOR,          // ES2017\r\n  FROM,         // AS possible identifier\r\n  FUNCTION,     // ES2017\r\n  GET,\r\n  IF,           // ES2017\r\n  IMPLEMENTS,   // ES2017 non-lexical\r\n  IMPORT,       // ES2017\r\n  IN,           // ES2017\r\n  INSTANCEOF,   // ES2017\r\n  INTERFACE,    // ES2017 non-lexical\r\n  IS,\r\n  KEYOF,\r\n  LET,          // ES2017 non-lexical\r\n  MODULE,       // AS possible identifier\r\n  NAMESPACE,    // AS possible identifier\r\n  NEW,          // ES2017\r\n  NULL,         // ES\r\n  OF,\r\n  PACKAGE,      // ES2017 non-lexical\r\n  PRIVATE,      // ES2017 non-lexical\r\n  PROTECTED,    // ES2017 non-lexical\r\n  PUBLIC,       // ES2017 non-lexical\r\n  READONLY,\r\n  RETURN,       // ES2017\r\n  SET,\r\n  STATIC,       // ES2017 non-lexical\r\n  SUPER,        // ES2017\r\n  SWITCH,       // ES2017\r\n  THIS,         // ES2017\r\n  THROW,        // ES2017\r\n  TRUE,         // ES\r\n  TRY,          // ES2017\r\n  TYPE,         // AS possible identifier\r\n  TYPEOF,       // ES2017\r\n  VAR,          // ES2017\r\n  VOID,         // ES2017\r\n  WHILE,        // ES2017\r\n  WITH,         // ES2017\r\n  YIELD,        // ES2017\r\n\r\n  // punctuation\r\n\r\n  OPENBRACE,\r\n  CLOSEBRACE,\r\n  OPENPAREN,\r\n  CLOSEPAREN,\r\n  OPENBRACKET,\r\n  CLOSEBRACKET,\r\n  DOT,\r\n  DOT_DOT_DOT,\r\n  SEMICOLON,\r\n  COMMA,\r\n  LESSTHAN,\r\n  GREATERTHAN,\r\n  LESSTHAN_EQUALS,\r\n  GREATERTHAN_EQUALS,\r\n  EQUALS_EQUALS,\r\n  EXCLAMATION_EQUALS,\r\n  EQUALS_EQUALS_EQUALS,\r\n  EXCLAMATION_EQUALS_EQUALS,\r\n  EQUALS_GREATERTHAN,\r\n  PLUS,\r\n  MINUS,\r\n  ASTERISK_ASTERISK,\r\n  ASTERISK,\r\n  SLASH,\r\n  PERCENT,\r\n  PLUS_PLUS,\r\n  MINUS_MINUS,\r\n  LESSTHAN_LESSTHAN,\r\n  GREATERTHAN_GREATERTHAN,\r\n  GREATERTHAN_GREATERTHAN_GREATERTHAN,\r\n  AMPERSAND,\r\n  BAR,\r\n  CARET,\r\n  EXCLAMATION,\r\n  TILDE,\r\n  AMPERSAND_AMPERSAND,\r\n  BAR_BAR,\r\n  QUESTION,\r\n  COLON,\r\n  EQUALS,\r\n  PLUS_EQUALS,\r\n  MINUS_EQUALS,\r\n  ASTERISK_EQUALS,\r\n  ASTERISK_ASTERISK_EQUALS,\r\n  SLASH_EQUALS,\r\n  PERCENT_EQUALS,\r\n  LESSTHAN_LESSTHAN_EQUALS,\r\n  GREATERTHAN_GREATERTHAN_EQUALS,\r\n  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,\r\n  AMPERSAND_EQUALS,\r\n  BAR_EQUALS,\r\n  CARET_EQUALS,\r\n  AT,\r\n\r\n  // literals\r\n\r\n  IDENTIFIER,\r\n  STRINGLITERAL,\r\n  INTEGERLITERAL,\r\n  FLOATLITERAL,\r\n  TEMPLATELITERAL,\r\n\r\n  // meta\r\n\r\n  INVALID,\r\n  ENDOFFILE\r\n}\r\n\r\nexport enum IdentifierHandling {\r\n  DEFAULT,\r\n  PREFER,\r\n  ALWAYS\r\n}\r\n\r\nexport function tokenFromKeyword(text: string): Token {\r\n  assert(text.length);\r\n  switch (text.charCodeAt(0)) {\r\n    case CharCode.a: {\r\n      if (text == \"abstract\") return Token.ABSTRACT;\r\n      if (text == \"as\") return Token.AS;\r\n      if (text == \"async\") return Token.ASYNC;\r\n      if (text == \"await\") return Token.AWAIT;\r\n      break;\r\n    }\r\n    case CharCode.b: {\r\n      if (text == \"break\") return Token.BREAK;\r\n      break;\r\n    }\r\n    case CharCode.c: {\r\n      if (text == \"case\") return Token.CASE;\r\n      if (text == \"catch\") return Token.CATCH;\r\n      if (text == \"class\") return Token.CLASS;\r\n      if (text == \"continue\") return Token.CONTINUE;\r\n      if (text == \"const\") return Token.CONST;\r\n      if (text == \"constructor\") return Token.CONSTRUCTOR;\r\n      break;\r\n    }\r\n    case CharCode.d: {\r\n      if (text == \"debugger\") return Token.DEBUGGER;\r\n      if (text == \"declare\") return Token.DECLARE;\r\n      if (text == \"default\") return Token.DEFAULT;\r\n      if (text == \"delete\") return Token.DELETE;\r\n      if (text == \"do\") return Token.DO;\r\n      break;\r\n    }\r\n    case CharCode.e: {\r\n      if (text == \"else\") return Token.ELSE;\r\n      if (text == \"enum\") return Token.ENUM;\r\n      if (text == \"export\") return Token.EXPORT;\r\n      if (text == \"extends\") return Token.EXTENDS;\r\n      break;\r\n    }\r\n    case CharCode.f: {\r\n      if (text == \"false\") return Token.FALSE;\r\n      if (text == \"finally\") return Token.FINALLY;\r\n      if (text == \"for\") return Token.FOR;\r\n      if (text == \"from\") return Token.FROM;\r\n      if (text == \"function\") return Token.FUNCTION;\r\n      break;\r\n    }\r\n    case CharCode.g: {\r\n      if (text == \"get\") return Token.GET;\r\n      break;\r\n    }\r\n    case CharCode.i: {\r\n      if (text == \"if\") return Token.IF;\r\n      if (text == \"implements\") return Token.IMPLEMENTS;\r\n      if (text == \"import\") return Token.IMPORT;\r\n      if (text == \"in\") return Token.IN;\r\n      if (text == \"instanceof\") return Token.INSTANCEOF;\r\n      if (text == \"interface\") return Token.INTERFACE;\r\n      if (text == \"is\") return Token.IS;\r\n      break;\r\n    }\r\n    case CharCode.k: {\r\n      if (text == \"keyof\") return Token.KEYOF;\r\n      break;\r\n    }\r\n    case CharCode.l: {\r\n      if (text == \"let\") return Token.LET;\r\n      break;\r\n    }\r\n    case CharCode.m: {\r\n      if (text == \"module\") return Token.MODULE;\r\n      break;\r\n    }\r\n    case CharCode.n: {\r\n      if (text == \"namespace\") return Token.NAMESPACE;\r\n      if (text == \"new\") return Token.NEW;\r\n      if (text == \"null\") return Token.NULL;\r\n      break;\r\n    }\r\n    case CharCode.o: {\r\n      if (text == \"of\") return Token.OF;\r\n      break;\r\n    }\r\n    case CharCode.p: {\r\n      if (text == \"package\") return Token.PACKAGE;\r\n      if (text == \"private\") return Token.PRIVATE;\r\n      if (text == \"protected\") return Token.PROTECTED;\r\n      if (text == \"public\") return Token.PUBLIC;\r\n      break;\r\n    }\r\n    case CharCode.r: {\r\n      if (text == \"readonly\") return Token.READONLY;\r\n      if (text == \"return\") return Token.RETURN;\r\n      break;\r\n    }\r\n    case CharCode.s: {\r\n      if (text == \"set\") return Token.SET;\r\n      if (text == \"static\") return Token.STATIC;\r\n      if (text == \"super\") return Token.SUPER;\r\n      if (text == \"switch\") return Token.SWITCH;\r\n      break;\r\n    }\r\n    case CharCode.t: {\r\n      if (text == \"this\") return Token.THIS;\r\n      if (text == \"throw\") return Token.THROW;\r\n      if (text == \"true\") return Token.TRUE;\r\n      if (text == \"try\") return Token.TRY;\r\n      if (text == \"type\") return Token.TYPE;\r\n      if (text == \"typeof\") return Token.TYPEOF;\r\n      break;\r\n    }\r\n    case CharCode.v: {\r\n      if (text == \"var\") return Token.VAR;\r\n      if (text == \"void\") return Token.VOID;\r\n      break;\r\n    }\r\n    case CharCode.w: {\r\n      if (text == \"while\") return Token.WHILE;\r\n      if (text == \"with\") return Token.WITH;\r\n      break;\r\n    }\r\n    case CharCode.y: {\r\n      if (text == \"yield\") return Token.YIELD;\r\n      break;\r\n    }\r\n  }\r\n  return Token.INVALID;\r\n}\r\n\r\nexport function tokenIsAlsoIdentifier(token: Token): bool {\r\n  switch (token) {\r\n    case Token.ABSTRACT:\r\n    case Token.AS:\r\n    case Token.CONSTRUCTOR:\r\n    case Token.DECLARE:\r\n    case Token.DELETE:\r\n    case Token.FROM:\r\n    case Token.FOR:\r\n    case Token.GET:\r\n    case Token.INSTANCEOF:\r\n    case Token.IS:\r\n    case Token.KEYOF:\r\n    case Token.MODULE:\r\n    case Token.NAMESPACE:\r\n    case Token.NULL:\r\n    case Token.READONLY:\r\n    case Token.SET:\r\n    case Token.TYPE:\r\n    case Token.VOID: return true;\r\n    default: return false;\r\n  }\r\n}\r\n\r\nexport function isIllegalVariableIdentifier(name: string): bool {\r\n  assert(name.length);\r\n  switch (name.charCodeAt(0)) {\r\n    case CharCode.d: return name == \"delete\";\r\n    case CharCode.f: return name == \"for\";\r\n    case CharCode.i: return name == \"instanceof\";\r\n    case CharCode.n: return name == \"null\";\r\n    case CharCode.v: return name == \"void\";\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function operatorTokenToString(token: Token): string {\r\n  switch (token) {\r\n    case Token.DELETE: return \"delete\";\r\n    case Token.IN: return \"in\";\r\n    case Token.INSTANCEOF: return \"instanceof\";\r\n    case Token.NEW: return \"new\";\r\n    case Token.TYPEOF: return \"typeof\";\r\n    case Token.VOID: return \"void\";\r\n    case Token.YIELD: return \"yield\";\r\n    case Token.DOT_DOT_DOT: return \"...\";\r\n    case Token.COMMA: return \",\";\r\n    case Token.LESSTHAN: return \"<\";\r\n    case Token.GREATERTHAN: return \">\";\r\n    case Token.LESSTHAN_EQUALS: return \"<=\";\r\n    case Token.GREATERTHAN_EQUALS: return \">=\";\r\n    case Token.EQUALS_EQUALS: return \"==\";\r\n    case Token.EXCLAMATION_EQUALS: return \"!=\";\r\n    case Token.EQUALS_EQUALS_EQUALS: return \"===\";\r\n    case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\r\n    case Token.PLUS: return \"+\";\r\n    case Token.MINUS: return \"-\";\r\n    case Token.ASTERISK_ASTERISK: return \"**\";\r\n    case Token.ASTERISK: return \"*\";\r\n    case Token.SLASH: return \"/\";\r\n    case Token.PERCENT: return \"%\";\r\n    case Token.PLUS_PLUS: return \"++\";\r\n    case Token.MINUS_MINUS: return \"--\";\r\n    case Token.LESSTHAN_LESSTHAN: return \"<<\";\r\n    case Token.GREATERTHAN_GREATERTHAN: return \">>\";\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\r\n    case Token.AMPERSAND: return \"&\";\r\n    case Token.BAR: return \"|\";\r\n    case Token.CARET: return \"^\";\r\n    case Token.EXCLAMATION: return \"!\";\r\n    case Token.TILDE: return \"~\";\r\n    case Token.AMPERSAND_AMPERSAND: return \"&&\";\r\n    case Token.BAR_BAR: return \"||\";\r\n    case Token.EQUALS: return \"=\";\r\n    case Token.PLUS_EQUALS: return \"+=\";\r\n    case Token.MINUS_EQUALS: return \"-=\";\r\n    case Token.ASTERISK_EQUALS: return \"*=\";\r\n    case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\r\n    case Token.SLASH_EQUALS: return \"/=\";\r\n    case Token.PERCENT_EQUALS: return \"%=\";\r\n    case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\r\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\r\n    case Token.AMPERSAND_EQUALS: return \"&=\";\r\n    case Token.BAR_EQUALS: return \"|=\";\r\n    case Token.CARET_EQUALS: return \"^=\";\r\n    default: {\r\n      assert(false);\r\n      return \"\";\r\n    }\r\n  }\r\n}\r\n\r\nexport class Range {\r\n\r\n  start: i32;\r\n  end: i32;\r\n  source!: Source;\r\n  debugInfoRef: usize = 0;\r\n\r\n  constructor(start: i32, end: i32) {\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n\r\n  static join(a: Range, b: Range): Range {\r\n    if (a.source != b.source) throw new Error(\"source mismatch\");\r\n    let range = new Range(\r\n      a.start < b.start ? a.start : b.start,\r\n      a.end > b.end ? a.end : b.end\r\n    );\r\n    range.source = a.source;\r\n    return range;\r\n  }\r\n\r\n  equals(other: Range): bool {\r\n    return this.source == other.source && this.start == other.start && this.end == other.end;\r\n  }\r\n\r\n  get atStart(): Range {\r\n    let range = new Range(this.start, this.start);\r\n    range.source = this.source;\r\n    return range;\r\n  }\r\n\r\n  get atEnd(): Range {\r\n    let range = new Range(this.end, this.end);\r\n    range.source = this.source;\r\n    return range;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.source.text.substring(this.start, this.end);\r\n  }\r\n}\r\n\r\n/** Handler for intercepting comments while tokenizing. */\r\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\r\n\r\n/** Tokenizes a source to individual {@link Token}s. */\r\nexport class Tokenizer extends DiagnosticEmitter {\r\n\r\n  source: Source;\r\n  end: i32 = 0;\r\n\r\n  pos: i32 = 0;\r\n  token: Token = -1;\r\n  tokenPos: i32 = 0;\r\n\r\n  nextToken: Token = -1;\r\n  nextTokenPos: i32 = 0;\r\n  nextTokenOnNewLine: bool = false;\r\n\r\n  onComment: CommentHandler | null = null;\r\n\r\n  /** Constructs a new tokenizer. */\r\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\r\n    super(diagnostics);\r\n\r\n    if (!diagnostics) diagnostics = [];\r\n    this.diagnostics = diagnostics;\r\n    this.source = source;\r\n\r\n    var text = source.text;\r\n    var end = text.length;\r\n    var pos = 0;\r\n    // skip bom\r\n    if (\r\n      pos < end &&\r\n      text.charCodeAt(pos) == CharCode.BYTEORDERMARK\r\n    ) {\r\n      ++pos;\r\n    }\r\n\r\n    // skip shebang\r\n    if (\r\n      pos + 1 < end &&\r\n      text.charCodeAt(pos) == CharCode.HASH &&\r\n      text.charCodeAt(pos + 1) == CharCode.EXCLAMATION\r\n    ) {\r\n      pos += 2;\r\n      while (\r\n        pos < end &&\r\n        text.charCodeAt(pos) != CharCode.LINEFEED\r\n      ) {\r\n        ++pos;\r\n      }\r\n      // 'next' now starts at lf or eof\r\n    }\r\n    this.pos = pos;\r\n    this.end = end;\r\n  }\r\n\r\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): Token {\r\n    this.nextToken = -1;\r\n    var token: Token;\r\n    do token = this.unsafeNext(identifierHandling);\r\n    while (token == Token.INVALID);\r\n    this.token = token;\r\n    return token;\r\n  }\r\n\r\n  private unsafeNext(\r\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\r\n    maxTokenLength: i32 = i32.MAX_VALUE\r\n  ): Token {\r\n    var text = this.source.text;\r\n    var end = this.end;\r\n    var pos = this.pos;\r\n    while (pos < end) {\r\n      this.tokenPos = pos;\r\n      let c = text.charCodeAt(pos);\r\n      switch (c) {\r\n        case CharCode.CARRIAGERETURN: {\r\n          if (!(\r\n            ++pos < end &&\r\n            text.charCodeAt(pos) == CharCode.LINEFEED\r\n          )) break;\r\n          // otherwise fall-through\r\n        }\r\n        case CharCode.LINEFEED:\r\n        case CharCode.TAB:\r\n        case CharCode.VERTICALTAB:\r\n        case CharCode.FORMFEED:\r\n        case CharCode.SPACE: {\r\n          ++pos;\r\n          break;\r\n        }\r\n        case CharCode.EXCLAMATION: {\r\n          ++pos;\r\n          if (\r\n            maxTokenLength > 1 && pos < end &&\r\n            text.charCodeAt(pos) == CharCode.EQUALS\r\n          ) {\r\n            ++pos;\r\n            if (\r\n              maxTokenLength > 2 && pos < end &&\r\n              text.charCodeAt(pos) == CharCode.EQUALS\r\n            ) {\r\n              this.pos = pos + 1;\r\n              return Token.EXCLAMATION_EQUALS_EQUALS;\r\n            }\r\n            this.pos = pos;\r\n            return Token.EXCLAMATION_EQUALS;\r\n          }\r\n          this.pos = pos;\r\n          return Token.EXCLAMATION;\r\n        }\r\n        case CharCode.DOUBLEQUOTE:\r\n        case CharCode.SINGLEQUOTE: {\r\n          this.pos = pos;\r\n          return Token.STRINGLITERAL;\r\n        }\r\n        case CharCode.BACKTICK: {\r\n          this.pos = pos;\r\n          return Token.TEMPLATELITERAL;\r\n        }\r\n        case CharCode.PERCENT: {\r\n          ++pos;\r\n          if (\r\n            maxTokenLength > 1 && pos < end &&\r\n            text.charCodeAt(pos) == CharCode.EQUALS\r\n          ) {\r\n            this.pos = pos + 1;\r\n            return Token.PERCENT_EQUALS;\r\n          }\r\n          this.pos = pos;\r\n          return Token.PERCENT;\r\n        }\r\n        case CharCode.AMPERSAND: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.AMPERSAND) {\r\n              this.pos = pos + 1;\r\n              return Token.AMPERSAND_AMPERSAND;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.AMPERSAND_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.AMPERSAND;\r\n        }\r\n        case CharCode.OPENPAREN: {\r\n          this.pos = pos + 1;\r\n          return Token.OPENPAREN;\r\n        }\r\n        case CharCode.CLOSEPAREN: {\r\n          this.pos = pos + 1;\r\n          return Token.CLOSEPAREN;\r\n        }\r\n        case CharCode.ASTERISK: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.ASTERISK_EQUALS;\r\n            }\r\n            if (chr == CharCode.ASTERISK) {\r\n              ++pos;\r\n              if (\r\n                maxTokenLength > 2 && pos < end &&\r\n                text.charCodeAt(pos) == CharCode.EQUALS\r\n              ) {\r\n                this.pos = pos + 1;\r\n                return Token.ASTERISK_ASTERISK_EQUALS;\r\n              }\r\n              this.pos = pos;\r\n              return Token.ASTERISK_ASTERISK;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.ASTERISK;\r\n        }\r\n        case CharCode.PLUS: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.PLUS) {\r\n              this.pos = pos + 1;\r\n              return Token.PLUS_PLUS;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.PLUS_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.PLUS;\r\n        }\r\n        case CharCode.COMMA: {\r\n          this.pos = pos + 1;\r\n          return Token.COMMA;\r\n        }\r\n        case CharCode.MINUS: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.MINUS) {\r\n              this.pos = pos + 1;\r\n              return Token.MINUS_MINUS;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.MINUS_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.MINUS;\r\n        }\r\n        case CharCode.DOT: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (isDecimalDigit(chr)) {\r\n              this.pos = pos - 1;\r\n              return Token.FLOATLITERAL; // expects a call to readFloat\r\n            }\r\n            if (\r\n              maxTokenLength > 2 && pos + 1 < end &&\r\n              chr == CharCode.DOT &&\r\n              text.charCodeAt(pos + 1) == CharCode.DOT\r\n            ) {\r\n              this.pos = pos + 2;\r\n              return Token.DOT_DOT_DOT;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.DOT;\r\n        }\r\n        case CharCode.SLASH: {\r\n          let commentStartPos = pos;\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.SLASH) { // single-line\r\n              let commentKind = CommentKind.LINE;\r\n              if (\r\n                pos + 1 < end &&\r\n                text.charCodeAt(pos + 1) == CharCode.SLASH\r\n              ) {\r\n                ++pos;\r\n                commentKind = CommentKind.TRIPLE;\r\n              }\r\n              while (++pos < end) {\r\n                if (text.charCodeAt(pos) == CharCode.LINEFEED) {\r\n                  ++pos;\r\n                  break;\r\n                }\r\n              }\r\n              if (this.onComment) {\r\n                this.onComment(\r\n                  commentKind,\r\n                  text.substring(commentStartPos, pos),\r\n                  this.range(commentStartPos, pos)\r\n                );\r\n              }\r\n              break;\r\n            }\r\n            if (chr == CharCode.ASTERISK) { // multi-line\r\n              let closed = false;\r\n              while (++pos < end) {\r\n                c = text.charCodeAt(pos);\r\n                if (\r\n                  c == CharCode.ASTERISK &&\r\n                  pos + 1 < end &&\r\n                  text.charCodeAt(pos + 1) == CharCode.SLASH\r\n                ) {\r\n                  pos += 2;\r\n                  closed = true;\r\n                  break;\r\n                }\r\n              }\r\n              if (!closed) {\r\n                this.error(\r\n                  DiagnosticCode._0_expected,\r\n                  this.range(pos), \"*/\"\r\n                );\r\n              } else if (this.onComment) {\r\n                this.onComment(\r\n                  CommentKind.BLOCK,\r\n                  text.substring(commentStartPos, pos),\r\n                  this.range(commentStartPos, pos)\r\n                );\r\n              }\r\n              break;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.SLASH_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.SLASH;\r\n        }\r\n        case CharCode._0:\r\n        case CharCode._1:\r\n        case CharCode._2:\r\n        case CharCode._3:\r\n        case CharCode._4:\r\n        case CharCode._5:\r\n        case CharCode._6:\r\n        case CharCode._7:\r\n        case CharCode._8:\r\n        case CharCode._9: {\r\n          this.pos = pos;\r\n          return this.testInteger()\r\n            ? Token.INTEGERLITERAL // expects a call to readInteger\r\n            : Token.FLOATLITERAL;  // expects a call to readFloat\r\n        }\r\n        case CharCode.COLON: {\r\n          this.pos = pos + 1;\r\n          return Token.COLON;\r\n        }\r\n        case CharCode.SEMICOLON: {\r\n          this.pos = pos + 1;\r\n          return Token.SEMICOLON;\r\n        }\r\n        case CharCode.LESSTHAN: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.LESSTHAN) {\r\n              ++pos;\r\n              if (\r\n                maxTokenLength > 2 &&\r\n                pos < end &&\r\n                text.charCodeAt(pos) == CharCode.EQUALS\r\n              ) {\r\n                this.pos = pos + 1;\r\n                return Token.LESSTHAN_LESSTHAN_EQUALS;\r\n              }\r\n              this.pos = pos;\r\n              return Token.LESSTHAN_LESSTHAN;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.LESSTHAN_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.LESSTHAN;\r\n        }\r\n        case CharCode.EQUALS: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.EQUALS) {\r\n              ++pos;\r\n              if (\r\n                maxTokenLength > 2 &&\r\n                pos < end &&\r\n                text.charCodeAt(pos) == CharCode.EQUALS\r\n              ) {\r\n                this.pos = pos + 1;\r\n                return Token.EQUALS_EQUALS_EQUALS;\r\n              }\r\n              this.pos = pos;\r\n              return Token.EQUALS_EQUALS;\r\n            }\r\n            if (chr == CharCode.GREATERTHAN) {\r\n              this.pos = pos + 1;\r\n              return Token.EQUALS_GREATERTHAN;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.EQUALS;\r\n        }\r\n        case CharCode.GREATERTHAN: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.GREATERTHAN) {\r\n              ++pos;\r\n              if (maxTokenLength > 2 && pos < end) {\r\n                chr = text.charCodeAt(pos);\r\n                if (chr == CharCode.GREATERTHAN) {\r\n                  ++pos;\r\n                  if (\r\n                    maxTokenLength > 3 && pos < end &&\r\n                    text.charCodeAt(pos) == CharCode.EQUALS\r\n                  ) {\r\n                    this.pos = pos + 1;\r\n                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\r\n                  }\r\n                  this.pos = pos;\r\n                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\r\n                }\r\n                if (chr == CharCode.EQUALS) {\r\n                  this.pos = pos + 1;\r\n                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;\r\n                }\r\n              }\r\n              this.pos = pos;\r\n              return Token.GREATERTHAN_GREATERTHAN;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.GREATERTHAN_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.GREATERTHAN;\r\n        }\r\n        case CharCode.QUESTION: {\r\n          this.pos = pos + 1;\r\n          return Token.QUESTION;\r\n        }\r\n        case CharCode.OPENBRACKET: {\r\n          this.pos = pos + 1;\r\n          return Token.OPENBRACKET;\r\n        }\r\n        case CharCode.CLOSEBRACKET: {\r\n          this.pos = pos + 1;\r\n          return Token.CLOSEBRACKET;\r\n        }\r\n        case CharCode.CARET: {\r\n          ++pos;\r\n          if (\r\n            maxTokenLength > 1 && pos < end &&\r\n            text.charCodeAt(pos) == CharCode.EQUALS\r\n          ) {\r\n            this.pos = pos + 1;\r\n            return Token.CARET_EQUALS;\r\n          }\r\n          this.pos = pos;\r\n          return Token.CARET;\r\n        }\r\n        case CharCode.OPENBRACE: {\r\n          this.pos = pos + 1;\r\n          return Token.OPENBRACE;\r\n        }\r\n        case CharCode.BAR: {\r\n          ++pos;\r\n          if (maxTokenLength > 1 && pos < end) {\r\n            let chr = text.charCodeAt(pos);\r\n            if (chr == CharCode.BAR) {\r\n              this.pos = pos + 1;\r\n              return Token.BAR_BAR;\r\n            }\r\n            if (chr == CharCode.EQUALS) {\r\n              this.pos = pos + 1;\r\n              return Token.BAR_EQUALS;\r\n            }\r\n          }\r\n          this.pos = pos;\r\n          return Token.BAR;\r\n        }\r\n        case CharCode.CLOSEBRACE: {\r\n          this.pos = pos + 1;\r\n          return Token.CLOSEBRACE;\r\n        }\r\n        case CharCode.TILDE: {\r\n          this.pos = pos + 1;\r\n          return Token.TILDE;\r\n        }\r\n        case CharCode.AT: {\r\n          this.pos = pos + 1;\r\n          return Token.AT;\r\n        }\r\n        default: {\r\n          if (isIdentifierStart(c)) {\r\n            let posBefore = pos;\r\n            while (\r\n              ++pos < end &&\r\n              isIdentifierPart(c = text.charCodeAt(pos))\r\n            ) { /* nop */ }\r\n            if (identifierHandling != IdentifierHandling.ALWAYS) {\r\n              let maybeKeywordToken = tokenFromKeyword(text.substring(posBefore, pos));\r\n              if (\r\n                maybeKeywordToken !== Token.INVALID &&\r\n                !(\r\n                  identifierHandling === IdentifierHandling.PREFER &&\r\n                  tokenIsAlsoIdentifier(maybeKeywordToken)\r\n                )\r\n              ) {\r\n                this.pos = pos;\r\n                return maybeKeywordToken;\r\n              }\r\n            }\r\n            this.pos = posBefore;\r\n            return Token.IDENTIFIER;\r\n          } else if (isWhiteSpace(c)) {\r\n            ++pos;\r\n            break;\r\n          }\r\n          let start = pos++;\r\n          if ( // surrogate pair?\r\n            (c & 0xFC00) == 0xD800 && pos < end &&\r\n            ((text.charCodeAt(pos)) & 0xFC00) == 0xDC00\r\n          ) ++pos;\r\n          this.error(\r\n            DiagnosticCode.Invalid_character,\r\n            this.range(start, pos)\r\n          );\r\n          this.pos = pos;\r\n          return Token.INVALID;\r\n        }\r\n      }\r\n    }\r\n    this.pos = pos;\r\n    return Token.ENDOFFILE;\r\n  }\r\n\r\n  peek(\r\n    checkOnNewLine: bool = false,\r\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\r\n    maxCompoundLength: i32 = i32.MAX_VALUE\r\n  ): Token {\r\n    var text = this.source.text;\r\n    if (this.nextToken < 0) {\r\n      let posBefore = this.pos;\r\n      let tokenBefore = this.token;\r\n      let tokenPosBefore = this.tokenPos;\r\n      let nextToken: Token;\r\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\r\n      while (nextToken == Token.INVALID);\r\n      this.nextToken = nextToken;\r\n      this.nextTokenPos = this.tokenPos;\r\n      if (checkOnNewLine) {\r\n        this.nextTokenOnNewLine = false;\r\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\r\n          if (isLineBreak(text.charCodeAt(pos))) {\r\n            this.nextTokenOnNewLine = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      this.pos = posBefore;\r\n      this.token = tokenBefore;\r\n      this.tokenPos = tokenPosBefore;\r\n    }\r\n    return this.nextToken;\r\n  }\r\n\r\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.PREFER): bool {\r\n    return this.skip(Token.IDENTIFIER, identifierHandling);\r\n  }\r\n\r\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): bool {\r\n    var posBefore = this.pos;\r\n    var tokenBefore = this.token;\r\n    var tokenPosBefore = this.tokenPos;\r\n    var maxCompoundLength = i32.MAX_VALUE;\r\n    if (token == Token.GREATERTHAN) {  // where parsing type arguments\r\n      maxCompoundLength = 1;\r\n    }\r\n    var nextToken: Token;\r\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\r\n    while (nextToken == Token.INVALID);\r\n    if (nextToken == token) {\r\n      this.token = token;\r\n      this.nextToken = -1;\r\n      return true;\r\n    } else {\r\n      this.pos = posBefore;\r\n      this.token = tokenBefore;\r\n      this.tokenPos = tokenPosBefore;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  mark(): State {\r\n    var state = reusableState;\r\n    if (state) {\r\n      reusableState = null;\r\n      state.pos = this.pos;\r\n      state.token = this.token;\r\n      state.tokenPos = this.tokenPos;\r\n    } else {\r\n      state = new State(this.pos, this.token, this.tokenPos);\r\n    }\r\n    return state;\r\n  }\r\n\r\n  discard(state: State): void {\r\n    reusableState = state;\r\n  }\r\n\r\n  reset(state: State): void {\r\n    this.pos = state.pos;\r\n    this.token = state.token;\r\n    this.tokenPos = state.tokenPos;\r\n    this.nextToken = -1;\r\n  }\r\n\r\n  range(start: i32 = -1, end: i32 = -1): Range {\r\n    if (start < 0) {\r\n      start = this.tokenPos;\r\n      end = this.pos;\r\n    } else if (end < 0) {\r\n      end = start;\r\n    }\r\n    let range = new Range(start, end);\r\n    range.source = this.source;\r\n    return range;\r\n  }\r\n\r\n  readIdentifier(): string {\r\n    var text = this.source.text;\r\n    var end = this.end;\r\n    var pos = this.pos;\r\n    var start = pos;\r\n    while (\r\n      ++pos < end &&\r\n      isIdentifierPart(text.charCodeAt(pos))\r\n    );\r\n    this.pos = pos;\r\n    return text.substring(start, pos);\r\n  }\r\n\r\n  readingTemplateString: bool = false;\r\n  readStringStart: i32 = 0;\r\n  readStringEnd: i32 = 0;\r\n\r\n  readString(quote: i32 = 0, isTaggedTemplate: bool = false): string {\r\n    var text = this.source.text;\r\n    var end = this.end;\r\n    var pos = this.pos;\r\n    if (!quote) quote = text.charCodeAt(pos++);\r\n    var start = pos;\r\n    this.readStringStart = start;\r\n    var result = \"\";\r\n\r\n    while (true) {\r\n      if (pos >= end) {\r\n        result += text.substring(start, pos);\r\n        this.error(\r\n          DiagnosticCode.Unterminated_string_literal,\r\n          this.range(start - 1, end)\r\n        );\r\n        this.readStringEnd = end;\r\n        break;\r\n      }\r\n      let c = text.charCodeAt(pos);\r\n      if (c == quote) {\r\n        this.readStringEnd = pos;\r\n        result += text.substring(start, pos++);\r\n        break;\r\n      }\r\n      if (c == CharCode.BACKSLASH) {\r\n        result += text.substring(start, pos);\r\n        this.pos = pos; // save\r\n        result += this.readEscapeSequence(isTaggedTemplate);\r\n        pos = this.pos; // restore\r\n        start = pos;\r\n        continue;\r\n      }\r\n      if (quote == CharCode.BACKTICK) {\r\n        if (c == CharCode.DOLLAR && pos + 1 < end && text.charCodeAt(pos + 1) == CharCode.OPENBRACE) {\r\n          result += text.substring(start, pos);\r\n          this.readStringEnd = pos;\r\n          this.pos = pos + 2;\r\n          this.readingTemplateString = true;\r\n          return result;\r\n        }\r\n      } else if (isLineBreak(c)) {\r\n        result += text.substring(start, pos);\r\n        this.error(\r\n          DiagnosticCode.Unterminated_string_literal,\r\n          this.range(start - 1, pos)\r\n        );\r\n        this.readStringEnd = pos;\r\n        break;\r\n      }\r\n      ++pos;\r\n    }\r\n    this.pos = pos;\r\n    this.readingTemplateString = false;\r\n    return result;\r\n  }\r\n\r\n  readEscapeSequence(isTaggedTemplate: bool = false): string {\r\n    // for context on isTaggedTemplate, see: https://tc39.es/proposal-template-literal-revision/\r\n    var start = this.pos;\r\n    var end = this.end;\r\n    if (++this.pos >= end) {\r\n      this.error(\r\n        DiagnosticCode.Unexpected_end_of_text,\r\n        this.range(end)\r\n      );\r\n      return \"\";\r\n    }\r\n\r\n    var text = this.source.text;\r\n    var c = text.charCodeAt(this.pos++);\r\n    switch (c) {\r\n      case CharCode._0: {\r\n        if (isTaggedTemplate && this.pos < end && isDecimalDigit(text.charCodeAt(this.pos))) {\r\n          ++this.pos;\r\n          return text.substring(start, this.pos);\r\n        }\r\n        return \"\\0\";\r\n      }\r\n      case CharCode.b: return \"\\b\";\r\n      case CharCode.t: return \"\\t\";\r\n      case CharCode.n: return \"\\n\";\r\n      case CharCode.v: return \"\\v\";\r\n      case CharCode.f: return \"\\f\";\r\n      case CharCode.r: return \"\\r\";\r\n      case CharCode.SINGLEQUOTE: return \"'\";\r\n      case CharCode.DOUBLEQUOTE: return \"\\\"\";\r\n      case CharCode.u: {\r\n        if (\r\n          this.pos < end &&\r\n          text.charCodeAt(this.pos) == CharCode.OPENBRACE\r\n        ) {\r\n          ++this.pos;\r\n          return this.readExtendedUnicodeEscape(isTaggedTemplate ? start : -1); // \\u{DDDDDDDD}\r\n        }\r\n        return this.readUnicodeEscape(isTaggedTemplate ? start : -1); // \\uDDDD\r\n      }\r\n      case CharCode.x: {\r\n        return this.readHexadecimalEscape(2, isTaggedTemplate ? start : - 1); // \\xDD\r\n      }\r\n      case CharCode.CARRIAGERETURN: {\r\n        if (\r\n          this.pos < end &&\r\n          text.charCodeAt(this.pos) == CharCode.LINEFEED\r\n        ) {\r\n          ++this.pos;\r\n        }\r\n        // fall through\r\n      }\r\n      case CharCode.LINEFEED:\r\n      case CharCode.LINESEPARATOR:\r\n      case CharCode.PARAGRAPHSEPARATOR: return \"\";\r\n      default: return String.fromCharCode(c);\r\n    }\r\n  }\r\n\r\n  readRegexpPattern(): string {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var end = this.end;\r\n    var escaped = false;\r\n    while (true) {\r\n      if (this.pos >= end) {\r\n        this.error(\r\n          DiagnosticCode.Unterminated_regular_expression_literal,\r\n          this.range(start, end)\r\n        );\r\n        break;\r\n      }\r\n      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {\r\n        ++this.pos;\r\n        escaped = true;\r\n        continue;\r\n      }\r\n      let c = text.charCodeAt(this.pos);\r\n      if (!escaped && c == CharCode.SLASH) break;\r\n      if (isLineBreak(c)) {\r\n        this.error(\r\n          DiagnosticCode.Unterminated_regular_expression_literal,\r\n          this.range(start, this.pos)\r\n        );\r\n        break;\r\n      }\r\n      ++this.pos;\r\n      escaped = false;\r\n    }\r\n    return text.substring(start, this.pos);\r\n  }\r\n\r\n  readRegexpFlags(): string {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var end = this.end;\r\n    var flags = 0;\r\n    while (this.pos < end) {\r\n      let c: i32 = text.charCodeAt(this.pos);\r\n      if (!isIdentifierPart(c)) break;\r\n      ++this.pos;\r\n\r\n      // make sure each supported flag is unique\r\n      switch (c) {\r\n        case CharCode.g: {\r\n          flags |= flags & 1 ? -1 : 1;\r\n          break;\r\n        }\r\n        case CharCode.i: {\r\n          flags |= flags & 2 ? -1 : 2;\r\n          break;\r\n        }\r\n        case CharCode.m: {\r\n          flags |= flags & 4 ? -1 : 4;\r\n          break;\r\n        }\r\n        default: {\r\n          flags = -1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (flags == -1) {\r\n      this.error(\r\n        DiagnosticCode.Invalid_regular_expression_flags,\r\n        this.range(start, this.pos)\r\n      );\r\n    }\r\n    return text.substring(start, this.pos);\r\n  }\r\n\r\n  testInteger(): bool {\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    var end = this.end;\r\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\r\n      switch (text.charCodeAt(pos + 2) | 32) {\r\n        case CharCode.x:\r\n        case CharCode.b:\r\n        case CharCode.o: return true;\r\n      }\r\n    }\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos);\r\n      if (c == CharCode.DOT || (c | 32) == CharCode.e) return false;\r\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\r\n      // does not validate separator placement (this is done in readXYInteger)\r\n      pos++;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  readInteger(): i64 {\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\r\n      switch (text.charCodeAt(pos + 1) | 32) {\r\n        case CharCode.x: {\r\n          this.pos = pos + 2;\r\n          return this.readHexInteger();\r\n        }\r\n        case CharCode.b: {\r\n          this.pos = pos + 2;\r\n          return this.readBinaryInteger();\r\n        }\r\n        case CharCode.o: {\r\n          this.pos = pos + 2;\r\n          return this.readOctalInteger();\r\n        }\r\n      }\r\n      if (isOctalDigit(text.charCodeAt(pos + 1))) {\r\n        let start = pos;\r\n        this.pos = pos + 1;\r\n        let value = this.readOctalInteger();\r\n        this.error(\r\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\r\n          this.range(start, this.pos)\r\n        );\r\n        return value;\r\n      }\r\n    }\r\n    return this.readDecimalInteger();\r\n  }\r\n\r\n  readHexInteger(): i64 {\r\n    var text = this.source.text;\r\n    let pos = this.pos;\r\n    var end = this.end;\r\n    var start = pos;\r\n    var sepEnd = start;\r\n    var value = i64_new(0);\r\n    var i64_4 = i64_new(4);\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos);\r\n      if (c >= CharCode._0 && c <= CharCode._9) {\r\n        // value = (value << 4) + c - CharCode._0;\r\n        value = i64_add(\r\n          i64_shl(value, i64_4),\r\n          i64_new(c - CharCode._0)\r\n        );\r\n      } else if (c >= CharCode.A && c <= CharCode.F) {\r\n        // value = (value << 4) + 10 + c - CharCode.A;\r\n        value = i64_add(\r\n          i64_shl(value, i64_4),\r\n          i64_new(10 + c - CharCode.A)\r\n        );\r\n      } else if (c >= CharCode.a && c <= CharCode.f) {\r\n        // value = (value << 4) + 10 + c - CharCode.a;\r\n        value = i64_add(\r\n          i64_shl(value, i64_4),\r\n          i64_new(10 + c - CharCode.a)\r\n        );\r\n      } else if (c == CharCode._) {\r\n        if (sepEnd == pos) {\r\n          this.error(\r\n            sepEnd == start\r\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\r\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\r\n            this.range(pos)\r\n          );\r\n        }\r\n        sepEnd = pos + 1;\r\n      } else {\r\n        break;\r\n      }\r\n      ++pos;\r\n    }\r\n    if (pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Hexadecimal_digit_expected,\r\n        this.range(start)\r\n      );\r\n    } else if (sepEnd == pos) {\r\n      this.error(\r\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n        this.range(sepEnd - 1)\r\n      );\r\n    }\r\n    this.pos = pos;\r\n    return value;\r\n  }\r\n\r\n  readDecimalInteger(): i64 {\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    var end = this.end;\r\n    var start = pos;\r\n    var sepEnd = start;\r\n    var value = i64_new(0);\r\n    var i64_10 = i64_new(10);\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos);\r\n      if (c >= CharCode._0 && c <= CharCode._9) {\r\n        // value = value * 10 + c - CharCode._0;\r\n        value = i64_add(\r\n          i64_mul(value, i64_10),\r\n          i64_new(c - CharCode._0)\r\n        );\r\n      } else if (c == CharCode._) {\r\n        if (sepEnd == pos) {\r\n          this.error(\r\n            sepEnd == start\r\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\r\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\r\n            this.range(pos)\r\n          );\r\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\r\n          this.error(\r\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n            this.range(pos)\r\n          );\r\n        }\r\n        sepEnd = pos + 1;\r\n      } else {\r\n        break;\r\n      }\r\n      ++pos;\r\n    }\r\n    if (pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Digit_expected,\r\n        this.range(start)\r\n      );\r\n    } else if (sepEnd == pos) {\r\n      this.error(\r\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n        this.range(sepEnd - 1)\r\n      );\r\n    }\r\n    this.pos = pos;\r\n    return value;\r\n  }\r\n\r\n  readOctalInteger(): i64 {\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    var end = this.end;\r\n    var start = pos;\r\n    var sepEnd = start;\r\n    var value = i64_new(0);\r\n    var i64_3 = i64_new(3);\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos);\r\n      if (c >= CharCode._0 && c <= CharCode._7) {\r\n        // value = (value << 3) + c - CharCode._0;\r\n        value = i64_add(\r\n          i64_shl(value, i64_3),\r\n          i64_new(c - CharCode._0)\r\n        );\r\n      } else if (c == CharCode._) {\r\n        if (sepEnd == pos) {\r\n          this.error(\r\n            sepEnd == start\r\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\r\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\r\n            this.range(pos)\r\n          );\r\n        }\r\n        sepEnd = pos + 1;\r\n      } else {\r\n        break;\r\n      }\r\n      ++pos;\r\n    }\r\n    if (pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Octal_digit_expected,\r\n        this.range(start)\r\n      );\r\n    } else if (sepEnd == pos) {\r\n      this.error(\r\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n        this.range(sepEnd - 1)\r\n      );\r\n    }\r\n    this.pos = pos;\r\n    return value;\r\n  }\r\n\r\n  readBinaryInteger(): i64 {\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    var end = this.end;\r\n    var start = pos;\r\n    var sepEnd = start;\r\n    var value = i64_new(0);\r\n    var i64_1 = i64_new(1);\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos);\r\n      if (c == CharCode._0) {\r\n        // value = (value << 1);\r\n        value = i64_shl(value, i64_1);\r\n      } else if (c == CharCode._1) {\r\n        // value = (value << 1) + 1;\r\n        value = i64_add(\r\n          i64_shl(value, i64_1),\r\n          i64_1\r\n        );\r\n      } else if (c == CharCode._) {\r\n        if (sepEnd == pos) {\r\n          this.error(\r\n            sepEnd == start\r\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\r\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\r\n            this.range(pos)\r\n          );\r\n        }\r\n        sepEnd = pos + 1;\r\n      } else {\r\n        break;\r\n      }\r\n      ++pos;\r\n    }\r\n    if (pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Binary_digit_expected,\r\n        this.range(start)\r\n      );\r\n    } else if (sepEnd == pos) {\r\n      this.error(\r\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n        this.range(sepEnd - 1)\r\n      );\r\n    }\r\n    this.pos = pos;\r\n    return value;\r\n  }\r\n\r\n  readFloat(): f64 {\r\n    // var text = this.source.text;\r\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\r\n    //   switch (text.charCodeAt(this.pos + 1)) {\r\n    //     case CharCode.X:\r\n    //     case CharCode.x: {\r\n    //       this.pos += 2;\r\n    //       return this.readHexFloat();\r\n    //     }\r\n    //   }\r\n    // }\r\n    return this.readDecimalFloat();\r\n  }\r\n\r\n  readDecimalFloat(): f64 {\r\n    var text = this.source.text;\r\n    var end = this.end;\r\n    var start = this.pos;\r\n    var sepCount = this.readDecimalFloatPartial(false);\r\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.DOT) {\r\n      ++this.pos;\r\n      sepCount += this.readDecimalFloatPartial();\r\n    }\r\n    if (this.pos < end) {\r\n      let c = text.charCodeAt(this.pos);\r\n      if ((c | 32) == CharCode.e) {\r\n        if (\r\n          ++this.pos < end &&\r\n          (c = text.charCodeAt(this.pos)) == CharCode.MINUS || c == CharCode.PLUS &&\r\n          isDecimalDigit(text.charCodeAt(this.pos + 1))\r\n        ) {\r\n          ++this.pos;\r\n        }\r\n        sepCount += this.readDecimalFloatPartial();\r\n      }\r\n    }\r\n    let result = text.substring(start, this.pos);\r\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\r\n    return parseFloat(result);\r\n  }\r\n\r\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\r\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    var start = pos;\r\n    var end = this.end;\r\n    var sepEnd = start;\r\n    var sepCount = 0;\r\n\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos);\r\n\r\n      if (c == CharCode._) {\r\n        if (sepEnd == pos) {\r\n          this.error(\r\n            sepEnd == start\r\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\r\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\r\n            this.range(pos)\r\n          );\r\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\r\n          this.error(\r\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n            this.range(pos)\r\n          );\r\n        }\r\n        sepEnd = pos + 1;\r\n        ++sepCount;\r\n      } else if (!isDecimalDigit(c)) {\r\n        break;\r\n      }\r\n      ++pos;\r\n    }\r\n\r\n    if (pos != start && sepEnd == pos) {\r\n      this.error(\r\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\r\n        this.range(sepEnd - 1)\r\n      );\r\n    }\r\n\r\n    this.pos = pos;\r\n    return sepCount;\r\n  }\r\n\r\n  readHexFloat(): f64 {\r\n    throw new Error(\"not implemented\"); // TBD\r\n  }\r\n\r\n  readHexadecimalEscape(remain: i32 = 2, startIfTaggedTemplate: i32 = -1): string {\r\n    var value = 0;\r\n    var text = this.source.text;\r\n    var pos = this.pos;\r\n    var end = this.end;\r\n    while (pos < end) {\r\n      let c = text.charCodeAt(pos++);\r\n      if (c >= CharCode._0 && c <= CharCode._9) {\r\n        value = (value << 4) + c - CharCode._0;\r\n      } else if (c >= CharCode.A && c <= CharCode.F) {\r\n        value = (value << 4) + c + (10 - CharCode.A);\r\n      } else if (c >= CharCode.a && c <= CharCode.f) {\r\n        value = (value << 4) + c + (10 - CharCode.a);\r\n      } else if (~startIfTaggedTemplate) {\r\n        this.pos = --pos;\r\n        return text.substring(startIfTaggedTemplate, pos);\r\n      } else {\r\n        this.pos = pos;\r\n        this.error(\r\n          DiagnosticCode.Hexadecimal_digit_expected,\r\n          this.range(pos - 1, pos)\r\n        );\r\n        return \"\";\r\n      }\r\n      if (--remain == 0) break;\r\n    }\r\n    if (remain) { // invalid\r\n      this.pos = pos;\r\n      if (~startIfTaggedTemplate) {\r\n        return text.substring(startIfTaggedTemplate, pos);\r\n      }\r\n      this.error(\r\n        DiagnosticCode.Unexpected_end_of_text,\r\n        this.range(pos)\r\n      );\r\n      return \"\";\r\n    }\r\n    this.pos = pos;\r\n    return String.fromCharCode(value);\r\n  }\r\n\r\n  checkForIdentifierStartAfterNumericLiteral(): void {\r\n    // TODO: BigInt n\r\n    var pos = this.pos;\r\n    if (pos < this.end && isIdentifierStart(this.source.text.charCodeAt(pos))) {\r\n      this.error(\r\n        DiagnosticCode.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal,\r\n        this.range(pos)\r\n      );\r\n    }\r\n  }\r\n\r\n  readUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\r\n    return this.readHexadecimalEscape(4, startIfTaggedTemplate);\r\n  }\r\n\r\n  private readExtendedUnicodeEscape(startIfTaggedTemplate: i32 = -1): string {\r\n    var start = this.pos;\r\n    var value = this.readHexInteger();\r\n    var value32 = i64_low(value);\r\n    var invalid = false;\r\n\r\n    assert(!i64_high(value));\r\n    if (value32 > 0x10FFFF) {\r\n      if (startIfTaggedTemplate == -1) {\r\n        this.error(\r\n          DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\r\n          this.range(start, this.pos)\r\n        );\r\n      }\r\n      invalid = true;\r\n    }\r\n\r\n    var end = this.end;\r\n    var text = this.source.text;\r\n    if (this.pos >= end) {\r\n      if (startIfTaggedTemplate == -1) {\r\n        this.error(\r\n          DiagnosticCode.Unexpected_end_of_text,\r\n          this.range(start, end)\r\n        );\r\n      }\r\n      invalid = true;\r\n    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {\r\n      ++this.pos;\r\n    } else {\r\n      if (startIfTaggedTemplate == -1) {\r\n        this.error(\r\n          DiagnosticCode.Unterminated_Unicode_escape_sequence,\r\n          this.range(start, this.pos)\r\n        );\r\n      }\r\n      invalid = true;\r\n    }\r\n\r\n    if (invalid) {\r\n      return ~startIfTaggedTemplate\r\n        ? text.substring(startIfTaggedTemplate, this.pos)\r\n        : \"\";\r\n    }\r\n    return value32 < 0x10000\r\n      ? String.fromCharCode(value32)\r\n      : String.fromCharCode(\r\n        ((value32 - 0x10000) >>> 10) | 0xD800,\r\n        ((value32 - 0x10000) & 1023) | 0xDC00\r\n      );\r\n  }\r\n}\r\n\r\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\r\nexport class State {\r\n  constructor(\r\n    /** Current position. */\r\n    public pos: i32,\r\n    /** Current token. */\r\n    public token: Token,\r\n    /** Current token's position. */\r\n    public tokenPos: i32\r\n  ) {}\r\n}\r\n\r\n// Reusable state object to reduce allocations\r\nvar reusableState: State | null = null;\r\n","/**\r\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  Class,\r\n  Program,\r\n  DecoratorFlags\r\n} from \"./program\";\r\n\r\nimport {\r\n  TypeRef,\r\n  createType\r\n} from \"./module\";\r\n\r\n/** Indicates the kind of a type. */\r\nexport const enum TypeKind {\r\n\r\n  // signed integers\r\n\r\n  /** An 8-bit signed integer. */\r\n  I8,\r\n  /** A 16-bit signed integer. */\r\n  I16,\r\n  /** A 32-bit signed integer. */\r\n  I32,\r\n  /** A 64-bit signed integer. */\r\n  I64,\r\n  /** A 32-bit/64-bit signed integer, depending on the target. */\r\n  ISIZE,\r\n\r\n  // unsigned integers\r\n\r\n  /** An 8-bit unsigned integer. */\r\n  U8,\r\n  /** A 16-bit unsigned integer. */\r\n  U16,\r\n  /** A 32-bit unsigned integer. Also the base of function types. */\r\n  U32,\r\n  /** A 64-bit unsigned integer. */\r\n  U64,\r\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\r\n  USIZE,\r\n  /** A 1-bit unsigned integer. */\r\n  BOOL, // sic\r\n\r\n  // floats\r\n\r\n  /** A 32-bit float. */\r\n  F32,\r\n  /** A 64-bit double. */\r\n  F64,\r\n\r\n  // vectors\r\n\r\n  /** A 128-bit vector. */\r\n  V128,\r\n\r\n  // references\r\n\r\n  /** Function reference. */\r\n  FUNCREF,\r\n  /** External reference. */\r\n  EXTERNREF,\r\n  /** Any reference. */\r\n  ANYREF,\r\n  /** Equatable reference. */\r\n  EQREF,\r\n  /** 31-bit integer reference. */\r\n  I31REF,\r\n  /** Data reference. */\r\n  DATAREF,\r\n\r\n  // other\r\n\r\n  /** No return type. */\r\n  VOID\r\n}\r\n\r\n/** Indicates capabilities of a type. */\r\nexport const enum TypeFlags {\r\n  NONE = 0,\r\n  /** Is a signed type that can represent negative values. */\r\n  SIGNED = 1 << 0,\r\n  /** Is an unsigned type that cannot represent negative values. */\r\n  UNSIGNED = 1 << 1,\r\n  /** Is an integer type. */\r\n  INTEGER = 1 << 2,\r\n  /** Is a floating point type. */\r\n  FLOAT = 1 << 3,\r\n  /** Is a varying (in size) type. */\r\n  VARYING = 1 << 4,\r\n  /** Is smaller than 32-bits. */\r\n  SHORT = 1 << 5,\r\n  /** Is larger than 32-bits. */\r\n  LONG = 1 << 6,\r\n  /** Is a value type. */\r\n  VALUE = 1 << 7,\r\n  /** Is a reference type (either a class or a function type). */\r\n  REFERENCE = 1 << 8,\r\n  /** Is a nullable type. */\r\n  NULLABLE = 1 << 9,\r\n  /** Is a vector type. */\r\n  VECTOR = 1 << 10,\r\n  /** Is an external type. */\r\n  EXTERNAL = 1 << 11,\r\n  /** Is a class. */\r\n  CLASS = 1 << 12,\r\n  /** Is a function. */\r\n  FUNCTION = 1 << 13\r\n}\r\n\r\n/** Represents a resolved type. */\r\nexport class Type {\r\n\r\n  /** Type kind. */\r\n  kind: TypeKind;\r\n  /** Type flags. */\r\n  flags: TypeFlags;\r\n  /** Size in bits. */\r\n  size: i32;\r\n  /** Size in bytes. */\r\n  byteSize: i32;\r\n  /** Underlying class reference, if a class type. */\r\n  classReference: Class | null;\r\n  /** Underlying signature reference, if a function type. */\r\n  signatureReference: Signature | null;\r\n  /** Respective non-nullable type, if nullable. */\r\n  private _nonNullableType: Type | null = null;\r\n  /** Respective nullable type, if non-nullable. */\r\n  private _nullableType: Type | null = null;\r\n\r\n  /** Constructs a new resolved type. */\r\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\r\n    this.kind = kind;\r\n    this.flags = flags;\r\n    this.size = size;\r\n    this.byteSize = <i32>ceil<f64>(<f64>size / 8);\r\n    this.classReference = null;\r\n    this.signatureReference = null;\r\n    if (!(flags & TypeFlags.NULLABLE)) {\r\n      this._nonNullableType = this;\r\n    } else {\r\n      this._nullableType = this;\r\n    }\r\n  }\r\n\r\n  /** Returns the closest int type representing this type. */\r\n  get intType(): Type {\r\n    if (this == Type.auto) return this; // keep auto as a hint\r\n    switch (this.kind) {\r\n      case TypeKind.I8: return Type.i8;\r\n      case TypeKind.I16: return Type.i16;\r\n      case TypeKind.F32:\r\n      case TypeKind.I32: return Type.i32;\r\n      case TypeKind.F64:\r\n      case TypeKind.I64: return Type.i64;\r\n      case TypeKind.ISIZE: return this.size == 64 ? Type.isize64 : Type.isize32;\r\n      case TypeKind.U8: return Type.u8;\r\n      case TypeKind.U16: return Type.u16;\r\n      case TypeKind.U32: return Type.u32;\r\n      case TypeKind.U64: return Type.u64;\r\n      case TypeKind.USIZE: return this.size == 64 ? Type.usize64 : Type.usize32;\r\n      case TypeKind.BOOL:\r\n      default: return Type.i32;\r\n    }\r\n  }\r\n\r\n  /** Substitutes this type with the auto type if this type is void. */\r\n  get exceptVoid(): Type {\r\n    if (this.kind == TypeKind.VOID) return Type.auto;\r\n    return this;\r\n  }\r\n\r\n  /** Gets this type's logarithmic alignment in memory. */\r\n  get alignLog2(): i32 {\r\n    return 31 - clz<i32>(this.byteSize);\r\n  }\r\n\r\n  /** Tests if this type represents a basic value. */\r\n  get isValue(): bool {\r\n    return this.is(TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents an integer value. */\r\n  get isIntegerValue(): bool {\r\n    return this.is(TypeFlags.INTEGER | TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents a small (< 32 bits) integer value. */\r\n  get isShortIntegerValue(): bool {\r\n    return this.is(TypeFlags.SHORT | TypeFlags.INTEGER | TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents a long (> 32 bits) integer value. */\r\n  get isLongIntegerValue(): bool {\r\n    return this.is(TypeFlags.LONG | TypeFlags.INTEGER | TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents a signed integer value. */\r\n  get isSignedIntegerValue(): bool {\r\n    return this.is(TypeFlags.SIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents an unsigned integer value. */\r\n  get isUnsignedIntegerValue(): bool {\r\n    return this.is(TypeFlags.UNSIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents a varying (in size) integer value. */\r\n  get isVaryingIntegerValue(): bool {\r\n    return this.is(TypeFlags.VARYING | TypeFlags.INTEGER | TypeFlags.VALUE);\r\n  }\r\n\r\n  /** Tests if this type represents an integer, including references.  */\r\n  get isIntegerInclReference(): bool {\r\n    return this.is(TypeFlags.INTEGER);\r\n  }\r\n\r\n  /** Tests if this type represents a floating point value. */\r\n  get isFloatValue(): bool {\r\n    return this.is(TypeFlags.FLOAT | TypeFlags.VALUE);\r\n  }\r\n  \r\n  /** Tests if this type represents a numeric (integer or floating point) value. */\r\n  get isNumericValue(): bool {\r\n    return this.isIntegerValue || this.isFloatValue;\r\n  }\r\n\r\n  /** Tests if this type represents a boolean value. */\r\n  get isBooleanValue(): bool {\r\n    return this == Type.bool;\r\n  }\r\n\r\n  /** Tests if this type represents a vector value. */\r\n  get isVectorValue(): bool {\r\n    return this.is(TypeFlags.VECTOR | TypeFlags.VALUE);\r\n  }\r\n  \r\n  /** Tests if this type represents an internal or external reference. */\r\n  get isReference(): bool {\r\n    return this.is(TypeFlags.REFERENCE);\r\n  }\r\n\r\n  /** Tests if this type represents a nullable internal or external reference. */\r\n  get isNullableReference(): bool {\r\n    return this.is(TypeFlags.NULLABLE | TypeFlags.REFERENCE);\r\n  }\r\n\r\n  /** Tests if this type represents an internal object. */\r\n  get isInternalReference(): bool {\r\n    return this.is(TypeFlags.INTEGER | TypeFlags.REFERENCE);\r\n  }\r\n\r\n  /** Tests if this type represents an external object. */\r\n  get isExternalReference(): bool {\r\n    return this.is(TypeFlags.EXTERNAL | TypeFlags.REFERENCE);\r\n  }\r\n\r\n  /** Tests if this type represents a class. */\r\n  get isClass(): bool {\r\n    return this.isInternalReference\r\n      ? this.classReference !== null\r\n      : false;\r\n  }\r\n\r\n  /** Gets the underlying class of this type, if any. */\r\n  getClass(): Class | null {\r\n    return this.isInternalReference\r\n      ? this.classReference\r\n      : null;\r\n  }\r\n\r\n  /** Gets the underlying class or wrapper class of this type, if any. */\r\n  getClassOrWrapper(program: Program): Class | null {\r\n    let classReference = this.getClass();\r\n    if (classReference) {\r\n      // typical class\r\n      return classReference;\r\n    } else {\r\n      let signatureReference = this.getSignature();\r\n      if (signatureReference) {\r\n        // function wrapper\r\n        let type = signatureReference.type;\r\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\r\n        wrapper.wrappedType = type;\r\n        return wrapper;\r\n      } else {\r\n        let wrapperClasses = program.wrapperClasses;\r\n        if (wrapperClasses.has(this)) {\r\n          // value wrapper\r\n          return assert(wrapperClasses.get(this));\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Tests if this type represents a function. */\r\n  get isFunction(): bool {\r\n    return this.isInternalReference\r\n      ? this.signatureReference !== null\r\n      : false;\r\n  }\r\n\r\n  /** Gets the underlying function signature of this type, if any. */\r\n  getSignature(): Signature | null {\r\n    return this.isInternalReference\r\n      ? this.signatureReference\r\n      : null;\r\n  }\r\n\r\n  /** Tests if this is a managed type that needs GC hooks. */\r\n  get isManaged(): bool {\r\n    if (this.isInternalReference) {\r\n      let classReference = this.classReference;\r\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.UNMANAGED);\r\n      return this.signatureReference !== null; // function references are managed\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\r\n  get isUnmanaged(): bool {\r\n    var classReference = this.classReference;\r\n    return classReference !== null && classReference.hasDecorator(DecoratorFlags.UNMANAGED);\r\n  }\r\n\r\n  /** Gets the corresponding non-nullable type. */\r\n  get nonNullableType(): Type {\r\n    if (this.isExternalReference) {\r\n      return this; // TODO\r\n    }\r\n    return assert(this._nonNullableType); // set either in ctor or asNullable\r\n  }\r\n\r\n  /** Gets the corresponding nullable type, if applicable. */\r\n  get nullableType(): Type | null {\r\n    return this._nullableType; // set either in ctor or asNullable\r\n  }\r\n\r\n  /** Computes the sign-extending shift in the target type. */\r\n  computeSmallIntegerShift(targetType: Type): i32 {\r\n    return targetType.size - this.size;\r\n  }\r\n\r\n  /** Computes the truncating mask in the target type. */\r\n  computeSmallIntegerMask(targetType: Type): i32 {\r\n    var size = this.is(TypeFlags.UNSIGNED) ? this.size : this.size - 1;\r\n    return ~0 >>> (targetType.size - size);\r\n  }\r\n\r\n  /** Tests if this type has (all of) the specified flags. */\r\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\r\n  /** Tests if this type has any of the specified flags. */\r\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\r\n\r\n  /** Composes the respective nullable type of this type. */\r\n  asNullable(): Type {\r\n    assert(this.isInternalReference);\r\n    var nullableType = this._nullableType;\r\n    if (!nullableType) {\r\n      assert(!this.isNullableReference);\r\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);\r\n      nullableType.classReference = this.classReference;         // either a class reference\r\n      nullableType.signatureReference = this.signatureReference; // or a function reference\r\n      nullableType._nonNullableType = this;\r\n    }\r\n    return nullableType;\r\n  }\r\n\r\n  /** Tests if this type equals the specified. */\r\n  equals(other: Type): bool {\r\n    if (this.kind != other.kind) return false;\r\n    if (this.isReference) {\r\n      return (\r\n        this.classReference == other.classReference &&\r\n        this.signatureReference == other.signatureReference &&\r\n        this.isNullableReference == other.isNullableReference\r\n      );\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\r\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\r\n    var currentClass: Class | null;\r\n    var targetClass: Class | null;\r\n    var currentFunction: Signature | null;\r\n    var targetFunction: Signature | null;\r\n    if (this.isReference) {\r\n      if (target.isReference) {\r\n        if (!this.isNullableReference || target.isNullableReference) {\r\n          if (currentClass = this.getClass()) {\r\n            if (targetClass = target.getClass()) {\r\n              return currentClass.isAssignableTo(targetClass);\r\n            }\r\n          } else if (currentFunction = this.getSignature()) {\r\n            if (targetFunction = target.getSignature()) {\r\n              return currentFunction.isAssignableTo(targetFunction);\r\n            }\r\n          } else if (this.isExternalReference && (this.kind == target.kind || (target.kind == TypeKind.ANYREF && this.kind != TypeKind.EXTERNREF))) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    } else if (!target.isReference) {\r\n      if (this.isIntegerValue) {\r\n        if (target.isIntegerValue) {\r\n          if (\r\n            !signednessIsRelevant ||\r\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\r\n            this.isSignedIntegerValue == target.isSignedIntegerValue\r\n          ) {\r\n            return this.size <= target.size;\r\n          }\r\n        } else if (target.kind == TypeKind.F32) {\r\n          return this.size <= 23; // mantissa bits\r\n        } else if (target.kind == TypeKind.F64) {\r\n          return this.size <= 52; // ^\r\n        }\r\n      } else if (this.isFloatValue) {\r\n        if (target.isFloatValue) {\r\n          return this.size <= target.size;\r\n        }\r\n      } else if (this.isVectorValue) {\r\n        if (target.isVectorValue) {\r\n          return this.size == target.size;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\r\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\r\n    if (this.isReference) return this.isAssignableTo(target);\r\n    else if (target.isReference) return false;\r\n    // not dealing with references from here on\r\n    if (this.isIntegerValue) {\r\n      return target.isIntegerValue && target.size == this.size && (\r\n        !signednessIsRelevant ||\r\n        this.isSignedIntegerValue == target.isSignedIntegerValue\r\n      );\r\n    }\r\n    return this.kind == target.kind;\r\n  }\r\n\r\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\r\n  isChangeableTo(target: Type): bool {\r\n    // special in that it allows integer references as well\r\n    if (this.is(TypeFlags.INTEGER) && target.is(TypeFlags.INTEGER)) {\r\n      let size = this.size;\r\n      return size == target.size && (size >= 32 || this.is(TypeFlags.SIGNED) == target.is(TypeFlags.SIGNED));\r\n    }\r\n    return this.kind == target.kind;\r\n  }\r\n\r\n  /** Determines the common denominator type of two types, if there is any. */\r\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\r\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\r\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\r\n    return null;\r\n  }\r\n\r\n  /** Converts this type to a string. */\r\n  toString(validWat: bool = false): string {\r\n    const nullablePostfix = validWat\r\n      ? \"|null\"\r\n      : \" | null\";\r\n    if (this.isReference) {\r\n      let classReference = this.getClass();\r\n      if (classReference) {\r\n        return this.isNullableReference\r\n          ? classReference.internalName + nullablePostfix\r\n          : classReference.internalName;\r\n      } else {\r\n        let signatureReference = this.getSignature();\r\n        if (signatureReference) {\r\n          return this.isNullableReference\r\n            ? \"(\" + signatureReference.toString(validWat) + \")\" + nullablePostfix\r\n            : signatureReference.toString(validWat);\r\n        }\r\n      }\r\n    }\r\n    switch (this.kind) {\r\n      case TypeKind.I8: return \"i8\";\r\n      case TypeKind.I16: return \"i16\";\r\n      case TypeKind.I32: return \"i32\";\r\n      case TypeKind.I64: return \"i64\";\r\n      case TypeKind.ISIZE: return \"isize\";\r\n      case TypeKind.U8: return \"u8\";\r\n      case TypeKind.U16: return \"u16\";\r\n      case TypeKind.U32: return \"u32\";\r\n      case TypeKind.U64: return \"u64\";\r\n      case TypeKind.USIZE: return \"usize\";\r\n      case TypeKind.BOOL: return \"bool\";\r\n      case TypeKind.F32: return \"f32\";\r\n      case TypeKind.F64: return \"f64\";\r\n      case TypeKind.V128: return \"v128\";\r\n      case TypeKind.FUNCREF: return \"funcref\";\r\n      case TypeKind.EXTERNREF: return \"externref\";\r\n      case TypeKind.ANYREF: return \"anyref\";\r\n      case TypeKind.EQREF: return \"eqref\";\r\n      case TypeKind.I31REF: return \"i31ref\";\r\n      case TypeKind.DATAREF: return \"dataref\";\r\n      default: assert(false);\r\n      case TypeKind.VOID: return \"void\";\r\n    }\r\n  }\r\n\r\n  // Binaryen specific\r\n\r\n  /** Converts this type to its respective type reference. */\r\n  toRef(): TypeRef {\r\n    switch (this.kind) {\r\n      default: assert(false);\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n      case TypeKind.I32:\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.U32:\r\n      case TypeKind.BOOL: return TypeRef.I32;\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE: if (this.size != 64) return TypeRef.I32;\r\n      case TypeKind.I64:\r\n      case TypeKind.U64: return TypeRef.I64;\r\n      case TypeKind.F32: return TypeRef.F32;\r\n      case TypeKind.F64: return TypeRef.F64;\r\n      case TypeKind.V128: return TypeRef.V128;\r\n      // TODO: nullable/non-nullable refs have different type refs\r\n      case TypeKind.FUNCREF: return TypeRef.Funcref;\r\n      case TypeKind.EXTERNREF: return TypeRef.Externref;\r\n      case TypeKind.ANYREF: return TypeRef.Anyref;\r\n      case TypeKind.EQREF: return TypeRef.Eqref;\r\n      case TypeKind.I31REF: return TypeRef.I31ref;\r\n      case TypeKind.DATAREF: return TypeRef.Dataref;\r\n      case TypeKind.VOID: return TypeRef.None;\r\n    }\r\n  }\r\n\r\n  // Types\r\n\r\n  /** An 8-bit signed integer. */\r\n  static readonly i8: Type  = new Type(TypeKind.I8,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.SHORT    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,   8\r\n  );\r\n\r\n  /** A 16-bit signed integer. */\r\n  static readonly i16: Type = new Type(TypeKind.I16,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.SHORT    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  16\r\n  );\r\n\r\n  /** A 32-bit signed integer. */\r\n  static readonly i32: Type = new Type(TypeKind.I32,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit signed integer. */\r\n  static readonly i64: Type = new Type(TypeKind.I64,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 32-bit signed size. WASM32 only. */\r\n  static readonly isize32: Type = new Type(TypeKind.ISIZE,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VARYING  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit signed size. WASM64 only. */\r\n  static readonly isize64: Type = new Type(TypeKind.ISIZE,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VARYING  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** An 8-bit unsigned integer. */\r\n  static readonly u8: Type = new Type(TypeKind.U8,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SHORT    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,   8\r\n  );\r\n\r\n  /** A 16-bit unsigned integer. */\r\n  static readonly u16: Type = new Type(TypeKind.U16,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SHORT    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  16\r\n  );\r\n\r\n  /** A 32-bit unsigned integer. */\r\n  static readonly u32: Type = new Type(TypeKind.U32,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit unsigned integer. */\r\n  static readonly u64: Type = new Type(TypeKind.U64,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 32-bit unsigned size. WASM32 only. */\r\n  static readonly usize32: Type = new Type(TypeKind.USIZE,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VARYING  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit unsigned size. WASM64 only. */\r\n  static readonly usize64: Type = new Type(TypeKind.USIZE,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VARYING  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 1-bit unsigned integer. */\r\n  static readonly bool: Type = new Type(TypeKind.BOOL,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SHORT    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,   1\r\n  );\r\n\r\n  /** A 32-bit float. */\r\n  static readonly f32: Type = new Type(TypeKind.F32,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.FLOAT    |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit float. */\r\n  static readonly f64: Type = new Type(TypeKind.F64,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.FLOAT    |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 128-bit vector. */\r\n  static readonly v128: Type = new Type(TypeKind.V128,\r\n    TypeFlags.VECTOR   |\r\n    TypeFlags.VALUE, 128\r\n  );\r\n\r\n  /** Function reference. */\r\n  static readonly funcref: Type = new Type(TypeKind.FUNCREF,\r\n    TypeFlags.EXTERNAL   |\r\n    TypeFlags.NULLABLE   |\r\n    TypeFlags.REFERENCE, 0\r\n  );\r\n\r\n  /** External reference. */\r\n  static readonly externref: Type = new Type(TypeKind.EXTERNREF,\r\n    TypeFlags.EXTERNAL   |\r\n    TypeFlags.NULLABLE   |\r\n    TypeFlags.REFERENCE, 0\r\n  );\r\n\r\n  /** Any reference. */\r\n  static readonly anyref: Type = new Type(TypeKind.ANYREF,\r\n    TypeFlags.EXTERNAL   |\r\n    TypeFlags.NULLABLE   |\r\n    TypeFlags.REFERENCE, 0\r\n  );\r\n\r\n  /** Equatable reference. */\r\n  static readonly eqref: Type = new Type(TypeKind.EQREF,\r\n    TypeFlags.EXTERNAL   |\r\n    TypeFlags.NULLABLE   |\r\n    TypeFlags.REFERENCE, 0\r\n  );\r\n\r\n  /** 31-bit integer reference. */\r\n  static readonly i31ref: Type = new Type(TypeKind.I31REF,\r\n    TypeFlags.EXTERNAL   |\r\n    TypeFlags.REFERENCE, 0\r\n  );\r\n\r\n  /** Data reference. */\r\n  static readonly dataref: Type = new Type(TypeKind.DATAREF,\r\n    TypeFlags.EXTERNAL   |\r\n    TypeFlags.NULLABLE   |\r\n    TypeFlags.REFERENCE, 0\r\n  );\r\n\r\n  /** No return type. */\r\n  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);\r\n\r\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\r\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\r\n}\r\n\r\n/** Converts an array of types to an array of type references. */\r\nexport function typesToRefs(types: Type[]): TypeRef[] {\r\n  var numTypes = types.length;\r\n  var ret = new Array<TypeRef>(numTypes);\r\n  for (let i = 0; i < numTypes; ++i) ret[i] = types[i].toRef();\r\n  return ret;\r\n}\r\n\r\n/** Converts an array of types to its combined string representation. */\r\nexport function typesToString(types: Type[]): string {\r\n  var numTypes = types.length;\r\n  if (!numTypes) return \"\";\r\n  var sb = new Array<string>(numTypes);\r\n  for (let i = 0; i < numTypes; ++i) sb[i] = types[i].toString(true);\r\n  return sb.join(\",\");\r\n}\r\n\r\n/** Represents a fully resolved function signature. */\r\nexport class Signature {\r\n  /** Unique id representing this signature. */\r\n  id: u32 = 0;\r\n  /** Parameter types, if any, excluding `this`. */\r\n  parameterTypes: Type[];\r\n  /** Number of required parameters excluding `this`. Other parameters are considered optional. */\r\n  requiredParameters: i32;\r\n  /** Return type. */\r\n  returnType: Type;\r\n  /** This type, if an instance signature. */\r\n  thisType: Type | null;\r\n  /** Whether the last parameter is a rest parameter. */\r\n  hasRest: bool;\r\n  /** Respective function type. */\r\n  type: Type;\r\n  /** The program that created this signature. */\r\n  program: Program;\r\n\r\n  /** Constructs a new signature. */\r\n  constructor(\r\n    program: Program,\r\n    parameterTypes: Type[] | null = null,\r\n    returnType: Type | null = null,\r\n    thisType: Type | null = null\r\n  ) {\r\n    this.parameterTypes = parameterTypes ? parameterTypes : [];\r\n    this.requiredParameters = 0;\r\n    this.returnType = returnType ? returnType : Type.void;\r\n    this.thisType = thisType;\r\n    this.program = program;\r\n    this.hasRest = false;\r\n    var usizeType = program.options.usizeType;\r\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\r\n    this.type = type;\r\n    type.signatureReference = this;\r\n\r\n    var signatureTypes = program.uniqueSignatures;\r\n    var length = signatureTypes.length;\r\n    for (let i = 0; i < length; i++) {\r\n      let compare = signatureTypes[i];\r\n      if (this.equals(compare)) {\r\n        this.id = compare.id;\r\n        return this;\r\n      }\r\n    }\r\n    this.id = program.nextSignatureId++;\r\n    program.uniqueSignatures.push(this);\r\n  }\r\n\r\n  get paramRefs(): TypeRef {\r\n    var thisType = this.thisType;\r\n    var parameterTypes = this.parameterTypes;\r\n    var numParameterTypes = parameterTypes.length;\r\n    if (!numParameterTypes) {\r\n      if (!thisType) return TypeRef.None;\r\n      return thisType.toRef();\r\n    }\r\n    if (thisType) {\r\n      let typeRefs = new Array<TypeRef>(1 + numParameterTypes);\r\n      typeRefs[0] = thisType.toRef();\r\n      for (let i = 0; i < numParameterTypes; ++i) {\r\n        typeRefs[i + 1] = parameterTypes[i].toRef();\r\n      }\r\n      return createType(typeRefs);\r\n    }\r\n    return createType(typesToRefs(parameterTypes));\r\n  }\r\n\r\n  get resultRefs(): TypeRef {\r\n    return this.returnType.toRef();\r\n  }\r\n\r\n  /** Tests if this signature equals the specified. */\r\n  equals(other: Signature): bool {\r\n\r\n    // check `this` type\r\n    var thisThisType = this.thisType;\r\n    var otherThisType = other.thisType;\r\n    if (thisThisType !== null) {\r\n      if (otherThisType === null || !thisThisType.equals(otherThisType)) return false;\r\n    } else if (otherThisType) {\r\n      return false;\r\n    }\r\n\r\n    // check rest parameter\r\n    if (this.hasRest != other.hasRest) return false;\r\n\r\n    // check parameter types\r\n    var thisParameterTypes = this.parameterTypes;\r\n    var otherParameterTypes = other.parameterTypes;\r\n    var numParameters = thisParameterTypes.length;\r\n    if (numParameters != otherParameterTypes.length) return false;\r\n    for (let i = 0; i < numParameters; ++i) {\r\n      if (!thisParameterTypes[i].equals(otherParameterTypes[i])) return false;\r\n    }\r\n\r\n    // check return type\r\n    return this.returnType.equals(other.returnType);\r\n  }\r\n\r\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\r\n  isAssignableTo(target: Signature, requireSameSize: bool = false): bool {\r\n\r\n    // check `this` type\r\n    var thisThisType = this.thisType;\r\n    var targetThisType = target.thisType;\r\n    if (thisThisType !== null) {\r\n      if (targetThisType === null || !thisThisType.isAssignableTo(targetThisType)) return false;\r\n    } else if (targetThisType) {\r\n      return false;\r\n    }\r\n\r\n    // check rest parameter\r\n    if (this.hasRest != target.hasRest) return false; // TODO\r\n\r\n    // check parameter types\r\n    var thisParameterTypes = this.parameterTypes;\r\n    var targetParameterTypes = target.parameterTypes;\r\n    var numParameters = thisParameterTypes.length;\r\n    if (numParameters != targetParameterTypes.length) return false; // TODO\r\n    for (let i = 0; i < numParameters; ++i) {\r\n      let thisParameterType = thisParameterTypes[i];\r\n      let targetParameterType = targetParameterTypes[i];\r\n      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;\r\n    }\r\n\r\n    // check return type\r\n    var thisReturnType = this.returnType;\r\n    var targetReturnType = target.returnType;\r\n    return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);\r\n  }\r\n\r\n  /** Tests if this signature has at least one managed operand. */\r\n  get hasManagedOperands(): bool {\r\n    var thisType = this.thisType;\r\n    if (thisType) {\r\n      if (thisType.isManaged) return true;\r\n    }\r\n    var parameterTypes = this.parameterTypes;\r\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n      if (parameterTypes[i].isManaged) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Gets the indices of all managed operands. */\r\n  getManagedOperandIndices(): i32[] {\r\n    var indices = new Array<i32>();\r\n    var index = 0;\r\n    var thisType = this.thisType;\r\n    if (thisType) {\r\n      if (thisType.isManaged) {\r\n        indices.push(index);\r\n      }\r\n      ++index;\r\n    }\r\n    var parameterTypes = this.parameterTypes;\r\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\r\n      if (parameterTypes[i].isManaged) {\r\n        indices.push(index);\r\n      }\r\n      ++index;\r\n    }\r\n    return indices;\r\n  }\r\n\r\n  /** Converts this signature to a string. */\r\n  toString(validWat: bool = false): string {\r\n    var sb = new Array<string>();\r\n    sb.push(validWat ? \"%28\" : \"(\");\r\n    var index = 0;\r\n    var thisType = this.thisType;\r\n    if (thisType) {\r\n      sb.push(validWat ? \"this:\" : \"this: \");\r\n      assert(!thisType.signatureReference);\r\n      sb.push(thisType.toString(validWat));\r\n      index = 1;\r\n    }\r\n    var parameters = this.parameterTypes;\r\n    var numParameters = parameters.length;\r\n    if (numParameters) {\r\n      let optionalStart = this.requiredParameters;\r\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\r\n      for (let i = 0; i < numParameters; ++i, ++index) {\r\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\r\n        if (i == restIndex) sb.push(\"...\");\r\n        sb.push(parameters[i].toString(validWat));\r\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\r\n      }\r\n    }\r\n    sb.push(validWat ? \"%29=>\" : \") => \");\r\n    sb.push(this.returnType.toString(validWat));\r\n    return sb.join(\"\");\r\n  }\r\n\r\n  /** Creates a clone of this signature that is safe to modify. */\r\n  clone(): Signature {\r\n    var parameterTypes = this.parameterTypes;\r\n    var numParameterTypes = parameterTypes.length;\r\n    var cloneParameterTypes = new Array<Type>(numParameterTypes);\r\n    for (let i = 0; i < numParameterTypes; ++i) {\r\n      cloneParameterTypes[i] = parameterTypes[i];\r\n    }\r\n    return new Signature(this.program, cloneParameterTypes, this.returnType, this.thisType);\r\n  }\r\n}\r\n","/**\r\n * @fileoverview Various binary reading and writing utility.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** Reads an 8-bit integer from the specified buffer. */\r\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\r\n  return buffer[offset];\r\n}\r\n\r\n/** Writes an 8-bit integer to the specified buffer. */\r\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\r\n  buffer[offset] = value;\r\n}\r\n\r\n/** Reads a 16-bit integer from the specified buffer. */\r\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\r\n  return i32(buffer[offset    ])\r\n       | i32(buffer[offset + 1]) << 8;\r\n}\r\n\r\n/** Writes a 16-bit integer to the specified buffer. */\r\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\r\n  buffer[offset    ] = value;\r\n  buffer[offset + 1] = value >>> 8;\r\n}\r\n\r\n/** Reads a 32-bit integer from the specified buffer. */\r\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\r\n  return i32(buffer[offset    ])\r\n       | i32(buffer[offset + 1]) << 8\r\n       | i32(buffer[offset + 2]) << 16\r\n       | i32(buffer[offset + 3]) << 24;\r\n}\r\n\r\n/** Writes a 32-bit integer to the specified buffer. */\r\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\r\n  buffer[offset    ] = value;\r\n  buffer[offset + 1] = value >>> 8;\r\n  buffer[offset + 2] = value >>> 16;\r\n  buffer[offset + 3] = value >>> 24;\r\n}\r\n\r\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\r\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\r\n  writeI32(value, buffer, offset);\r\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\r\n}\r\n\r\n/** Reads a 64-bit integer from the specified buffer. */\r\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\r\n  var lo = readI32(buffer, offset);\r\n  var hi = readI32(buffer, offset + 4);\r\n  return i64_new(lo, hi);\r\n}\r\n\r\n/** Writes a 64-bit integer to the specified buffer. */\r\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\r\n  writeI32(i64_low(value), buffer, offset);\r\n  writeI32(i64_high(value), buffer, offset + 4);\r\n}\r\n\r\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\r\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\r\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\r\n  writeI32(i64_low(value), buffer, offset);\r\n}\r\n\r\n/** Reads a 32-bit float from the specified buffer. */\r\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\r\n  return i32_as_f32(readI32(buffer, offset));\r\n}\r\n\r\n/** Writes a 32-bit float to the specified buffer. */\r\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\r\n  writeI32(f32_as_i32(value), buffer, offset);\r\n}\r\n\r\n/** Reads a 64-bit float from the specified buffer. */\r\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\r\n  return i64_as_f64(readI64(buffer, offset));\r\n}\r\n\r\n/** Writes a 64-bit float to the specified buffer. */\r\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\r\n  var valueI64 = f64_as_i64(value);\r\n  writeI32(i64_low(valueI64), buffer, offset);\r\n  writeI32(i64_high(valueI64), buffer, offset + 4);\r\n}\r\n","/**\r\n * @fileoverview Various collections utility.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** Makes a unique map. Typically used to track contextual type arguemnts. */\r\nexport function uniqueMap<K,V>(original: Map<K,V> | null = null, overrides: Map<K,V> | null = null): Map<K,V> {\r\n  var cloned = new Map<K,V>();\r\n  if (original) {\r\n    // TODO: for (let [k, v] of original) {\r\n    for (let _keys = Map_keys(original), i = 0, k = _keys.length; i < k; ++i) {\r\n      let k = unchecked(_keys[i]);\r\n      let v = assert(original.get(k));\r\n      cloned.set(k, v);\r\n    }\r\n  }\r\n  if (overrides) {\r\n    // TODO: for (let [k, v] of overrides) {\r\n    for (let _keys = Map_keys(overrides), i = 0, k = _keys.length; i < k; ++i) {\r\n      let k = unchecked(_keys[i]);\r\n      let v = assert(overrides.get(k));\r\n      cloned.set(k, v);\r\n    }\r\n  }\r\n  return cloned;\r\n}\r\n","/**\r\n * @fileoverview Various utility.\r\n * @license Apache-2.0\r\n */\r\n\r\nexport * from \"./binary\";\r\nexport * from \"./collections\";\r\nexport * from \"./math\";\r\nexport * from \"./path\";\r\nexport * from \"./terminal\";\r\nexport * from \"./text\";\r\nexport * from \"./vector\";\r\n","/**\r\n * @fileoverview Various math utility.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** Tests if `x` is a power of two. */\r\nexport function isPowerOf2(x: i32): bool {\r\n  return x != 0 && (x & (x - 1)) == 0;\r\n}\r\n","/**\r\n * @fileoverview Various file path utility.\r\n * @license Apache-2.0\r\n */\r\n\r\nimport {\r\n  CharCode\r\n} from \"./text\";\r\n\r\nimport {\r\n  PATH_DELIMITER\r\n} from \"../common\";\r\n\r\nconst separator = CharCode.SLASH;\r\n\r\n/**\r\n * Normalizes the specified path, removing interior placeholders.\r\n * Expects a posix-compatible relative path (not Windows compatible).\r\n */\r\nexport function normalizePath(path: string): string {\r\n  var pos = 0;\r\n  var len = path.length;\r\n\r\n  // trim leading './'\r\n  while (pos + 1 < len &&\r\n    path.charCodeAt(pos) == CharCode.DOT &&\r\n    path.charCodeAt(pos + 1) == separator\r\n  ) {\r\n    pos += 2;\r\n  }\r\n\r\n  if (pos > 0 || len < path.length) {\r\n    path = path.substring(pos, len);\r\n    len -= pos;\r\n    pos = 0;\r\n  }\r\n\r\n  var atEnd: bool;\r\n  while (pos + 1 < len) {\r\n    atEnd = false;\r\n\r\n    // we are only interested in '/.' sequences ...\r\n    if (\r\n      path.charCodeAt(pos) == separator &&\r\n      path.charCodeAt(pos + 1) == CharCode.DOT\r\n    ) {\r\n      // '/.' ( '/' | $ )\r\n      atEnd = pos + 2 == len;\r\n      if (atEnd ||\r\n        pos + 2 < len &&\r\n        path.charCodeAt(pos + 2) == separator\r\n      ) {\r\n        path = atEnd\r\n          ? path.substring(0, pos)\r\n          : path.substring(0, pos) + path.substring(pos + 2);\r\n        len -= 2;\r\n        continue;\r\n      }\r\n\r\n      // '/.' ( './' | '.' $ )\r\n      atEnd = pos + 3 == len;\r\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||\r\n        pos + 3 < len &&\r\n        path.charCodeAt(pos + 2) == CharCode.DOT &&\r\n        path.charCodeAt(pos + 3) == separator\r\n      ) {\r\n        // find preceeding '/'\r\n        let ipos = pos;\r\n        while (--ipos >= 0) {\r\n          if (path.charCodeAt(ipos) == separator) {\r\n            if (pos - ipos != 3 ||\r\n              path.charCodeAt(ipos + 1) != CharCode.DOT ||\r\n              path.charCodeAt(ipos + 2) != CharCode.DOT\r\n            ) { // exclude '..' itself\r\n              path = atEnd\r\n                ? path.substring(0, ipos)\r\n                : path.substring(0, ipos) + path.substring(pos + 3);\r\n              len -= pos + 3 - ipos;\r\n              pos = ipos - 1; // incremented again at end of loop\r\n            }\r\n            break;\r\n          }\r\n        }\r\n\r\n        // if there's no preceeding '/', trim start if non-empty\r\n        if (ipos < 0 && pos > 0) {\r\n          if (pos != 2 ||\r\n            path.charCodeAt(0) != CharCode.DOT ||\r\n            path.charCodeAt(1) != CharCode.DOT\r\n          ) { // exclude '..' itself\r\n            path = path.substring(pos + 4);\r\n            len = path.length;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    pos++;\r\n  }\r\n  return len > 0 ? path : \".\";\r\n}\r\n\r\n/** Resolves the specified path relative to the specified origin. */\r\nexport function resolvePath(normalizedPath: string, origin: string): string {\r\n  if (normalizedPath.startsWith(\"std/\")) {\r\n    return normalizedPath;\r\n  }\r\n  return normalizePath(\r\n    dirname(origin) + PATH_DELIMITER + normalizedPath\r\n  );\r\n}\r\n\r\n/** Obtains the directory portion of a normalized path. */\r\nexport function dirname(normalizedPath: string): string {\r\n  var pos = normalizedPath.length;\r\n  if (pos <= 1) {\r\n    if (pos == 0) return \".\";\r\n    if (normalizedPath.charCodeAt(0) == separator) {\r\n      return normalizedPath;\r\n    }\r\n  }\r\n  while (--pos > 0) {\r\n    if (normalizedPath.charCodeAt(pos) == separator) {\r\n      return normalizedPath.substring(0, pos);\r\n    }\r\n  }\r\n  return \".\";\r\n}\r\n","/**\r\n * @fileoverview Terminal utility.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** Gray terminal color code. */\r\nexport const COLOR_GRAY = \"\\u001b[90m\";\r\n/** Red terminal color code. */\r\nexport const COLOR_RED = \"\\u001b[91m\";\r\n/** Green terminal color code. */\r\nexport const COLOR_GREEN = \"\\u001b[92m\";\r\n/** Yellow terminal color code. */\r\nexport const COLOR_YELLOW = \"\\u001b[93m\";\r\n/** Blue terminal color code. */\r\nexport const COLOR_BLUE = \"\\u001b[94m\";\r\n/** Magenta terminal color code. */\r\nexport const COLOR_MAGENTA = \"\\u001b[95m\";\r\n/** Cyan terminal color code. */\r\nexport const COLOR_CYAN = \"\\u001b[96m\";\r\n/** White terminal color code. */\r\nexport const COLOR_WHITE = \"\\u001b[97m\";\r\n/** Terminal color reset code. */\r\nexport const COLOR_RESET = \"\\u001b[0m\";\r\n\r\n/** Whether terminal colors are enabled or not. */\r\nvar colorsEnabled = true;\r\n\r\n/** Checks whether terminal colors are enabled or not. */\r\nexport function isColorsEnabled(): bool {\r\n  return colorsEnabled;\r\n}\r\n\r\n/** Sets whether terminal colors are enabled or not. */\r\nexport function setColorsEnabled(isEnabled: bool): bool {\r\n  var wasEnabled = isEnabled;\r\n  colorsEnabled = isEnabled;\r\n  return wasEnabled;\r\n}\r\n\r\n/** Wraps the specified text in the specified terminal color code. */\r\nexport function colorize(text: string, color: string): string {\r\n  return colorsEnabled ? color + text + COLOR_RESET : text;\r\n}\r\n","/**\r\n * @fileoverview Various character and text utility.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** An enum of named character codes. */\r\nexport const enum CharCode {\r\n\r\n  NULL = 0,\r\n  LINEFEED = 0x0A,\r\n  CARRIAGERETURN = 0x0D,\r\n  LINESEPARATOR = 0x2028,\r\n  PARAGRAPHSEPARATOR = 0x2029,\r\n  NEXTLINE = 0x0085,\r\n\r\n  SPACE = 0x20,\r\n  NONBREAKINGSPACE = 0xA0,\r\n  ENQUAD = 0x2000,\r\n  EMQUAD = 0x2001,\r\n  ENSPACE = 0x2002,\r\n  EMSPACE = 0x2003,\r\n  THREEPEREMSPACE = 0x2004,\r\n  FOURPEREMSPACE = 0x2005,\r\n  SIXPEREMSPACE = 0x2006,\r\n  FIGURESPACE = 0x2007,\r\n  PUNCTUATIONSPACE = 0x2008,\r\n  THINSPACE = 0x2009,\r\n  HAIRSPACE = 0x200A,\r\n  ZEROWIDTHSPACE = 0x200B,\r\n  NARROWNOBREAKSPACE = 0x202F,\r\n  IDEOGRAPHICSPACE = 0x3000,\r\n  MATHEMATICALSPACE = 0x205F,\r\n  OGHAM = 0x1680,\r\n\r\n  _ = 0x5F,\r\n\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n\r\n  a = 0x61,\r\n  b = 0x62,\r\n  c = 0x63,\r\n  d = 0x64,\r\n  e = 0x65,\r\n  f = 0x66,\r\n  g = 0x67,\r\n  h = 0x68,\r\n  i = 0x69,\r\n  j = 0x6A,\r\n  k = 0x6B,\r\n  l = 0x6C,\r\n  m = 0x6D,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  p = 0x70,\r\n  q = 0x71,\r\n  r = 0x72,\r\n  s = 0x73,\r\n  t = 0x74,\r\n  u = 0x75,\r\n  v = 0x76,\r\n  w = 0x77,\r\n  x = 0x78,\r\n  y = 0x79,\r\n  z = 0x7A,\r\n\r\n  A = 0x41,\r\n  B = 0x42,\r\n  C = 0x43,\r\n  D = 0x44,\r\n  E = 0x45,\r\n  F = 0x46,\r\n  G = 0x47,\r\n  H = 0x48,\r\n  I = 0x49,\r\n  J = 0x4A,\r\n  K = 0x4B,\r\n  L = 0x4C,\r\n  M = 0x4D,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  P = 0x50,\r\n  Q = 0x51,\r\n  R = 0x52,\r\n  S = 0x53,\r\n  T = 0x54,\r\n  U = 0x55,\r\n  V = 0x56,\r\n  W = 0x57,\r\n  X = 0x58,\r\n  Y = 0x59,\r\n  Z = 0x5a,\r\n\r\n  AMPERSAND = 0x26,\r\n  ASTERISK = 0x2A,\r\n  AT = 0x40,\r\n  BACKSLASH = 0x5C,\r\n  BACKTICK = 0x60,\r\n  BAR = 0x7C,\r\n  CARET = 0x5E,\r\n  CLOSEBRACE = 0x7D,\r\n  CLOSEBRACKET = 0x5D,\r\n  CLOSEPAREN = 0x29,\r\n  COLON = 0x3A,\r\n  COMMA = 0x2C,\r\n  DOLLAR = 0x24,\r\n  DOT = 0x2E,\r\n  DOUBLEQUOTE = 0x22,\r\n  EQUALS = 0x3D,\r\n  EXCLAMATION = 0x21,\r\n  GREATERTHAN = 0x3E,\r\n  HASH = 0x23,\r\n  LESSTHAN = 0x3C,\r\n  MINUS = 0x2D,\r\n  OPENBRACE = 0x7B,\r\n  OPENBRACKET = 0x5B,\r\n  OPENPAREN = 0x28,\r\n  PERCENT = 0x25,\r\n  PLUS = 0x2B,\r\n  QUESTION = 0x3F,\r\n  SEMICOLON = 0x3B,\r\n  SINGLEQUOTE = 0x27,\r\n  SLASH = 0x2F,\r\n  TILDE = 0x7E,\r\n\r\n  BACKSPACE = 0x08,\r\n  FORMFEED = 0x0C,\r\n  BYTEORDERMARK = 0xFEFF,\r\n  TAB = 0x09,\r\n  VERTICALTAB = 0x0B\r\n}\r\n\r\n/** Tests if the specified character code is some sort of line break. */\r\nexport function isLineBreak(c: CharCode): bool {\r\n  switch (c) {\r\n    case CharCode.LINEFEED:\r\n    case CharCode.CARRIAGERETURN:\r\n    case CharCode.LINESEPARATOR:\r\n    case CharCode.PARAGRAPHSEPARATOR: {\r\n      return true;\r\n    }\r\n    default: {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n/** Tests if the specified character code is some sort of white space. */\r\nexport function isWhiteSpace(c: i32): bool {\r\n  switch (c) {\r\n    case CharCode.SPACE:\r\n    case CharCode.TAB:\r\n    case CharCode.VERTICALTAB:\r\n    case CharCode.FORMFEED:\r\n    case CharCode.NONBREAKINGSPACE:\r\n    case CharCode.NEXTLINE:\r\n    case CharCode.OGHAM:\r\n    case CharCode.NARROWNOBREAKSPACE:\r\n    case CharCode.MATHEMATICALSPACE:\r\n    case CharCode.IDEOGRAPHICSPACE:\r\n    case CharCode.BYTEORDERMARK: {\r\n      return true;\r\n    }\r\n    default: {\r\n      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;\r\n    }\r\n  }\r\n}\r\n\r\n/** Tests if the specified character code is a valid decimal digit. */\r\nexport function isDecimalDigit(c: i32): bool {\r\n  return c >= CharCode._0 && c <= CharCode._9;\r\n}\r\n\r\n/** Tests if the specified character code is a valid octal digit. */\r\nexport function isOctalDigit(c: i32): bool {\r\n  return c >= CharCode._0 && c <= CharCode._7;\r\n}\r\n\r\n/** Tests if the specified character code is a valid hexadecimal digit. */\r\nexport function isHexDigit(c: i32): bool {\r\n  return isDecimalDigit(c) || ((c | 32) >= CharCode.a && (c | 32) <= CharCode.f);\r\n}\r\n\r\n/** Tests if the specified character code is trivially alphanumeric. */\r\nexport function isTrivialAlphanum(code: i32): bool {\r\n  return code >= CharCode.a && code <= CharCode.z\r\n      || code >= CharCode.A && code <= CharCode.Z\r\n      || code >= CharCode._0 && code <= CharCode._9;\r\n}\r\n\r\n/** Tests if the specified character code is a valid start of an identifier. */\r\nexport function isIdentifierStart(c: i32): bool {\r\n  let c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\r\n  return c0 >= CharCode.a && c0 <= CharCode.z\r\n      || c == CharCode._\r\n      || c == CharCode.DOLLAR\r\n      || c > 0x7F && isUnicodeIdentifierStart(c);\r\n}\r\n\r\n/** Tests if the specified character code is a valid part of an identifier. */\r\nexport function isIdentifierPart(c: i32): bool {\r\n  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\r\n  return c0 >= CharCode.a && c0 <= CharCode.z\r\n      || c >= CharCode._0 && c <= CharCode._9\r\n      || c == CharCode._\r\n      || c == CharCode.DOLLAR\r\n      || c > 0x7F && isUnicodeIdentifierPart(c);\r\n}\r\n\r\n// storing as u16 to save memory\r\nconst unicodeIdentifierStart: u16[] = [\r\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\r\n  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\r\n  908, 908, 910, 929, 931,\r\n  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\r\n  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\r\n  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\r\n  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\r\n  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\r\n  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\r\n  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\r\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\r\n  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\r\n  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\r\n  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\r\n  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\r\n  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\r\n  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\r\n  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\r\n  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\r\n  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\r\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\r\n  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\r\n  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\r\n  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\r\n  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\r\n  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\r\n  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\r\n  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\r\n  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\r\n  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\r\n  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\r\n  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\r\n  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\r\n  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\r\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\r\n  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\r\n  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\r\n  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\r\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\r\n  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\r\n  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\r\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\r\n  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\r\n  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\r\n  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\r\n  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\r\n  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\r\n  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\r\n  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\r\n  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\r\n  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\r\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\r\n  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\r\n  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\r\n  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\r\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\r\n  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\r\n  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\r\n  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\r\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\r\n  65479, 65482, 65487, 65490, 65495, 65498, 65500,\r\n];\r\nconst unicodeIdentifierPart: u16[] = [\r\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\r\n  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\r\n  908, 908, 910, 929, 931,\r\n  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\r\n  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\r\n  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\r\n  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\r\n  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\r\n  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\r\n  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\r\n  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\r\n  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\r\n  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\r\n  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\r\n  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\r\n  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\r\n  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\r\n  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\r\n  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\r\n  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\r\n  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\r\n  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\r\n  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\r\n  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\r\n  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\r\n  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\r\n  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\r\n  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\r\n  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\r\n  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\r\n  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\r\n  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\r\n  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\r\n  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\r\n  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\r\n  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\r\n  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\r\n  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\r\n  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\r\n  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\r\n  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\r\n  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\r\n  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\r\n  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\r\n  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\r\n  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\r\n  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\r\n  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\r\n  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\r\n  8521, 8526, 8526, 8544, 8584,\r\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\r\n  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\r\n  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\r\n  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\r\n  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\r\n  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\r\n  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\r\n  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\r\n  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\r\n  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\r\n  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\r\n  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\r\n  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\r\n  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\r\n  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\r\n  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\r\n  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\r\n  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\r\n  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\r\n  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\r\n];\r\n\r\nfunction lookupInUnicodeMap(code: u16, map: u16[]): bool {\r\n  if (code < map[0]) return false;\r\n\r\n  var lo = 0;\r\n  var hi = map.length;\r\n  var mid: i32;\r\n  var midVal: u16;\r\n\r\n  while (lo + 1 < hi) {\r\n    mid = lo + ((hi - lo) >> 1);\r\n    mid -= (mid & 1);\r\n    midVal = map[mid];\r\n    if (midVal <= code && code <= map[mid + 1]) {\r\n      return true;\r\n    }\r\n    if (code < midVal) {\r\n      hi = mid;\r\n    } else {\r\n      lo = mid + 2;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isUnicodeIdentifierStart(code: i32): bool {\r\n  return code < 170 || code > 65500 ? false :\r\n         lookupInUnicodeMap(code as u16, unicodeIdentifierStart);\r\n}\r\n\r\nfunction isUnicodeIdentifierPart(code: i32): bool {\r\n  return code < 170 || code > 65500 ? false :\r\n         lookupInUnicodeMap(code as u16, unicodeIdentifierPart);\r\n}\r\n\r\nconst indentX1 = \"  \";\r\nconst indentX2 = \"    \";\r\nconst indentX4 = \"        \";\r\n\r\n/** Creates an indentation matching the number of specified levels. */\r\nexport function indent(sb: string[], level: i32): void {\r\n  while (level >= 4) {\r\n    sb.push(indentX4);\r\n    level -= 4;\r\n  }\r\n  if (level >= 2) {\r\n    sb.push(indentX2);\r\n    level -= 2;\r\n  }\r\n  if (level) {\r\n    sb.push(indentX1);\r\n  }\r\n}\r\n","/**\r\n * @fileoverview Various vector utility.\r\n * @license Apache-2.0\r\n */\r\n\r\n/** v128 zero constant. */\r\nexport const v128_zero = new Uint8Array(16);\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n/** Indicates specific features to activate. */\r\nexport const enum Feature {\r\n  /** No additional features. */\r\n  NONE = 0,\r\n  /** Sign extension operations. */\r\n  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\r\n  /** Mutable global imports and exports. */\r\n  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\r\n  /** Non-trapping float to integer operations. */\r\n  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\r\n  /** Bulk memory operations. */\r\n  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\r\n  /** SIMD types and operations. */\r\n  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd\r\n  /** Threading and atomic operations. */\r\n  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads\r\n  /** Exception handling operations. */\r\n  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\r\n  /** Tail call operations. */\r\n  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call\r\n  /** Reference types. */\r\n  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types\r\n  /** Multi value types. */\r\n  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value\r\n  /** Garbage collection. */\r\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\r\n  /** Memory64. */\r\n  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64\r\n}\r\n\r\n/** Gets the name of the specified feature one would specify on the command line. */\r\nexport function featureToString(feature: Feature): string {\r\n  switch (feature) {\r\n    case Feature.SIGN_EXTENSION: return \"sign-extension\";\r\n    case Feature.MUTABLE_GLOBALS: return \"mutable-globals\";\r\n    case Feature.NONTRAPPING_F2I: return \"nontrapping-f2i\";\r\n    case Feature.BULK_MEMORY: return \"bulk-memory\";\r\n    case Feature.SIMD: return \"simd\";\r\n    case Feature.THREADS: return \"threads\";\r\n    case Feature.EXCEPTION_HANDLING: return \"exception-handling\";\r\n    case Feature.TAIL_CALLS: return \"tail-calls\";\r\n    case Feature.REFERENCE_TYPES: return \"reference-types\";\r\n    case Feature.MULTI_VALUE: return \"multi-value\";\r\n    case Feature.GC: return \"gc\";\r\n    case Feature.MEMORY64: return \"memory64\";\r\n  }\r\n  assert(false);\r\n  return \"\";\r\n}\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n/** Compilation target. */\r\nexport enum Target {\r\n  /** Portable. */\r\n  JS = 0,\r\n  /** WebAssembly with 32-bit pointers. */\r\n  WASM32 = 1,\r\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\r\n  WASM64 = 2,\r\n}\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n//  Typeinfo interpretation \r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n//   __rtti_base\r\n//                              count                             \r\n//  \r\n//                       Typeinfo#flags [id=0]                     id < count\r\n//                                 \r\n//                       Typeinfo#base  [id=0]                    \r\n// \r\n//                               ...                              \r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\r\n  /** Base class id or `0` if none. */\r\n  base: u32 = 0;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `StaticArray`. */\r\n  STATICARRAY = 1 << 2,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 3,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 4,\r\n  /** Type has no outgoing pointers. */\r\n  POINTERFREE = 1 << 5,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 6,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 7,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 8,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 9,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 10,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 11,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 12,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 13,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 14,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 15,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 16,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 17,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 18,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 19,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 20,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 21,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 22,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 23\r\n}\r\n","/**\r\n * @fileoverview Binaryen glue code for JavaScript.\r\n * @license Apache-2.0\r\n */\r\n\r\nconst binaryen = global.binaryen || (global.binaryen = require(\"binaryen\"));\r\n\r\nmodule.exports = binaryen;\r\n\r\nconst { Module } = require(\"../module\");\r\n\r\nModule.prototype.toText = function toText(watFormat = true) {\r\n  if (watFormat) {\r\n    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences\r\n    // of unreachable statements not actually emitted by the compiler. Optimizing\r\n    // StackIR removes these again, but may also suppress useless code emitted by\r\n    // the compiler that's then no longer visible in tests. Both not ideal.\r\n    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);\r\n  } else {\r\n    return binaryen.wrapModule(this.ref).emitText();\r\n  }\r\n};\r\n\r\nModule.prototype.toAsmjs = function toAsmjs() {\r\n  return binaryen.wrapModule(this.ref).emitAsmjs();\r\n};\r\n","/**\r\n * @fileoverview Collections glue code for JavaScript.\r\n * @license Apache-2.0\r\n */\r\n\r\nglobal.Map_keys = function Map_keys(map) {\r\n  return Array.from(map.keys());\r\n};\r\n\r\nglobal.Map_values = function Map_values(map) {\r\n  return Array.from(map.values());\r\n};\r\n\r\nglobal.Set_values = function Set_values(set) {\r\n  return Array.from(set.values());\r\n};\r\n","/**\r\n * @fileoverview Floating point glue code for JavaScript.\r\n * @license Apache-2.0\r\n */\r\n\r\n/* eslint-disable no-undef */\r\n\r\nconst F64 = new Float64Array(1);\r\nconst F32 = new Float32Array(F64.buffer);\r\nconst I32 = new Int32Array(F64.buffer);\r\n\r\nglobal.f32_as_i32 = function f32_as_i32(value) {\r\n  F32[0] = value;\r\n  return I32[0];\r\n};\r\n\r\nglobal.i32_as_f32 = function i32_as_f32(value) {\r\n  I32[0] = value;\r\n  return F32[0];\r\n};\r\n\r\nglobal.f64_as_i64 = function f64_as_i64(value) {\r\n  F64[0] = value;\r\n  return i64_new(I32[0], I32[1]);\r\n};\r\n\r\nglobal.i64_as_f64 = function i64_as_f64(value) {\r\n  I32[0] = i64_low(value);\r\n  I32[1] = i64_high(value);\r\n  return F64[0];\r\n};\r\n","/**\r\n * @fileoverview 64-bit integer glue code for JavaScript.\r\n * @license Apache-2.0\r\n */\r\n\r\n/* eslint-disable no-undef */\r\n\r\nconst Long = global.Long || require(\"long\");\r\n\r\nglobal.i64_zero    = Long.ZERO;\r\nglobal.i64_one     = Long.ONE;\r\nglobal.i64_neg_one = Long.fromInt(-1);\r\n\r\nglobal.i64_is = function i64_is(value) {\r\n  return Long.isLong(value);\r\n};\r\n\r\nglobal.i64_new = function i64_new(lo, hi) {\r\n  return Long.fromBits(lo, hi);\r\n};\r\n\r\nglobal.i64_low = function i64_low(value) {\r\n  return value.low;\r\n};\r\n\r\nglobal.i64_high = function i64_high(value) {\r\n  return value.high;\r\n};\r\n\r\nglobal.i64_add = function i64_add(left, right) {\r\n  return left.add(right);\r\n};\r\n\r\nglobal.i64_sub = function i64_sub(left, right) {\r\n  return left.sub(right);\r\n};\r\n\r\nglobal.i64_mul = function i64_mul(left, right) {\r\n  return left.mul(right);\r\n};\r\n\r\nglobal.i64_pow = function i64_pow(left, right) {\r\n  var rightLo = right.low;\r\n  var rightHi = right.high;\r\n  if (rightHi <= 0) {\r\n    if (rightHi < 0) {\r\n      if (left.eq(global.i64_neg_one)) {\r\n        return rightLo & 1 ? left : Long.ONE;\r\n      }\r\n      return left.eq(Long.ONE) ? left : Long.ZERO;\r\n    }\r\n    if (rightLo == 0) return Long.ONE;\r\n    if (rightLo == 1) return left;\r\n    if (rightLo == 2) return left.mul(left);\r\n  }\r\n  var result = Long.ONE;\r\n  while (rightLo | rightHi) {\r\n    if (rightLo & 1) result = result.mul(left);\r\n    right = right.shru(1);\r\n    left  = left.mul(left);\r\n    rightLo = right.low;\r\n    rightHi = right.high;\r\n  }\r\n  return result;\r\n};\r\n\r\nglobal.i64_div = function i64_div(left, right) {\r\n  return left.div(right);\r\n};\r\n\r\nglobal.i64_div_u = function i64_div_u(left, right) {\r\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\r\n};\r\n\r\nglobal.i64_rem = function i64_rem(left, right) {\r\n  return left.mod(right);\r\n};\r\n\r\nglobal.i64_rem_u = function i64_rem_u(left, right) {\r\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\r\n};\r\n\r\nglobal.i64_and = function i64_and(left, right) {\r\n  return left.and(right);\r\n};\r\n\r\nglobal.i64_or = function i64_or(left, right) {\r\n  return left.or(right);\r\n};\r\n\r\nglobal.i64_xor = function i64_xor(left, right) {\r\n  return left.xor(right);\r\n};\r\n\r\nglobal.i64_shl = function i64_shl(left, right) {\r\n  return left.shl(right);\r\n};\r\n\r\nglobal.i64_shr = function i64_shr(left, right) {\r\n  return left.shr(right);\r\n};\r\n\r\nglobal.i64_shr_u = function i64_shr_u(left, right) {\r\n  return left.shru(right);\r\n};\r\n\r\nglobal.i64_not = function i64_not(value) {\r\n  return value.not();\r\n};\r\n\r\nglobal.i64_eq = function i64_eq(left, right) {\r\n  return left.eq(right);\r\n};\r\n\r\nglobal.i64_ne = function i64_ne(left, right) {\r\n  return left.ne(right);\r\n};\r\n\r\nglobal.i64_gt = function i64_gt(left, right) {\r\n  return left.gt(right);\r\n};\r\n\r\nglobal.i64_align = function i64_align(value, alignment) {\r\n  assert(alignment && (alignment & (alignment - 1)) == 0);\r\n  var mask = Long.fromInt(alignment - 1);\r\n  return value.add(mask).and(mask.not());\r\n};\r\n\r\nglobal.i64_is_i8 = function i64_is_i8(value) {\r\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\r\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_i16 = function i64_is_i16(value) {\r\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\r\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_i32 = function i64_is_i32(value) {\r\n  return (value.high === 0 && value.low >= 0)\r\n      || (value.high === -1 && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_u8 = function i64_is_u8(value) {\r\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\r\n};\r\n\r\nglobal.i64_is_u16 = function i64_is_u16(value) {\r\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\r\n};\r\n\r\nglobal.i64_is_u32 = function i64_is_u32(value) {\r\n  return value.high === 0;\r\n};\r\n\r\nglobal.i64_is_bool = function i64_is_bool(value) {\r\n  return (value.high | (value.low & ~1)) === 0;\r\n};\r\n\r\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\r\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\r\n\r\nglobal.i64_is_f32 = function i64_is_f32(value) {\r\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\r\n};\r\n\r\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\r\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\r\n\r\nglobal.i64_is_f64 = function i64_is_f64(value) {\r\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\r\n};\r\n\r\nglobal.i64_to_f32 = function i64_to_f32(value) {\r\n  return global.Math.fround(value.toNumber());\r\n};\r\n\r\nglobal.i64_to_f64 = function i64_to_f64(value) {\r\n  return value.toNumber();\r\n};\r\n\r\nglobal.i64_to_string = function i64_to_string(value, unsigned) {\r\n  return unsigned ? value.toUnsigned().toString() : value.toString();\r\n};\r\n","/** @module std/portable *//***/\r\n\r\nvar globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\r\n\r\nglobalScope.ASC_TARGET = 0; // Target.JS\r\nglobalScope.ASC_NO_ASSERT = false;\r\nglobalScope.ASC_MEMORY_BASE = 0;\r\nglobalScope.ASC_OPTIMIZE_LEVEL = 3;\r\nglobalScope.ASC_SHRINK_LEVEL = 0;\r\nglobalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\r\nglobalScope.ASC_FEATURE_SIGN_EXTENSION = false;\r\nglobalScope.ASC_FEATURE_BULK_MEMORY = false;\r\nglobalScope.ASC_FEATURE_SIMD = false;\r\nglobalScope.ASC_FEATURE_THREADS = false;\r\n\r\nvar F64 = new Float64Array(1);\r\nvar U64 = new Uint32Array(F64.buffer);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\r\n  {\r\n    \"MIN_VALUE\": { value: -128, writable: false },\r\n    \"MAX_VALUE\": { value:  127, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\r\n  {\r\n    \"MIN_VALUE\": { value: -32768, writable: false },\r\n    \"MAX_VALUE\": { value:  32767, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\r\n  {\r\n    \"MIN_VALUE\": { value: -2147483648, writable: false },\r\n    \"MAX_VALUE\": { value:  2147483647, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\r\n  {\r\n    \"MIN_VALUE\": { value:   0, writable: false },\r\n    \"MAX_VALUE\": { value: 255, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\r\n  {\r\n    \"MIN_VALUE\": { value:     0, writable: false },\r\n    \"MAX_VALUE\": { value: 65535, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\r\n  {\r\n    \"MIN_VALUE\": { value:          0, writable: false },\r\n    \"MAX_VALUE\": { value: 4294967295, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"bool\"] = function bool(value) { return !!value; },\r\n  {\r\n    \"MIN_VALUE\": { value: false, writable: false },\r\n    \"MAX_VALUE\": { value: true,  writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\r\n  {\r\n    \"EPSILON\":   { value: 1.1920928955078125e-07, writable: false },\r\n    \"MIN_VALUE\": { value: 1.4012984643248170e-45, writable: false },\r\n    \"MAX_VALUE\": { value: 3.4028234663852886e+38, writable: false },\r\n    \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38, writable: false },\r\n    \"MIN_SAFE_INTEGER\":  { value: -16777215, writable: false },\r\n    \"MAX_SAFE_INTEGER\":  { value:  16777215, writable: false },\r\n    \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\r\n    \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\r\n    \"NaN\": { value: NaN, writable: false }\r\n  }\r\n);\r\n\r\nObject.defineProperties(\r\n  globalScope[\"f64\"] = function f64(value) { return +value; },\r\n  {\r\n    \"EPSILON\":   { value: 2.2204460492503131e-016, writable: false },\r\n    \"MIN_VALUE\": { value:                  5e-324, writable: false },\r\n    \"MAX_VALUE\": { value: 1.7976931348623157e+308, writable: false },\r\n    \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308, writable: false },\r\n    \"MIN_SAFE_INTEGER\":  { value: -9007199254740991, writable: false },\r\n    \"MAX_SAFE_INTEGER\":  { value:  9007199254740991, writable: false },\r\n    \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\r\n    \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\r\n    \"NaN\": { value: NaN, writable: false }\r\n  }\r\n);\r\n\r\nglobalScope[\"clz\"] = Math.clz32;\r\n\r\nglobalScope[\"ctz\"] = function ctz(value) {\r\n  var c = Math.clz32(value & -value);\r\n  return value ? 31 - c : c;\r\n};\r\n\r\nglobalScope[\"popcnt\"] = function popcnt(value) {\r\n  value -= value >>> 1 & 0x55555555;\r\n  value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\r\n  return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\r\n};\r\n\r\nglobalScope[\"rotl\"] = function rotl(value, shift) {\r\n  shift &= 31;\r\n  return (value << shift) | (value >>> (32 - shift));\r\n};\r\n\r\nglobalScope[\"rotr\"] = function rotr(value, shift) {\r\n  shift &= 31;\r\n  return (value >>> shift) | (value << (32 - shift));\r\n};\r\n\r\nglobalScope[\"abs\"] = Math.abs;\r\n\r\nglobalScope[\"max\"] = Math.max;\r\n\r\nglobalScope[\"min\"] = Math.min;\r\n\r\nglobalScope[\"ceil\"] = Math.ceil;\r\n\r\nglobalScope[\"floor\"] = Math.floor;\r\n\r\n// Adopt code from https://github.com/rfk/wasm-polyfill\r\nglobalScope[\"nearest\"] = function nearest(value) {\r\n  if (Math.abs(value - Math.trunc(value)) === 0.5) {\r\n    return 2.0 * Math.round(value * 0.5);\r\n  }\r\n  return Math.round(value);\r\n};\r\n\r\nglobalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\r\n  return condition ? ifTrue : ifFalse;\r\n};\r\n\r\nglobalScope[\"sqrt\"] = Math.sqrt;\r\n\r\nglobalScope[\"trunc\"] = Math.trunc;\r\n\r\nglobalScope[\"copysign\"] = function copysign(x, y) {\r\n  return Math.abs(x) * Math.sign(y);\r\n};\r\n\r\nglobalScope[\"bswap\"] = function bswap(value) {\r\n  var a = value >> 8 & 0x00FF00FF;\r\n  var b = (value & 0x00FF00FF) << 8;\r\n  value = a | b;\r\n  a = value >> 16 & 0x0000FFFF;\r\n  b = (value & 0x0000FFFF) << 16;\r\n  return a | b;\r\n};\r\n\r\nglobalScope[\"bswap16\"] = function bswap16(value) {\r\n  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\r\n};\r\n\r\nfunction UnreachableError() {\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, UnreachableError);\r\n  } else {\r\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\r\n  }\r\n}\r\nUnreachableError.prototype = Object.create(Error.prototype);\r\nUnreachableError.prototype.name = \"UnreachableError\";\r\nUnreachableError.prototype.message = \"unreachable\";\r\n\r\nglobalScope[\"unreachable\"] = function unreachable() {\r\n  throw new UnreachableError();\r\n};\r\n\r\nfunction AssertionError(message) {\r\n  this.message = message || \"assertion failed\";\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, AssertionError);\r\n  } else {\r\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\r\n  }\r\n}\r\nAssertionError.prototype = Object.create(Error.prototype);\r\nAssertionError.prototype.name = \"AssertionError\";\r\n\r\nglobalScope[\"assert\"] = function assert(isTrueish, message) {\r\n  if (isTrueish) return isTrueish;\r\n  throw new AssertionError(message);\r\n};\r\n\r\nglobalScope[\"changetype\"] = function changetype(value) {\r\n  return value;\r\n};\r\n\r\nString[\"fromCharCodes\"] = function fromCharCodes(arr) {\r\n  const CHUNKSIZE = 1 << 13;\r\n  const len = arr.length;\r\n  if (len <= CHUNKSIZE) {\r\n    return String.fromCharCode.apply(String, arr);\r\n  }\r\n  let index = 0;\r\n  let parts = '';\r\n  while (index < len) {\r\n    parts += String.fromCharCode.apply(\r\n      String,\r\n      arr.slice(index, Math.min(index + CHUNKSIZE, len))\r\n    );\r\n    index += CHUNKSIZE;\r\n  }\r\n  return parts;\r\n};\r\n\r\nString[\"fromCodePoints\"] = function fromCodePoints(arr) {\r\n  const CHUNKSIZE = 1 << 13;\r\n  const len = arr.length;\r\n  if (len <= CHUNKSIZE) {\r\n    return String.fromCodePoint.apply(String, arr);\r\n  }\r\n  let index = 0;\r\n  let parts = '';\r\n  while (index < len) {\r\n    parts += String.fromCodePoint.apply(\r\n      String,\r\n      arr.slice(index, Math.min(index + CHUNKSIZE, len))\r\n    );\r\n    index += CHUNKSIZE;\r\n  }\r\n  return parts;\r\n};\r\n\r\nif (!String.prototype.at) {\r\n  Object.defineProperty(String.prototype, \"at\", {\r\n    value: function at(index) {\r\n      return this.charAt(index >= 0 ? index : index + this.length);\r\n    },\r\n    configurable: true\r\n  });\r\n}\r\n\r\nif (!String.prototype.replaceAll) {\r\n  Object.defineProperty(String.prototype, \"replaceAll\", {\r\n    value: function replaceAll(search, replacment) {\r\n      var res = this.split(search).join(replacment);\r\n      if (!search.length) res = replacment + res + replacment;\r\n      return res;\r\n    },\r\n    configurable: true\r\n  });\r\n}\r\n\r\nfunction defaultComparator(a, b) {\r\n  if (a === b) {\r\n    if (a !== 0) return 0;\r\n    a = 1 / a, b = 1 / b;\r\n  } else {\r\n    var nanA = a != a, nanB = b != b;\r\n    if (nanA | nanB) return nanA - nanB;\r\n    if (a == null) a = String(a);\r\n    if (b == null) b = String(b);\r\n  }\r\n  return a > b ? 1 : -1;\r\n}\r\n\r\nconst arraySort = Array.prototype.sort;\r\nArray.prototype.sort = function sort(comparator) {\r\n  return arraySort.call(this, comparator || defaultComparator);\r\n};\r\n\r\n[ Array,\r\n  Uint8ClampedArray,\r\n  Uint8Array, Int8Array,\r\n  Uint16Array, Int16Array,\r\n  Uint32Array, Int32Array,\r\n  Float32Array, Float64Array\r\n].forEach(Ctr => {\r\n  if (!Ctr.prototype.at) {\r\n    Object.defineProperty(Ctr.prototype, \"at\", {\r\n      value: function at(index) {\r\n        return this[index >= 0 ? index : index + this.length];\r\n      },\r\n      configurable: true\r\n    });\r\n  }\r\n\r\n  if (!Ctr.prototype.findLastIndex) {\r\n    Object.defineProperty(Ctr.prototype, \"findLastIndex\", {\r\n      value: function findLastIndex(fn) {\r\n        for (let i = this.length - 1; i >= 0; --i) {\r\n          if (fn(this[i], i, this)) return i;\r\n        }\r\n        return -1;\r\n      },\r\n      configurable: true\r\n    });\r\n  }\r\n});\r\n\r\nglobalScope[\"isInteger\"] = Number.isInteger;\r\n\r\nglobalScope[\"isFloat\"] = function isFloat(arg) {\r\n  return typeof arg === \"number\";\r\n};\r\n\r\nglobalScope[\"isNullable\"] = function isNullable(arg) {\r\n  return true;\r\n};\r\n\r\nglobalScope[\"isReference\"] = function isReference(arg) {\r\n  return typeof arg === \"object\" || typeof arg === \"string\";\r\n};\r\n\r\nglobalScope[\"isFunction\"] = function isFunction(arg) {\r\n  return typeof arg === \"function\";\r\n};\r\n\r\nglobalScope[\"isString\"] = function isString(arg) {\r\n  return typeof arg === \"string\" || arg instanceof String;\r\n};\r\n\r\nglobalScope[\"isArray\"] = Array.isArray;\r\nglobalScope[\"isArrayLike\"] = function isArrayLike(expr) {\r\n  return expr\r\n    && typeof expr === 'object'\r\n    && typeof expr.length === 'number'\r\n    && expr.length >= 0\r\n    && Math.trunc(expr.length) === expr.length;\r\n};\r\n\r\nglobalScope[\"isDefined\"] = function isDefined(expr) {\r\n  return typeof expr !== \"undefined\";\r\n};\r\n\r\nglobalScope[\"isConstant\"] = function isConstant(expr) {\r\n  return false;\r\n};\r\n\r\nglobalScope[\"unchecked\"] = function unchecked(expr) {\r\n  return expr;\r\n};\r\n\r\nglobalScope[\"fmod\"] = function fmod(x, y) {\r\n  return x % y;\r\n};\r\n\r\nglobalScope[\"fmodf\"] = function fmodf(x, y) {\r\n  return Math.fround(x % y);\r\n};\r\n\r\nglobalScope[\"JSMath\"] = Math;\r\n\r\nObject.defineProperties(globalScope[\"JSMath\"], {\r\n  sincos_sin: { value: 0.0, writable: true },\r\n  sincos_cos: { value: 0.0, writable: true },\r\n  signbit: {\r\n    value: function signbit(x) {\r\n      F64[0] = x; return Boolean(U64[1] >>> 31);\r\n    }\r\n  },\r\n  sincos: {\r\n    value: function sincos(x) {\r\n      this.sincos_sin = Math.sin(x);\r\n      this.sincos_cos = Math.cos(x);\r\n    }\r\n  },\r\n  exp2: {\r\n    value: function exp2(x) {\r\n      return Math.pow(2, x);\r\n    }\r\n  }\r\n});\r\n\r\nglobalScope[\"unmanaged\"] = function() { /* nop */ };\r\n\r\nglobalScope[\"trace\"] = function(message, n) {\r\n  if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\r\n  console.error(\"trace: \" + message);\r\n};\r\n\r\nObject.defineProperty(Int8Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Int8Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Uint8Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Uint8Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Uint8ClampedArray, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Uint8ClampedArray(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Int16Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Int16Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Uint16Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Uint16Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Int32Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Int32Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Uint32Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Uint32Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Float32Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Float32Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n\r\nObject.defineProperty(Float64Array, \"wrap\", {\r\n  value: function wrap(buffer, byteOffset, length) {\r\n    return new Float64Array(buffer, byteOffset, length);\r\n  }\r\n});\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__911__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n__webpack_require__(308);\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(780);\n"],"sourceRoot":""}